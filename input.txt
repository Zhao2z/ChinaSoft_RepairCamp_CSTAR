protected void reportPrologUnexpChar(boolean isProlog, int ch, String msg) throws XMLStreamException { <BUGS> String fullMsg = isProlog ? ErrorConsts.SUFFIX_IN_PROLOG : ErrorConsts.SUFFIX_IN_EPILOG; if (msg == null) { <BUGE> if (ch == '&') { throwUnexpectedChar(ch, fullMsg+"; no entities allowed"); } } else { fullMsg += msg; } throwUnexpectedChar(ch, fullMsg); }
protected void reportPrologUnexpChar(boolean isProlog, int ch, String msg) throws XMLStreamException { String fullMsg = isProlog ? ErrorConsts.SUFFIX_IN_PROLOG : ErrorConsts.SUFFIX_IN_EPILOG; if (msg == null) { if (ch == '&') { throwUnexpectedChar(ch, fullMsg+"; no entities allowed"); } } else { <BUGS> fullMsg += msg; <BUGE> } throwUnexpectedChar(ch, fullMsg); }
protected void reportPrologUnexpChar(boolean isProlog, int ch, String msg) throws XMLStreamException { String fullMsg = isProlog ? ErrorConsts.SUFFIX_IN_PROLOG : ErrorConsts.SUFFIX_IN_EPILOG; if (msg == null) { if (ch == '&') { throwUnexpectedChar(ch, fullMsg+"; no entities allowed"); } } else { fullMsg += msg; } <BUGS> throwUnexpectedChar(ch, fullMsg); <BUGE> }
public boolean willEscapeCR() { /* !!! TBI*/ <BUGS> return true; <BUGE> }
*/ private XMLStreamWriter2 createSW(OutputStream out, Writer w, String enc, boolean forceAutoClose) throws XMLStreamException { /* Need to ensure that the configuration object is not shared * any more; otherwise later changes via factory could be * visible half-way through output... */ <BUGS> WriterConfig cfg = _config.createNonShared(); if (forceAutoClose) { <BUGE> cfg.doAutoCloseOutput(true); } XmlWriter xw; WNameTable symbols;  if (w == null) { if (enc == null) { enc = XmlConsts.STAX_DEFAULT_OUTPUT_ENCODING; } else { /* Canonical ones are interned, so we may have * normalized encoding already... */ if (enc != CharsetNames.CS_UTF8 && enc != CharsetNames.CS_ISO_LATIN1 && enc != CharsetNames.CS_US_ASCII) { enc = CharsetNames.normalize(enc); } }
*/ private XMLStreamWriter2 createSW(OutputStream out, Writer w, String enc, boolean forceAutoClose) throws XMLStreamException { /* Need to ensure that the configuration object is not shared * any more; otherwise later changes via factory could be * visible half-way through output... */ WriterConfig cfg = _config.createNonShared(); if (forceAutoClose) { cfg.doAutoCloseOutput(true); } XmlWriter xw; WNameTable symbols;  <BUGS> if (w == null) { if (enc == null) { <BUGE> enc = XmlConsts.STAX_DEFAULT_OUTPUT_ENCODING; } else { /* Canonical ones are interned, so we may have * normalized encoding already... */ if (enc != CharsetNames.CS_UTF8 && enc != CharsetNames.CS_ISO_LATIN1 && enc != CharsetNames.CS_US_ASCII) { enc = CharsetNames.normalize(enc); } }
*/ private XMLStreamWriter2 createSW(OutputStream out, Writer w, String enc, boolean forceAutoClose) throws XMLStreamException { /* Need to ensure that the configuration object is not shared * any more; otherwise later changes via factory could be * visible half-way through output... */ WriterConfig cfg = _config.createNonShared(); if (forceAutoClose) { cfg.doAutoCloseOutput(true); } XmlWriter xw; WNameTable symbols;  if (w == null) { if (enc == null) { enc = XmlConsts.STAX_DEFAULT_OUTPUT_ENCODING; } else { /* Canonical ones are interned, so we may have * normalized encoding already... */ <BUGS> if (enc != CharsetNames.CS_UTF8 <BUGE> && enc != CharsetNames.CS_ISO_LATIN1 && enc != CharsetNames.CS_US_ASCII) { enc = CharsetNames.normalize(enc); } }
*/ private XMLStreamWriter2 createSW(OutputStream out, Writer w, String enc, boolean forceAutoClose) throws XMLStreamException { /* Need to ensure that the configuration object is not shared * any more; otherwise later changes via factory could be * visible half-way through output... */ WriterConfig cfg = _config.createNonShared(); if (forceAutoClose) { cfg.doAutoCloseOutput(true); } XmlWriter xw; WNameTable symbols;  if (w == null) { if (enc == null) { enc = XmlConsts.STAX_DEFAULT_OUTPUT_ENCODING; } else { /* Canonical ones are interned, so we may have * normalized encoding already... */ if (enc != CharsetNames.CS_UTF8 && enc != CharsetNames.CS_ISO_LATIN1 && enc != CharsetNames.CS_US_ASCII) { <BUGS> enc = CharsetNames.normalize(enc); <BUGE> } }
*/ private XMLStreamWriter2 createSW(OutputStream out, Writer w, String enc, boolean forceAutoClose) throws XMLStreamException { /* Need to ensure that the configuration object is not shared * any more; otherwise later changes via factory could be * visible half-way through output... */ WriterConfig cfg = _config.createNonShared(); if (forceAutoClose) { cfg.doAutoCloseOutput(true); } XmlWriter xw; WNameTable symbols;  if (w == null) { if (enc == null) { enc = XmlConsts.STAX_DEFAULT_OUTPUT_ENCODING; } else { /* Canonical ones are interned, so we may have * normalized encoding already... */ if (enc != CharsetNames.CS_UTF8 && enc != CharsetNames.CS_ISO_LATIN1 && enc != CharsetNames.CS_US_ASCII) { enc = CharsetNames.normalize(enc); } }
}  /* /********************************************************************** /* Internal methods: /********************************************************************** */  /** * Bottleneck factory method used internally; needs to take care of passing * proper settings to stream writer. * * @param autoCloseOutput Whether writer should automatically close the *   output stream or Writer, when close() is called on stream writer. try { <BUGS> if (enc == CharsetNames.CS_UTF8) { <BUGE> /* !!! TEST-only:*/ /* w = new com.fasterxml.aalto.io.UTF8Writer(cfg, out, autoCloseOutput); xw = new CharXmlWriter(cfg, w); */  xw = new Utf8XmlWriter(cfg, out); symbols = _config.getUtf8Symbols(xw); } else if (enc == CharsetNames.CS_ISO_LATIN1) { xw = new Latin1XmlWriter(cfg, out); symbols = _config.getLatin1Symbols(xw); } else if (enc == CharsetNames.CS_US_ASCII) { xw = new AsciiXmlWriter(cfg, out); symbols = _config.getAsciiSymbols(xw);
}  /* /********************************************************************** /* Internal methods: /********************************************************************** */  /** * Bottleneck factory method used internally; needs to take care of passing * proper settings to stream writer. * * @param autoCloseOutput Whether writer should automatically close the *   output stream or Writer, when close() is called on stream writer.  <BUGS> xw = new Utf8XmlWriter(cfg, out); symbols = _config.getUtf8Symbols(xw); <BUGE> } else if (enc == CharsetNames.CS_ISO_LATIN1) { xw = new Latin1XmlWriter(cfg, out); symbols = _config.getLatin1Symbols(xw); } else if (enc == CharsetNames.CS_US_ASCII) { xw = new AsciiXmlWriter(cfg, out); symbols = _config.getAsciiSymbols(xw); } else { w = new OutputStreamWriter(out, enc); xw = new CharXmlWriter(cfg, w); symbols = _config.getCharSymbols(xw); } } catch (IOException ioe) { throw new XMLStreamException(ioe);
}  /* /********************************************************************** /* Internal methods: /********************************************************************** */  /** * Bottleneck factory method used internally; needs to take care of passing * proper settings to stream writer. * * @param autoCloseOutput Whether writer should automatically close the *   output stream or Writer, when close() is called on stream writer. throw new XMLStreamException(ioe); <BUGS> } <BUGE> /* try { if (enc == CharsetNames.CS_UTF8) { w = new UTF8Writer(cfg, out, autoCloseOutput); xw = new BufferingXmlWriter(w, cfg, enc, true); } else if (enc == CharsetNames.CS_ISO_LATIN1) { xw = new ISOLatin1XmlWriter(out, cfg, autoCloseOutput); } else if (enc == CharsetNames.CS_US_ASCII) { xw = new ISOLatin1XmlWriter(out, cfg, autoCloseOutput); } else { w = new OutputStreamWriter(out, enc); xw = new BufferingXmlWriter(w, cfg, enc, autoCloseOutput); } } catch (IOException ex) {
}  /* /********************************************************************** /* Internal methods: /********************************************************************** */  /** * Bottleneck factory method used internally; needs to take care of passing * proper settings to stream writer. * * @param autoCloseOutput Whether writer should automatically close the *   output stream or Writer, when close() is called on stream writer.  <BUGS> if (cfg.willRepairNamespaces()) { <BUGE> return new RepairingStreamWriter(cfg, xw, symbols); } return new NonRepairingStreamWriter(cfg, xw, symbols); }  private XMLStreamWriter2 createSW(Result res) throws XMLStreamException { OutputStream out = null; Writer w = null; String encoding = null; boolean autoclose; String sysId = null;  if (res instanceof Stax2Result) {
}  /* /********************************************************************** /* Internal methods: /********************************************************************** */  /** * Bottleneck factory method used internally; needs to take care of passing * proper settings to stream writer. * * @param autoCloseOutput Whether writer should automatically close the *   output stream or Writer, when close() is called on stream writer. } <BUGS> return new NonRepairingStreamWriter(cfg, xw, symbols); <BUGE> }  private XMLStreamWriter2 createSW(Result res) throws XMLStreamException { OutputStream out = null; Writer w = null; String encoding = null; boolean autoclose; String sysId = null;  if (res instanceof Stax2Result) { Stax2Result sr = (Stax2Result) res; try { out = sr.constructOutputStream();
@Override public final int nextFromProlog(boolean isProlog) throws XMLStreamException { <BUGS> if (_tokenIncomplete) { /* left-overs from last thingy? <BUGE>*/ skipToken(); }  /* First: keep track of where event started*/ setStartLocation(); /* Ok: we should get a WS or '<'. So, let's skip through WS*/ while (true) { if (_inputPtr >= _inputEnd) { if (!loadMore()) { setStartLocation(); return TOKEN_EOI; } } int c = _inputBuffer[_inputPtr++] & 0xFF;  /* Really should get white space or '<'...*/ if (c == INT_LT) { break; } /* 26-Mar-2008, tatus: White space in prolog/epilog is *   not to be reported at all (by default at least), as *   it is not part of XML Infoset content. So let's *   just actively skip it here */ if (c != INT_SPACE) { if (c == INT_LF) {
@Override public final int nextFromProlog(boolean isProlog) throws XMLStreamException { if (_tokenIncomplete) { /* left-overs from last thingy?*/ skipToken(); }  /* First: keep track of where event started*/ <BUGS> setStartLocation(); <BUGE> /* Ok: we should get a WS or '<'. So, let's skip through WS*/ while (true) { if (_inputPtr >= _inputEnd) { if (!loadMore()) { setStartLocation(); return TOKEN_EOI; } } int c = _inputBuffer[_inputPtr++] & 0xFF;  /* Really should get white space or '<'...*/ if (c == INT_LT) { break; } /* 26-Mar-2008, tatus: White space in prolog/epilog is *   not to be reported at all (by default at least), as *   it is not part of XML Infoset content. So let's *   just actively skip it here */ if (c != INT_SPACE) { if (c == INT_LF) {
@Override public final int nextFromProlog(boolean isProlog) throws XMLStreamException { if (_tokenIncomplete) { /* left-overs from last thingy?*/ skipToken(); }  /* First: keep track of where event started*/ setStartLocation(); /* Ok: we should get a WS or '<'. So, let's skip through WS*/ while (true) { <BUGS> if (_inputPtr >= _inputEnd) { <BUGE> if (!loadMore()) { setStartLocation(); return TOKEN_EOI; } } int c = _inputBuffer[_inputPtr++] & 0xFF;  /* Really should get white space or '<'...*/ if (c == INT_LT) { break; } /* 26-Mar-2008, tatus: White space in prolog/epilog is *   not to be reported at all (by default at least), as *   it is not part of XML Infoset content. So let's *   just actively skip it here */ if (c != INT_SPACE) { if (c == INT_LF) {
@Override public final int nextFromProlog(boolean isProlog) throws XMLStreamException { if (_tokenIncomplete) { /* left-overs from last thingy?*/ skipToken(); }  /* First: keep track of where event started*/ setStartLocation(); /* Ok: we should get a WS or '<'. So, let's skip through WS*/ while (true) { if (_inputPtr >= _inputEnd) { if (!loadMore()) { setStartLocation(); return TOKEN_EOI; } } <BUGS> int c = _inputBuffer[_inputPtr++] & 0xFF; <BUGE>  /* Really should get white space or '<'...*/ if (c == INT_LT) { break; } /* 26-Mar-2008, tatus: White space in prolog/epilog is *   not to be reported at all (by default at least), as *   it is not part of XML Infoset content. So let's *   just actively skip it here */ if (c != INT_SPACE) { if (c == INT_LF) {
@Override public final int nextFromProlog(boolean isProlog) throws XMLStreamException { if (_tokenIncomplete) { /* left-overs from last thingy?*/ skipToken(); }  /* First: keep track of where event started*/ setStartLocation(); /* Ok: we should get a WS or '<'. So, let's skip through WS*/ while (true) { if (_inputPtr >= _inputEnd) { if (!loadMore()) { setStartLocation(); return TOKEN_EOI; } } int c = _inputBuffer[_inputPtr++] & 0xFF;  /* Really should get white space or '<'...*/ <BUGS> if (c == INT_LT) { break; <BUGE> } /* 26-Mar-2008, tatus: White space in prolog/epilog is *   not to be reported at all (by default at least), as *   it is not part of XML Infoset content. So let's *   just actively skip it here */ if (c != INT_SPACE) { if (c == INT_LF) {
@Override public final int nextFromProlog(boolean isProlog) throws XMLStreamException { if (_tokenIncomplete) { /* left-overs from last thingy?*/ skipToken(); }  /* First: keep track of where event started*/ setStartLocation(); /* Ok: we should get a WS or '<'. So, let's skip through WS*/ while (true) { if (_inputPtr >= _inputEnd) { if (!loadMore()) { setStartLocation(); return TOKEN_EOI; } } int c = _inputBuffer[_inputPtr++] & 0xFF;  /* Really should get white space or '<'...*/ if (c == INT_LT) { break; } /* 26-Mar-2008, tatus: White space in prolog/epilog is *   not to be reported at all (by default at least), as *   it is not part of XML Infoset content. So let's *   just actively skip it here */ <BUGS> if (c != INT_SPACE) { if (c == INT_LF) {
throws XMLStreamException;  protected abstract String parsePublicId(byte quoteChar) throws XMLStreamException;  protected abstract String parseSystemId(byte quoteChar) throws XMLStreamException;  /* /********************************************************************** /* Implementation of parsing API /********************************************************************** */  } <BUGS> } <BUGE>  /* Ok, got LT:*/ if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(COMMENT); /* not necessarily a comment of course*/ } byte b = _inputBuffer[_inputPtr++]; if (b == BYTE_EXCL) { /* comment/DOCTYPE? (CDATA not legal)*/ return handlePrologDeclStart(isProlog); } if (b == BYTE_QMARK) { return handlePIStart(); } /* End tag not allowed if no open tree; and only one root * element (one root-level start tag)
throws XMLStreamException;  protected abstract String parsePublicId(byte quoteChar) throws XMLStreamException;  protected abstract String parseSystemId(byte quoteChar) throws XMLStreamException;  /* /********************************************************************** /* Implementation of parsing API /********************************************************************** */  /* Ok, got LT:*/ <BUGS> if (_inputPtr >= _inputEnd) { <BUGE> loadMoreGuaranteed(COMMENT); /* not necessarily a comment of course*/ } byte b = _inputBuffer[_inputPtr++]; if (b == BYTE_EXCL) { /* comment/DOCTYPE? (CDATA not legal)*/ return handlePrologDeclStart(isProlog); } if (b == BYTE_QMARK) { return handlePIStart(); } /* End tag not allowed if no open tree; and only one root * element (one root-level start tag) */ if (b == BYTE_SLASH || !isProlog) { reportPrologUnexpElement(isProlog, b);
protected abstract String parsePublicId(byte quoteChar) throws XMLStreamException;  protected abstract String parseSystemId(byte quoteChar) throws XMLStreamException;  /* /********************************************************************** /* Implementation of parsing API /********************************************************************** */  } <BUGS> byte b = _inputBuffer[_inputPtr++]; if (b == BYTE_EXCL) { /* comment/DOCTYPE? (CDATA not legal)*/ return handlePrologDeclStart(isProlog); <BUGE> } if (b == BYTE_QMARK) { return handlePIStart(); } /* End tag not allowed if no open tree; and only one root * element (one root-level start tag) */ if (b == BYTE_SLASH || !isProlog) { reportPrologUnexpElement(isProlog, b); } return handleStartElement(b); }
@Override public final void writeCharacters(String text) throws IOException, XMLStreamException { <BUGS> final int len = text.length(); <BUGE>  /* Not so common case, let's offline:*/ if (len > _copyBufferLen) { longWriteCharacters(text); return; } if (len > 0) { char[] buf = _copyBuffer; text.getChars(0, len, buf, 0); writeCharacters(buf, 0, len); } }
@Override public final void writeCharacters(String text) throws IOException, XMLStreamException { final int len = text.length();  /* Not so common case, let's offline:*/ <BUGS> if (len > _copyBufferLen) { longWriteCharacters(text); return; <BUGE> } if (len > 0) { char[] buf = _copyBuffer; text.getChars(0, len, buf, 0); writeCharacters(buf, 0, len); } }
@Override public AsyncXMLStreamReader<AsyncByteArrayFeeder> createAsyncFor(byte[] input) throws XMLStreamException { <BUGS> ReaderConfig cfg = getNonSharedConfig(null, null, null, false, false); cfg.setActualEncoding("UTF-8"); AsyncByteArrayScanner scanner = new AsyncByteArrayScanner(cfg); return new AsyncStreamReaderImpl<AsyncByteArrayFeeder>(scanner); <BUGE> }
protected void reportPrologUnexpChar(boolean isProlog, int ch, String msg) throws XMLStreamException { <BUGS> String fullMsg = isProlog ? ErrorConsts.SUFFIX_IN_PROLOG : ErrorConsts.SUFFIX_IN_EPILOG; if (msg == null) { <BUGE> if (ch == '&') { throwUnexpectedChar(ch, fullMsg+"; no entities allowed"); } } else { fullMsg += msg; } throwUnexpectedChar(ch, fullMsg); }
protected void reportPrologUnexpChar(boolean isProlog, int ch, String msg) throws XMLStreamException { String fullMsg = isProlog ? ErrorConsts.SUFFIX_IN_PROLOG : ErrorConsts.SUFFIX_IN_EPILOG; if (msg == null) { if (ch == '&') { throwUnexpectedChar(ch, fullMsg+"; no entities allowed"); } } else { <BUGS> fullMsg += msg; <BUGE> } throwUnexpectedChar(ch, fullMsg); }
protected void reportPrologUnexpChar(boolean isProlog, int ch, String msg) throws XMLStreamException { String fullMsg = isProlog ? ErrorConsts.SUFFIX_IN_PROLOG : ErrorConsts.SUFFIX_IN_EPILOG; if (msg == null) { if (ch == '&') { throwUnexpectedChar(ch, fullMsg+"; no entities allowed"); } } else { fullMsg += msg; } <BUGS> throwUnexpectedChar(ch, fullMsg); <BUGE> }
protected final void verifyXmlChar(int value) throws XMLStreamException { /* Ok, and then need to check result is a valid XML content char:*/ <BUGS> if (value >= 0xD800) { /* note: checked for overflow earlier <BUGE>*/ if (value < 0xE000) { /* no surrogates via entity expansion*/ reportInvalidXmlChar(value); } if (value == 0xFFFE || value == 0xFFFF) { reportInvalidXmlChar(value); } } else if (value < 32) { /* XML 1.1 allows most other chars; 1.0 does not:*/ if (value != INT_LF && value != INT_CR && value != INT_TAB) { if (!_xml11 || value == 0) { reportInvalidXmlChar(value); } } } }
protected final void verifyXmlChar(int value) throws XMLStreamException { /* Ok, and then need to check result is a valid XML content char:*/ if (value >= 0xD800) { /* note: checked for overflow earlier*/ if (value < 0xE000) { /* no surrogates via entity expansion*/ reportInvalidXmlChar(value); } if (value == 0xFFFE || value == 0xFFFF) { reportInvalidXmlChar(value); } <BUGS> } else if (value < 32) { <BUGE> /* XML 1.1 allows most other chars; 1.0 does not:*/ if (value != INT_LF && value != INT_CR && value != INT_TAB) { if (!_xml11 || value == 0) { reportInvalidXmlChar(value); } } } }
protected final void verifyXmlChar(int value) throws XMLStreamException { /* Ok, and then need to check result is a valid XML content char:*/ if (value >= 0xD800) { /* note: checked for overflow earlier*/ if (value < 0xE000) { /* no surrogates via entity expansion*/ reportInvalidXmlChar(value); } if (value == 0xFFFE || value == 0xFFFF) { reportInvalidXmlChar(value); } } else if (value < 32) { /* XML 1.1 allows most other chars; 1.0 does not:*/ <BUGS> if (value != INT_LF && value != INT_CR && value != INT_TAB) { if (!_xml11 || value == 0) { reportInvalidXmlChar(value); <BUGE> } } } }
protected final void verifyXmlChar(int value) throws XMLStreamException { /* Ok, and then need to check result is a valid XML content char:*/ if (value >= 0xD800) { /* note: checked for overflow earlier*/ if (value < 0xE000) { /* no surrogates via entity expansion*/ reportInvalidXmlChar(value); } if (value == 0xFFFE || value == 0xFFFF) { reportInvalidXmlChar(value); } } else if (value < 32) { /* XML 1.1 allows most other chars; 1.0 does not:*/ if (value != INT_LF && value != INT_CR && value != INT_TAB) { if (!_xml11 || value == 0) { reportInvalidXmlChar(value); } } } <BUGS> } <BUGE>
*/ <BUGS> public ClassParser(InputStream inputStream, String file_name) { this.file_name = file_name; fileOwned = false; String clazz = inputStream.getClass().getName(); /* Not a very clean solution ...*/ is_zip = clazz.startsWith("java.util.zip.") || clazz.startsWith("java.util.jar."); if (inputStream instanceof DataInputStream) { <BUGE> this.dataInputStream = (DataInputStream) inputStream; } else { this.dataInputStream = new DataInputStream(new BufferedInputStream(inputStream, BUFSIZE)); } }
*/ public ClassParser(InputStream inputStream, String file_name) { this.file_name = file_name; fileOwned = false; String clazz = inputStream.getClass().getName(); /* Not a very clean solution ...*/ is_zip = clazz.startsWith("java.util.zip.") || clazz.startsWith("java.util.jar."); if (inputStream instanceof DataInputStream) { this.dataInputStream = (DataInputStream) inputStream; } else { <BUGS> this.dataInputStream = new DataInputStream(new BufferedInputStream(inputStream, BUFSIZE)); <BUGE> } }
*/ public ClassParser(InputStream inputStream, String file_name) { this.file_name = file_name; fileOwned = false; String clazz = inputStream.getClass().getName(); /* Not a very clean solution ...*/ is_zip = clazz.startsWith("java.util.zip.") || clazz.startsWith("java.util.jar."); if (inputStream instanceof DataInputStream) { this.dataInputStream = (DataInputStream) inputStream; } else { this.dataInputStream = new DataInputStream(new BufferedInputStream(inputStream, BUFSIZE)); } <BUGS> } <BUGE>
public String getName() { <BUGS> return name; <BUGE> }
*/ public static JavaClass lookupClass( String class_name ) throws ClassNotFoundException { <BUGS> return _repository.loadClass(class_name); <BUGE> }
*/ public static String getTypeName(final int index) { <BUGS> return TYPE_NAMES[index]; <BUGE> }
*/ public String toString( final ConstantPool cp ) { <BUGS> return toString(false); <BUGE> }
*/ public List<AnnotationEntryGen> getAnnotationsOnParameter(final int i) { <BUGS> ensureExistingParameterAnnotationsUnpacked(); <BUGE> if (!hasParameterAnnotations || i>arg_types.length) { return null; } return param_annotations[i]; }
private void fillLength(byte[] aBuffer, int aOffset, int aLength) {  <BUGS> if(aLength < 0x80) { <BUGE> aBuffer[aOffset] = (byte) aLength;  } else if (aLength <0x100) { aBuffer[aOffset] = (byte) 0x81; aBuffer[aOffset+1] = (byte) aLength;  } else if( aLength < 0x10000) {  aBuffer[aOffset]   = (byte) 0x82; aBuffer[aOffset+1] = (byte) (aLength / 0x100); aBuffer[aOffset+2] = (byte) (aLength % 0x100);  } else if( aLength < 0x1000000 ) { aBuffer[aOffset]   = (byte) 0x83; aBuffer[aOffset+1] = (byte) (aLength / 0x10000); aBuffer[aOffset+2] = (byte) (aLength / 0x100); aBuffer[aOffset+3] = (byte) (aLength % 0x100); } else { throw new IllegalStateException("length ["+aLength+"] out of range (0x1000000)"); } }
private void fillLength(byte[] aBuffer, int aOffset, int aLength) {  if(aLength < 0x80) { aBuffer[aOffset] = (byte) aLength;  <BUGS> } else if (aLength <0x100) { <BUGE> aBuffer[aOffset] = (byte) 0x81; aBuffer[aOffset+1] = (byte) aLength;  } else if( aLength < 0x10000) {  aBuffer[aOffset]   = (byte) 0x82; aBuffer[aOffset+1] = (byte) (aLength / 0x100); aBuffer[aOffset+2] = (byte) (aLength % 0x100);  } else if( aLength < 0x1000000 ) { aBuffer[aOffset]   = (byte) 0x83; aBuffer[aOffset+1] = (byte) (aLength / 0x10000); aBuffer[aOffset+2] = (byte) (aLength / 0x100); aBuffer[aOffset+3] = (byte) (aLength % 0x100); } else { throw new IllegalStateException("length ["+aLength+"] out of range (0x1000000)"); } }
private void fillLength(byte[] aBuffer, int aOffset, int aLength) {  if(aLength < 0x80) { aBuffer[aOffset] = (byte) aLength;  } else if (aLength <0x100) { aBuffer[aOffset] = (byte) 0x81; aBuffer[aOffset+1] = (byte) aLength;  <BUGS> } else if( aLength < 0x10000) { <BUGE>  aBuffer[aOffset]   = (byte) 0x82; aBuffer[aOffset+1] = (byte) (aLength / 0x100); aBuffer[aOffset+2] = (byte) (aLength % 0x100);  } else if( aLength < 0x1000000 ) { aBuffer[aOffset]   = (byte) 0x83; aBuffer[aOffset+1] = (byte) (aLength / 0x10000); aBuffer[aOffset+2] = (byte) (aLength / 0x100); aBuffer[aOffset+3] = (byte) (aLength % 0x100); } else { throw new IllegalStateException("length ["+aLength+"] out of range (0x1000000)"); } }
private void fillLength(byte[] aBuffer, int aOffset, int aLength) {  if(aLength < 0x80) { aBuffer[aOffset] = (byte) aLength;  } else if (aLength <0x100) { aBuffer[aOffset] = (byte) 0x81; aBuffer[aOffset+1] = (byte) aLength;  } else if( aLength < 0x10000) {  <BUGS> aBuffer[aOffset]   = (byte) 0x82; aBuffer[aOffset+1] = (byte) (aLength / 0x100); aBuffer[aOffset+2] = (byte) (aLength % 0x100); <BUGE>  } else if( aLength < 0x1000000 ) { aBuffer[aOffset]   = (byte) 0x83; aBuffer[aOffset+1] = (byte) (aLength / 0x10000); aBuffer[aOffset+2] = (byte) (aLength / 0x100); aBuffer[aOffset+3] = (byte) (aLength % 0x100); } else { throw new IllegalStateException("length ["+aLength+"] out of range (0x1000000)"); } }
private void fillLength(byte[] aBuffer, int aOffset, int aLength) {  if(aLength < 0x80) { aBuffer[aOffset] = (byte) aLength;  } else if (aLength <0x100) { aBuffer[aOffset] = (byte) 0x81; aBuffer[aOffset+1] = (byte) aLength;  } else if( aLength < 0x10000) {  aBuffer[aOffset]   = (byte) 0x82; aBuffer[aOffset+1] = (byte) (aLength / 0x100); aBuffer[aOffset+2] = (byte) (aLength % 0x100);  } else if( aLength < 0x1000000 ) { aBuffer[aOffset]   = (byte) 0x83; aBuffer[aOffset+1] = (byte) (aLength / 0x10000); aBuffer[aOffset+2] = (byte) (aLength / 0x100); aBuffer[aOffset+3] = (byte) (aLength % 0x100); } else { throw new IllegalStateException("length ["+aLength+"] out of range (0x1000000)"); } <BUGS> } <BUGE>
private void fillLength(byte[] aBuffer, int aOffset, int aLength) {  <BUGS> if(aLength < 0x80) { <BUGE> aBuffer[aOffset] = (byte) aLength;  } else if (aLength <0x100) { aBuffer[aOffset] = (byte) 0x81; aBuffer[aOffset+1] = (byte) aLength;  } else if( aLength < 0x10000) {  aBuffer[aOffset]   = (byte) 0x82; aBuffer[aOffset+1] = (byte) (aLength / 0x100); aBuffer[aOffset+2] = (byte) (aLength % 0x100);  } else if( aLength < 0x1000000 ) { aBuffer[aOffset]   = (byte) 0x83; aBuffer[aOffset+1] = (byte) (aLength / 0x10000); aBuffer[aOffset+2] = (byte) (aLength / 0x100); aBuffer[aOffset+3] = (byte) (aLength % 0x100); } else { throw new IllegalStateException("length ["+aLength+"] out of range (0x1000000)"); } }
private void fillLength(byte[] aBuffer, int aOffset, int aLength) {  if(aLength < 0x80) { aBuffer[aOffset] = (byte) aLength;  <BUGS> } else if (aLength <0x100) { <BUGE> aBuffer[aOffset] = (byte) 0x81; aBuffer[aOffset+1] = (byte) aLength;  } else if( aLength < 0x10000) {  aBuffer[aOffset]   = (byte) 0x82; aBuffer[aOffset+1] = (byte) (aLength / 0x100); aBuffer[aOffset+2] = (byte) (aLength % 0x100);  } else if( aLength < 0x1000000 ) { aBuffer[aOffset]   = (byte) 0x83; aBuffer[aOffset+1] = (byte) (aLength / 0x10000); aBuffer[aOffset+2] = (byte) (aLength / 0x100); aBuffer[aOffset+3] = (byte) (aLength % 0x100); } else { throw new IllegalStateException("length ["+aLength+"] out of range (0x1000000)"); } }
private void fillLength(byte[] aBuffer, int aOffset, int aLength) {  if(aLength < 0x80) { aBuffer[aOffset] = (byte) aLength;  } else if (aLength <0x100) { aBuffer[aOffset] = (byte) 0x81; aBuffer[aOffset+1] = (byte) aLength;  <BUGS> } else if( aLength < 0x10000) { <BUGE>  aBuffer[aOffset]   = (byte) 0x82; aBuffer[aOffset+1] = (byte) (aLength / 0x100); aBuffer[aOffset+2] = (byte) (aLength % 0x100);  } else if( aLength < 0x1000000 ) { aBuffer[aOffset]   = (byte) 0x83; aBuffer[aOffset+1] = (byte) (aLength / 0x10000); aBuffer[aOffset+2] = (byte) (aLength / 0x100); aBuffer[aOffset+3] = (byte) (aLength % 0x100); } else { throw new IllegalStateException("length ["+aLength+"] out of range (0x1000000)"); } }
private void fillLength(byte[] aBuffer, int aOffset, int aLength) {  if(aLength < 0x80) { aBuffer[aOffset] = (byte) aLength;  } else if (aLength <0x100) { aBuffer[aOffset] = (byte) 0x81; aBuffer[aOffset+1] = (byte) aLength;  } else if( aLength < 0x10000) {  <BUGS> aBuffer[aOffset]   = (byte) 0x82; aBuffer[aOffset+1] = (byte) (aLength / 0x100); aBuffer[aOffset+2] = (byte) (aLength % 0x100); <BUGE>  } else if( aLength < 0x1000000 ) { aBuffer[aOffset]   = (byte) 0x83; aBuffer[aOffset+1] = (byte) (aLength / 0x10000); aBuffer[aOffset+2] = (byte) (aLength / 0x100); aBuffer[aOffset+3] = (byte) (aLength % 0x100); } else { throw new IllegalStateException("length ["+aLength+"] out of range (0x1000000)"); } }
private void fillLength(byte[] aBuffer, int aOffset, int aLength) {  if(aLength < 0x80) { aBuffer[aOffset] = (byte) aLength;  } else if (aLength <0x100) { aBuffer[aOffset] = (byte) 0x81; aBuffer[aOffset+1] = (byte) aLength;  } else if( aLength < 0x10000) {  aBuffer[aOffset]   = (byte) 0x82; aBuffer[aOffset+1] = (byte) (aLength / 0x100); aBuffer[aOffset+2] = (byte) (aLength % 0x100);  } else if( aLength < 0x1000000 ) { aBuffer[aOffset]   = (byte) 0x83; aBuffer[aOffset+1] = (byte) (aLength / 0x10000); aBuffer[aOffset+2] = (byte) (aLength / 0x100); aBuffer[aOffset+3] = (byte) (aLength % 0x100); } else { throw new IllegalStateException("length ["+aLength+"] out of range (0x1000000)"); } <BUGS> } <BUGE>
@Override public boolean equals(Object o) { <BUGS> if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; <BUGE>  BerTag berTag = (BerTag) o;  return Arrays.equals(bytes, berTag.bytes);  }
@Override public boolean equals(Object o) { if (this == o) return true; if (o == null || getClass() != o.getClass()) return false;  <BUGS> BerTag berTag = (BerTag) o; <BUGE>  return Arrays.equals(bytes, berTag.bytes);  }
@Override public boolean equals(Object o) { if (this == o) return true; if (o == null || getClass() != o.getClass()) return false;  BerTag berTag = (BerTag) o;  <BUGS> return Arrays.equals(bytes, berTag.bytes); <BUGE>  }
public BerTlv find(BerTag aTag) { <BUGS> for (BerTlv tlv : tlvs) { BerTlv found = tlv.find(aTag); if(found!=null) { <BUGE> return found; } } return null; }
public BerTlv find(BerTag aTag) { for (BerTlv tlv : tlvs) { BerTlv found = tlv.find(aTag); if(found!=null) { return found; } <BUGS> } return null; <BUGE> }
*/ private String extractErrorMessageFromResponse(HttpResponse response) { <BUGS> String contentType = response.getEntity().getContentType().getValue(); if(contentType.contains("application/json")) { Gson gson = GsonResponseParser.getDefaultGsonParser(false); String responseBody = null; <BUGE> try { responseBody = EntityUtils.toString(response.getEntity()); LOG.error("Body of error response from Canvas: " + responseBody); CanvasErrorResponse errorResponse = gson.fromJson(responseBody, CanvasErrorResponse.class); List<ErrorMessage> errors = errorResponse.getErrors(); if(errors != null) { /*I have only ever seen a single error message but it is an array so presumably there could be more.*/ return errors.stream().map(e -> e.getMessage()).collect(Collectors.joining(", ")); } } catch (Exception e) { /*Returned JSON was not in expected format. Fall back to returning the whole response body, if any*/ if(StringUtils.isNotBlank(responseBody)) { return responseBody; } } } return null; }
*/ private String extractErrorMessageFromResponse(HttpResponse response) { String contentType = response.getEntity().getContentType().getValue(); if(contentType.contains("application/json")) { Gson gson = GsonResponseParser.getDefaultGsonParser(false); String responseBody = null; try { <BUGS> responseBody = EntityUtils.toString(response.getEntity()); LOG.error("Body of error response from Canvas: " + responseBody); CanvasErrorResponse errorResponse = gson.fromJson(responseBody, CanvasErrorResponse.class); List<ErrorMessage> errors = errorResponse.getErrors(); if(errors != null) { <BUGE> /*I have only ever seen a single error message but it is an array so presumably there could be more.*/ return errors.stream().map(e -> e.getMessage()).collect(Collectors.joining(", ")); } } catch (Exception e) { /*Returned JSON was not in expected format. Fall back to returning the whole response body, if any*/ if(StringUtils.isNotBlank(responseBody)) { return responseBody; } } } return null; }
*/ private String extractErrorMessageFromResponse(HttpResponse response) { String contentType = response.getEntity().getContentType().getValue(); if(contentType.contains("application/json")) { Gson gson = GsonResponseParser.getDefaultGsonParser(false); String responseBody = null; try { responseBody = EntityUtils.toString(response.getEntity()); LOG.error("Body of error response from Canvas: " + responseBody); CanvasErrorResponse errorResponse = gson.fromJson(responseBody, CanvasErrorResponse.class); List<ErrorMessage> errors = errorResponse.getErrors(); if(errors != null) { /*I have only ever seen a single error message but it is an array so presumably there could be more.*/ return errors.stream().map(e -> e.getMessage()).collect(Collectors.joining(", ")); } } catch (Exception e) { /*Returned JSON was not in expected format. Fall back to returning the whole response body, if any*/ if(StringUtils.isNotBlank(responseBody)) { return responseBody; } <BUGS> } <BUGE> } return null; }
*/ private String extractErrorMessageFromResponse(HttpResponse response) { String contentType = response.getEntity().getContentType().getValue(); if(contentType.contains("application/json")) { Gson gson = GsonResponseParser.getDefaultGsonParser(false); String responseBody = null; try { responseBody = EntityUtils.toString(response.getEntity()); LOG.error("Body of error response from Canvas: " + responseBody); CanvasErrorResponse errorResponse = gson.fromJson(responseBody, CanvasErrorResponse.class); List<ErrorMessage> errors = errorResponse.getErrors(); if(errors != null) { /*I have only ever seen a single error message but it is an array so presumably there could be more.*/ return errors.stream().map(e -> e.getMessage()).collect(Collectors.joining(", ")); } } catch (Exception e) { /*Returned JSON was not in expected format. Fall back to returning the whole response body, if any*/ if(StringUtils.isNotBlank(responseBody)) { return responseBody; } } } <BUGS> return null; <BUGE> }
public void setDueAt(Date dueAt) { <BUGS> this.dueAt = dueAt; } <BUGE>
*/ public void setSelected(Option option) throws AlreadySelectedException { <BUGS> if (option == null) <BUGE> { /* reset the option previously selected*/ selected = null; return; }  /* if no option has already been selected or the */ /* same option is being reselected then set the*/ /* selected member variable*/ if (selected == null || selected.equals(option.getKey())) { selected = option.getKey(); } else { throw new AlreadySelectedException(this, option); } }
*/ public void setSelected(Option option) throws AlreadySelectedException { if (option == null) { /* reset the option previously selected*/ <BUGS> selected = null; return; <BUGE> }  /* if no option has already been selected or the */ /* same option is being reselected then set the*/ /* selected member variable*/ if (selected == null || selected.equals(option.getKey())) { selected = option.getKey(); } else { throw new AlreadySelectedException(this, option); } }
*/ public void setSelected(Option option) throws AlreadySelectedException { if (option == null) { /* reset the option previously selected*/ selected = null; return; }  /* if no option has already been selected or the */ /* same option is being reselected then set the*/ /* selected member variable*/ <BUGS> if (selected == null || selected.equals(option.getKey())) <BUGE> { selected = option.getKey(); } else { throw new AlreadySelectedException(this, option); } }
*/ public void setSelected(Option option) throws AlreadySelectedException { if (option == null) { /* reset the option previously selected*/ selected = null; return; }  /* if no option has already been selected or the */ /* same option is being reselected then set the*/ /* selected member variable*/ if (selected == null || selected.equals(option.getKey())) { <BUGS> selected = option.getKey(); <BUGE> } else { throw new AlreadySelectedException(this, option); } }
*/ public void setSelected(Option option) throws AlreadySelectedException { if (option == null) { /* reset the option previously selected*/ selected = null; return; }  /* if no option has already been selected or the */ /* same option is being reselected then set the*/ /* selected member variable*/ if (selected == null || selected.equals(option.getKey())) { selected = option.getKey(); } else { <BUGS> throw new AlreadySelectedException(this, option); <BUGE> } }
*/ public void setSelected(Option option) throws AlreadySelectedException { if (option == null) { /* reset the option previously selected*/ selected = null; return; }  /* if no option has already been selected or the */ /* same option is being reselected then set the*/ /* selected member variable*/ if (selected == null || selected.equals(option.getKey())) { selected = option.getKey(); } else { throw new AlreadySelectedException(this, option); } <BUGS> } <BUGE>
*/ public void setArgName(String name) { <BUGS> this.defaultArgName = name; } <BUGE>
*/ protected int findWrapPos(String text, int width, int startPos) { int pos;  /* the line ends before the max wrap pos or a new line char found*/ <BUGS> if (((pos = text.indexOf('\n', startPos)) != -1 && pos <= width) || ((pos = text.indexOf('\t', startPos)) != -1 && pos <= width)) <BUGE> { return pos + 1; } else if (startPos + width >= text.length()) { return -1; }   /* look for the last whitespace character before startPos+width*/ pos = startPos + width;  char c;  while ((pos >= startPos) && ((c = text.charAt(pos)) != ' ') && (c != '\n') && (c != '\r')) { --pos; }  /* if we found it - just return*/ if (pos > startPos)
*/ protected int findWrapPos(String text, int width, int startPos) { int pos;  /* the line ends before the max wrap pos or a new line char found*/ if (((pos = text.indexOf('\n', startPos)) != -1 && pos <= width) || ((pos = text.indexOf('\t', startPos)) != -1 && pos <= width)) { return pos + 1; } <BUGS> else if (startPos + width >= text.length()) <BUGE> { return -1; }   /* look for the last whitespace character before startPos+width*/ pos = startPos + width;  char c;  while ((pos >= startPos) && ((c = text.charAt(pos)) != ' ') && (c != '\n') && (c != '\r')) { --pos; }  /* if we found it - just return*/ if (pos > startPos)
*/ protected int findWrapPos(String text, int width, int startPos) { int pos;  /* the line ends before the max wrap pos or a new line char found*/ if (((pos = text.indexOf('\n', startPos)) != -1 && pos <= width) || ((pos = text.indexOf('\t', startPos)) != -1 && pos <= width)) { return pos + 1; } else if (startPos + width >= text.length()) { <BUGS> return -1; <BUGE> }   /* look for the last whitespace character before startPos+width*/ pos = startPos + width;  char c;  while ((pos >= startPos) && ((c = text.charAt(pos)) != ' ') && (c != '\n') && (c != '\r')) { --pos; }  /* if we found it - just return*/ if (pos > startPos)
*/ protected int findWrapPos(String text, int width, int startPos) { int pos;  /* the line ends before the max wrap pos or a new line char found*/ if (((pos = text.indexOf('\n', startPos)) != -1 && pos <= width) || ((pos = text.indexOf('\t', startPos)) != -1 && pos <= width)) { return pos + 1; } else if (startPos + width >= text.length()) { return -1; }   /* look for the last whitespace character before startPos+width*/ <BUGS> pos = startPos + width; <BUGE>  char c;  while ((pos >= startPos) && ((c = text.charAt(pos)) != ' ') && (c != '\n') && (c != '\r')) { --pos; }  /* if we found it - just return*/ if (pos > startPos)
*/ protected int findWrapPos(String text, int width, int startPos) { int pos;  /* the line ends before the max wrap pos or a new line char found*/ if (((pos = text.indexOf('\n', startPos)) != -1 && pos <= width) || ((pos = text.indexOf('\t', startPos)) != -1 && pos <= width)) { return pos + 1; } else if (startPos + width >= text.length()) { return -1; }   /* look for the last whitespace character before startPos+width*/ pos = startPos + width;  char c;  <BUGS> while ((pos >= startPos) && ((c = text.charAt(pos)) != ' ') <BUGE> && (c != '\n') && (c != '\r')) { --pos; }  /* if we found it - just return*/ if (pos > startPos)
*/ protected int findWrapPos(String text, int width, int startPos) { int pos;  /* the line ends before the max wrap pos or a new line char found*/ if (((pos = text.indexOf('\n', startPos)) != -1 && pos <= width) || ((pos = text.indexOf('\t', startPos)) != -1 && pos <= width)) { return pos + 1; } else if (startPos + width >= text.length()) { return -1; }   /* look for the last whitespace character before startPos+width*/ pos = startPos + width;  char c;  while ((pos >= startPos) && ((c = text.charAt(pos)) != ' ') && (c != '\n') && (c != '\r')) { <BUGS> --pos; <BUGE> }  /* if we found it - just return*/ if (pos > startPos)
*/ protected int findWrapPos(String text, int width, int startPos) { int pos;  /* the line ends before the max wrap pos or a new line char found*/ if (((pos = text.indexOf('\n', startPos)) != -1 && pos <= width) || ((pos = text.indexOf('\t', startPos)) != -1 && pos <= width)) { return pos + 1; } else if (startPos + width >= text.length()) { return -1; }   /* look for the last whitespace character before startPos+width*/ pos = startPos + width;  char c;  while ((pos >= startPos) && ((c = text.charAt(pos)) != ' ') && (c != '\n') && (c != '\r')) { --pos; }  /* if we found it - just return*/ <BUGS> if (pos > startPos) <BUGE>
/** * Finds the next text wrap position after <code>startPos</code> for the * text in <code>text</code> with the column width <code>width</code>. * The wrap point is the last position before startPos+width having a * whitespace character (space, \n, \r). If there is no whitespace character * before startPos+width, it will return startPos+width. * * @param text The text being searched for the wrap position * @param width width of the wrapped text * @param startPos position from which to start the lookup whitespace * character * @return postion on which the text must be wrapped or -1 if the wrap * position is at the end of the text { <BUGS> return pos; <BUGE> }  /* if we didn't find one, simply chop at startPos+width*/ pos = startPos + width; while ((pos <= text.length()) && ((c = text.charAt(pos)) != ' ') && (c != '\n') && (c != '\r')) { ++pos; } return pos == text.length() ? -1 : pos; }  /** * Return a String of padding of length <code>len</code>.
/** * Finds the next text wrap position after <code>startPos</code> for the * text in <code>text</code> with the column width <code>width</code>. * The wrap point is the last position before startPos+width having a * whitespace character (space, \n, \r). If there is no whitespace character * before startPos+width, it will return startPos+width. * * @param text The text being searched for the wrap position * @param width width of the wrapped text * @param startPos position from which to start the lookup whitespace * character * @return postion on which the text must be wrapped or -1 if the wrap * position is at the end of the text /* if we didn't find one, simply chop at startPos+width*/ <BUGS> pos = startPos + width; while ((pos <= text.length()) && ((c = text.charAt(pos)) != ' ') <BUGE> && (c != '\n') && (c != '\r')) { ++pos; } return pos == text.length() ? -1 : pos; }  /** * Return a String of padding of length <code>len</code>. * * @param len The length of the String of padding to create. * * @return The String of padding
/** * Finds the next text wrap position after <code>startPos</code> for the * text in <code>text</code> with the column width <code>width</code>. * The wrap point is the last position before startPos+width having a * whitespace character (space, \n, \r). If there is no whitespace character * before startPos+width, it will return startPos+width. * * @param text The text being searched for the wrap position * @param width width of the wrapped text * @param startPos position from which to start the lookup whitespace * character * @return postion on which the text must be wrapped or -1 if the wrap * position is at the end of the text { <BUGS> ++pos; <BUGE> } return pos == text.length() ? -1 : pos; }  /** * Return a String of padding of length <code>len</code>. * * @param len The length of the String of padding to create. * * @return The String of padding */ protected String createPadding(int len) { char[] padding = new char[len];
/** * Finds the next text wrap position after <code>startPos</code> for the * text in <code>text</code> with the column width <code>width</code>. * The wrap point is the last position before startPos+width having a * whitespace character (space, \n, \r). If there is no whitespace character * before startPos+width, it will return startPos+width. * * @param text The text being searched for the wrap position * @param width width of the wrapped text * @param startPos position from which to start the lookup whitespace * character * @return postion on which the text must be wrapped or -1 if the wrap * position is at the end of the text } <BUGS> return pos == text.length() ? -1 : pos; <BUGE> }  /** * Return a String of padding of length <code>len</code>. * * @param len The length of the String of padding to create. * * @return The String of padding */ protected String createPadding(int len) { char[] padding = new char[len]; Arrays.fill(padding, ' ');
*/ public void printHelp(PrintWriter pw, int width, String cmdLineSyntax, String header, Options options, int leftPad, int descPad, String footer, boolean autoUsage) { <BUGS> if ((cmdLineSyntax == null) || (cmdLineSyntax.length() == 0)) <BUGE> { throw new IllegalArgumentException("cmdLineSyntax not provided"); }  if (autoUsage) { printUsage(pw, width, cmdLineSyntax, options); } else { printUsage(pw, width, cmdLineSyntax); }  if ((header != null) && (header.trim().length() > 0)) { printWrapped(pw, width, header); }  printOptions(pw, width, options, leftPad, descPad);  if ((footer != null) && (footer.trim().length() > 0)) { printWrapped(pw, width, footer); }
*/ public void printHelp(PrintWriter pw, int width, String cmdLineSyntax, String header, Options options, int leftPad, int descPad, String footer, boolean autoUsage) { if ((cmdLineSyntax == null) || (cmdLineSyntax.length() == 0)) { throw new IllegalArgumentException("cmdLineSyntax not provided"); }  <BUGS> if (autoUsage) <BUGE> { printUsage(pw, width, cmdLineSyntax, options); } else { printUsage(pw, width, cmdLineSyntax); }  if ((header != null) && (header.trim().length() > 0)) { printWrapped(pw, width, header); }  printOptions(pw, width, options, leftPad, descPad);  if ((footer != null) && (footer.trim().length() > 0)) { printWrapped(pw, width, footer); }
*/ public void printHelp(PrintWriter pw, int width, String cmdLineSyntax, String header, Options options, int leftPad, int descPad, String footer, boolean autoUsage) { if ((cmdLineSyntax == null) || (cmdLineSyntax.length() == 0)) { throw new IllegalArgumentException("cmdLineSyntax not provided"); }  if (autoUsage) { <BUGS> printUsage(pw, width, cmdLineSyntax, options); <BUGE> } else { printUsage(pw, width, cmdLineSyntax); }  if ((header != null) && (header.trim().length() > 0)) { printWrapped(pw, width, header); }  printOptions(pw, width, options, leftPad, descPad);  if ((footer != null) && (footer.trim().length() > 0)) { printWrapped(pw, width, footer); }
*/ public void printHelp(PrintWriter pw, int width, String cmdLineSyntax, String header, Options options, int leftPad, int descPad, String footer, boolean autoUsage) { if ((cmdLineSyntax == null) || (cmdLineSyntax.length() == 0)) { throw new IllegalArgumentException("cmdLineSyntax not provided"); }  if (autoUsage) { printUsage(pw, width, cmdLineSyntax, options); } else { printUsage(pw, width, cmdLineSyntax); }  <BUGS> if ((header != null) && (header.trim().length() > 0)) <BUGE> { printWrapped(pw, width, header); }  printOptions(pw, width, options, leftPad, descPad);  if ((footer != null) && (footer.trim().length() > 0)) { printWrapped(pw, width, footer); }
*/ public void printHelp(PrintWriter pw, int width, String cmdLineSyntax, String header, Options options, int leftPad, int descPad, String footer, boolean autoUsage) { if ((cmdLineSyntax == null) || (cmdLineSyntax.length() == 0)) { throw new IllegalArgumentException("cmdLineSyntax not provided"); }  if (autoUsage) { printUsage(pw, width, cmdLineSyntax, options); } else { printUsage(pw, width, cmdLineSyntax); }  if ((header != null) && (header.trim().length() > 0)) { <BUGS> printWrapped(pw, width, header); <BUGE> }  printOptions(pw, width, options, leftPad, descPad);  if ((footer != null) && (footer.trim().length() > 0)) { printWrapped(pw, width, footer); }
*/ public void printHelp(PrintWriter pw, int width, String cmdLineSyntax, String header, Options options, int leftPad, int descPad, String footer, boolean autoUsage) { if ((cmdLineSyntax == null) || (cmdLineSyntax.length() == 0)) { throw new IllegalArgumentException("cmdLineSyntax not provided"); }  if (autoUsage) { printUsage(pw, width, cmdLineSyntax, options); } else { printUsage(pw, width, cmdLineSyntax); }  if ((header != null) && (header.trim().length() > 0)) { printWrapped(pw, width, header); }  <BUGS> printOptions(pw, width, options, leftPad, descPad); <BUGE>  if ((footer != null) && (footer.trim().length() > 0)) { printWrapped(pw, width, footer); }
*/ public void printHelp(PrintWriter pw, int width, String cmdLineSyntax, String header, Options options, int leftPad, int descPad, String footer, boolean autoUsage) { if ((cmdLineSyntax == null) || (cmdLineSyntax.length() == 0)) { throw new IllegalArgumentException("cmdLineSyntax not provided"); }  if (autoUsage) { printUsage(pw, width, cmdLineSyntax, options); } else { printUsage(pw, width, cmdLineSyntax); }  if ((header != null) && (header.trim().length() > 0)) { printWrapped(pw, width, header); }  printOptions(pw, width, options, leftPad, descPad);  <BUGS> if ((footer != null) && (footer.trim().length() > 0)) <BUGE> { printWrapped(pw, width, footer); }
*/ public void printHelp(PrintWriter pw, int width, String cmdLineSyntax, String header, Options options, int leftPad, int descPad, String footer, boolean autoUsage) { if ((cmdLineSyntax == null) || (cmdLineSyntax.length() == 0)) { throw new IllegalArgumentException("cmdLineSyntax not provided"); }  if (autoUsage) { printUsage(pw, width, cmdLineSyntax, options); } else { printUsage(pw, width, cmdLineSyntax); }  if ((header != null) && (header.trim().length() > 0)) { printWrapped(pw, width, header); }  printOptions(pw, width, options, leftPad, descPad);  if ((footer != null) && (footer.trim().length() > 0)) { <BUGS> printWrapped(pw, width, footer); <BUGE> }
*/ public void printHelp(PrintWriter pw, int width, String cmdLineSyntax, String header, Options options, int leftPad, int descPad, String footer, boolean autoUsage) { if ((cmdLineSyntax == null) || (cmdLineSyntax.length() == 0)) { throw new IllegalArgumentException("cmdLineSyntax not provided"); }  if (autoUsage) { printUsage(pw, width, cmdLineSyntax, options); } else { printUsage(pw, width, cmdLineSyntax); }  if ((header != null) && (header.trim().length() > 0)) { printWrapped(pw, width, header); }  printOptions(pw, width, options, leftPad, descPad);  if ((footer != null) && (footer.trim().length() > 0)) { printWrapped(pw, width, footer); }
*/ public static Object createValue(String str, Class clazz) throws ParseException { <BUGS> if (PatternOptionBuilder.STRING_VALUE == clazz) <BUGE> { return str; } else if (PatternOptionBuilder.OBJECT_VALUE == clazz) { return createObject(str); } else if (PatternOptionBuilder.NUMBER_VALUE == clazz) { return createNumber(str); } else if (PatternOptionBuilder.DATE_VALUE == clazz) { return createDate(str); } else if (PatternOptionBuilder.CLASS_VALUE == clazz) { return createClass(str); } else if (PatternOptionBuilder.FILE_VALUE == clazz) { return createFile(str); } else if (PatternOptionBuilder.EXISTING_FILE_VALUE == clazz) { return createFile(str);
*/ public static Object createValue(String str, Class clazz) throws ParseException { if (PatternOptionBuilder.STRING_VALUE == clazz) { return str; } <BUGS> else if (PatternOptionBuilder.OBJECT_VALUE == clazz) <BUGE> { return createObject(str); } else if (PatternOptionBuilder.NUMBER_VALUE == clazz) { return createNumber(str); } else if (PatternOptionBuilder.DATE_VALUE == clazz) { return createDate(str); } else if (PatternOptionBuilder.CLASS_VALUE == clazz) { return createClass(str); } else if (PatternOptionBuilder.FILE_VALUE == clazz) { return createFile(str); } else if (PatternOptionBuilder.EXISTING_FILE_VALUE == clazz) { return createFile(str);
*/ public static Object createValue(String str, Class clazz) throws ParseException { if (PatternOptionBuilder.STRING_VALUE == clazz) { return str; } else if (PatternOptionBuilder.OBJECT_VALUE == clazz) { return createObject(str); } <BUGS> else if (PatternOptionBuilder.NUMBER_VALUE == clazz) <BUGE> { return createNumber(str); } else if (PatternOptionBuilder.DATE_VALUE == clazz) { return createDate(str); } else if (PatternOptionBuilder.CLASS_VALUE == clazz) { return createClass(str); } else if (PatternOptionBuilder.FILE_VALUE == clazz) { return createFile(str); } else if (PatternOptionBuilder.EXISTING_FILE_VALUE == clazz) { return createFile(str);
*/ public static Object createValue(String str, Class clazz) throws ParseException { if (PatternOptionBuilder.STRING_VALUE == clazz) { return str; } else if (PatternOptionBuilder.OBJECT_VALUE == clazz) { return createObject(str); } else if (PatternOptionBuilder.NUMBER_VALUE == clazz) { <BUGS> return createNumber(str); <BUGE> } else if (PatternOptionBuilder.DATE_VALUE == clazz) { return createDate(str); } else if (PatternOptionBuilder.CLASS_VALUE == clazz) { return createClass(str); } else if (PatternOptionBuilder.FILE_VALUE == clazz) { return createFile(str); } else if (PatternOptionBuilder.EXISTING_FILE_VALUE == clazz) { return createFile(str);
*/ public static Object createValue(String str, Class clazz) throws ParseException { if (PatternOptionBuilder.STRING_VALUE == clazz) { return str; } else if (PatternOptionBuilder.OBJECT_VALUE == clazz) { return createObject(str); } else if (PatternOptionBuilder.NUMBER_VALUE == clazz) { return createNumber(str); } <BUGS> else if (PatternOptionBuilder.DATE_VALUE == clazz) <BUGE> { return createDate(str); } else if (PatternOptionBuilder.CLASS_VALUE == clazz) { return createClass(str); } else if (PatternOptionBuilder.FILE_VALUE == clazz) { return createFile(str); } else if (PatternOptionBuilder.EXISTING_FILE_VALUE == clazz) { return createFile(str);
*/ public static Object createValue(String str, Class clazz) throws ParseException { if (PatternOptionBuilder.STRING_VALUE == clazz) { return str; } else if (PatternOptionBuilder.OBJECT_VALUE == clazz) { return createObject(str); } else if (PatternOptionBuilder.NUMBER_VALUE == clazz) { return createNumber(str); } else if (PatternOptionBuilder.DATE_VALUE == clazz) { return createDate(str); } <BUGS> else if (PatternOptionBuilder.CLASS_VALUE == clazz) <BUGE> { return createClass(str); } else if (PatternOptionBuilder.FILE_VALUE == clazz) { return createFile(str); } else if (PatternOptionBuilder.EXISTING_FILE_VALUE == clazz) { return createFile(str);
*/ public static Object createValue(String str, Class clazz) throws ParseException { if (PatternOptionBuilder.STRING_VALUE == clazz) { return str; } else if (PatternOptionBuilder.OBJECT_VALUE == clazz) { return createObject(str); } else if (PatternOptionBuilder.NUMBER_VALUE == clazz) { return createNumber(str); } else if (PatternOptionBuilder.DATE_VALUE == clazz) { return createDate(str); } else if (PatternOptionBuilder.CLASS_VALUE == clazz) { return createClass(str); } <BUGS> else if (PatternOptionBuilder.FILE_VALUE == clazz) <BUGE> { return createFile(str); } else if (PatternOptionBuilder.EXISTING_FILE_VALUE == clazz) { return createFile(str);
*/ public static Object createValue(String str, Class clazz) throws ParseException { if (PatternOptionBuilder.STRING_VALUE == clazz) { return str; } else if (PatternOptionBuilder.OBJECT_VALUE == clazz) { return createObject(str); } else if (PatternOptionBuilder.NUMBER_VALUE == clazz) { return createNumber(str); } else if (PatternOptionBuilder.DATE_VALUE == clazz) { return createDate(str); } else if (PatternOptionBuilder.CLASS_VALUE == clazz) { return createClass(str); } else if (PatternOptionBuilder.FILE_VALUE == clazz) { return createFile(str); } <BUGS> else if (PatternOptionBuilder.EXISTING_FILE_VALUE == clazz) <BUGE> { return createFile(str);
*/ public static Object createValue(String str, Object obj) throws ParseException { return createValue(str, (Class) obj); }  /** * Returns the <code>Object</code> of type <code>clazz</code> * with the value of <code>str</code>. * * @param str the command line value * @param clazz the type of argument * @return The instance of <code>clazz</code> initialised with * the value of <code>str</code>. } <BUGS> else if (PatternOptionBuilder.FILES_VALUE == clazz) <BUGE> { return createFiles(str); } else if (PatternOptionBuilder.URL_VALUE == clazz) { return createURL(str); } else { return null; } }  /**
*/ public static Object createValue(String str, Object obj) throws ParseException { return createValue(str, (Class) obj); }  /** * Returns the <code>Object</code> of type <code>clazz</code> * with the value of <code>str</code>. * * @param str the command line value * @param clazz the type of argument * @return The instance of <code>clazz</code> initialised with * the value of <code>str</code>. } <BUGS> else if (PatternOptionBuilder.URL_VALUE == clazz) <BUGE> { return createURL(str); } else { return null; } }  /** * Create an Object from the classname and empty constructor. * * @param classname the argument value * @return the initialised object, or null if it couldn't create
*/ public static Object createValue(String str, Object obj) throws ParseException { return createValue(str, (Class) obj); }  /** * Returns the <code>Object</code> of type <code>clazz</code> * with the value of <code>str</code>. * * @param str the command line value * @param clazz the type of argument * @return The instance of <code>clazz</code> initialised with * the value of <code>str</code>. { <BUGS> return null; <BUGE> } }  /** * Create an Object from the classname and empty constructor. * * @param classname the argument value * @return the initialised object, or null if it couldn't create * the Object. */ public static Object createObject(String classname) throws ParseException { Class cl = null;
*/ public static Builder builder() { <BUGS> return builder(null); <BUGE> }
*/ public Builder required() { <BUGS> return required(true); <BUGE> }
*/ private void handleShortAndLongOption(String token) throws ParseException { <BUGS> String t = Util.stripLeadingHyphens(token); <BUGE>  int pos = t.indexOf('=');  if (t.length() == 1) { /* -S*/ if (options.hasShortOption(t)) { handleOption(options.getOption(t)); } else { handleUnknownToken(token); } } else if (pos == -1) { /* no equal sign found (-xxx)*/ if (options.hasShortOption(t)) { handleOption(options.getOption(t)); } else if (!options.getMatchingOptions(t).isEmpty()) { /* -L or -l*/ handleLongOptionWithoutEqual(token);
*/ private void handleShortAndLongOption(String token) throws ParseException { String t = Util.stripLeadingHyphens(token);  <BUGS> int pos = t.indexOf('='); <BUGE>  if (t.length() == 1) { /* -S*/ if (options.hasShortOption(t)) { handleOption(options.getOption(t)); } else { handleUnknownToken(token); } } else if (pos == -1) { /* no equal sign found (-xxx)*/ if (options.hasShortOption(t)) { handleOption(options.getOption(t)); } else if (!options.getMatchingOptions(t).isEmpty()) { /* -L or -l*/ handleLongOptionWithoutEqual(token);
*/ private void handleShortAndLongOption(String token) throws ParseException { String t = Util.stripLeadingHyphens(token);  int pos = t.indexOf('=');  <BUGS> if (t.length() == 1) <BUGE> { /* -S*/ if (options.hasShortOption(t)) { handleOption(options.getOption(t)); } else { handleUnknownToken(token); } } else if (pos == -1) { /* no equal sign found (-xxx)*/ if (options.hasShortOption(t)) { handleOption(options.getOption(t)); } else if (!options.getMatchingOptions(t).isEmpty()) { /* -L or -l*/ handleLongOptionWithoutEqual(token);
*/ private void handleShortAndLongOption(String token) throws ParseException { String t = Util.stripLeadingHyphens(token);  int pos = t.indexOf('=');  if (t.length() == 1) { /* -S*/ if (options.hasShortOption(t)) { handleOption(options.getOption(t)); } else { handleUnknownToken(token); } } <BUGS> else if (pos == -1) <BUGE> { /* no equal sign found (-xxx)*/ if (options.hasShortOption(t)) { handleOption(options.getOption(t)); } else if (!options.getMatchingOptions(t).isEmpty()) { /* -L or -l*/ handleLongOptionWithoutEqual(token);
*/ private void handleShortAndLongOption(String token) throws ParseException { String t = Util.stripLeadingHyphens(token);  int pos = t.indexOf('=');  if (t.length() == 1) { /* -S*/ if (options.hasShortOption(t)) { handleOption(options.getOption(t)); } else { handleUnknownToken(token); } } else if (pos == -1) { /* no equal sign found (-xxx)*/ <BUGS> if (options.hasShortOption(t)) <BUGE> { handleOption(options.getOption(t)); } else if (!options.getMatchingOptions(t).isEmpty()) { /* -L or -l*/ handleLongOptionWithoutEqual(token);
*/ private void handleShortAndLongOption(String token) throws ParseException { String t = Util.stripLeadingHyphens(token);  int pos = t.indexOf('=');  if (t.length() == 1) { /* -S*/ if (options.hasShortOption(t)) { handleOption(options.getOption(t)); } else { handleUnknownToken(token); } } else if (pos == -1) { /* no equal sign found (-xxx)*/ if (options.hasShortOption(t)) { <BUGS> handleOption(options.getOption(t)); <BUGE> } else if (!options.getMatchingOptions(t).isEmpty()) { /* -L or -l*/ handleLongOptionWithoutEqual(token);
* -SV * -S V * -S=V * -S1S2 * -S1S2 V * -SV1=V2 * * -L * -LV * -L V * -L=V * -l * * @param token the command line token to handle } <BUGS> } <BUGE>  /** * Search for a prefix that is the long name of an option (-Xmx512m) * * @param token */ private String getLongPrefix(String token) { String t = Util.stripLeadingHyphens(token);  int i; String opt = null; for (i = t.length() - 2; i > 1; i--) {
*/ private void handleShortAndLongOption(String token) throws ParseException { <BUGS> String t = Util.stripLeadingHyphens(token); <BUGE>  int pos = t.indexOf('=');  if (t.length() == 1) { /* -S*/ if (options.hasShortOption(t)) { handleOption(options.getOption(t)); } else { handleUnknownToken(token); } } else if (pos == -1) { /* no equal sign found (-xxx)*/ if (options.hasShortOption(t)) { handleOption(options.getOption(t)); } else if (!options.getMatchingOptions(t).isEmpty()) { /* -L or -l*/ handleLongOptionWithoutEqual(token);
*/ private void handleShortAndLongOption(String token) throws ParseException { String t = Util.stripLeadingHyphens(token);  <BUGS> int pos = t.indexOf('='); <BUGE>  if (t.length() == 1) { /* -S*/ if (options.hasShortOption(t)) { handleOption(options.getOption(t)); } else { handleUnknownToken(token); } } else if (pos == -1) { /* no equal sign found (-xxx)*/ if (options.hasShortOption(t)) { handleOption(options.getOption(t)); } else if (!options.getMatchingOptions(t).isEmpty()) { /* -L or -l*/ handleLongOptionWithoutEqual(token);
*/ private void handleShortAndLongOption(String token) throws ParseException { String t = Util.stripLeadingHyphens(token);  int pos = t.indexOf('=');  <BUGS> if (t.length() == 1) <BUGE> { /* -S*/ if (options.hasShortOption(t)) { handleOption(options.getOption(t)); } else { handleUnknownToken(token); } } else if (pos == -1) { /* no equal sign found (-xxx)*/ if (options.hasShortOption(t)) { handleOption(options.getOption(t)); } else if (!options.getMatchingOptions(t).isEmpty()) { /* -L or -l*/ handleLongOptionWithoutEqual(token);
*/ private void handleShortAndLongOption(String token) throws ParseException { String t = Util.stripLeadingHyphens(token);  int pos = t.indexOf('=');  if (t.length() == 1) { /* -S*/ if (options.hasShortOption(t)) { handleOption(options.getOption(t)); } else { handleUnknownToken(token); } } <BUGS> else if (pos == -1) <BUGE> { /* no equal sign found (-xxx)*/ if (options.hasShortOption(t)) { handleOption(options.getOption(t)); } else if (!options.getMatchingOptions(t).isEmpty()) { /* -L or -l*/ handleLongOptionWithoutEqual(token);
*/ private void handleShortAndLongOption(String token) throws ParseException { String t = Util.stripLeadingHyphens(token);  int pos = t.indexOf('=');  if (t.length() == 1) { /* -S*/ if (options.hasShortOption(t)) { handleOption(options.getOption(t)); } else { handleUnknownToken(token); } } else if (pos == -1) { /* no equal sign found (-xxx)*/ <BUGS> if (options.hasShortOption(t)) <BUGE> { handleOption(options.getOption(t)); } else if (!options.getMatchingOptions(t).isEmpty()) { /* -L or -l*/ handleLongOptionWithoutEqual(token);
*/ private void handleShortAndLongOption(String token) throws ParseException { String t = Util.stripLeadingHyphens(token);  int pos = t.indexOf('=');  if (t.length() == 1) { /* -S*/ if (options.hasShortOption(t)) { handleOption(options.getOption(t)); } else { handleUnknownToken(token); } } else if (pos == -1) { /* no equal sign found (-xxx)*/ if (options.hasShortOption(t)) { <BUGS> handleOption(options.getOption(t)); <BUGE> } else if (!options.getMatchingOptions(t).isEmpty()) { /* -L or -l*/ handleLongOptionWithoutEqual(token);
* -SV * -S V * -S=V * -S1S2 * -S1S2 V * -SV1=V2 * * -L * -LV * -L V * -L=V * -l * * @param token the command line token to handle } <BUGS> } <BUGE>  /** * Search for a prefix that is the long name of an option (-Xmx512m) * * @param token */ private String getLongPrefix(String token) { String t = Util.stripLeadingHyphens(token);  int i; String opt = null; for (i = t.length() - 2; i > 1; i--) {
*/ public static Object getValueClass(final char ch) { <BUGS> switch (ch) <BUGE> { case '@': return PatternOptionBuilder.OBJECT_VALUE; case ':': return PatternOptionBuilder.STRING_VALUE; case '%': return PatternOptionBuilder.NUMBER_VALUE; case '+': return PatternOptionBuilder.CLASS_VALUE; case '#': return PatternOptionBuilder.DATE_VALUE; case '<': return PatternOptionBuilder.EXISTING_FILE_VALUE; case '>': return PatternOptionBuilder.FILE_VALUE; case '*': return PatternOptionBuilder.FILES_VALUE; case '/': return PatternOptionBuilder.URL_VALUE; }  return null; }
*/ public static Object getValueClass(final char ch) { switch (ch) { case '@': return PatternOptionBuilder.OBJECT_VALUE; case ':': return PatternOptionBuilder.STRING_VALUE; case '%': return PatternOptionBuilder.NUMBER_VALUE; case '+': return PatternOptionBuilder.CLASS_VALUE; case '#': return PatternOptionBuilder.DATE_VALUE; case '<': <BUGS> return PatternOptionBuilder.EXISTING_FILE_VALUE; <BUGE> case '>': return PatternOptionBuilder.FILE_VALUE; case '*': return PatternOptionBuilder.FILES_VALUE; case '/': return PatternOptionBuilder.URL_VALUE; }  return null; }
@SuppressWarnings("unchecked") /* returned value will have type T because it is fixed by clazz*/ public static <T> T createValue(final String str, final Class<T> clazz) throws ParseException { <BUGS> if (PatternOptionBuilder.STRING_VALUE == clazz) <BUGE> { return (T) str; } else if (PatternOptionBuilder.OBJECT_VALUE == clazz) { return (T) createObject(str); } else if (PatternOptionBuilder.NUMBER_VALUE == clazz) { return (T) createNumber(str); } else if (PatternOptionBuilder.DATE_VALUE == clazz) { return (T) createDate(str); } else if (PatternOptionBuilder.CLASS_VALUE == clazz) { return (T) createClass(str); } else if (PatternOptionBuilder.FILE_VALUE == clazz) { return (T) createFile(str); } else if (PatternOptionBuilder.EXISTING_FILE_VALUE == clazz) { return (T) openFile(str);
@SuppressWarnings("unchecked") /* returned value will have type T because it is fixed by clazz*/ public static <T> T createValue(final String str, final Class<T> clazz) throws ParseException { if (PatternOptionBuilder.STRING_VALUE == clazz) { return (T) str; } <BUGS> else if (PatternOptionBuilder.OBJECT_VALUE == clazz) <BUGE> { return (T) createObject(str); } else if (PatternOptionBuilder.NUMBER_VALUE == clazz) { return (T) createNumber(str); } else if (PatternOptionBuilder.DATE_VALUE == clazz) { return (T) createDate(str); } else if (PatternOptionBuilder.CLASS_VALUE == clazz) { return (T) createClass(str); } else if (PatternOptionBuilder.FILE_VALUE == clazz) { return (T) createFile(str); } else if (PatternOptionBuilder.EXISTING_FILE_VALUE == clazz) { return (T) openFile(str);
@SuppressWarnings("unchecked") /* returned value will have type T because it is fixed by clazz*/ public static <T> T createValue(final String str, final Class<T> clazz) throws ParseException { if (PatternOptionBuilder.STRING_VALUE == clazz) { return (T) str; } else if (PatternOptionBuilder.OBJECT_VALUE == clazz) { return (T) createObject(str); } <BUGS> else if (PatternOptionBuilder.NUMBER_VALUE == clazz) <BUGE> { return (T) createNumber(str); } else if (PatternOptionBuilder.DATE_VALUE == clazz) { return (T) createDate(str); } else if (PatternOptionBuilder.CLASS_VALUE == clazz) { return (T) createClass(str); } else if (PatternOptionBuilder.FILE_VALUE == clazz) { return (T) createFile(str); } else if (PatternOptionBuilder.EXISTING_FILE_VALUE == clazz) { return (T) openFile(str);
@SuppressWarnings("unchecked") /* returned value will have type T because it is fixed by clazz*/ public static <T> T createValue(final String str, final Class<T> clazz) throws ParseException { if (PatternOptionBuilder.STRING_VALUE == clazz) { return (T) str; } else if (PatternOptionBuilder.OBJECT_VALUE == clazz) { return (T) createObject(str); } else if (PatternOptionBuilder.NUMBER_VALUE == clazz) { return (T) createNumber(str); } <BUGS> else if (PatternOptionBuilder.DATE_VALUE == clazz) <BUGE> { return (T) createDate(str); } else if (PatternOptionBuilder.CLASS_VALUE == clazz) { return (T) createClass(str); } else if (PatternOptionBuilder.FILE_VALUE == clazz) { return (T) createFile(str); } else if (PatternOptionBuilder.EXISTING_FILE_VALUE == clazz) { return (T) openFile(str);
@SuppressWarnings("unchecked") /* returned value will have type T because it is fixed by clazz*/ public static <T> T createValue(final String str, final Class<T> clazz) throws ParseException { if (PatternOptionBuilder.STRING_VALUE == clazz) { return (T) str; } else if (PatternOptionBuilder.OBJECT_VALUE == clazz) { return (T) createObject(str); } else if (PatternOptionBuilder.NUMBER_VALUE == clazz) { return (T) createNumber(str); } else if (PatternOptionBuilder.DATE_VALUE == clazz) { return (T) createDate(str); } <BUGS> else if (PatternOptionBuilder.CLASS_VALUE == clazz) <BUGE> { return (T) createClass(str); } else if (PatternOptionBuilder.FILE_VALUE == clazz) { return (T) createFile(str); } else if (PatternOptionBuilder.EXISTING_FILE_VALUE == clazz) { return (T) openFile(str);
@SuppressWarnings("unchecked") /* returned value will have type T because it is fixed by clazz*/ public static <T> T createValue(final String str, final Class<T> clazz) throws ParseException { if (PatternOptionBuilder.STRING_VALUE == clazz) { return (T) str; } else if (PatternOptionBuilder.OBJECT_VALUE == clazz) { return (T) createObject(str); } else if (PatternOptionBuilder.NUMBER_VALUE == clazz) { return (T) createNumber(str); } else if (PatternOptionBuilder.DATE_VALUE == clazz) { return (T) createDate(str); } else if (PatternOptionBuilder.CLASS_VALUE == clazz) { return (T) createClass(str); } <BUGS> else if (PatternOptionBuilder.FILE_VALUE == clazz) <BUGE> { return (T) createFile(str); } else if (PatternOptionBuilder.EXISTING_FILE_VALUE == clazz) { return (T) openFile(str);
@SuppressWarnings("unchecked") /* returned value will have type T because it is fixed by clazz*/ public static <T> T createValue(final String str, final Class<T> clazz) throws ParseException { if (PatternOptionBuilder.STRING_VALUE == clazz) { return (T) str; } else if (PatternOptionBuilder.OBJECT_VALUE == clazz) { return (T) createObject(str); } else if (PatternOptionBuilder.NUMBER_VALUE == clazz) { return (T) createNumber(str); } else if (PatternOptionBuilder.DATE_VALUE == clazz) { return (T) createDate(str); } else if (PatternOptionBuilder.CLASS_VALUE == clazz) { return (T) createClass(str); } else if (PatternOptionBuilder.FILE_VALUE == clazz) { return (T) createFile(str); } <BUGS> else if (PatternOptionBuilder.EXISTING_FILE_VALUE == clazz) <BUGE> { return (T) openFile(str);
{ return createValue(str, (Class<?>) obj); }  /** * Returns the <code>Object</code> of type <code>clazz</code> * with the value of <code>str</code>. * * @param str the command line value * @param clazz the type of argument * @return The instance of <code>clazz</code> initialised with * the value of <code>str</code>. * @throws ParseException if the value creation for the given class failed */ } <BUGS> else if (PatternOptionBuilder.FILES_VALUE == clazz) <BUGE> { return (T) createFiles(str); } else if (PatternOptionBuilder.URL_VALUE == clazz) { return (T) createURL(str); } else { return null; } }  /**
{ return createValue(str, (Class<?>) obj); }  /** * Returns the <code>Object</code> of type <code>clazz</code> * with the value of <code>str</code>. * * @param str the command line value * @param clazz the type of argument * @return The instance of <code>clazz</code> initialised with * the value of <code>str</code>. * @throws ParseException if the value creation for the given class failed */ } <BUGS> else if (PatternOptionBuilder.URL_VALUE == clazz) <BUGE> { return (T) createURL(str); } else { return null; } }  /** * Create an Object from the classname and empty constructor. * * @param classname the argument value * @return the initialised object
{ return createValue(str, (Class<?>) obj); }  /** * Returns the <code>Object</code> of type <code>clazz</code> * with the value of <code>str</code>. * * @param str the command line value * @param clazz the type of argument * @return The instance of <code>clazz</code> initialised with * the value of <code>str</code>. * @throws ParseException if the value creation for the given class failed */ { <BUGS> return null; <BUGE> } }  /** * Create an Object from the classname and empty constructor. * * @param classname the argument value * @return the initialised object * @throws ParseException if the class could not be found or the object could not be created */ public static Object createObject(final String classname) throws ParseException { Class<?> cl;
@Override protected void doWriteObject(final ObjectOutputStream out) throws IOException { <BUGS> out.writeInt(keyType.value); out.writeInt(valueType.value); out.writeBoolean(purgeValues); out.writeFloat(loadFactor); out.writeInt(data.length); for (final MapIterator<K, V> it = mapIterator(); it.hasNext();) { out.writeObject(it.next()); out.writeObject(it.getValue()); <BUGE> } out.writeObject(null);  /* null terminate map*/ /* do not call super.doWriteObject() as code there doesn't work for reference map*/ }
@Override protected void doWriteObject(final ObjectOutputStream out) throws IOException { out.writeInt(keyType.value); out.writeInt(valueType.value); out.writeBoolean(purgeValues); out.writeFloat(loadFactor); out.writeInt(data.length); for (final MapIterator<K, V> it = mapIterator(); it.hasNext();) { out.writeObject(it.next()); out.writeObject(it.getValue()); } <BUGS> out.writeObject(null);  /* null terminate map <BUGE>*/ /* do not call super.doWriteObject() as code there doesn't work for reference map*/ }
@Override protected void doWriteObject(final ObjectOutputStream out) throws IOException { out.writeInt(keyType.value); out.writeInt(valueType.value); out.writeBoolean(purgeValues); out.writeFloat(loadFactor); out.writeInt(data.length); for (final MapIterator<K, V> it = mapIterator(); it.hasNext();) { out.writeObject(it.next()); out.writeObject(it.getValue()); } out.writeObject(null);  /* null terminate map*/ /* do not call super.doWriteObject() as code there doesn't work for reference map*/ <BUGS> } <BUGE>
*/ public static <T> List<List<T>> partition(final List<T> list, final int size) { <BUGS> if (list == null) { throw new NullPointerException("List must not be null"); <BUGE> } if (size <= 0) { throw new IllegalArgumentException("Size must be greater than 0"); } return new Partition<>(list, size); }
*/ public static <T> List<List<T>> partition(final List<T> list, final int size) { if (list == null) { throw new NullPointerException("List must not be null"); } <BUGS> if (size <= 0) { throw new IllegalArgumentException("Size must be greater than 0"); <BUGE> } return new Partition<>(list, size); }
*/ public static <T> List<List<T>> partition(final List<T> list, final int size) { if (list == null) { throw new NullPointerException("List must not be null"); } if (size <= 0) { throw new IllegalArgumentException("Size must be greater than 0"); } <BUGS> return new Partition<>(list, size); <BUGE> }
@Override public int hashCode() { <BUGS> return decorated().hashCode(); <BUGE> }
private MoonTimes(@Nullable Date rise, @Nullable Date set, boolean alwaysUp, <BUGS> boolean alwaysDown) { this.rise = rise; this.set = set; this.alwaysUp = alwaysUp; this.alwaysDown = alwaysDown; } <BUGE>
*/ <BUGS> public QuadraticInterpolation(double yMinus, double y0, double yPlus) { double a = 0.5 * (yPlus + yMinus) - y0; double b = 0.5 * (yPlus - yMinus); double c = y0; <BUGE>  xe = -b / (2.0 * a); ye = (a * xe + b) * xe + c; maximum = a < 0.0; double dis = b * b - 4.0 * a * c;  int rootCount = 0;  if (dis >= 0.0) { double dx = 0.5 * sqrt(dis) / abs(a); root1 = xe - dx; root2 = xe + dx;  if (abs(root1) <= 1.0) { rootCount++; }  if (abs(root2) <= 1.0) { rootCount++; } } else { root1 = Double.NaN; root2 = Double.NaN; }
*/ public QuadraticInterpolation(double yMinus, double y0, double yPlus) { double a = 0.5 * (yPlus + yMinus) - y0; double b = 0.5 * (yPlus - yMinus); double c = y0;  <BUGS> xe = -b / (2.0 * a); ye = (a * xe + b) * xe + c; maximum = a < 0.0; double dis = b * b - 4.0 * a * c; <BUGE>  int rootCount = 0;  if (dis >= 0.0) { double dx = 0.5 * sqrt(dis) / abs(a); root1 = xe - dx; root2 = xe + dx;  if (abs(root1) <= 1.0) { rootCount++; }  if (abs(root2) <= 1.0) { rootCount++; } } else { root1 = Double.NaN; root2 = Double.NaN; }
*/ public QuadraticInterpolation(double yMinus, double y0, double yPlus) { double a = 0.5 * (yPlus + yMinus) - y0; double b = 0.5 * (yPlus - yMinus); double c = y0;  xe = -b / (2.0 * a); ye = (a * xe + b) * xe + c; maximum = a < 0.0; double dis = b * b - 4.0 * a * c;  <BUGS> int rootCount = 0; <BUGE>  if (dis >= 0.0) { double dx = 0.5 * sqrt(dis) / abs(a); root1 = xe - dx; root2 = xe + dx;  if (abs(root1) <= 1.0) { rootCount++; }  if (abs(root2) <= 1.0) { rootCount++; } } else { root1 = Double.NaN; root2 = Double.NaN; }
*/ public QuadraticInterpolation(double yMinus, double y0, double yPlus) { double a = 0.5 * (yPlus + yMinus) - y0; double b = 0.5 * (yPlus - yMinus); double c = y0;  xe = -b / (2.0 * a); ye = (a * xe + b) * xe + c; maximum = a < 0.0; double dis = b * b - 4.0 * a * c;  int rootCount = 0;  <BUGS> if (dis >= 0.0) { double dx = 0.5 * sqrt(dis) / abs(a); root1 = xe - dx; root2 = xe + dx; <BUGE>  if (abs(root1) <= 1.0) { rootCount++; }  if (abs(root2) <= 1.0) { rootCount++; } } else { root1 = Double.NaN; root2 = Double.NaN; }
*/ public QuadraticInterpolation(double yMinus, double y0, double yPlus) { double a = 0.5 * (yPlus + yMinus) - y0; double b = 0.5 * (yPlus - yMinus); double c = y0;  xe = -b / (2.0 * a); ye = (a * xe + b) * xe + c; maximum = a < 0.0; double dis = b * b - 4.0 * a * c;  int rootCount = 0;  if (dis >= 0.0) { double dx = 0.5 * sqrt(dis) / abs(a); root1 = xe - dx; root2 = xe + dx;  <BUGS> if (abs(root1) <= 1.0) { rootCount++; <BUGE> }  if (abs(root2) <= 1.0) { rootCount++; } } else { root1 = Double.NaN; root2 = Double.NaN; }
*/ public QuadraticInterpolation(double yMinus, double y0, double yPlus) { double a = 0.5 * (yPlus + yMinus) - y0; double b = 0.5 * (yPlus - yMinus); double c = y0;  xe = -b / (2.0 * a); ye = (a * xe + b) * xe + c; maximum = a < 0.0; double dis = b * b - 4.0 * a * c;  int rootCount = 0;  if (dis >= 0.0) { double dx = 0.5 * sqrt(dis) / abs(a); root1 = xe - dx; root2 = xe + dx;  if (abs(root1) <= 1.0) { rootCount++; }  <BUGS> if (abs(root2) <= 1.0) { rootCount++; <BUGE> } } else { root1 = Double.NaN; root2 = Double.NaN; }
*/ public QuadraticInterpolation(double yMinus, double y0, double yPlus) { double a = 0.5 * (yPlus + yMinus) - y0; double b = 0.5 * (yPlus - yMinus); double c = y0;  xe = -b / (2.0 * a); ye = (a * xe + b) * xe + c; maximum = a < 0.0; double dis = b * b - 4.0 * a * c;  int rootCount = 0;  if (dis >= 0.0) { double dx = 0.5 * sqrt(dis) / abs(a); root1 = xe - dx; root2 = xe + dx;  if (abs(root1) <= 1.0) { rootCount++; }  if (abs(root2) <= 1.0) { rootCount++; } <BUGS> } else { root1 = Double.NaN; root2 = Double.NaN; <BUGE> }
private final double root1; private final double root2; private final int nRoot; private final boolean maximum;  /** * Creates a new quadratic equation. * * @param yMinus *            y at x == -1 * @param y0 *            y at x == 0 * @param yPlus *            y at x == 1  <BUGS> nRoot = rootCount; } <BUGE>  /** * Returns X of extremum. Can be outside [-1 .. 1]. * * @return X */ public double getXe() { return xe; }  /** * Returns the Y value at the extremum. *
*/ public ArchiveInputStream createArchiveInputStream( final String archiverName, final InputStream in) throws ArchiveException { <BUGS> if (archiverName == null || in == null) { <BUGE> throw new IllegalArgumentException("Archivername must not be null."); }  if ("ar".equalsIgnoreCase(archiverName)) { return new ArArchiveInputStream(in); } else if ("zip".equalsIgnoreCase(archiverName)) { return new ZipArchiveInputStream(in); } else if ("tar".equalsIgnoreCase(archiverName)) { return new TarArchiveInputStream(in); } else if ("jar".equalsIgnoreCase(archiverName)) { return new JarArchiveInputStream(in); } else if ("cpio".equalsIgnoreCase(archiverName)) { return new CpioArchiveInputStream(in); } throw new ArchiveException("Archiver: " + archiverName + " not found."); }
*/ public ArchiveInputStream createArchiveInputStream( final String archiverName, final InputStream in) throws ArchiveException { if (archiverName == null || in == null) { throw new IllegalArgumentException("Archivername must not be null."); }  <BUGS> if ("ar".equalsIgnoreCase(archiverName)) { <BUGE> return new ArArchiveInputStream(in); } else if ("zip".equalsIgnoreCase(archiverName)) { return new ZipArchiveInputStream(in); } else if ("tar".equalsIgnoreCase(archiverName)) { return new TarArchiveInputStream(in); } else if ("jar".equalsIgnoreCase(archiverName)) { return new JarArchiveInputStream(in); } else if ("cpio".equalsIgnoreCase(archiverName)) { return new CpioArchiveInputStream(in); } throw new ArchiveException("Archiver: " + archiverName + " not found."); }
*/ public ArchiveInputStream createArchiveInputStream( final String archiverName, final InputStream in) throws ArchiveException { if (archiverName == null || in == null) { throw new IllegalArgumentException("Archivername must not be null."); }  if ("ar".equalsIgnoreCase(archiverName)) { return new ArArchiveInputStream(in); <BUGS> } else if ("zip".equalsIgnoreCase(archiverName)) { <BUGE> return new ZipArchiveInputStream(in); } else if ("tar".equalsIgnoreCase(archiverName)) { return new TarArchiveInputStream(in); } else if ("jar".equalsIgnoreCase(archiverName)) { return new JarArchiveInputStream(in); } else if ("cpio".equalsIgnoreCase(archiverName)) { return new CpioArchiveInputStream(in); } throw new ArchiveException("Archiver: " + archiverName + " not found."); }
*/ public ArchiveInputStream createArchiveInputStream( final String archiverName, final InputStream in) throws ArchiveException { if (archiverName == null || in == null) { throw new IllegalArgumentException("Archivername must not be null."); }  if ("ar".equalsIgnoreCase(archiverName)) { return new ArArchiveInputStream(in); } else if ("zip".equalsIgnoreCase(archiverName)) { return new ZipArchiveInputStream(in); <BUGS> } else if ("tar".equalsIgnoreCase(archiverName)) { <BUGE> return new TarArchiveInputStream(in); } else if ("jar".equalsIgnoreCase(archiverName)) { return new JarArchiveInputStream(in); } else if ("cpio".equalsIgnoreCase(archiverName)) { return new CpioArchiveInputStream(in); } throw new ArchiveException("Archiver: " + archiverName + " not found."); }
*/ public ArchiveInputStream createArchiveInputStream( final String archiverName, final InputStream in) throws ArchiveException { if (archiverName == null || in == null) { throw new IllegalArgumentException("Archivername must not be null."); }  if ("ar".equalsIgnoreCase(archiverName)) { return new ArArchiveInputStream(in); } else if ("zip".equalsIgnoreCase(archiverName)) { return new ZipArchiveInputStream(in); } else if ("tar".equalsIgnoreCase(archiverName)) { return new TarArchiveInputStream(in); <BUGS> } else if ("jar".equalsIgnoreCase(archiverName)) { <BUGE> return new JarArchiveInputStream(in); } else if ("cpio".equalsIgnoreCase(archiverName)) { return new CpioArchiveInputStream(in); } throw new ArchiveException("Archiver: " + archiverName + " not found."); }
*/ public ArchiveInputStream createArchiveInputStream( final String archiverName, final InputStream in) throws ArchiveException { if (archiverName == null || in == null) { throw new IllegalArgumentException("Archivername must not be null."); }  if ("ar".equalsIgnoreCase(archiverName)) { return new ArArchiveInputStream(in); } else if ("zip".equalsIgnoreCase(archiverName)) { return new ZipArchiveInputStream(in); } else if ("tar".equalsIgnoreCase(archiverName)) { return new TarArchiveInputStream(in); } else if ("jar".equalsIgnoreCase(archiverName)) { return new JarArchiveInputStream(in); <BUGS> } else if ("cpio".equalsIgnoreCase(archiverName)) { return new CpioArchiveInputStream(in); <BUGE> } throw new ArchiveException("Archiver: " + archiverName + " not found."); }
*/ public ArArchiveEntry getNextArEntry() throws IOException { /* hit EOF before previous entry was complete*/ /* TODO: throw an exception instead?*/  <BUGS> if (offset == 0) { final byte[] expected = ArArchiveEntry.HEADER.getBytes(); final byte[] realized = new byte[expected.length]; final int read = read(realized); if (read != expected.length) { <BUGE> throw new IOException("failed to read header"); } for (int i = 0; i < expected.length; i++) { if (expected[i] != realized[i]) { throw new IOException("invalid header " + new String(realized)); } } }  /* hit eof*/  if (input.available() == 0) { return null; }  if (offset % 2 != 0) { read(); } final byte[] name = new byte[16]; final byte[] lastmodified = new byte[12];
*/ public ArArchiveEntry getNextArEntry() throws IOException { /* hit EOF before previous entry was complete*/ /* TODO: throw an exception instead?*/  if (offset == 0) { final byte[] expected = ArArchiveEntry.HEADER.getBytes(); final byte[] realized = new byte[expected.length]; final int read = read(realized); if (read != expected.length) { throw new IOException("failed to read header"); } <BUGS> for (int i = 0; i < expected.length; i++) { if (expected[i] != realized[i]) { <BUGE> throw new IOException("invalid header " + new String(realized)); } } }  /* hit eof*/  if (input.available() == 0) { return null; }  if (offset % 2 != 0) { read(); } final byte[] name = new byte[16]; final byte[] lastmodified = new byte[12];
*/ public ArArchiveEntry getNextArEntry() throws IOException { /* hit EOF before previous entry was complete*/ /* TODO: throw an exception instead?*/  if (offset == 0) { final byte[] expected = ArArchiveEntry.HEADER.getBytes(); final byte[] realized = new byte[expected.length]; final int read = read(realized); if (read != expected.length) { throw new IOException("failed to read header"); } for (int i = 0; i < expected.length; i++) { if (expected[i] != realized[i]) { throw new IOException("invalid header " + new String(realized)); } } }  /* hit eof*/  <BUGS> if (input.available() == 0) { return null; <BUGE> }  if (offset % 2 != 0) { read(); } final byte[] name = new byte[16]; final byte[] lastmodified = new byte[12];
*/ public ArArchiveEntry getNextArEntry() throws IOException { /* hit EOF before previous entry was complete*/ /* TODO: throw an exception instead?*/  if (offset == 0) { final byte[] expected = ArArchiveEntry.HEADER.getBytes(); final byte[] realized = new byte[expected.length]; final int read = read(realized); if (read != expected.length) { throw new IOException("failed to read header"); } for (int i = 0; i < expected.length; i++) { if (expected[i] != realized[i]) { throw new IOException("invalid header " + new String(realized)); } } }  /* hit eof*/  if (input.available() == 0) { return null; }  <BUGS> if (offset % 2 != 0) { <BUGE> read(); } final byte[] name = new byte[16]; final byte[] lastmodified = new byte[12];
public ArArchiveInputStream( final InputStream pInput ) { input = pInput; closed = false; }  /** * Returns the next AR entry in this stream. * * @return the next AR entry. * @throws IOException *             if the entry could not be read } <BUGS> final byte[] name = new byte[16]; final byte[] lastmodified = new byte[12]; final byte[] userid = new byte[6]; final byte[] groupid = new byte[6]; final byte[] filemode = new byte[8]; final byte[] length = new byte[10]; <BUGE>  read(name); read(lastmodified); read(userid); read(groupid); read(filemode); read(length);  { final byte[] expected = ArArchiveEntry.TRAILER.getBytes(); final byte[] realized = new byte[expected.length];
public ArArchiveInputStream( final InputStream pInput ) { input = pInput; closed = false; }  /** * Returns the next AR entry in this stream. * * @return the next AR entry. * @throws IOException *             if the entry could not be read  <BUGS> read(name); read(lastmodified); read(userid); read(groupid); read(filemode); read(length); <BUGE>  { final byte[] expected = ArArchiveEntry.TRAILER.getBytes(); final byte[] realized = new byte[expected.length]; final int read = read(realized); if (read != expected.length) { throw new IOException("failed to read entry header"); } for (int i = 0; i < expected.length; i++) { if (expected[i] != realized[i]) { throw new IOException("invalid entry header. not read the content?");
*/  public ArArchiveInputStream( final InputStream pInput ) { input = pInput; closed = false; }  /** * Returns the next AR entry in this stream. * * @return the next AR entry. * @throws IOException *             if the entry could not be read { <BUGS> final byte[] expected = ArArchiveEntry.TRAILER.getBytes(); final byte[] realized = new byte[expected.length]; final int read = read(realized); if (read != expected.length) { <BUGE> throw new IOException("failed to read entry header"); } for (int i = 0; i < expected.length; i++) { if (expected[i] != realized[i]) { throw new IOException("invalid entry header. not read the content?"); } } }  return new ArArchiveEntry(new String(name).trim(), Long.parseLong(new String(length) .trim()));
* called */  public ArArchiveInputStream( final InputStream pInput ) { input = pInput; closed = false; }  /** * Returns the next AR entry in this stream. * * @return the next AR entry. * @throws IOException *             if the entry could not be read } <BUGS> for (int i = 0; i < expected.length; i++) { if (expected[i] != realized[i]) { <BUGE> throw new IOException("invalid entry header. not read the content?"); } } }  return new ArArchiveEntry(new String(name).trim(), Long.parseLong(new String(length) .trim())); }   public ArchiveEntry getNextEntry() throws IOException { return getNextArEntry();
* called */  public ArArchiveInputStream( final InputStream pInput ) { input = pInput; closed = false; }  /** * Returns the next AR entry in this stream. * * @return the next AR entry. * @throws IOException *             if the entry could not be read  <BUGS> return new ArArchiveEntry(new String(name).trim(), <BUGE> Long.parseLong(new String(length) .trim())); }   public ArchiveEntry getNextEntry() throws IOException { return getNextArEntry(); }  public void close() throws IOException { if (!closed) { closed = true; input.close(); }
*/ public void finish() throws IOException { <BUGS> if(entry != null) { throw new IOException("This archives contains unclosed entries."); <BUGE> }  cdOffset = written; for (Iterator i = entries.iterator(); i.hasNext(); ) { writeCentralFileHeader((ZipArchiveEntry) i.next()); } cdLength = written - cdOffset; writeCentralDirectoryEnd(); offsets.clear(); entries.clear(); }
*/ public ZipFile(File f, String encoding, boolean useUnicodeExtraFields) throws IOException { this.encoding = encoding; this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding); this.useUnicodeExtraFields = useUnicodeExtraFields; archive = new RandomAccessFile(f, "r"); boolean success = false; try { Map entriesWithoutEFS = populateFromCentralDirectory(); resolveLocalFileHeaderData(entriesWithoutEFS); success = true; } finally { if (!success) { try { archive.close(); } catch (IOException e2) { /* swallow, throw the original exception instead*/ } } } }
*/ public ZipFile(File f, String encoding, boolean useUnicodeExtraFields) throws IOException { this.encoding = encoding; this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding); this.useUnicodeExtraFields = useUnicodeExtraFields; archive = new RandomAccessFile(f, "r"); boolean success = false; try { Map entriesWithoutEFS = populateFromCentralDirectory(); resolveLocalFileHeaderData(entriesWithoutEFS); success = true; } finally { if (!success) { try { archive.close(); } catch (IOException e2) { /* swallow, throw the original exception instead*/ } } } }
*/ public ZipFile(File f, String encoding, boolean useUnicodeExtraFields) <BUGS> throws IOException { this.encoding = encoding; this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding); this.useUnicodeExtraFields = useUnicodeExtraFields; archive = new RandomAccessFile(f, "r"); boolean success = false; <BUGE> try { Map entriesWithoutEFS = populateFromCentralDirectory(); resolveLocalFileHeaderData(entriesWithoutEFS); success = true; } finally { if (!success) { try { archive.close(); } catch (IOException e2) { /* swallow, throw the original exception instead*/ } } } }
*/ public ZipFile(File f, String encoding, boolean useUnicodeExtraFields) throws IOException { this.encoding = encoding; this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding); this.useUnicodeExtraFields = useUnicodeExtraFields; archive = new RandomAccessFile(f, "r"); boolean success = false; try { <BUGS> Map entriesWithoutEFS = populateFromCentralDirectory(); <BUGE> resolveLocalFileHeaderData(entriesWithoutEFS); success = true; } finally { if (!success) { try { archive.close(); } catch (IOException e2) { /* swallow, throw the original exception instead*/ } } } }
*/ public ZipFile(File f, String encoding, boolean useUnicodeExtraFields) throws IOException { this.encoding = encoding; this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding); this.useUnicodeExtraFields = useUnicodeExtraFields; archive = new RandomAccessFile(f, "r"); boolean success = false; try { Map entriesWithoutEFS = populateFromCentralDirectory(); resolveLocalFileHeaderData(entriesWithoutEFS); success = true; } finally { <BUGS> if (!success) { <BUGE> try { archive.close(); } catch (IOException e2) { /* swallow, throw the original exception instead*/ } } } }
*/ public ZipFile(File f, String encoding, boolean useUnicodeExtraFields) throws IOException { this.encoding = encoding; this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding); this.useUnicodeExtraFields = useUnicodeExtraFields; archive = new RandomAccessFile(f, "r"); boolean success = false; try { Map entriesWithoutEFS = populateFromCentralDirectory(); resolveLocalFileHeaderData(entriesWithoutEFS); success = true; } finally { if (!success) { try { <BUGS> archive.close(); <BUGE> } catch (IOException e2) { /* swallow, throw the original exception instead*/ } } } }
*/ public ZipFile(File f, String encoding, boolean useUnicodeExtraFields) throws IOException { this.encoding = encoding; this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding); this.useUnicodeExtraFields = useUnicodeExtraFields; archive = new RandomAccessFile(f, "r"); boolean success = false; try { Map entriesWithoutEFS = populateFromCentralDirectory(); resolveLocalFileHeaderData(entriesWithoutEFS); success = true; } finally { if (!success) { try { archive.close(); } catch (IOException e2) { /* swallow, throw the original exception instead*/ <BUGS> } <BUGE> } } }
public int read(byte[] buffer, int start, int length) throws IOException { <BUGS> if (closed) { <BUGE> throw new IOException("The stream is closed"); } if (inf.finished() || current == null) { return -1; }  /* avoid int overflow, check null buffer*/ if (start <= buffer.length && length >= 0 && start >= 0 && buffer.length - start >= length) { if (current.getMethod() == ZipArchiveOutputStream.STORED) { int csize = (int) current.getSize(); if (readBytesOfEntry >= csize) { return -1; } if (offsetInBuffer >= lengthOfLastRead) { offsetInBuffer = 0; if ((lengthOfLastRead = in.read(buf)) == -1) { return -1; } count(lengthOfLastRead); bytesReadFromStream += lengthOfLastRead; } int toRead = length > lengthOfLastRead ? lengthOfLastRead - offsetInBuffer : length; if ((csize - readBytesOfEntry) < toRead) { toRead = csize - readBytesOfEntry;
public int read(byte[] buffer, int start, int length) throws IOException { if (closed) { throw new IOException("The stream is closed"); } <BUGS> if (inf.finished() || current == null) { return -1; <BUGE> }  /* avoid int overflow, check null buffer*/ if (start <= buffer.length && length >= 0 && start >= 0 && buffer.length - start >= length) { if (current.getMethod() == ZipArchiveOutputStream.STORED) { int csize = (int) current.getSize(); if (readBytesOfEntry >= csize) { return -1; } if (offsetInBuffer >= lengthOfLastRead) { offsetInBuffer = 0; if ((lengthOfLastRead = in.read(buf)) == -1) { return -1; } count(lengthOfLastRead); bytesReadFromStream += lengthOfLastRead; } int toRead = length > lengthOfLastRead ? lengthOfLastRead - offsetInBuffer : length; if ((csize - readBytesOfEntry) < toRead) { toRead = csize - readBytesOfEntry;
public int read(byte[] buffer, int start, int length) throws IOException { if (closed) { throw new IOException("The stream is closed"); } if (inf.finished() || current == null) { return -1; }  /* avoid int overflow, check null buffer*/ <BUGS> if (start <= buffer.length && length >= 0 && start >= 0 <BUGE> && buffer.length - start >= length) { if (current.getMethod() == ZipArchiveOutputStream.STORED) { int csize = (int) current.getSize(); if (readBytesOfEntry >= csize) { return -1; } if (offsetInBuffer >= lengthOfLastRead) { offsetInBuffer = 0; if ((lengthOfLastRead = in.read(buf)) == -1) { return -1; } count(lengthOfLastRead); bytesReadFromStream += lengthOfLastRead; } int toRead = length > lengthOfLastRead ? lengthOfLastRead - offsetInBuffer : length; if ((csize - readBytesOfEntry) < toRead) { toRead = csize - readBytesOfEntry;
public int read(byte[] buffer, int start, int length) throws IOException { if (closed) { throw new IOException("The stream is closed"); } if (inf.finished() || current == null) { return -1; }  /* avoid int overflow, check null buffer*/ if (start <= buffer.length && length >= 0 && start >= 0 && buffer.length - start >= length) { <BUGS> if (current.getMethod() == ZipArchiveOutputStream.STORED) { int csize = (int) current.getSize(); if (readBytesOfEntry >= csize) { return -1; <BUGE> } if (offsetInBuffer >= lengthOfLastRead) { offsetInBuffer = 0; if ((lengthOfLastRead = in.read(buf)) == -1) { return -1; } count(lengthOfLastRead); bytesReadFromStream += lengthOfLastRead; } int toRead = length > lengthOfLastRead ? lengthOfLastRead - offsetInBuffer : length; if ((csize - readBytesOfEntry) < toRead) { toRead = csize - readBytesOfEntry;
byte[] extraData = new byte[extraLen]; readFully(extraData); current.setExtra(extraData);  if (!hasEFS && useUnicodeExtraFields) { ZipUtil.setNameAndCommentFromExtraFields(current, fileName, null); } return current; }  public ArchiveEntry getNextEntry() throws IOException { return getNextZipEntry(); } } <BUGS> if (inf.needsInput()) { fill(); if (lengthOfLastRead > 0) { bytesReadFromStream += lengthOfLastRead; <BUGE> } } int read = 0; try { read = inf.inflate(buffer, start, length); } catch (DataFormatException e) { throw new ZipException(e.getMessage()); } if (read == 0 && inf.finished()) { return -1; } crc.update(buffer, start, read);
byte[] extraData = new byte[extraLen]; readFully(extraData); current.setExtra(extraData);  if (!hasEFS && useUnicodeExtraFields) { ZipUtil.setNameAndCommentFromExtraFields(current, fileName, null); } return current; }  public ArchiveEntry getNextEntry() throws IOException { return getNextZipEntry(); } } <BUGS> int read = 0; <BUGE> try { read = inf.inflate(buffer, start, length); } catch (DataFormatException e) { throw new ZipException(e.getMessage()); } if (read == 0 && inf.finished()) { return -1; } crc.update(buffer, start, read); return read; } throw new ArrayIndexOutOfBoundsException(); }
byte[] extraData = new byte[extraLen]; readFully(extraData); current.setExtra(extraData);  if (!hasEFS && useUnicodeExtraFields) { ZipUtil.setNameAndCommentFromExtraFields(current, fileName, null); } return current; }  public ArchiveEntry getNextEntry() throws IOException { return getNextZipEntry(); } try { <BUGS> read = inf.inflate(buffer, start, length); <BUGE> } catch (DataFormatException e) { throw new ZipException(e.getMessage()); } if (read == 0 && inf.finished()) { return -1; } crc.update(buffer, start, read); return read; } throw new ArrayIndexOutOfBoundsException(); }  public void close() throws IOException { if (!closed) {
byte[] extraData = new byte[extraLen]; readFully(extraData); current.setExtra(extraData);  if (!hasEFS && useUnicodeExtraFields) { ZipUtil.setNameAndCommentFromExtraFields(current, fileName, null); } return current; }  public ArchiveEntry getNextEntry() throws IOException { return getNextZipEntry(); } throw new ZipException(e.getMessage()); <BUGS> } if (read == 0 && inf.finished()) { <BUGE> return -1; } crc.update(buffer, start, read); return read; } throw new ArrayIndexOutOfBoundsException(); }  public void close() throws IOException { if (!closed) { closed = true; in.close(); }
byte[] extraData = new byte[extraLen]; readFully(extraData); current.setExtra(extraData);  if (!hasEFS && useUnicodeExtraFields) { ZipUtil.setNameAndCommentFromExtraFields(current, fileName, null); } return current; }  public ArchiveEntry getNextEntry() throws IOException { return getNextZipEntry(); } } <BUGS> crc.update(buffer, start, read); return read; <BUGE> } throw new ArrayIndexOutOfBoundsException(); }  public void close() throws IOException { if (!closed) { closed = true; in.close(); } }  public long skip(long value) throws IOException { if (value >= 0) {
*/ public boolean equals(Object obj) { <BUGS> if (this == obj) { <BUGE> return true; } if (obj == null || getClass() != obj.getClass()) { return false; } ZipArchiveEntry other = (ZipArchiveEntry) obj; if (name == null) { if (other.name != null) { return false; } } else if (!name.equals(other.name)) { return false; } return true; }
*/ public boolean equals(Object obj) { if (this == obj) { return true; } <BUGS> if (obj == null || getClass() != obj.getClass()) { <BUGE> return false; } ZipArchiveEntry other = (ZipArchiveEntry) obj; if (name == null) { if (other.name != null) { return false; } } else if (!name.equals(other.name)) { return false; } return true; }
*/ public boolean equals(Object obj) { if (this == obj) { return true; } if (obj == null || getClass() != obj.getClass()) { return false; } <BUGS> ZipArchiveEntry other = (ZipArchiveEntry) obj; if (name == null) { if (other.name != null) { <BUGE> return false; } } else if (!name.equals(other.name)) { return false; } return true; }
*/ public boolean equals(Object obj) { if (this == obj) { return true; } if (obj == null || getClass() != obj.getClass()) { return false; } ZipArchiveEntry other = (ZipArchiveEntry) obj; if (name == null) { if (other.name != null) { return false; } } else if (!name.equals(other.name)) { return false; } <BUGS> return true; <BUGE> }
*/ public static String parseName(byte[] buffer, final int offset, final int length) { <BUGS> StringBuffer result = new StringBuffer(length); int          end = offset + length; <BUGE>  for (int i = offset; i < end; ++i) { if (buffer[i] == 0) { break; } result.append((char) buffer[i]); }  return result.toString(); }
*/ public static String parseName(byte[] buffer, final int offset, final int length) { StringBuffer result = new StringBuffer(length); int          end = offset + length;  <BUGS> for (int i = offset; i < end; ++i) { if (buffer[i] == 0) { break; <BUGE> } result.append((char) buffer[i]); }  return result.toString(); }
*/ public static String parseName(byte[] buffer, final int offset, final int length) { StringBuffer result = new StringBuffer(length); int          end = offset + length;  for (int i = offset; i < end; ++i) { if (buffer[i] == 0) { break; } <BUGS> result.append((char) buffer[i]); <BUGE> }  return result.toString(); }
*/ public static String parseName(byte[] buffer, final int offset, final int length) { StringBuffer result = new StringBuffer(length); int          end = offset + length;  for (int i = offset; i < end; ++i) { if (buffer[i] == 0) { break; } result.append((char) buffer[i]); }  <BUGS> return result.toString(); <BUGE> }
*/ public static long parseOctal(final byte[] buffer, final int offset, final int length) { <BUGS> long    result = 0; boolean stillPadding = true; int     end = offset + length; int     start = offset; <BUGE>  for (int i = start; i < end; i++){ final byte currentByte = buffer[i]; if (currentByte == 0) { break; }  /* Skip leading spaces*/ if (currentByte == (byte) ' ' || currentByte == '0') { if (stillPadding) { continue; } if (currentByte == (byte) ' ') { break; } }  /* Must have trailing NUL or space*/ /* May have additional NUL or space*/  stillPadding = false; /* CheckStyle:MagicNumber OFF*/ if (currentByte < '0' || currentByte > '7'){ throw new IllegalArgumentException(
*/ public static long parseOctal(final byte[] buffer, final int offset, final int length) { long    result = 0; boolean stillPadding = true; int     end = offset + length; int     start = offset;  <BUGS> for (int i = start; i < end; i++){ <BUGE> final byte currentByte = buffer[i]; if (currentByte == 0) { break; }  /* Skip leading spaces*/ if (currentByte == (byte) ' ' || currentByte == '0') { if (stillPadding) { continue; } if (currentByte == (byte) ' ') { break; } }  /* Must have trailing NUL or space*/ /* May have additional NUL or space*/  stillPadding = false; /* CheckStyle:MagicNumber OFF*/ if (currentByte < '0' || currentByte > '7'){ throw new IllegalArgumentException(
* Parse an octal string from a buffer. * Leading spaces are ignored. * The buffer must contain a trailing space or NUL, * and may contain an additional trailing space or NUL. * * The input buffer is allowed to contain all NULs, * in which case the method returns 0L * (this allows for missing fields). * * @param buffer The buffer from which to parse. * @param offset The offset into the buffer from which to parse. * @param length The maximum number of bytes to parse - must be at least 2 bytes. * @return The long value of the octal string. * @throws IllegalArgumentException if the trailing space/NUL is missing or if a invalid byte is detected.  <BUGS> return result; <BUGE> }  /* Helper method to generate the exception message*/ private static String exceptionMessage(byte[] buffer, final int offset, final int length, int current, final byte currentByte) { String string = new String(buffer, offset, length); string=string.replaceAll("\0", "{NUL}"); /* Replace NULs to allow string to be printed*/ final String s = "Invalid byte "+currentByte+" at offset "+(current-offset)+" in '"+string+"' len="+length; return s; }  /** * Parse an entry name from a buffer. * Parsing stops when a NUL is found
*/ public TarArchiveEntry(File file) { <BUGS> this(file, normalizeFileName(file.getPath(), false)); } <BUGE>
*/ public InputStream getInputStream(ZipArchiveEntry ze) throws IOException, ZipException { <BUGS> OffsetEntry offsetEntry = entries.get(ze); if (offsetEntry == null) { return null; <BUGE> } ZipUtil.checkRequestedFeatures(ze); long start = offsetEntry.dataOffset; BoundedInputStream bis = new BoundedInputStream(start, ze.getCompressedSize()); switch (ze.getMethod()) { case ZipArchiveEntry.STORED: return bis; case ZipArchiveEntry.DEFLATED: bis.addDummy(); final Inflater inflater = new Inflater(true); return new InflaterInputStream(bis, inflater) { @Override public void close() throws IOException { super.close(); inflater.end(); } }; default: throw new ZipException("Found unsupported compression method " + ze.getMethod()); } }
*/ public InputStream getInputStream(ZipArchiveEntry ze) throws IOException, ZipException { OffsetEntry offsetEntry = entries.get(ze); if (offsetEntry == null) { return null; } <BUGS> ZipUtil.checkRequestedFeatures(ze); long start = offsetEntry.dataOffset; BoundedInputStream bis = <BUGE> new BoundedInputStream(start, ze.getCompressedSize()); switch (ze.getMethod()) { case ZipArchiveEntry.STORED: return bis; case ZipArchiveEntry.DEFLATED: bis.addDummy(); final Inflater inflater = new Inflater(true); return new InflaterInputStream(bis, inflater) { @Override public void close() throws IOException { super.close(); inflater.end(); } }; default: throw new ZipException("Found unsupported compression method " + ze.getMethod()); } }
*/ public InputStream getInputStream(ZipArchiveEntry ze) throws IOException, ZipException { OffsetEntry offsetEntry = entries.get(ze); if (offsetEntry == null) { return null; } ZipUtil.checkRequestedFeatures(ze); long start = offsetEntry.dataOffset; BoundedInputStream bis = new BoundedInputStream(start, ze.getCompressedSize()); <BUGS> switch (ze.getMethod()) { <BUGE> case ZipArchiveEntry.STORED: return bis; case ZipArchiveEntry.DEFLATED: bis.addDummy(); final Inflater inflater = new Inflater(true); return new InflaterInputStream(bis, inflater) { @Override public void close() throws IOException { super.close(); inflater.end(); } }; default: throw new ZipException("Found unsupported compression method " + ze.getMethod()); } }
*/ public InputStream getInputStream(ZipArchiveEntry ze) throws IOException, ZipException { OffsetEntry offsetEntry = entries.get(ze); if (offsetEntry == null) { return null; } ZipUtil.checkRequestedFeatures(ze); long start = offsetEntry.dataOffset; BoundedInputStream bis = new BoundedInputStream(start, ze.getCompressedSize()); switch (ze.getMethod()) { case ZipArchiveEntry.STORED: <BUGS> return bis; <BUGE> case ZipArchiveEntry.DEFLATED: bis.addDummy(); final Inflater inflater = new Inflater(true); return new InflaterInputStream(bis, inflater) { @Override public void close() throws IOException { super.close(); inflater.end(); } }; default: throw new ZipException("Found unsupported compression method " + ze.getMethod()); } }
*/ public static boolean matches(byte[] signature, int length) { <BUGS> if (length < TarConstants.VERSION_OFFSET+TarConstants.VERSIONLEN) { return false; <BUGE> }  if (ArchiveUtils.matchAsciiBuffer(TarConstants.MAGIC_POSIX, signature, TarConstants.MAGIC_OFFSET, TarConstants.MAGICLEN) && ArchiveUtils.matchAsciiBuffer(TarConstants.VERSION_POSIX, signature, TarConstants.VERSION_OFFSET, TarConstants.VERSIONLEN) ){ return true; } if (ArchiveUtils.matchAsciiBuffer(TarConstants.MAGIC_GNU, signature, TarConstants.MAGIC_OFFSET, TarConstants.MAGICLEN) && ( ArchiveUtils.matchAsciiBuffer(TarConstants.VERSION_GNU_SPACE, signature, TarConstants.VERSION_OFFSET, TarConstants.VERSIONLEN) || ArchiveUtils.matchAsciiBuffer(TarConstants.VERSION_GNU_ZERO, signature, TarConstants.VERSION_OFFSET, TarConstants.VERSIONLEN) ) ){ return true; } /* COMPRESS-107 - recognise Ant tar files*/ if (ArchiveUtils.matchAsciiBuffer(TarConstants.MAGIC_ANT, signature, TarConstants.MAGIC_OFFSET, TarConstants.MAGICLEN)
*/ public static long parseOctal(final byte[] buffer, final int offset, final int length) { <BUGS> long    result = 0; int     end = offset + length; int     start = offset; <BUGE>  if (length < 2){ throw new IllegalArgumentException("Length "+length+" must be at least 2"); }  boolean allNUL = true; for (int i = start; i < end; i++){ if (buffer[i] != 0){ allNUL = false; break; } } if (allNUL) { return 0L; }  /* Skip leading spaces*/ while (start < end){ if (buffer[start] == ' '){ start++; } else { break; } }
*/ public static long parseOctal(final byte[] buffer, final int offset, final int length) { long    result = 0; int     end = offset + length; int     start = offset;  <BUGS> if (length < 2){ <BUGE> throw new IllegalArgumentException("Length "+length+" must be at least 2"); }  boolean allNUL = true; for (int i = start; i < end; i++){ if (buffer[i] != 0){ allNUL = false; break; } } if (allNUL) { return 0L; }  /* Skip leading spaces*/ while (start < end){ if (buffer[start] == ' '){ start++; } else { break; } }
*/ public static long parseOctal(final byte[] buffer, final int offset, final int length) { long    result = 0; int     end = offset + length; int     start = offset;  if (length < 2){ throw new IllegalArgumentException("Length "+length+" must be at least 2"); }  <BUGS> boolean allNUL = true; for (int i = start; i < end; i++){ if (buffer[i] != 0){ allNUL = false; break; <BUGE> } } if (allNUL) { return 0L; }  /* Skip leading spaces*/ while (start < end){ if (buffer[start] == ' '){ start++; } else { break; } }
*/ public static long parseOctal(final byte[] buffer, final int offset, final int length) { long    result = 0; int     end = offset + length; int     start = offset;  if (length < 2){ throw new IllegalArgumentException("Length "+length+" must be at least 2"); }  boolean allNUL = true; for (int i = start; i < end; i++){ if (buffer[i] != 0){ allNUL = false; break; } } <BUGS> if (allNUL) { <BUGE> return 0L; }  /* Skip leading spaces*/ while (start < end){ if (buffer[start] == ' '){ start++; } else { break; } }
*/ public static long parseOctal(final byte[] buffer, final int offset, final int length) { long    result = 0; int     end = offset + length; int     start = offset;  if (length < 2){ throw new IllegalArgumentException("Length "+length+" must be at least 2"); }  boolean allNUL = true; for (int i = start; i < end; i++){ if (buffer[i] != 0){ allNUL = false; break; } } if (allNUL) { return 0L; }  /* Skip leading spaces*/ <BUGS> while (start < end){ if (buffer[start] == ' '){ <BUGE> start++; } else { break; } }
* Leading spaces are ignored. * The buffer must contain a trailing space or NUL, * and may contain an additional trailing space or NUL. * * The input buffer is allowed to contain all NULs, * in which case the method returns 0L * (this allows for missing fields). * * @param buffer The buffer from which to parse. * @param offset The offset into the buffer from which to parse. * @param length The maximum number of bytes to parse - must be at least 2 bytes. * @return The long value of the octal string. * @throws IllegalArgumentException if the trailing space/NUL is missing or if a invalid byte is detected. byte trailer; <BUGS> trailer = buffer[end-1]; if (trailer == 0 || trailer == ' '){ end--; <BUGE> } else { throw new IllegalArgumentException( exceptionMessage(buffer, offset, length, end-1, trailer)); } /* May have additional NUL or space*/ trailer = buffer[end-1]; if (trailer == 0 || trailer == ' '){ end--; }  for ( ;start < end; start++) { final byte currentByte = buffer[start]; /* CheckStyle:MagicNumber OFF*/
* Parse an octal string from a buffer. * Leading spaces are ignored. * The buffer must contain a trailing space or NUL, * and may contain an additional trailing space or NUL. * * The input buffer is allowed to contain all NULs, * in which case the method returns 0L * (this allows for missing fields). * * @param buffer The buffer from which to parse. * @param offset The offset into the buffer from which to parse. * @param length The maximum number of bytes to parse - must be at least 2 bytes. * @return The long value of the octal string. * @throws IllegalArgumentException if the trailing space/NUL is missing or if a invalid byte is detected. /* May have additional NUL or space*/ <BUGS> trailer = buffer[end-1]; if (trailer == 0 || trailer == ' '){ <BUGE> end--; }  for ( ;start < end; start++) { final byte currentByte = buffer[start]; /* CheckStyle:MagicNumber OFF*/ if (currentByte < '0' || currentByte > '7'){ throw new IllegalArgumentException( exceptionMessage(buffer, offset, length, start, currentByte)); } result = (result << 3) + (currentByte - '0'); /* convert from ASCII*/ /* CheckStyle:MagicNumber ON*/ }
* Parse an octal string from a buffer. * Leading spaces are ignored. * The buffer must contain a trailing space or NUL, * and may contain an additional trailing space or NUL. * * The input buffer is allowed to contain all NULs, * in which case the method returns 0L * (this allows for missing fields). * * @param buffer The buffer from which to parse. * @param offset The offset into the buffer from which to parse. * @param length The maximum number of bytes to parse - must be at least 2 bytes. * @return The long value of the octal string. * @throws IllegalArgumentException if the trailing space/NUL is missing or if a invalid byte is detected.  <BUGS> for ( ;start < end; start++) { final byte currentByte = buffer[start]; <BUGE> /* CheckStyle:MagicNumber OFF*/ if (currentByte < '0' || currentByte > '7'){ throw new IllegalArgumentException( exceptionMessage(buffer, offset, length, start, currentByte)); } result = (result << 3) + (currentByte - '0'); /* convert from ASCII*/ /* CheckStyle:MagicNumber ON*/ }  return result; }  /**
* Parse an octal string from a buffer. * Leading spaces are ignored. * The buffer must contain a trailing space or NUL, * and may contain an additional trailing space or NUL. * * The input buffer is allowed to contain all NULs, * in which case the method returns 0L * (this allows for missing fields). * * @param buffer The buffer from which to parse. * @param offset The offset into the buffer from which to parse. * @param length The maximum number of bytes to parse - must be at least 2 bytes. * @return The long value of the octal string. * @throws IllegalArgumentException if the trailing space/NUL is missing or if a invalid byte is detected. /* CheckStyle:MagicNumber OFF*/ <BUGS> if (currentByte < '0' || currentByte > '7'){ throw new IllegalArgumentException( <BUGE> exceptionMessage(buffer, offset, length, start, currentByte)); } result = (result << 3) + (currentByte - '0'); /* convert from ASCII*/ /* CheckStyle:MagicNumber ON*/ }  return result; }  /** * Compute the value contained in a byte buffer.  If the most * significant bit of the first byte in the buffer is set, this * bit is ignored and the rest of the buffer is interpreted as a
* Parse an octal string from a buffer. * Leading spaces are ignored. * The buffer must contain a trailing space or NUL, * and may contain an additional trailing space or NUL. * * The input buffer is allowed to contain all NULs, * in which case the method returns 0L * (this allows for missing fields). * * @param buffer The buffer from which to parse. * @param offset The offset into the buffer from which to parse. * @param length The maximum number of bytes to parse - must be at least 2 bytes. * @return The long value of the octal string. * @throws IllegalArgumentException if the trailing space/NUL is missing or if a invalid byte is detected. } <BUGS> result = (result << 3) + (currentByte - '0'); /* convert from ASCII <BUGE>*/ /* CheckStyle:MagicNumber ON*/ }  return result; }  /** * Compute the value contained in a byte buffer.  If the most * significant bit of the first byte in the buffer is set, this * bit is ignored and the rest of the buffer is interpreted as a * binary number.  Otherwise, the buffer is interpreted as an * octal number as per the parseOctal function above. * * @param buffer The buffer from which to parse.
* Parse an octal string from a buffer. * Leading spaces are ignored. * The buffer must contain a trailing space or NUL, * and may contain an additional trailing space or NUL. * * The input buffer is allowed to contain all NULs, * in which case the method returns 0L * (this allows for missing fields). * * @param buffer The buffer from which to parse. * @param offset The offset into the buffer from which to parse. * @param length The maximum number of bytes to parse - must be at least 2 bytes. * @return The long value of the octal string. * @throws IllegalArgumentException if the trailing space/NUL is missing or if a invalid byte is detected.  <BUGS> return result; <BUGE> }  /** * Compute the value contained in a byte buffer.  If the most * significant bit of the first byte in the buffer is set, this * bit is ignored and the rest of the buffer is interpreted as a * binary number.  Otherwise, the buffer is interpreted as an * octal number as per the parseOctal function above. * * @param buffer The buffer from which to parse. * @param offset The offset into the buffer from which to parse. * @param length The maximum number of bytes to parse. * @return The long value of the octal or binary string. * @throws IllegalArgumentException if the trailing space/NUL is
*/ static void setNameAndCommentFromExtraFields(ZipArchiveEntry ze, byte[] originalNameBytes, byte[] commentBytes) { <BUGS> UnicodePathExtraField name = (UnicodePathExtraField) <BUGE> ze.getExtraField(UnicodePathExtraField.UPATH_ID); String originalName = ze.getName(); String newName = getUnicodeStringIfOriginalMatches(name, originalNameBytes); if (newName != null && !originalName.equals(newName)) { ze.setName(newName); }  if (commentBytes != null && commentBytes.length > 0) { UnicodeCommentExtraField cmt = (UnicodeCommentExtraField) ze.getExtraField(UnicodeCommentExtraField.UCOM_ID); String newComment = getUnicodeStringIfOriginalMatches(cmt, commentBytes); if (newComment != null) { ze.setComment(newComment); } } }
*/ static void setNameAndCommentFromExtraFields(ZipArchiveEntry ze, byte[] originalNameBytes, byte[] commentBytes) { UnicodePathExtraField name = (UnicodePathExtraField) ze.getExtraField(UnicodePathExtraField.UPATH_ID); <BUGS> String originalName = ze.getName(); String newName = getUnicodeStringIfOriginalMatches(name, <BUGE> originalNameBytes); if (newName != null && !originalName.equals(newName)) { ze.setName(newName); }  if (commentBytes != null && commentBytes.length > 0) { UnicodeCommentExtraField cmt = (UnicodeCommentExtraField) ze.getExtraField(UnicodeCommentExtraField.UCOM_ID); String newComment = getUnicodeStringIfOriginalMatches(cmt, commentBytes); if (newComment != null) { ze.setComment(newComment); } } }
*/ static void setNameAndCommentFromExtraFields(ZipArchiveEntry ze, byte[] originalNameBytes, byte[] commentBytes) { UnicodePathExtraField name = (UnicodePathExtraField) ze.getExtraField(UnicodePathExtraField.UPATH_ID); String originalName = ze.getName(); String newName = getUnicodeStringIfOriginalMatches(name, originalNameBytes); <BUGS> if (newName != null && !originalName.equals(newName)) { ze.setName(newName); <BUGE> }  if (commentBytes != null && commentBytes.length > 0) { UnicodeCommentExtraField cmt = (UnicodeCommentExtraField) ze.getExtraField(UnicodeCommentExtraField.UCOM_ID); String newComment = getUnicodeStringIfOriginalMatches(cmt, commentBytes); if (newComment != null) { ze.setComment(newComment); } } }
*/ static void setNameAndCommentFromExtraFields(ZipArchiveEntry ze, byte[] originalNameBytes, byte[] commentBytes) { UnicodePathExtraField name = (UnicodePathExtraField) ze.getExtraField(UnicodePathExtraField.UPATH_ID); String originalName = ze.getName(); String newName = getUnicodeStringIfOriginalMatches(name, originalNameBytes); if (newName != null && !originalName.equals(newName)) { ze.setName(newName); }  <BUGS> if (commentBytes != null && commentBytes.length > 0) { <BUGE> UnicodeCommentExtraField cmt = (UnicodeCommentExtraField) ze.getExtraField(UnicodeCommentExtraField.UCOM_ID); String newComment = getUnicodeStringIfOriginalMatches(cmt, commentBytes); if (newComment != null) { ze.setComment(newComment); } } }
*/ static void setNameAndCommentFromExtraFields(ZipArchiveEntry ze, byte[] originalNameBytes, byte[] commentBytes) { UnicodePathExtraField name = (UnicodePathExtraField) ze.getExtraField(UnicodePathExtraField.UPATH_ID); String originalName = ze.getName(); String newName = getUnicodeStringIfOriginalMatches(name, originalNameBytes); if (newName != null && !originalName.equals(newName)) { ze.setName(newName); }  if (commentBytes != null && commentBytes.length > 0) { UnicodeCommentExtraField cmt = (UnicodeCommentExtraField) ze.getExtraField(UnicodeCommentExtraField.UCOM_ID); String newComment = getUnicodeStringIfOriginalMatches(cmt, commentBytes); if (newComment != null) { ze.setComment(newComment); } } <BUGS> } <BUGE>
*/ public TarArchiveEntry getNextTarEntry() throws IOException { <BUGS> if (hasHitEOF) { <BUGE> return null; }  if (currEntry != null) { long numToSkip = entrySize - entryOffset;  while (numToSkip > 0) { long skipped = skip(numToSkip); if (skipped <= 0) { throw new RuntimeException("failed to skip current tar entry"); } numToSkip -= skipped; }  readBuf = null; }  byte[] headerBuf = getRecord();  if (hasHitEOF) { currEntry = null; return null; }  try { currEntry = new TarArchiveEntry(headerBuf); } catch (IllegalArgumentException e) {
*/ public TarArchiveEntry getNextTarEntry() throws IOException { if (hasHitEOF) { return null; }  <BUGS> if (currEntry != null) { long numToSkip = entrySize - entryOffset; <BUGE>  while (numToSkip > 0) { long skipped = skip(numToSkip); if (skipped <= 0) { throw new RuntimeException("failed to skip current tar entry"); } numToSkip -= skipped; }  readBuf = null; }  byte[] headerBuf = getRecord();  if (hasHitEOF) { currEntry = null; return null; }  try { currEntry = new TarArchiveEntry(headerBuf); } catch (IllegalArgumentException e) {
*/ public TarArchiveEntry getNextTarEntry() throws IOException { if (hasHitEOF) { return null; }  if (currEntry != null) { long numToSkip = entrySize - entryOffset;  <BUGS> while (numToSkip > 0) { <BUGE> long skipped = skip(numToSkip); if (skipped <= 0) { throw new RuntimeException("failed to skip current tar entry"); } numToSkip -= skipped; }  readBuf = null; }  byte[] headerBuf = getRecord();  if (hasHitEOF) { currEntry = null; return null; }  try { currEntry = new TarArchiveEntry(headerBuf); } catch (IllegalArgumentException e) {
*/ public TarArchiveEntry getNextTarEntry() throws IOException { if (hasHitEOF) { return null; }  if (currEntry != null) { long numToSkip = entrySize - entryOffset;  while (numToSkip > 0) { long skipped = skip(numToSkip); if (skipped <= 0) { throw new RuntimeException("failed to skip current tar entry"); } numToSkip -= skipped; }  <BUGS> readBuf = null; <BUGE> }  byte[] headerBuf = getRecord();  if (hasHitEOF) { currEntry = null; return null; }  try { currEntry = new TarArchiveEntry(headerBuf); } catch (IllegalArgumentException e) {
*/ public TarArchiveEntry getNextTarEntry() throws IOException { if (hasHitEOF) { return null; }  if (currEntry != null) { long numToSkip = entrySize - entryOffset;  while (numToSkip > 0) { long skipped = skip(numToSkip); if (skipped <= 0) { throw new RuntimeException("failed to skip current tar entry"); } numToSkip -= skipped; }  readBuf = null; }  <BUGS> byte[] headerBuf = getRecord(); <BUGE>  if (hasHitEOF) { currEntry = null; return null; }  try { currEntry = new TarArchiveEntry(headerBuf); } catch (IllegalArgumentException e) {
*/ public TarArchiveEntry getNextTarEntry() throws IOException { if (hasHitEOF) { return null; }  if (currEntry != null) { long numToSkip = entrySize - entryOffset;  while (numToSkip > 0) { long skipped = skip(numToSkip); if (skipped <= 0) { throw new RuntimeException("failed to skip current tar entry"); } numToSkip -= skipped; }  readBuf = null; }  byte[] headerBuf = getRecord();  <BUGS> if (hasHitEOF) { <BUGE> currEntry = null; return null; }  try { currEntry = new TarArchiveEntry(headerBuf); } catch (IllegalArgumentException e) {
* Get the next entry in this tar archive. This will skip * over any remaining data in the current entry, if there * is one, and place the input stream at the header of the * next entry, and read the header and instantiate a new * TarEntry from the header bytes and return that entry. * If there are no more entries in the archive, null will * be returned to indicate that the end of the archive has * been reached. * * @return The next TarEntry in the archive, or null. * @throws IOException on error try { <BUGS> currEntry = new TarArchiveEntry(headerBuf); } catch (IllegalArgumentException e) { IOException ioe = new IOException("Error detected parsing the header"); ioe.initCause(e); throw ioe; } entryOffset = 0; entrySize = currEntry.getSize(); <BUGE>  if (currEntry.isGNULongNameEntry()) { /* read in the name*/ StringBuffer longName = new StringBuffer(); byte[] buf = new byte[SMALL_BUFFER_SIZE]; int length = 0; while ((length = read(buf)) >= 0) { longName.append(new String(buf, 0, length)); } getNextEntry();
}  /** * Get the next entry in this tar archive. This will skip * over any remaining data in the current entry, if there * is one, and place the input stream at the header of the * next entry, and read the header and instantiate a new * TarEntry from the header bytes and return that entry. * If there are no more entries in the archive, null will * be returned to indicate that the end of the archive has * been reached. * * @return The next TarEntry in the archive, or null. * @throws IOException on error  <BUGS> if (currEntry.isGNULongNameEntry()) { <BUGE> /* read in the name*/ StringBuffer longName = new StringBuffer(); byte[] buf = new byte[SMALL_BUFFER_SIZE]; int length = 0; while ((length = read(buf)) >= 0) { longName.append(new String(buf, 0, length)); } getNextEntry(); if (currEntry == null) { /* Bugzilla: 40334*/ /* Malformed tar file - long entry name not followed by entry*/ return null; } /* remove trailing null terminator*/
}  /** * Get the next entry in this tar archive. This will skip * over any remaining data in the current entry, if there * is one, and place the input stream at the header of the * next entry, and read the header and instantiate a new * TarEntry from the header bytes and return that entry. * If there are no more entries in the archive, null will * be returned to indicate that the end of the archive has * been reached. * * @return The next TarEntry in the archive, or null. * @throws IOException on error  <BUGS> if (currEntry.isPaxHeader()){ /* Process Pax headers <BUGE>*/ paxHeaders(); }  if (currEntry.isGNUSparse()){ /* Process sparse files*/ readGNUSparse(); }  /* If the size of the next element in the archive has changed*/ /* due to a new size being reported in the posix header*/ /* information, we update entrySize here so that it contains*/ /* the correct value.*/ entrySize = currEntry.getSize(); return currEntry; }
}  /** * Get the next entry in this tar archive. This will skip * over any remaining data in the current entry, if there * is one, and place the input stream at the header of the * next entry, and read the header and instantiate a new * TarEntry from the header bytes and return that entry. * If there are no more entries in the archive, null will * be returned to indicate that the end of the archive has * been reached. * * @return The next TarEntry in the archive, or null. * @throws IOException on error  <BUGS> if (currEntry.isGNUSparse()){ /* Process sparse files <BUGE>*/ readGNUSparse(); }  /* If the size of the next element in the archive has changed*/ /* due to a new size being reported in the posix header*/ /* information, we update entrySize here so that it contains*/ /* the correct value.*/ entrySize = currEntry.getSize(); return currEntry; }  /** * Get the next record in this tar archive. This will skip * over any remaining data in the current entry, if there
}  /** * Get the next entry in this tar archive. This will skip * over any remaining data in the current entry, if there * is one, and place the input stream at the header of the * next entry, and read the header and instantiate a new * TarEntry from the header bytes and return that entry. * If there are no more entries in the archive, null will * be returned to indicate that the end of the archive has * been reached. * * @return The next TarEntry in the archive, or null. * @throws IOException on error /* the correct value.*/ <BUGS> entrySize = currEntry.getSize(); return currEntry; <BUGE> }  /** * Get the next record in this tar archive. This will skip * over any remaining data in the current entry, if there * is one, and place the input stream at the header of the * next entry. * If there are no more entries in the archive, null will * be returned to indicate that the end of the archive has * been reached. * * @return The next header in the archive, or null. * @throws IOException on error
@Override public boolean equals(Object obj) { <BUGS> if (this == obj) { <BUGE> return true; } if (obj == null || getClass() != obj.getClass()) { return false; } ZipArchiveEntry other = (ZipArchiveEntry) obj; String myName = getName(); String otherName = other.getName(); if (myName == null) { if (otherName != null) { return false; } } else if (!myName.equals(otherName)) { return false; } String myComment = getComment(); String otherComment = other.getComment(); if (myComment == null) { if (otherComment != null) { return false; } } else if (!myComment.equals(otherComment)) { return false; } return getTime() == other.getTime() && getInternalAttributes() == other.getInternalAttributes() && getPlatform() == other.getPlatform()
@Override public boolean equals(Object obj) { if (this == obj) { return true; } <BUGS> if (obj == null || getClass() != obj.getClass()) { <BUGE> return false; } ZipArchiveEntry other = (ZipArchiveEntry) obj; String myName = getName(); String otherName = other.getName(); if (myName == null) { if (otherName != null) { return false; } } else if (!myName.equals(otherName)) { return false; } String myComment = getComment(); String otherComment = other.getComment(); if (myComment == null) { if (otherComment != null) { return false; } } else if (!myComment.equals(otherComment)) { return false; } return getTime() == other.getTime() && getInternalAttributes() == other.getInternalAttributes() && getPlatform() == other.getPlatform()
@Override public boolean equals(Object obj) { if (this == obj) { return true; } if (obj == null || getClass() != obj.getClass()) { return false; } <BUGS> ZipArchiveEntry other = (ZipArchiveEntry) obj; String myName = getName(); String otherName = other.getName(); if (myName == null) { <BUGE> if (otherName != null) { return false; } } else if (!myName.equals(otherName)) { return false; } String myComment = getComment(); String otherComment = other.getComment(); if (myComment == null) { if (otherComment != null) { return false; } } else if (!myComment.equals(otherComment)) { return false; } return getTime() == other.getTime() && getInternalAttributes() == other.getInternalAttributes() && getPlatform() == other.getPlatform()
@Override public boolean equals(Object obj) { if (this == obj) { return true; } if (obj == null || getClass() != obj.getClass()) { return false; } ZipArchiveEntry other = (ZipArchiveEntry) obj; String myName = getName(); String otherName = other.getName(); if (myName == null) { if (otherName != null) { return false; } <BUGS> } else if (!myName.equals(otherName)) { <BUGE> return false; } String myComment = getComment(); String otherComment = other.getComment(); if (myComment == null) { if (otherComment != null) { return false; } } else if (!myComment.equals(otherComment)) { return false; } return getTime() == other.getTime() && getInternalAttributes() == other.getInternalAttributes() && getPlatform() == other.getPlatform()
@Override public boolean equals(Object obj) { if (this == obj) { return true; } if (obj == null || getClass() != obj.getClass()) { return false; } ZipArchiveEntry other = (ZipArchiveEntry) obj; String myName = getName(); String otherName = other.getName(); if (myName == null) { if (otherName != null) { return false; } } else if (!myName.equals(otherName)) { return false; } <BUGS> String myComment = getComment(); String otherComment = other.getComment(); if (myComment == null) { if (otherComment != null) { return false; <BUGE> } } else if (!myComment.equals(otherComment)) { return false; } return getTime() == other.getTime() && getInternalAttributes() == other.getInternalAttributes() && getPlatform() == other.getPlatform()
private void parseTarHeader(byte[] header, ZipEncoding encoding, final boolean oldStyle) throws IOException { <BUGS> int offset = 0; <BUGE>  name = oldStyle ? TarUtils.parseName(header, offset, NAMELEN) : TarUtils.parseName(header, offset, NAMELEN, encoding); offset += NAMELEN; mode = (int) TarUtils.parseOctalOrBinary(header, offset, MODELEN); offset += MODELEN; userId = (int) TarUtils.parseOctalOrBinary(header, offset, UIDLEN); offset += UIDLEN; groupId = (int) TarUtils.parseOctalOrBinary(header, offset, GIDLEN); offset += GIDLEN; size = TarUtils.parseOctalOrBinary(header, offset, SIZELEN); offset += SIZELEN; modTime = TarUtils.parseOctalOrBinary(header, offset, MODTIMELEN); offset += MODTIMELEN; checkSumOK = TarUtils.verifyCheckSum(header); offset += CHKSUMLEN; linkFlag = header[offset++]; linkName = oldStyle ? TarUtils.parseName(header, offset, NAMELEN) : TarUtils.parseName(header, offset, NAMELEN, encoding); offset += NAMELEN; magic = TarUtils.parseName(header, offset, MAGICLEN); offset += MAGICLEN; version = TarUtils.parseName(header, offset, VERSIONLEN); offset += VERSIONLEN; userName = oldStyle ? TarUtils.parseName(header, offset, UNAMELEN)
private void parseTarHeader(byte[] header, ZipEncoding encoding, final boolean oldStyle) throws IOException { int offset = 0;  <BUGS> name = oldStyle ? TarUtils.parseName(header, offset, NAMELEN) <BUGE> : TarUtils.parseName(header, offset, NAMELEN, encoding); offset += NAMELEN; mode = (int) TarUtils.parseOctalOrBinary(header, offset, MODELEN); offset += MODELEN; userId = (int) TarUtils.parseOctalOrBinary(header, offset, UIDLEN); offset += UIDLEN; groupId = (int) TarUtils.parseOctalOrBinary(header, offset, GIDLEN); offset += GIDLEN; size = TarUtils.parseOctalOrBinary(header, offset, SIZELEN); offset += SIZELEN; modTime = TarUtils.parseOctalOrBinary(header, offset, MODTIMELEN); offset += MODTIMELEN; checkSumOK = TarUtils.verifyCheckSum(header); offset += CHKSUMLEN; linkFlag = header[offset++]; linkName = oldStyle ? TarUtils.parseName(header, offset, NAMELEN) : TarUtils.parseName(header, offset, NAMELEN, encoding); offset += NAMELEN; magic = TarUtils.parseName(header, offset, MAGICLEN); offset += MAGICLEN; version = TarUtils.parseName(header, offset, VERSIONLEN); offset += VERSIONLEN; userName = oldStyle ? TarUtils.parseName(header, offset, UNAMELEN)
private void parseTarHeader(byte[] header, ZipEncoding encoding, final boolean oldStyle) throws IOException { int offset = 0;  name = oldStyle ? TarUtils.parseName(header, offset, NAMELEN) : TarUtils.parseName(header, offset, NAMELEN, encoding); <BUGS> offset += NAMELEN; mode = (int) TarUtils.parseOctalOrBinary(header, offset, MODELEN); offset += MODELEN; userId = (int) TarUtils.parseOctalOrBinary(header, offset, UIDLEN); offset += UIDLEN; groupId = (int) TarUtils.parseOctalOrBinary(header, offset, GIDLEN); offset += GIDLEN; size = TarUtils.parseOctalOrBinary(header, offset, SIZELEN); offset += SIZELEN; modTime = TarUtils.parseOctalOrBinary(header, offset, MODTIMELEN); offset += MODTIMELEN; checkSumOK = TarUtils.verifyCheckSum(header); offset += CHKSUMLEN; linkFlag = header[offset++]; linkName = oldStyle ? TarUtils.parseName(header, offset, NAMELEN) <BUGE> : TarUtils.parseName(header, offset, NAMELEN, encoding); offset += NAMELEN; magic = TarUtils.parseName(header, offset, MAGICLEN); offset += MAGICLEN; version = TarUtils.parseName(header, offset, VERSIONLEN); offset += VERSIONLEN; userName = oldStyle ? TarUtils.parseName(header, offset, UNAMELEN)
private void parseTarHeader(byte[] header, ZipEncoding encoding, final boolean oldStyle) throws IOException { int offset = 0;  name = oldStyle ? TarUtils.parseName(header, offset, NAMELEN) : TarUtils.parseName(header, offset, NAMELEN, encoding); offset += NAMELEN; mode = (int) TarUtils.parseOctalOrBinary(header, offset, MODELEN); offset += MODELEN; userId = (int) TarUtils.parseOctalOrBinary(header, offset, UIDLEN); offset += UIDLEN; groupId = (int) TarUtils.parseOctalOrBinary(header, offset, GIDLEN); offset += GIDLEN; size = TarUtils.parseOctalOrBinary(header, offset, SIZELEN); offset += SIZELEN; modTime = TarUtils.parseOctalOrBinary(header, offset, MODTIMELEN); offset += MODTIMELEN; checkSumOK = TarUtils.verifyCheckSum(header); offset += CHKSUMLEN; linkFlag = header[offset++]; linkName = oldStyle ? TarUtils.parseName(header, offset, NAMELEN) : TarUtils.parseName(header, offset, NAMELEN, encoding); <BUGS> offset += NAMELEN; magic = TarUtils.parseName(header, offset, MAGICLEN); offset += MAGICLEN; version = TarUtils.parseName(header, offset, VERSIONLEN); offset += VERSIONLEN; userName = oldStyle ? TarUtils.parseName(header, offset, UNAMELEN) <BUGE>
/** * Parse an entry's header information from a header buffer. * * @param header The tar entry header buffer to get information from. * @param encoding encoding to use for file names * @since Commons Compress 1.4 * @throws IllegalArgumentException if any of the numeric fields * have an invalid format */ public void parseTarHeader(byte[] header, ZipEncoding encoding) throws IOException { parseTarHeader(header, encoding, false); } : TarUtils.parseName(header, offset, UNAMELEN, encoding); <BUGS> offset += UNAMELEN; groupName = oldStyle ? TarUtils.parseName(header, offset, GNAMELEN) <BUGE> : TarUtils.parseName(header, offset, GNAMELEN, encoding); offset += GNAMELEN; devMajor = (int) TarUtils.parseOctalOrBinary(header, offset, DEVLEN); offset += DEVLEN; devMinor = (int) TarUtils.parseOctalOrBinary(header, offset, DEVLEN); offset += DEVLEN;  int type = evaluateType(header); switch (type) { case FORMAT_OLDGNU: { offset += ATIMELEN_GNU; offset += CTIMELEN_GNU; offset += OFFSETLEN_GNU;
* Parse an entry's header information from a header buffer. * * @param header The tar entry header buffer to get information from. * @param encoding encoding to use for file names * @since Commons Compress 1.4 * @throws IllegalArgumentException if any of the numeric fields * have an invalid format */ public void parseTarHeader(byte[] header, ZipEncoding encoding) throws IOException { parseTarHeader(header, encoding, false); } : TarUtils.parseName(header, offset, GNAMELEN, encoding); <BUGS> offset += GNAMELEN; devMajor = (int) TarUtils.parseOctalOrBinary(header, offset, DEVLEN); offset += DEVLEN; devMinor = (int) TarUtils.parseOctalOrBinary(header, offset, DEVLEN); offset += DEVLEN; <BUGE>  int type = evaluateType(header); switch (type) { case FORMAT_OLDGNU: { offset += ATIMELEN_GNU; offset += CTIMELEN_GNU; offset += OFFSETLEN_GNU; offset += LONGNAMESLEN_GNU; offset += PAD2LEN_GNU; offset += SPARSELEN_GNU; isExtended = TarUtils.parseBoolean(header, offset); offset += ISEXTENDEDLEN_GNU;
/** * Parse an entry's header information from a header buffer. * * @param header The tar entry header buffer to get information from. * @param encoding encoding to use for file names * @since Commons Compress 1.4 * @throws IllegalArgumentException if any of the numeric fields * have an invalid format */ public void parseTarHeader(byte[] header, ZipEncoding encoding) throws IOException { parseTarHeader(header, encoding, false); }  <BUGS> int type = evaluateType(header); switch (type) { <BUGE> case FORMAT_OLDGNU: { offset += ATIMELEN_GNU; offset += CTIMELEN_GNU; offset += OFFSETLEN_GNU; offset += LONGNAMESLEN_GNU; offset += PAD2LEN_GNU; offset += SPARSELEN_GNU; isExtended = TarUtils.parseBoolean(header, offset); offset += ISEXTENDEDLEN_GNU; realSize = TarUtils.parseOctal(header, offset, REALSIZELEN_GNU); offset += REALSIZELEN_GNU; break; }
/** * Parse an entry's header information from a header buffer. * * @param header The tar entry header buffer to get information from. * @param encoding encoding to use for file names * @since Commons Compress 1.4 * @throws IllegalArgumentException if any of the numeric fields * have an invalid format */ public void parseTarHeader(byte[] header, ZipEncoding encoding) throws IOException { parseTarHeader(header, encoding, false); } default: { <BUGS> String prefix = oldStyle <BUGE> ? TarUtils.parseName(header, offset, PREFIXLEN) : TarUtils.parseName(header, offset, PREFIXLEN, encoding); /* SunOS tar -E does not add / to directory names, so fix*/ /* up to be consistent*/ if (isDirectory() && !name.endsWith("/")){ name = name + "/"; } if (prefix.length() > 0){ name = prefix + "/" + name; } } } }
/** * Parse an entry's header information from a header buffer. * * @param header The tar entry header buffer to get information from. * @param encoding encoding to use for file names * @since Commons Compress 1.4 * @throws IllegalArgumentException if any of the numeric fields * have an invalid format */ public void parseTarHeader(byte[] header, ZipEncoding encoding) throws IOException { parseTarHeader(header, encoding, false); } /* up to be consistent*/ <BUGS> if (isDirectory() && !name.endsWith("/")){ <BUGE> name = name + "/"; } if (prefix.length() > 0){ name = prefix + "/" + name; } } } }  /** * Strips Windows' drive letter as well as any leading slashes, * turns path separators into forward slahes. */ private static String normalizeFileName(String fileName,
/** * Parse an entry's header information from a header buffer. * * @param header The tar entry header buffer to get information from. * @param encoding encoding to use for file names * @since Commons Compress 1.4 * @throws IllegalArgumentException if any of the numeric fields * have an invalid format */ public void parseTarHeader(byte[] header, ZipEncoding encoding) throws IOException { parseTarHeader(header, encoding, false); } } <BUGS> if (prefix.length() > 0){ name = prefix + "/" + name; <BUGE> } } } }  /** * Strips Windows' drive letter as well as any leading slashes, * turns path separators into forward slahes. */ private static String normalizeFileName(String fileName, boolean preserveLeadingSlashes) { String osname = System.getProperty("os.name").toLowerCase(Locale.ENGLISH);
/** * Parse an entry's header information from a header buffer. * * @param header The tar entry header buffer to get information from. * @param encoding encoding to use for file names * @since Commons Compress 1.4 * @throws IllegalArgumentException if any of the numeric fields * have an invalid format */ public void parseTarHeader(byte[] header, ZipEncoding encoding) throws IOException { parseTarHeader(header, encoding, false); } } <BUGS> } <BUGE>  /** * Strips Windows' drive letter as well as any leading slashes, * turns path separators into forward slahes. */ private static String normalizeFileName(String fileName, boolean preserveLeadingSlashes) { String osname = System.getProperty("os.name").toLowerCase(Locale.ENGLISH);  if (osname != null) {  /* Strip off drive letters!*/ /* REVIEW Would a better check be "(File.separator == '\')"?*/
*/ public TarArchiveEntry getNextTarEntry() throws IOException { <BUGS> if (hasHitEOF) { <BUGE> return null; }  if (currEntry != null) { long numToSkip = entrySize - entryOffset;  while (numToSkip > 0) { long skipped = skip(numToSkip); if (skipped <= 0) { throw new RuntimeException("failed to skip current tar" + " entry"); } numToSkip -= skipped; }  readBuf = null; }  byte[] headerBuf = getRecord();  if (hasHitEOF) { currEntry = null; return null; }  try { currEntry = new TarArchiveEntry(headerBuf, encoding);
*/ public TarArchiveEntry getNextTarEntry() throws IOException { if (hasHitEOF) { return null; }  <BUGS> if (currEntry != null) { <BUGE> long numToSkip = entrySize - entryOffset;  while (numToSkip > 0) { long skipped = skip(numToSkip); if (skipped <= 0) { throw new RuntimeException("failed to skip current tar" + " entry"); } numToSkip -= skipped; }  readBuf = null; }  byte[] headerBuf = getRecord();  if (hasHitEOF) { currEntry = null; return null; }  try { currEntry = new TarArchiveEntry(headerBuf, encoding);
*/ public TarArchiveEntry getNextTarEntry() throws IOException { if (hasHitEOF) { return null; }  if (currEntry != null) { long numToSkip = entrySize - entryOffset;  while (numToSkip > 0) { long skipped = skip(numToSkip); if (skipped <= 0) { throw new RuntimeException("failed to skip current tar" + " entry"); } numToSkip -= skipped; }  readBuf = null; }  <BUGS> byte[] headerBuf = getRecord(); <BUGE>  if (hasHitEOF) { currEntry = null; return null; }  try { currEntry = new TarArchiveEntry(headerBuf, encoding);
*/ public TarArchiveEntry getNextTarEntry() throws IOException { if (hasHitEOF) { return null; }  if (currEntry != null) { long numToSkip = entrySize - entryOffset;  while (numToSkip > 0) { long skipped = skip(numToSkip); if (skipped <= 0) { throw new RuntimeException("failed to skip current tar" + " entry"); } numToSkip -= skipped; }  readBuf = null; }  byte[] headerBuf = getRecord();  <BUGS> if (hasHitEOF) { <BUGE> currEntry = null; return null; }  try { currEntry = new TarArchiveEntry(headerBuf, encoding);
/** * Get the next entry in this tar archive. This will skip * over any remaining data in the current entry, if there * is one, and place the input stream at the header of the * next entry, and read the header and instantiate a new * TarEntry from the header bytes and return that entry. * If there are no more entries in the archive, null will * be returned to indicate that the end of the archive has * been reached. * * @return The next TarEntry in the archive, or null. * @throws IOException on error try { <BUGS> currEntry = new TarArchiveEntry(headerBuf, encoding); } catch (IllegalArgumentException e) { IOException ioe = new IOException("Error detected parsing the header"); ioe.initCause(e); throw ioe; <BUGE> } entryOffset = 0; entrySize = currEntry.getSize();  if (currEntry.isGNULongNameEntry()) { /* read in the name*/ StringBuffer longName = new StringBuffer(); byte[] buf = new byte[SMALL_BUFFER_SIZE]; int length = 0; while ((length = read(buf)) >= 0) { longName.append(new String(buf, 0, length)); /* TODO default charset?*/ }
*/ public boolean isDirectory() { <BUGS> if (file != null) { <BUGE> return file.isDirectory(); }  if (linkFlag == LF_DIR) { return true; }  if (getName().endsWith("/")) { return true; }  return false; }
*/ public boolean isDirectory() { if (file != null) { return file.isDirectory(); }  <BUGS> if (linkFlag == LF_DIR) { <BUGE> return true; }  if (getName().endsWith("/")) { return true; }  return false; }
*/ public boolean isDirectory() { if (file != null) { return file.isDirectory(); }  if (linkFlag == LF_DIR) { return true; }  <BUGS> if (getName().endsWith("/")) { return true; <BUGE> }  return false; }
*/ public void reparseCentralDirectoryData(boolean hasUncompressedSize, boolean hasCompressedSize, boolean hasRelativeHeaderOffset, boolean hasDiskStart) throws ZipException { <BUGS> if (rawCentralDirectoryData != null) { int expectedLength = (hasUncompressedSize ? DWORD : 0) <BUGE> + (hasCompressedSize ? DWORD : 0) + (hasRelativeHeaderOffset ? DWORD : 0) + (hasDiskStart ? WORD : 0); if (rawCentralDirectoryData.length != expectedLength) { throw new ZipException("central directory zip64 extended" + " information extra field's length" + " doesn't match central directory" + " data.  Expected length " + expectedLength + " but is " + rawCentralDirectoryData.length); } int offset = 0; if (hasUncompressedSize) { size = new ZipEightByteInteger(rawCentralDirectoryData, offset); offset += DWORD; } if (hasCompressedSize) { compressedSize = new ZipEightByteInteger(rawCentralDirectoryData, offset); offset += DWORD; } if (hasRelativeHeaderOffset) {
*/ public void reparseCentralDirectoryData(boolean hasUncompressedSize, boolean hasCompressedSize, boolean hasRelativeHeaderOffset, boolean hasDiskStart) throws ZipException { if (rawCentralDirectoryData != null) { int expectedLength = (hasUncompressedSize ? DWORD : 0) + (hasCompressedSize ? DWORD : 0) + (hasRelativeHeaderOffset ? DWORD : 0) + (hasDiskStart ? WORD : 0); <BUGS> if (rawCentralDirectoryData.length != expectedLength) { throw new ZipException("central directory zip64 extended" <BUGE> + " information extra field's length" + " doesn't match central directory" + " data.  Expected length " + expectedLength + " but is " + rawCentralDirectoryData.length); } int offset = 0; if (hasUncompressedSize) { size = new ZipEightByteInteger(rawCentralDirectoryData, offset); offset += DWORD; } if (hasCompressedSize) { compressedSize = new ZipEightByteInteger(rawCentralDirectoryData, offset); offset += DWORD; } if (hasRelativeHeaderOffset) {
*/ public void setMode(final long mode) { <BUGS> final long maskedMode = mode & S_IFMT; switch ((int) maskedMode) { <BUGE> case C_ISDIR: case C_ISLNK: case C_ISREG: case C_ISFIFO: case C_ISCHR: case C_ISBLK: case C_ISSOCK: case C_ISNWK: break; default: throw new IllegalArgumentException( "Unknown mode. " + "Full: " + Long.toHexString(mode) + " Masked: " + Long.toHexString(maskedMode)); }  this.mode = mode; }
*/ public void setMode(final long mode) { final long maskedMode = mode & S_IFMT; switch ((int) maskedMode) { case C_ISDIR: case C_ISLNK: case C_ISREG: case C_ISFIFO: case C_ISCHR: case C_ISBLK: case C_ISSOCK: case C_ISNWK: <BUGS> break; <BUGE> default: throw new IllegalArgumentException( "Unknown mode. " + "Full: " + Long.toHexString(mode) + " Masked: " + Long.toHexString(maskedMode)); }  this.mode = mode; }
*/ public void setMode(final long mode) { final long maskedMode = mode & S_IFMT; switch ((int) maskedMode) { case C_ISDIR: case C_ISLNK: case C_ISREG: case C_ISFIFO: case C_ISCHR: case C_ISBLK: case C_ISSOCK: case C_ISNWK: break; default: <BUGS> throw new IllegalArgumentException( <BUGE> "Unknown mode. " + "Full: " + Long.toHexString(mode) + " Masked: " + Long.toHexString(maskedMode)); }  this.mode = mode; }
*/ public void setMode(final long mode) { final long maskedMode = mode & S_IFMT; switch ((int) maskedMode) { case C_ISDIR: case C_ISLNK: case C_ISREG: case C_ISFIFO: case C_ISCHR: case C_ISBLK: case C_ISSOCK: case C_ISNWK: break; default: throw new IllegalArgumentException( "Unknown mode. " + "Full: " + Long.toHexString(mode) + " Masked: " + Long.toHexString(maskedMode)); }  <BUGS> this.mode = mode; } <BUGE>
private void writeUint64(final DataOutput header, long value) throws IOException { <BUGS> int firstByte = 0; int mask = 0x80; <BUGE> int i; for (i = 0; i < 8; i++) { if (value < ((1L << ( 7  * (i + 1))))) { firstByte |= (value >>> (8 * i)); break; } firstByte |= mask; mask >>>= 1; } header.write(firstByte); for (; i > 0; i--) { header.write((int) (0xff & value)); value >>>= 8; } }
private void writeUint64(final DataOutput header, long value) throws IOException { int firstByte = 0; int mask = 0x80; int i; <BUGS> for (i = 0; i < 8; i++) { if (value < ((1L << ( 7  * (i + 1))))) { firstByte |= (value >>> (8 * i)); break; <BUGE> } firstByte |= mask; mask >>>= 1; } header.write(firstByte); for (; i > 0; i--) { header.write((int) (0xff & value)); value >>>= 8; } }
private void writeUint64(final DataOutput header, long value) throws IOException { int firstByte = 0; int mask = 0x80; int i; for (i = 0; i < 8; i++) { if (value < ((1L << ( 7  * (i + 1))))) { firstByte |= (value >>> (8 * i)); break; } <BUGS> firstByte |= mask; mask >>>= 1; <BUGE> } header.write(firstByte); for (; i > 0; i--) { header.write((int) (0xff & value)); value >>>= 8; } }
private void writeUint64(final DataOutput header, long value) throws IOException { int firstByte = 0; int mask = 0x80; int i; for (i = 0; i < 8; i++) { if (value < ((1L << ( 7  * (i + 1))))) { firstByte |= (value >>> (8 * i)); break; } firstByte |= mask; mask >>>= 1; } <BUGS> header.write(firstByte); for (; i > 0; i--) { header.write((int) (0xff & value)); value >>>= 8; <BUGE> } }
private void writeUint64(final DataOutput header, long value) throws IOException { int firstByte = 0; int mask = 0x80; int i; for (i = 0; i < 8; i++) { if (value < ((1L << ( 7  * (i + 1))))) { firstByte |= (value >>> (8 * i)); break; } firstByte |= mask; mask >>>= 1; } header.write(firstByte); for (; i > 0; i--) { header.write((int) (0xff & value)); value >>>= 8; } <BUGS> } <BUGE>
private int bsR(final int n) throws IOException { <BUGS> int bsLiveShadow = this.bsLive; int bsBuffShadow = this.bsBuff; <BUGE>  if (bsLiveShadow < n) { final InputStream inShadow = this.in; do { int thech = inShadow.read();  if (thech < 0) { throw new IOException("unexpected end of stream"); }  bsBuffShadow = (bsBuffShadow << 8) | thech; bsLiveShadow += 8; } while (bsLiveShadow < n);  this.bsBuff = bsBuffShadow; }  this.bsLive = bsLiveShadow - n; return (bsBuffShadow >> (bsLiveShadow - n)) & ((1 << n) - 1); }
private int bsR(final int n) throws IOException { int bsLiveShadow = this.bsLive; int bsBuffShadow = this.bsBuff;  <BUGS> if (bsLiveShadow < n) { final InputStream inShadow = this.in; <BUGE> do { int thech = inShadow.read();  if (thech < 0) { throw new IOException("unexpected end of stream"); }  bsBuffShadow = (bsBuffShadow << 8) | thech; bsLiveShadow += 8; } while (bsLiveShadow < n);  this.bsBuff = bsBuffShadow; }  this.bsLive = bsLiveShadow - n; return (bsBuffShadow >> (bsLiveShadow - n)) & ((1 << n) - 1); }
private int bsR(final int n) throws IOException { int bsLiveShadow = this.bsLive; int bsBuffShadow = this.bsBuff;  if (bsLiveShadow < n) { final InputStream inShadow = this.in; do { <BUGS> int thech = inShadow.read(); <BUGE>  if (thech < 0) { throw new IOException("unexpected end of stream"); }  bsBuffShadow = (bsBuffShadow << 8) | thech; bsLiveShadow += 8; } while (bsLiveShadow < n);  this.bsBuff = bsBuffShadow; }  this.bsLive = bsLiveShadow - n; return (bsBuffShadow >> (bsLiveShadow - n)) & ((1 << n) - 1); }
private int bsR(final int n) throws IOException { int bsLiveShadow = this.bsLive; int bsBuffShadow = this.bsBuff;  if (bsLiveShadow < n) { final InputStream inShadow = this.in; do { int thech = inShadow.read();  <BUGS> if (thech < 0) { throw new IOException("unexpected end of stream"); <BUGE> }  bsBuffShadow = (bsBuffShadow << 8) | thech; bsLiveShadow += 8; } while (bsLiveShadow < n);  this.bsBuff = bsBuffShadow; }  this.bsLive = bsLiveShadow - n; return (bsBuffShadow >> (bsLiveShadow - n)) & ((1 << n) - 1); }
private int bsR(final int n) throws IOException { int bsLiveShadow = this.bsLive; int bsBuffShadow = this.bsBuff;  if (bsLiveShadow < n) { final InputStream inShadow = this.in; do { int thech = inShadow.read();  if (thech < 0) { throw new IOException("unexpected end of stream"); }  <BUGS> bsBuffShadow = (bsBuffShadow << 8) | thech; bsLiveShadow += 8; } while (bsLiveShadow < n); <BUGE>  this.bsBuff = bsBuffShadow; }  this.bsLive = bsLiveShadow - n; return (bsBuffShadow >> (bsLiveShadow - n)) & ((1 << n) - 1); }
private int bsR(final int n) throws IOException { int bsLiveShadow = this.bsLive; int bsBuffShadow = this.bsBuff;  if (bsLiveShadow < n) { final InputStream inShadow = this.in; do { int thech = inShadow.read();  if (thech < 0) { throw new IOException("unexpected end of stream"); }  bsBuffShadow = (bsBuffShadow << 8) | thech; bsLiveShadow += 8; } while (bsLiveShadow < n);  <BUGS> this.bsBuff = bsBuffShadow; <BUGE> }  this.bsLive = bsLiveShadow - n; return (bsBuffShadow >> (bsLiveShadow - n)) & ((1 << n) - 1); }
private int bsR(final int n) throws IOException { int bsLiveShadow = this.bsLive; int bsBuffShadow = this.bsBuff;  if (bsLiveShadow < n) { final InputStream inShadow = this.in; do { int thech = inShadow.read();  if (thech < 0) { throw new IOException("unexpected end of stream"); }  bsBuffShadow = (bsBuffShadow << 8) | thech; bsLiveShadow += 8; } while (bsLiveShadow < n);  this.bsBuff = bsBuffShadow; }  <BUGS> this.bsLive = bsLiveShadow - n; return (bsBuffShadow >> (bsLiveShadow - n)) & ((1 << n) - 1); <BUGE> }
*/ public SevenZFile(final File filename, final byte[] password) throws IOException { boolean succeeded = false; this.file = new RandomAccessFile(filename, "r"); try { archive = readHeaders(password); if (password != null) { this.password = new byte[password.length]; System.arraycopy(password, 0, this.password, 0, password.length); } else { this.password = null; } succeeded = true; } finally { if (!succeeded) { this.file.close(); } } }
*/ <BUGS> public SevenZFile(final File filename, final byte[] password) throws IOException { boolean succeeded = false; this.file = new RandomAccessFile(filename, "r"); <BUGE> try { archive = readHeaders(password); if (password != null) { this.password = new byte[password.length]; System.arraycopy(password, 0, this.password, 0, password.length); } else { this.password = null; } succeeded = true; } finally { if (!succeeded) { this.file.close(); } } }
*/ public SevenZFile(final File filename, final byte[] password) throws IOException { boolean succeeded = false; this.file = new RandomAccessFile(filename, "r"); try { <BUGS> archive = readHeaders(password); <BUGE> if (password != null) { this.password = new byte[password.length]; System.arraycopy(password, 0, this.password, 0, password.length); } else { this.password = null; } succeeded = true; } finally { if (!succeeded) { this.file.close(); } } }
*/ public SevenZFile(final File filename, final byte[] password) throws IOException { boolean succeeded = false; this.file = new RandomAccessFile(filename, "r"); try { archive = readHeaders(password); if (password != null) { this.password = new byte[password.length]; System.arraycopy(password, 0, this.password, 0, password.length); } else { this.password = null; } succeeded = true; } finally { <BUGS> if (!succeeded) { this.file.close(); <BUGE> } } }
*/ public static long parseOctal(final byte[] buffer, final int offset, final int length) { <BUGS> long    result = 0; int     end = offset + length; int     start = offset; <BUGE>  if (length < 2){ throw new IllegalArgumentException("Length "+length+" must be at least 2"); }  if (buffer[start] == 0) { return 0L; }  /* Skip leading spaces*/ while (start < end){ if (buffer[start] == ' '){ start++; } else { break; } }  /* Trim all trailing NULs and spaces.*/ /* The ustar and POSIX tar specs require a trailing NUL or*/ /* space but some implementations use the extra digit for big*/ /* sizes/uids/gids ...*/ byte trailer = buffer[end - 1]; if (trailer == 0 || trailer == ' '){ end--;
*/ public static long parseOctal(final byte[] buffer, final int offset, final int length) { long    result = 0; int     end = offset + length; int     start = offset;  <BUGS> if (length < 2){ <BUGE> throw new IllegalArgumentException("Length "+length+" must be at least 2"); }  if (buffer[start] == 0) { return 0L; }  /* Skip leading spaces*/ while (start < end){ if (buffer[start] == ' '){ start++; } else { break; } }  /* Trim all trailing NULs and spaces.*/ /* The ustar and POSIX tar specs require a trailing NUL or*/ /* space but some implementations use the extra digit for big*/ /* sizes/uids/gids ...*/ byte trailer = buffer[end - 1]; if (trailer == 0 || trailer == ' '){ end--;
*/ public static long parseOctal(final byte[] buffer, final int offset, final int length) { long    result = 0; int     end = offset + length; int     start = offset;  if (length < 2){ throw new IllegalArgumentException("Length "+length+" must be at least 2"); }  <BUGS> if (buffer[start] == 0) { <BUGE> return 0L; }  /* Skip leading spaces*/ while (start < end){ if (buffer[start] == ' '){ start++; } else { break; } }  /* Trim all trailing NULs and spaces.*/ /* The ustar and POSIX tar specs require a trailing NUL or*/ /* space but some implementations use the extra digit for big*/ /* sizes/uids/gids ...*/ byte trailer = buffer[end - 1]; if (trailer == 0 || trailer == ' '){ end--;
*/ public static long parseOctal(final byte[] buffer, final int offset, final int length) { long    result = 0; int     end = offset + length; int     start = offset;  if (length < 2){ throw new IllegalArgumentException("Length "+length+" must be at least 2"); }  if (buffer[start] == 0) { return 0L; }  /* Skip leading spaces*/ <BUGS> while (start < end){ if (buffer[start] == ' '){ <BUGE> start++; } else { break; } }  /* Trim all trailing NULs and spaces.*/ /* The ustar and POSIX tar specs require a trailing NUL or*/ /* space but some implementations use the extra digit for big*/ /* sizes/uids/gids ...*/ byte trailer = buffer[end - 1]; if (trailer == 0 || trailer == ' '){ end--;
*/ public static long parseOctal(final byte[] buffer, final int offset, final int length) { long    result = 0; int     end = offset + length; int     start = offset;  if (length < 2){ throw new IllegalArgumentException("Length "+length+" must be at least 2"); }  if (buffer[start] == 0) { return 0L; }  /* Skip leading spaces*/ while (start < end){ if (buffer[start] == ' '){ start++; } else { break; } }  /* Trim all trailing NULs and spaces.*/ /* The ustar and POSIX tar specs require a trailing NUL or*/ /* space but some implementations use the extra digit for big*/ /* sizes/uids/gids ...*/ <BUGS> byte trailer = buffer[end - 1]; if (trailer == 0 || trailer == ' '){ <BUGE> end--;
* * <p>The input buffer is allowed to contain all NULs, * in which case the method returns 0L * (this allows for missing fields).</p> * * <p>To work-around some tar implementations that insert a * leading NUL this method returns 0 if it detects a leading NUL * since Commons Compress 1.4.</p> * * @param buffer The buffer from which to parse. * @param offset The offset into the buffer from which to parse. * @param length The maximum number of bytes to parse - must be at least 2 bytes. * @return The long value of the octal string. * @throws IllegalArgumentException if the trailing space/NUL is missing or if a invalid byte is detected. } else { <BUGS> throw new IllegalArgumentException( <BUGE> exceptionMessage(buffer, offset, length, end-1, trailer)); } trailer = buffer[end - 1]; while (start < end - 1 && (trailer == 0 || trailer == ' ')) { end--; trailer = buffer[end - 1]; }  for ( ;start < end; start++) { final byte currentByte = buffer[start]; /* CheckStyle:MagicNumber OFF*/ if (currentByte < '0' || currentByte > '7'){ throw new IllegalArgumentException( exceptionMessage(buffer, offset, length, start, currentByte));
*/ private int readStored(byte[] buffer, int offset, int length) throws IOException {  <BUGS> if (current.hasDataDescriptor) { <BUGE> if (lastStoredEntry == null) { readStoredEntry(); } return lastStoredEntry.read(buffer, offset, length); }  long csize = current.entry.getSize(); if (current.bytesRead >= csize) { return -1; }  if (buf.position() >= buf.limit()) { buf.position(0); int l = in.read(buf.array()); if (l == -1) { return -1; } buf.limit(l);  count(buf.limit()); current.bytesReadFromStream += buf.limit(); }  int toRead = Math.min(buf.remaining(), length); if ((csize - current.bytesRead) < toRead) { /* if it is smaller than toRead then it fits into an int*/
*/ private int readStored(byte[] buffer, int offset, int length) throws IOException {  if (current.hasDataDescriptor) { if (lastStoredEntry == null) { readStoredEntry(); } return lastStoredEntry.read(buffer, offset, length); }  <BUGS> long csize = current.entry.getSize(); if (current.bytesRead >= csize) { return -1; <BUGE> }  if (buf.position() >= buf.limit()) { buf.position(0); int l = in.read(buf.array()); if (l == -1) { return -1; } buf.limit(l);  count(buf.limit()); current.bytesReadFromStream += buf.limit(); }  int toRead = Math.min(buf.remaining(), length); if ((csize - current.bytesRead) < toRead) { /* if it is smaller than toRead then it fits into an int*/
*/ private int readStored(byte[] buffer, int offset, int length) throws IOException {  if (current.hasDataDescriptor) { if (lastStoredEntry == null) { readStoredEntry(); } return lastStoredEntry.read(buffer, offset, length); }  long csize = current.entry.getSize(); if (current.bytesRead >= csize) { return -1; }  <BUGS> if (buf.position() >= buf.limit()) { <BUGE> buf.position(0); int l = in.read(buf.array()); if (l == -1) { return -1; } buf.limit(l);  count(buf.limit()); current.bytesReadFromStream += buf.limit(); }  int toRead = Math.min(buf.remaining(), length); if ((csize - current.bytesRead) < toRead) { /* if it is smaller than toRead then it fits into an int*/
*/ private int readStored(byte[] buffer, int offset, int length) throws IOException {  if (current.hasDataDescriptor) { if (lastStoredEntry == null) { readStoredEntry(); } return lastStoredEntry.read(buffer, offset, length); }  long csize = current.entry.getSize(); if (current.bytesRead >= csize) { return -1; }  if (buf.position() >= buf.limit()) { buf.position(0); int l = in.read(buf.array()); if (l == -1) { return -1; } buf.limit(l);  count(buf.limit()); current.bytesReadFromStream += buf.limit(); }  <BUGS> int toRead = Math.min(buf.remaining(), length); if ((csize - current.bytesRead) < toRead) { <BUGE> /* if it is smaller than toRead then it fits into an int*/
*/ private int readStored(byte[] buffer, int offset, int length) throws IOException {  if (current.hasDataDescriptor) { if (lastStoredEntry == null) { readStoredEntry(); } return lastStoredEntry.read(buffer, offset, length); }  long csize = current.entry.getSize(); if (current.bytesRead >= csize) { return -1; }  if (buf.position() >= buf.limit()) { buf.position(0); int l = in.read(buf.array()); if (l == -1) { return -1; } buf.limit(l);  count(buf.limit()); current.bytesReadFromStream += buf.limit(); }  int toRead = Math.min(buf.remaining(), length); if ((csize - current.bytesRead) < toRead) { /* if it is smaller than toRead then it fits into an int*/
throw new UnsupportedZipFeatureException(ZipMethod.getMethodByCode(current.entry.getMethod()), current.entry); }  if (read >= 0) { current.crc.update(buffer, offset, read); }  return read; }  /** * Implementation of read for STORED entries. } <BUGS> buf.get(buffer, offset, toRead); current.bytesRead += toRead; return toRead; <BUGE> }  /** * Implementation of read for DEFLATED entries. */ private int readDeflated(byte[] buffer, int offset, int length) throws IOException { int read = readFromInflater(buffer, offset, length); if (read <= 0) { if (inf.finished()) { return -1; } else if (inf.needsDictionary()) { throw new ZipException("This archive needs a preset dictionary" + " which is not supported by Commons"
*/ public static long skip(InputStream input, long numToSkip) throws IOException { <BUGS> long available = numToSkip; while (numToSkip > 0) { long skipped = input.skip(numToSkip); if (skipped == 0) { break; <BUGE> } numToSkip -= skipped; }  return available - numToSkip; }
*/ public static long skip(InputStream input, long numToSkip) throws IOException { long available = numToSkip; while (numToSkip > 0) { long skipped = input.skip(numToSkip); if (skipped == 0) { break; } <BUGS> numToSkip -= skipped; } <BUGE>  return available - numToSkip; }
*/ public static long skip(InputStream input, long numToSkip) throws IOException { long available = numToSkip; while (numToSkip > 0) { long skipped = input.skip(numToSkip); if (skipped == 0) { break; } numToSkip -= skipped; }  <BUGS> return available - numToSkip; <BUGE> }
*/ public static long parseOctal(final byte[] buffer, final int offset, final int length) { <BUGS> long    result = 0; int     end = offset + length; int     start = offset; <BUGE>  if (length < 2){ throw new IllegalArgumentException("Length "+length+" must be at least 2"); }  if (buffer[start] == 0) { return 0L; }  /* Skip leading spaces*/ while (start < end){ if (buffer[start] == ' '){ start++; } else { break; } }  /* Trim all trailing NULs and spaces.*/ /* The ustar and POSIX tar specs require a trailing NUL or*/ /* space but some implementations use the extra digit for big*/ /* sizes/uids/gids ...*/ byte trailer = buffer[end - 1]; while (start < end && (trailer == 0 || trailer == ' ')) { end--;
*/ public static long parseOctal(final byte[] buffer, final int offset, final int length) { long    result = 0; int     end = offset + length; int     start = offset;  <BUGS> if (length < 2){ <BUGE> throw new IllegalArgumentException("Length "+length+" must be at least 2"); }  if (buffer[start] == 0) { return 0L; }  /* Skip leading spaces*/ while (start < end){ if (buffer[start] == ' '){ start++; } else { break; } }  /* Trim all trailing NULs and spaces.*/ /* The ustar and POSIX tar specs require a trailing NUL or*/ /* space but some implementations use the extra digit for big*/ /* sizes/uids/gids ...*/ byte trailer = buffer[end - 1]; while (start < end && (trailer == 0 || trailer == ' ')) { end--;
*/ public static long parseOctal(final byte[] buffer, final int offset, final int length) { long    result = 0; int     end = offset + length; int     start = offset;  if (length < 2){ throw new IllegalArgumentException("Length "+length+" must be at least 2"); }  <BUGS> if (buffer[start] == 0) { return 0L; <BUGE> }  /* Skip leading spaces*/ while (start < end){ if (buffer[start] == ' '){ start++; } else { break; } }  /* Trim all trailing NULs and spaces.*/ /* The ustar and POSIX tar specs require a trailing NUL or*/ /* space but some implementations use the extra digit for big*/ /* sizes/uids/gids ...*/ byte trailer = buffer[end - 1]; while (start < end && (trailer == 0 || trailer == ' ')) { end--;
*/ public static long parseOctal(final byte[] buffer, final int offset, final int length) { long    result = 0; int     end = offset + length; int     start = offset;  if (length < 2){ throw new IllegalArgumentException("Length "+length+" must be at least 2"); }  if (buffer[start] == 0) { return 0L; }  /* Skip leading spaces*/ <BUGS> while (start < end){ if (buffer[start] == ' '){ start++; <BUGE> } else { break; } }  /* Trim all trailing NULs and spaces.*/ /* The ustar and POSIX tar specs require a trailing NUL or*/ /* space but some implementations use the extra digit for big*/ /* sizes/uids/gids ...*/ byte trailer = buffer[end - 1]; while (start < end && (trailer == 0 || trailer == ' ')) { end--;
*/ public static long parseOctal(final byte[] buffer, final int offset, final int length) { long    result = 0; int     end = offset + length; int     start = offset;  if (length < 2){ throw new IllegalArgumentException("Length "+length+" must be at least 2"); }  if (buffer[start] == 0) { return 0L; }  /* Skip leading spaces*/ while (start < end){ if (buffer[start] == ' '){ start++; } else { break; } }  /* Trim all trailing NULs and spaces.*/ /* The ustar and POSIX tar specs require a trailing NUL or*/ /* space but some implementations use the extra digit for big*/ /* sizes/uids/gids ...*/ <BUGS> byte trailer = buffer[end - 1]; while (start < end && (trailer == 0 || trailer == ' ')) { end--;
* * <p>The input buffer is allowed to contain all NULs, * in which case the method returns 0L * (this allows for missing fields).</p> * * <p>To work-around some tar implementations that insert a * leading NUL this method returns 0 if it detects a leading NUL * since Commons Compress 1.4.</p> * * @param buffer The buffer from which to parse. * @param offset The offset into the buffer from which to parse. * @param length The maximum number of bytes to parse - must be at least 2 bytes. * @return The long value of the octal string. * @throws IllegalArgumentException if the trailing space/NUL is missing or if a invalid byte is detected. } <BUGS> if (start == end) { throw new IllegalArgumentException( <BUGE> exceptionMessage(buffer, offset, length, start, trailer)); }  for ( ;start < end; start++) { final byte currentByte = buffer[start]; /* CheckStyle:MagicNumber OFF*/ if (currentByte < '0' || currentByte > '7'){ throw new IllegalArgumentException( exceptionMessage(buffer, offset, length, start, currentByte)); } result = (result << 3) + (currentByte - '0'); /* convert from ASCII*/ /* CheckStyle:MagicNumber ON*/ }
* * <p>The input buffer is allowed to contain all NULs, * in which case the method returns 0L * (this allows for missing fields).</p> * * <p>To work-around some tar implementations that insert a * leading NUL this method returns 0 if it detects a leading NUL * since Commons Compress 1.4.</p> * * @param buffer The buffer from which to parse. * @param offset The offset into the buffer from which to parse. * @param length The maximum number of bytes to parse - must be at least 2 bytes. * @return The long value of the octal string. * @throws IllegalArgumentException if the trailing space/NUL is missing or if a invalid byte is detected.  <BUGS> for ( ;start < end; start++) { final byte currentByte = buffer[start]; <BUGE> /* CheckStyle:MagicNumber OFF*/ if (currentByte < '0' || currentByte > '7'){ throw new IllegalArgumentException( exceptionMessage(buffer, offset, length, start, currentByte)); } result = (result << 3) + (currentByte - '0'); /* convert from ASCII*/ /* CheckStyle:MagicNumber ON*/ }  return result; }  /**
* * <p>The input buffer is allowed to contain all NULs, * in which case the method returns 0L * (this allows for missing fields).</p> * * <p>To work-around some tar implementations that insert a * leading NUL this method returns 0 if it detects a leading NUL * since Commons Compress 1.4.</p> * * @param buffer The buffer from which to parse. * @param offset The offset into the buffer from which to parse. * @param length The maximum number of bytes to parse - must be at least 2 bytes. * @return The long value of the octal string. * @throws IllegalArgumentException if the trailing space/NUL is missing or if a invalid byte is detected. /* CheckStyle:MagicNumber OFF*/ <BUGS> if (currentByte < '0' || currentByte > '7'){ <BUGE> throw new IllegalArgumentException( exceptionMessage(buffer, offset, length, start, currentByte)); } result = (result << 3) + (currentByte - '0'); /* convert from ASCII*/ /* CheckStyle:MagicNumber ON*/ }  return result; }  /** * Compute the value contained in a byte buffer.  If the most * significant bit of the first byte in the buffer is set, this * bit is ignored and the rest of the buffer is interpreted as a
* * <p>The input buffer is allowed to contain all NULs, * in which case the method returns 0L * (this allows for missing fields).</p> * * <p>To work-around some tar implementations that insert a * leading NUL this method returns 0 if it detects a leading NUL * since Commons Compress 1.4.</p> * * @param buffer The buffer from which to parse. * @param offset The offset into the buffer from which to parse. * @param length The maximum number of bytes to parse - must be at least 2 bytes. * @return The long value of the octal string. * @throws IllegalArgumentException if the trailing space/NUL is missing or if a invalid byte is detected. } <BUGS> result = (result << 3) + (currentByte - '0'); /* convert from ASCII <BUGE>*/ /* CheckStyle:MagicNumber ON*/ }  return result; }  /** * Compute the value contained in a byte buffer.  If the most * significant bit of the first byte in the buffer is set, this * bit is ignored and the rest of the buffer is interpreted as a * binary number.  Otherwise, the buffer is interpreted as an * octal number as per the parseOctal function above. * * @param buffer The buffer from which to parse.
* * <p>The input buffer is allowed to contain all NULs, * in which case the method returns 0L * (this allows for missing fields).</p> * * <p>To work-around some tar implementations that insert a * leading NUL this method returns 0 if it detects a leading NUL * since Commons Compress 1.4.</p> * * @param buffer The buffer from which to parse. * @param offset The offset into the buffer from which to parse. * @param length The maximum number of bytes to parse - must be at least 2 bytes. * @return The long value of the octal string. * @throws IllegalArgumentException if the trailing space/NUL is missing or if a invalid byte is detected.  <BUGS> return result; <BUGE> }  /** * Compute the value contained in a byte buffer.  If the most * significant bit of the first byte in the buffer is set, this * bit is ignored and the rest of the buffer is interpreted as a * binary number.  Otherwise, the buffer is interpreted as an * octal number as per the parseOctal function above. * * @param buffer The buffer from which to parse. * @param offset The offset into the buffer from which to parse. * @param length The maximum number of bytes to parse. * @return The long value of the octal or binary string. * @throws IllegalArgumentException if the trailing space/NUL is
*/ public TarArchiveEntry getNextTarEntry() throws IOException { <BUGS> if (hasHitEOF) { return null; <BUGE> }  if (currEntry != null) { /* Skip will only go to the end of the current entry */ skip(Long.MAX_VALUE);  /* skip to the end of the last record */ skipRecordPadding(); }  byte[] headerBuf = getRecord();  if (headerBuf == null) { /* hit EOF */ currEntry = null; return null; }  try { currEntry = new TarArchiveEntry(headerBuf, encoding); } catch (IllegalArgumentException e) { IOException ioe = new IOException("Error detected parsing the header"); ioe.initCause(e); throw ioe; }
*/ public TarArchiveEntry getNextTarEntry() throws IOException { if (hasHitEOF) { return null; }  <BUGS> if (currEntry != null) { <BUGE> /* Skip will only go to the end of the current entry */ skip(Long.MAX_VALUE);  /* skip to the end of the last record */ skipRecordPadding(); }  byte[] headerBuf = getRecord();  if (headerBuf == null) { /* hit EOF */ currEntry = null; return null; }  try { currEntry = new TarArchiveEntry(headerBuf, encoding); } catch (IllegalArgumentException e) { IOException ioe = new IOException("Error detected parsing the header"); ioe.initCause(e); throw ioe; }
*/ public TarArchiveEntry getNextTarEntry() throws IOException { if (hasHitEOF) { return null; }  if (currEntry != null) { /* Skip will only go to the end of the current entry */ <BUGS> skip(Long.MAX_VALUE); <BUGE>  /* skip to the end of the last record */ skipRecordPadding(); }  byte[] headerBuf = getRecord();  if (headerBuf == null) { /* hit EOF */ currEntry = null; return null; }  try { currEntry = new TarArchiveEntry(headerBuf, encoding); } catch (IllegalArgumentException e) { IOException ioe = new IOException("Error detected parsing the header"); ioe.initCause(e); throw ioe; }
*/ public TarArchiveEntry getNextTarEntry() throws IOException { if (hasHitEOF) { return null; }  if (currEntry != null) { /* Skip will only go to the end of the current entry */ skip(Long.MAX_VALUE);  /* skip to the end of the last record */ <BUGS> skipRecordPadding(); <BUGE> }  byte[] headerBuf = getRecord();  if (headerBuf == null) { /* hit EOF */ currEntry = null; return null; }  try { currEntry = new TarArchiveEntry(headerBuf, encoding); } catch (IllegalArgumentException e) { IOException ioe = new IOException("Error detected parsing the header"); ioe.initCause(e); throw ioe; }
*/ public TarArchiveEntry getNextTarEntry() throws IOException { if (hasHitEOF) { return null; }  if (currEntry != null) { /* Skip will only go to the end of the current entry */ skip(Long.MAX_VALUE);  /* skip to the end of the last record */ skipRecordPadding(); }  <BUGS> byte[] headerBuf = getRecord(); <BUGE>  if (headerBuf == null) { /* hit EOF */ currEntry = null; return null; }  try { currEntry = new TarArchiveEntry(headerBuf, encoding); } catch (IllegalArgumentException e) { IOException ioe = new IOException("Error detected parsing the header"); ioe.initCause(e); throw ioe; }
*/ public TarArchiveEntry getNextTarEntry() throws IOException { if (hasHitEOF) { return null; }  if (currEntry != null) { /* Skip will only go to the end of the current entry */ skip(Long.MAX_VALUE);  /* skip to the end of the last record */ skipRecordPadding(); }  byte[] headerBuf = getRecord();  <BUGS> if (headerBuf == null) { <BUGE> /* hit EOF */ currEntry = null; return null; }  try { currEntry = new TarArchiveEntry(headerBuf, encoding); } catch (IllegalArgumentException e) { IOException ioe = new IOException("Error detected parsing the header"); ioe.initCause(e); throw ioe; }
*/ public TarArchiveEntry getNextTarEntry() throws IOException { if (hasHitEOF) { return null; }  if (currEntry != null) { /* Skip will only go to the end of the current entry */ skip(Long.MAX_VALUE);  /* skip to the end of the last record */ skipRecordPadding(); }  byte[] headerBuf = getRecord();  if (headerBuf == null) { /* hit EOF */ currEntry = null; return null; }  try { <BUGS> currEntry = new TarArchiveEntry(headerBuf, encoding); <BUGE> } catch (IllegalArgumentException e) { IOException ioe = new IOException("Error detected parsing the header"); ioe.initCause(e); throw ioe; }
*/ public TarArchiveEntry getNextTarEntry() throws IOException { if (hasHitEOF) { return null; }  if (currEntry != null) { /* Skip will only go to the end of the current entry */ skip(Long.MAX_VALUE);  /* skip to the end of the last record */ skipRecordPadding(); }  byte[] headerBuf = getRecord();  if (headerBuf == null) { /* hit EOF */ currEntry = null; return null; }  try { currEntry = new TarArchiveEntry(headerBuf, encoding); } catch (IllegalArgumentException e) { IOException ioe = new IOException("Error detected parsing the header"); ioe.initCause(e); throw ioe; <BUGS> } <BUGE>
}  /** * Get the next entry in this tar archive. This will skip * over any remaining data in the current entry, if there * is one, and place the input stream at the header of the * next entry, and read the header and instantiate a new * TarEntry from the header bytes and return that entry. * If there are no more entries in the archive, null will * be returned to indicate that the end of the archive has * been reached. * * @return The next TarEntry in the archive, or null. * @throws IOException on error  <BUGS> entryOffset = 0; entrySize = currEntry.getSize(); <BUGE>  if (currEntry.isGNULongLinkEntry()) { byte[] longLinkData = getLongNameData(); if (longLinkData == null) { /* Bugzilla: 40334*/ /* Malformed tar file - long link entry name not followed by*/ /* entry*/ return null; } currEntry.setLinkName(encoding.decode(longLinkData)); }  if (currEntry.isGNULongNameEntry()) {
}  /** * Get the next entry in this tar archive. This will skip * over any remaining data in the current entry, if there * is one, and place the input stream at the header of the * next entry, and read the header and instantiate a new * TarEntry from the header bytes and return that entry. * If there are no more entries in the archive, null will * be returned to indicate that the end of the archive has * been reached. * * @return The next TarEntry in the archive, or null. * @throws IOException on error  <BUGS> if (currEntry.isGNULongLinkEntry()) { <BUGE> byte[] longLinkData = getLongNameData(); if (longLinkData == null) { /* Bugzilla: 40334*/ /* Malformed tar file - long link entry name not followed by*/ /* entry*/ return null; } currEntry.setLinkName(encoding.decode(longLinkData)); }  if (currEntry.isGNULongNameEntry()) { byte[] longNameData = getLongNameData(); if (longNameData == null) { /* Bugzilla: 40334*/
}  /** * Get the next entry in this tar archive. This will skip * over any remaining data in the current entry, if there * is one, and place the input stream at the header of the * next entry, and read the header and instantiate a new * TarEntry from the header bytes and return that entry. * If there are no more entries in the archive, null will * be returned to indicate that the end of the archive has * been reached. * * @return The next TarEntry in the archive, or null. * @throws IOException on error  <BUGS> if (currEntry.isGNULongNameEntry()) { <BUGE> byte[] longNameData = getLongNameData(); if (longNameData == null) { /* Bugzilla: 40334*/ /* Malformed tar file - long entry name not followed by*/ /* entry*/ return null; } currEntry.setName(encoding.decode(longNameData)); }  if (currEntry.isPaxHeader()){ /* Process Pax headers*/ paxHeaders(); }
}  /** * Get the next entry in this tar archive. This will skip * over any remaining data in the current entry, if there * is one, and place the input stream at the header of the * next entry, and read the header and instantiate a new * TarEntry from the header bytes and return that entry. * If there are no more entries in the archive, null will * be returned to indicate that the end of the archive has * been reached. * * @return The next TarEntry in the archive, or null. * @throws IOException on error  <BUGS> if (currEntry.isPaxHeader()){ /* Process Pax headers <BUGE>*/ paxHeaders(); }  if (currEntry.isGNUSparse()){ /* Process sparse files*/ readGNUSparse(); }  /* If the size of the next element in the archive has changed*/ /* due to a new size being reported in the posix header*/ /* information, we update entrySize here so that it contains*/ /* the correct value.*/ entrySize = currEntry.getSize();  return currEntry;
}  /** * Get the next entry in this tar archive. This will skip * over any remaining data in the current entry, if there * is one, and place the input stream at the header of the * next entry, and read the header and instantiate a new * TarEntry from the header bytes and return that entry. * If there are no more entries in the archive, null will * be returned to indicate that the end of the archive has * been reached. * * @return The next TarEntry in the archive, or null. * @throws IOException on error  <BUGS> if (currEntry.isGNUSparse()){ /* Process sparse files <BUGE>*/ readGNUSparse(); }  /* If the size of the next element in the archive has changed*/ /* due to a new size being reported in the posix header*/ /* information, we update entrySize here so that it contains*/ /* the correct value.*/ entrySize = currEntry.getSize();  return currEntry; }  /** * The last record block should be written at the full size, so skip any
}  /** * Get the next entry in this tar archive. This will skip * over any remaining data in the current entry, if there * is one, and place the input stream at the header of the * next entry, and read the header and instantiate a new * TarEntry from the header bytes and return that entry. * If there are no more entries in the archive, null will * be returned to indicate that the end of the archive has * been reached. * * @return The next TarEntry in the archive, or null. * @throws IOException on error /* the correct value.*/ <BUGS> entrySize = currEntry.getSize(); <BUGE>  return currEntry; }  /** * The last record block should be written at the full size, so skip any * additional space used to fill a record after an entry */ private void skipRecordPadding() throws IOException { if (this.entrySize > 0 && this.entrySize % this.recordSize != 0) { long numRecords = (this.entrySize / this.recordSize) + 1; long padding = (numRecords * this.recordSize) - this.entrySize; long skipped = IOUtils.skip(is, padding); count(skipped);
}  /** * Get the next entry in this tar archive. This will skip * over any remaining data in the current entry, if there * is one, and place the input stream at the header of the * next entry, and read the header and instantiate a new * TarEntry from the header bytes and return that entry. * If there are no more entries in the archive, null will * be returned to indicate that the end of the archive has * been reached. * * @return The next TarEntry in the archive, or null. * @throws IOException on error  <BUGS> return currEntry; <BUGE> }  /** * The last record block should be written at the full size, so skip any * additional space used to fill a record after an entry */ private void skipRecordPadding() throws IOException { if (this.entrySize > 0 && this.entrySize % this.recordSize != 0) { long numRecords = (this.entrySize / this.recordSize) + 1; long padding = (numRecords * this.recordSize) - this.entrySize; long skipped = IOUtils.skip(is, padding); count(skipped); } }
*/ public CpioArchiveInputStream(final InputStream in, String encoding) { <BUGS> this(in, BLOCK_SIZE, encoding); } <BUGE>
*/ private void writeRun() throws IOException { <BUGS> final int lastShadow = this.last; <BUGE>  if (lastShadow < this.allowableBlockSize) { final int currentCharShadow = this.currentChar; final Data dataShadow = this.data; dataShadow.inUse[currentCharShadow] = true; final byte ch = (byte) currentCharShadow;  int runLengthShadow = this.runLength; this.crc.updateCRC(currentCharShadow, runLengthShadow);  switch (runLengthShadow) { case 1: dataShadow.block[lastShadow + 2] = ch; this.last = lastShadow + 1; break;  case 2: dataShadow.block[lastShadow + 2] = ch; dataShadow.block[lastShadow + 3] = ch; this.last = lastShadow + 2; break;  case 3: { final byte[] block = dataShadow.block; block[lastShadow + 2] = ch; block[lastShadow + 3] = ch; block[lastShadow + 4] = ch;
*/ private void writeRun() throws IOException { final int lastShadow = this.last;  <BUGS> if (lastShadow < this.allowableBlockSize) { final int currentCharShadow = this.currentChar; final Data dataShadow = this.data; dataShadow.inUse[currentCharShadow] = true; final byte ch = (byte) currentCharShadow; <BUGE>  int runLengthShadow = this.runLength; this.crc.updateCRC(currentCharShadow, runLengthShadow);  switch (runLengthShadow) { case 1: dataShadow.block[lastShadow + 2] = ch; this.last = lastShadow + 1; break;  case 2: dataShadow.block[lastShadow + 2] = ch; dataShadow.block[lastShadow + 3] = ch; this.last = lastShadow + 2; break;  case 3: { final byte[] block = dataShadow.block; block[lastShadow + 2] = ch; block[lastShadow + 3] = ch; block[lastShadow + 4] = ch;
*/ private void writeRun() throws IOException { final int lastShadow = this.last;  if (lastShadow < this.allowableBlockSize) { final int currentCharShadow = this.currentChar; final Data dataShadow = this.data; dataShadow.inUse[currentCharShadow] = true; final byte ch = (byte) currentCharShadow;  <BUGS> int runLengthShadow = this.runLength; this.crc.updateCRC(currentCharShadow, runLengthShadow); <BUGE>  switch (runLengthShadow) { case 1: dataShadow.block[lastShadow + 2] = ch; this.last = lastShadow + 1; break;  case 2: dataShadow.block[lastShadow + 2] = ch; dataShadow.block[lastShadow + 3] = ch; this.last = lastShadow + 2; break;  case 3: { final byte[] block = dataShadow.block; block[lastShadow + 2] = ch; block[lastShadow + 3] = ch; block[lastShadow + 4] = ch;
*/ private void writeRun() throws IOException { final int lastShadow = this.last;  if (lastShadow < this.allowableBlockSize) { final int currentCharShadow = this.currentChar; final Data dataShadow = this.data; dataShadow.inUse[currentCharShadow] = true; final byte ch = (byte) currentCharShadow;  int runLengthShadow = this.runLength; this.crc.updateCRC(currentCharShadow, runLengthShadow);  <BUGS> switch (runLengthShadow) { <BUGE> case 1: dataShadow.block[lastShadow + 2] = ch; this.last = lastShadow + 1; break;  case 2: dataShadow.block[lastShadow + 2] = ch; dataShadow.block[lastShadow + 3] = ch; this.last = lastShadow + 2; break;  case 3: { final byte[] block = dataShadow.block; block[lastShadow + 2] = ch; block[lastShadow + 3] = ch; block[lastShadow + 4] = ch;
*/ private void writeRun() throws IOException { final int lastShadow = this.last;  if (lastShadow < this.allowableBlockSize) { final int currentCharShadow = this.currentChar; final Data dataShadow = this.data; dataShadow.inUse[currentCharShadow] = true; final byte ch = (byte) currentCharShadow;  int runLengthShadow = this.runLength; this.crc.updateCRC(currentCharShadow, runLengthShadow);  switch (runLengthShadow) { case 1: <BUGS> dataShadow.block[lastShadow + 2] = ch; this.last = lastShadow + 1; break; <BUGE>  case 2: dataShadow.block[lastShadow + 2] = ch; dataShadow.block[lastShadow + 3] = ch; this.last = lastShadow + 2; break;  case 3: { final byte[] block = dataShadow.block; block[lastShadow + 2] = ch; block[lastShadow + 3] = ch; block[lastShadow + 4] = ch;
*/ private void writeRun() throws IOException { final int lastShadow = this.last;  if (lastShadow < this.allowableBlockSize) { final int currentCharShadow = this.currentChar; final Data dataShadow = this.data; dataShadow.inUse[currentCharShadow] = true; final byte ch = (byte) currentCharShadow;  int runLengthShadow = this.runLength; this.crc.updateCRC(currentCharShadow, runLengthShadow);  switch (runLengthShadow) { case 1: dataShadow.block[lastShadow + 2] = ch; this.last = lastShadow + 1; break;  case 2: <BUGS> dataShadow.block[lastShadow + 2] = ch; dataShadow.block[lastShadow + 3] = ch; this.last = lastShadow + 2; break; <BUGE>  case 3: { final byte[] block = dataShadow.block; block[lastShadow + 2] = ch; block[lastShadow + 3] = ch; block[lastShadow + 4] = ch;
*/ private void writeRun() throws IOException { final int lastShadow = this.last;  if (lastShadow < this.allowableBlockSize) { final int currentCharShadow = this.currentChar; final Data dataShadow = this.data; dataShadow.inUse[currentCharShadow] = true; final byte ch = (byte) currentCharShadow;  int runLengthShadow = this.runLength; this.crc.updateCRC(currentCharShadow, runLengthShadow);  switch (runLengthShadow) { case 1: dataShadow.block[lastShadow + 2] = ch; this.last = lastShadow + 1; break;  case 2: dataShadow.block[lastShadow + 2] = ch; dataShadow.block[lastShadow + 3] = ch; this.last = lastShadow + 2; break;  case 3: { <BUGS> final byte[] block = dataShadow.block; block[lastShadow + 2] = ch; block[lastShadow + 3] = ch; block[lastShadow + 4] = ch;
}  /** * Writes the current byte to the buffer, run-length encoding it * if it has been repeated at least four times (the first step * RLEs sequences of four identical bytes). * * <p>Flushes the current block before writing data if it is * full.</p> * * <p>"write to the buffer" means adding to data.buffer starting * two steps "after" this.last - initially starting at index 1 * (not 0) - and updating this.last to point to the last index * written minus 1.</p> } <BUGS> break; <BUGE>  default: { runLengthShadow -= 4; dataShadow.inUse[runLengthShadow] = true; final byte[] block = dataShadow.block; block[lastShadow + 2] = ch; block[lastShadow + 3] = ch; block[lastShadow + 4] = ch; block[lastShadow + 5] = ch; block[lastShadow + 6] = (byte) runLengthShadow; this.last = lastShadow + 5; } break;
/** * Writes the current byte to the buffer, run-length encoding it * if it has been repeated at least four times (the first step * RLEs sequences of four identical bytes). * * <p>Flushes the current block before writing data if it is * full.</p> * * <p>"write to the buffer" means adding to data.buffer starting * two steps "after" this.last - initially starting at index 1 * (not 0) - and updating this.last to point to the last index * written minus 1.</p> } <BUGS> } else { endBlock(); initBlock(); writeRun(); <BUGE> } }  /** * Overriden to close the stream. */ @Override protected void finalize() throws Throwable { finish(); super.finalize(); }
}  /** * Writes the current byte to the buffer, run-length encoding it * if it has been repeated at least four times (the first step * RLEs sequences of four identical bytes). * * <p>Flushes the current block before writing data if it is * full.</p> * * <p>"write to the buffer" means adding to data.buffer starting * two steps "after" this.last - initially starting at index 1 * (not 0) - and updating this.last to point to the last index * written minus 1.</p> } <BUGS> } <BUGE>  /** * Overriden to close the stream. */ @Override protected void finalize() throws Throwable { finish(); super.finalize(); }   public void finish() throws IOException { if (out != null) { try {
*/ public static long parseOctal(final byte[] buffer, final int offset, final int length) { <BUGS> long    result = 0; int     end = offset + length; int     start = offset; <BUGE>  if (length < 2){ throw new IllegalArgumentException("Length "+length+" must be at least 2"); }  if (buffer[start] == 0) { return 0L; }  /* Skip leading spaces*/ while (start < end){ if (buffer[start] == ' '){ start++; } else { break; } }  /* Trim all trailing NULs and spaces.*/ /* The ustar and POSIX tar specs require a trailing NUL or*/ /* space but some implementations use the extra digit for big*/ /* sizes/uids/gids ...*/ byte trailer = buffer[end - 1]; while (start < end && (trailer == 0 || trailer == ' ')) { end--;
*/ public static long parseOctal(final byte[] buffer, final int offset, final int length) { long    result = 0; int     end = offset + length; int     start = offset;  <BUGS> if (length < 2){ throw new IllegalArgumentException("Length "+length+" must be at least 2"); <BUGE> }  if (buffer[start] == 0) { return 0L; }  /* Skip leading spaces*/ while (start < end){ if (buffer[start] == ' '){ start++; } else { break; } }  /* Trim all trailing NULs and spaces.*/ /* The ustar and POSIX tar specs require a trailing NUL or*/ /* space but some implementations use the extra digit for big*/ /* sizes/uids/gids ...*/ byte trailer = buffer[end - 1]; while (start < end && (trailer == 0 || trailer == ' ')) { end--;
*/ public static long parseOctal(final byte[] buffer, final int offset, final int length) { long    result = 0; int     end = offset + length; int     start = offset;  if (length < 2){ throw new IllegalArgumentException("Length "+length+" must be at least 2"); }  <BUGS> if (buffer[start] == 0) { return 0L; <BUGE> }  /* Skip leading spaces*/ while (start < end){ if (buffer[start] == ' '){ start++; } else { break; } }  /* Trim all trailing NULs and spaces.*/ /* The ustar and POSIX tar specs require a trailing NUL or*/ /* space but some implementations use the extra digit for big*/ /* sizes/uids/gids ...*/ byte trailer = buffer[end - 1]; while (start < end && (trailer == 0 || trailer == ' ')) { end--;
*/ public static long parseOctal(final byte[] buffer, final int offset, final int length) { long    result = 0; int     end = offset + length; int     start = offset;  if (length < 2){ throw new IllegalArgumentException("Length "+length+" must be at least 2"); }  if (buffer[start] == 0) { return 0L; }  /* Skip leading spaces*/ <BUGS> while (start < end){ if (buffer[start] == ' '){ start++; <BUGE> } else { break; } }  /* Trim all trailing NULs and spaces.*/ /* The ustar and POSIX tar specs require a trailing NUL or*/ /* space but some implementations use the extra digit for big*/ /* sizes/uids/gids ...*/ byte trailer = buffer[end - 1]; while (start < end && (trailer == 0 || trailer == ' ')) { end--;
*/ public static long parseOctal(final byte[] buffer, final int offset, final int length) { long    result = 0; int     end = offset + length; int     start = offset;  if (length < 2){ throw new IllegalArgumentException("Length "+length+" must be at least 2"); }  if (buffer[start] == 0) { return 0L; }  /* Skip leading spaces*/ while (start < end){ if (buffer[start] == ' '){ start++; } else { break; } }  /* Trim all trailing NULs and spaces.*/ /* The ustar and POSIX tar specs require a trailing NUL or*/ /* space but some implementations use the extra digit for big*/ /* sizes/uids/gids ...*/ <BUGS> byte trailer = buffer[end - 1]; while (start < end && (trailer == 0 || trailer == ' ')) { end--;
* <p>The input buffer is allowed to contain all NULs, * in which case the method returns 0L * (this allows for missing fields).</p> * * <p>To work-around some tar implementations that insert a * leading NUL this method returns 0 if it detects a leading NUL * since Commons Compress 1.4.</p> * * @param buffer The buffer from which to parse. * @param offset The offset into the buffer from which to parse. * @param length The maximum number of bytes to parse - must be at least 2 bytes. * @return The long value of the octal string. * @throws IllegalArgumentException if the trailing space/NUL is missing or if a invalid byte is detected.  <BUGS> for ( ;start < end; start++) { final byte currentByte = buffer[start]; if (currentByte == 0) { break; <BUGE> } /* CheckStyle:MagicNumber OFF*/ if (currentByte < '0' || currentByte > '7'){ throw new IllegalArgumentException( exceptionMessage(buffer, offset, length, start, currentByte)); } result = (result << 3) + (currentByte - '0'); /* convert from ASCII*/ /* CheckStyle:MagicNumber ON*/ }  return result; }
* * <p>The input buffer is allowed to contain all NULs, * in which case the method returns 0L * (this allows for missing fields).</p> * * <p>To work-around some tar implementations that insert a * leading NUL this method returns 0 if it detects a leading NUL * since Commons Compress 1.4.</p> * * @param buffer The buffer from which to parse. * @param offset The offset into the buffer from which to parse. * @param length The maximum number of bytes to parse - must be at least 2 bytes. * @return The long value of the octal string. * @throws IllegalArgumentException if the trailing space/NUL is missing or if a invalid byte is detected. /* CheckStyle:MagicNumber OFF*/ <BUGS> if (currentByte < '0' || currentByte > '7'){ throw new IllegalArgumentException( <BUGE> exceptionMessage(buffer, offset, length, start, currentByte)); } result = (result << 3) + (currentByte - '0'); /* convert from ASCII*/ /* CheckStyle:MagicNumber ON*/ }  return result; }  /** * Compute the value contained in a byte buffer.  If the most * significant bit of the first byte in the buffer is set, this * bit is ignored and the rest of the buffer is interpreted as a
* * <p>The input buffer is allowed to contain all NULs, * in which case the method returns 0L * (this allows for missing fields).</p> * * <p>To work-around some tar implementations that insert a * leading NUL this method returns 0 if it detects a leading NUL * since Commons Compress 1.4.</p> * * @param buffer The buffer from which to parse. * @param offset The offset into the buffer from which to parse. * @param length The maximum number of bytes to parse - must be at least 2 bytes. * @return The long value of the octal string. * @throws IllegalArgumentException if the trailing space/NUL is missing or if a invalid byte is detected. } <BUGS> result = (result << 3) + (currentByte - '0'); /* convert from ASCII <BUGE>*/ /* CheckStyle:MagicNumber ON*/ }  return result; }  /** * Compute the value contained in a byte buffer.  If the most * significant bit of the first byte in the buffer is set, this * bit is ignored and the rest of the buffer is interpreted as a * binary number.  Otherwise, the buffer is interpreted as an * octal number as per the parseOctal function above. * * @param buffer The buffer from which to parse.
* * <p>The input buffer is allowed to contain all NULs, * in which case the method returns 0L * (this allows for missing fields).</p> * * <p>To work-around some tar implementations that insert a * leading NUL this method returns 0 if it detects a leading NUL * since Commons Compress 1.4.</p> * * @param buffer The buffer from which to parse. * @param offset The offset into the buffer from which to parse. * @param length The maximum number of bytes to parse - must be at least 2 bytes. * @return The long value of the octal string. * @throws IllegalArgumentException if the trailing space/NUL is missing or if a invalid byte is detected.  <BUGS> return result; <BUGE> }  /** * Compute the value contained in a byte buffer.  If the most * significant bit of the first byte in the buffer is set, this * bit is ignored and the rest of the buffer is interpreted as a * binary number.  Otherwise, the buffer is interpreted as an * octal number as per the parseOctal function above. * * @param buffer The buffer from which to parse. * @param offset The offset into the buffer from which to parse. * @param length The maximum number of bytes to parse. * @return The long value of the octal or binary string. * @throws IllegalArgumentException if the trailing space/NUL is
private void applyPaxHeadersToCurrentEntry(Map<String, String> headers) { /* * The following headers are defined for Pax. * atime, ctime, charset: cannot use these without changing TarArchiveEntry fields * mtime * comment * gid, gname * linkpath * size * uid,uname * SCHILY.devminor, SCHILY.devmajor: don't have setters/getters for those */ <BUGS> for (Entry<String, String> ent : headers.entrySet()){ String key = ent.getKey(); String val = ent.getValue(); if ("path".equals(key)){ <BUGE> currEntry.setName(val); } else if ("linkpath".equals(key)){ currEntry.setLinkName(val); } else if ("gid".equals(key)){ currEntry.setGroupId(Integer.parseInt(val)); } else if ("gname".equals(key)){ currEntry.setGroupName(val); } else if ("uid".equals(key)){ currEntry.setUserId(Integer.parseInt(val)); } else if ("uname".equals(key)){ currEntry.setUserName(val); } else if ("size".equals(key)){ currEntry.setSize(Long.parseLong(val));
private void applyPaxHeadersToCurrentEntry(Map<String, String> headers) { /* * The following headers are defined for Pax. * atime, ctime, charset: cannot use these without changing TarArchiveEntry fields * mtime * comment * gid, gname * linkpath * size * uid,uname * SCHILY.devminor, SCHILY.devmajor: don't have setters/getters for those */ for (Entry<String, String> ent : headers.entrySet()){ String key = ent.getKey(); String val = ent.getValue(); if ("path".equals(key)){ currEntry.setName(val); <BUGS> } else if ("linkpath".equals(key)){ <BUGE> currEntry.setLinkName(val); } else if ("gid".equals(key)){ currEntry.setGroupId(Integer.parseInt(val)); } else if ("gname".equals(key)){ currEntry.setGroupName(val); } else if ("uid".equals(key)){ currEntry.setUserId(Integer.parseInt(val)); } else if ("uname".equals(key)){ currEntry.setUserName(val); } else if ("size".equals(key)){ currEntry.setSize(Long.parseLong(val));
private void applyPaxHeadersToCurrentEntry(Map<String, String> headers) { /* * The following headers are defined for Pax. * atime, ctime, charset: cannot use these without changing TarArchiveEntry fields * mtime * comment * gid, gname * linkpath * size * uid,uname * SCHILY.devminor, SCHILY.devmajor: don't have setters/getters for those */ for (Entry<String, String> ent : headers.entrySet()){ String key = ent.getKey(); String val = ent.getValue(); if ("path".equals(key)){ currEntry.setName(val); } else if ("linkpath".equals(key)){ currEntry.setLinkName(val); <BUGS> } else if ("gid".equals(key)){ currEntry.setGroupId(Integer.parseInt(val)); <BUGE> } else if ("gname".equals(key)){ currEntry.setGroupName(val); } else if ("uid".equals(key)){ currEntry.setUserId(Integer.parseInt(val)); } else if ("uname".equals(key)){ currEntry.setUserName(val); } else if ("size".equals(key)){ currEntry.setSize(Long.parseLong(val));
*/ public void setGID(long l) { <BUGS> this.gid = ZipUtil.longToBig(l); } <BUGE>
*/ public ArchiveInputStream createArchiveInputStream(final InputStream in) throws ArchiveException { <BUGS> if (in == null) { <BUGE> throw new IllegalArgumentException("Stream must not be null."); }  if (!in.markSupported()) { throw new IllegalArgumentException("Mark is not supported."); }  final byte[] signature = new byte[12]; in.mark(signature.length); try { int signatureLength = IOUtils.readFully(in, signature); in.reset(); if (ZipArchiveInputStream.matches(signature, signatureLength)) { return createArchiveInputStream(ZIP, in); } else if (JarArchiveInputStream.matches(signature, signatureLength)) { return createArchiveInputStream(JAR, in); } else if (ArArchiveInputStream.matches(signature, signatureLength)) { return createArchiveInputStream(AR, in); } else if (CpioArchiveInputStream.matches(signature, signatureLength)) { return createArchiveInputStream(CPIO, in); } else if (ArjArchiveInputStream.matches(signature, signatureLength)) { return createArchiveInputStream(ARJ, in); } else if (SevenZFile.matches(signature, signatureLength)) { throw new StreamingNotSupportedException(SEVEN_Z); }
*/ public ArchiveInputStream createArchiveInputStream(final InputStream in) throws ArchiveException { if (in == null) { throw new IllegalArgumentException("Stream must not be null."); }  <BUGS> if (!in.markSupported()) { <BUGE> throw new IllegalArgumentException("Mark is not supported."); }  final byte[] signature = new byte[12]; in.mark(signature.length); try { int signatureLength = IOUtils.readFully(in, signature); in.reset(); if (ZipArchiveInputStream.matches(signature, signatureLength)) { return createArchiveInputStream(ZIP, in); } else if (JarArchiveInputStream.matches(signature, signatureLength)) { return createArchiveInputStream(JAR, in); } else if (ArArchiveInputStream.matches(signature, signatureLength)) { return createArchiveInputStream(AR, in); } else if (CpioArchiveInputStream.matches(signature, signatureLength)) { return createArchiveInputStream(CPIO, in); } else if (ArjArchiveInputStream.matches(signature, signatureLength)) { return createArchiveInputStream(ARJ, in); } else if (SevenZFile.matches(signature, signatureLength)) { throw new StreamingNotSupportedException(SEVEN_Z); }
*/ public ArchiveInputStream createArchiveInputStream(final InputStream in) throws ArchiveException { if (in == null) { throw new IllegalArgumentException("Stream must not be null."); }  if (!in.markSupported()) { throw new IllegalArgumentException("Mark is not supported."); }  <BUGS> final byte[] signature = new byte[12]; in.mark(signature.length); <BUGE> try { int signatureLength = IOUtils.readFully(in, signature); in.reset(); if (ZipArchiveInputStream.matches(signature, signatureLength)) { return createArchiveInputStream(ZIP, in); } else if (JarArchiveInputStream.matches(signature, signatureLength)) { return createArchiveInputStream(JAR, in); } else if (ArArchiveInputStream.matches(signature, signatureLength)) { return createArchiveInputStream(AR, in); } else if (CpioArchiveInputStream.matches(signature, signatureLength)) { return createArchiveInputStream(CPIO, in); } else if (ArjArchiveInputStream.matches(signature, signatureLength)) { return createArchiveInputStream(ARJ, in); } else if (SevenZFile.matches(signature, signatureLength)) { throw new StreamingNotSupportedException(SEVEN_Z); }
*/ public ArchiveInputStream createArchiveInputStream(final InputStream in) throws ArchiveException { if (in == null) { throw new IllegalArgumentException("Stream must not be null."); }  if (!in.markSupported()) { throw new IllegalArgumentException("Mark is not supported."); }  final byte[] signature = new byte[12]; in.mark(signature.length); try { <BUGS> int signatureLength = IOUtils.readFully(in, signature); in.reset(); if (ZipArchiveInputStream.matches(signature, signatureLength)) { <BUGE> return createArchiveInputStream(ZIP, in); } else if (JarArchiveInputStream.matches(signature, signatureLength)) { return createArchiveInputStream(JAR, in); } else if (ArArchiveInputStream.matches(signature, signatureLength)) { return createArchiveInputStream(AR, in); } else if (CpioArchiveInputStream.matches(signature, signatureLength)) { return createArchiveInputStream(CPIO, in); } else if (ArjArchiveInputStream.matches(signature, signatureLength)) { return createArchiveInputStream(ARJ, in); } else if (SevenZFile.matches(signature, signatureLength)) { throw new StreamingNotSupportedException(SEVEN_Z); }
*/ public ArchiveInputStream createArchiveInputStream(final InputStream in) throws ArchiveException { if (in == null) { throw new IllegalArgumentException("Stream must not be null."); }  if (!in.markSupported()) { throw new IllegalArgumentException("Mark is not supported."); }  final byte[] signature = new byte[12]; in.mark(signature.length); try { int signatureLength = IOUtils.readFully(in, signature); in.reset(); if (ZipArchiveInputStream.matches(signature, signatureLength)) { return createArchiveInputStream(ZIP, in); <BUGS> } else if (JarArchiveInputStream.matches(signature, signatureLength)) { <BUGE> return createArchiveInputStream(JAR, in); } else if (ArArchiveInputStream.matches(signature, signatureLength)) { return createArchiveInputStream(AR, in); } else if (CpioArchiveInputStream.matches(signature, signatureLength)) { return createArchiveInputStream(CPIO, in); } else if (ArjArchiveInputStream.matches(signature, signatureLength)) { return createArchiveInputStream(ARJ, in); } else if (SevenZFile.matches(signature, signatureLength)) { throw new StreamingNotSupportedException(SEVEN_Z); }
*/ public ArchiveInputStream createArchiveInputStream(final InputStream in) throws ArchiveException { if (in == null) { throw new IllegalArgumentException("Stream must not be null."); }  if (!in.markSupported()) { throw new IllegalArgumentException("Mark is not supported."); }  final byte[] signature = new byte[12]; in.mark(signature.length); try { int signatureLength = IOUtils.readFully(in, signature); in.reset(); if (ZipArchiveInputStream.matches(signature, signatureLength)) { return createArchiveInputStream(ZIP, in); } else if (JarArchiveInputStream.matches(signature, signatureLength)) { return createArchiveInputStream(JAR, in); <BUGS> } else if (ArArchiveInputStream.matches(signature, signatureLength)) { <BUGE> return createArchiveInputStream(AR, in); } else if (CpioArchiveInputStream.matches(signature, signatureLength)) { return createArchiveInputStream(CPIO, in); } else if (ArjArchiveInputStream.matches(signature, signatureLength)) { return createArchiveInputStream(ARJ, in); } else if (SevenZFile.matches(signature, signatureLength)) { throw new StreamingNotSupportedException(SEVEN_Z); }
*/ public ArchiveInputStream createArchiveInputStream(final InputStream in) throws ArchiveException { if (in == null) { throw new IllegalArgumentException("Stream must not be null."); }  if (!in.markSupported()) { throw new IllegalArgumentException("Mark is not supported."); }  final byte[] signature = new byte[12]; in.mark(signature.length); try { int signatureLength = IOUtils.readFully(in, signature); in.reset(); if (ZipArchiveInputStream.matches(signature, signatureLength)) { return createArchiveInputStream(ZIP, in); } else if (JarArchiveInputStream.matches(signature, signatureLength)) { return createArchiveInputStream(JAR, in); } else if (ArArchiveInputStream.matches(signature, signatureLength)) { return createArchiveInputStream(AR, in); <BUGS> } else if (CpioArchiveInputStream.matches(signature, signatureLength)) { <BUGE> return createArchiveInputStream(CPIO, in); } else if (ArjArchiveInputStream.matches(signature, signatureLength)) { return createArchiveInputStream(ARJ, in); } else if (SevenZFile.matches(signature, signatureLength)) { throw new StreamingNotSupportedException(SEVEN_Z); }
*/ public ArchiveInputStream createArchiveInputStream(final InputStream in) throws ArchiveException { if (in == null) { throw new IllegalArgumentException("Stream must not be null."); }  if (!in.markSupported()) { throw new IllegalArgumentException("Mark is not supported."); }  final byte[] signature = new byte[12]; in.mark(signature.length); try { int signatureLength = IOUtils.readFully(in, signature); in.reset(); if (ZipArchiveInputStream.matches(signature, signatureLength)) { return createArchiveInputStream(ZIP, in); } else if (JarArchiveInputStream.matches(signature, signatureLength)) { return createArchiveInputStream(JAR, in); } else if (ArArchiveInputStream.matches(signature, signatureLength)) { return createArchiveInputStream(AR, in); } else if (CpioArchiveInputStream.matches(signature, signatureLength)) { return createArchiveInputStream(CPIO, in); <BUGS> } else if (ArjArchiveInputStream.matches(signature, signatureLength)) { <BUGE> return createArchiveInputStream(ARJ, in); } else if (SevenZFile.matches(signature, signatureLength)) { throw new StreamingNotSupportedException(SEVEN_Z); }
*/ public ArchiveInputStream createArchiveInputStream(final InputStream in) throws ArchiveException { if (in == null) { throw new IllegalArgumentException("Stream must not be null."); }  if (!in.markSupported()) { throw new IllegalArgumentException("Mark is not supported."); }  final byte[] signature = new byte[12]; in.mark(signature.length); try { int signatureLength = IOUtils.readFully(in, signature); in.reset(); if (ZipArchiveInputStream.matches(signature, signatureLength)) { return createArchiveInputStream(ZIP, in); } else if (JarArchiveInputStream.matches(signature, signatureLength)) { return createArchiveInputStream(JAR, in); } else if (ArArchiveInputStream.matches(signature, signatureLength)) { return createArchiveInputStream(AR, in); } else if (CpioArchiveInputStream.matches(signature, signatureLength)) { return createArchiveInputStream(CPIO, in); } else if (ArjArchiveInputStream.matches(signature, signatureLength)) { return createArchiveInputStream(ARJ, in); <BUGS> } else if (SevenZFile.matches(signature, signatureLength)) { <BUGE> throw new StreamingNotSupportedException(SEVEN_Z); }
/** * Create an archive input stream from an input stream, autodetecting * the archive type from the first few bytes of the stream. The InputStream * must support marks, like BufferedInputStream. * * @param in the input stream * @return the archive input stream * @throws ArchiveException if the archiver name is not known * @throws StreamingNotSupportedException if the format cannot be * read from a stream * @throws IllegalArgumentException if the stream is null or does not support mark /* Dump needs a bigger buffer to check the signature;*/ <BUGS> final byte[] dumpsig = new byte[32]; in.mark(dumpsig.length); signatureLength = IOUtils.readFully(in, dumpsig); in.reset(); if (DumpArchiveInputStream.matches(dumpsig, signatureLength)) { <BUGE> return createArchiveInputStream(DUMP, in); }  /* Tar needs an even bigger buffer to check the signature; read the first block*/ final byte[] tarheader = new byte[512]; in.mark(tarheader.length); signatureLength = IOUtils.readFully(in, tarheader); in.reset(); if (TarArchiveInputStream.matches(tarheader, signatureLength)) { return createArchiveInputStream(TAR, in); } /* COMPRESS-117 - improve auto-recognition*/
/** * Create an archive input stream from an input stream, autodetecting * the archive type from the first few bytes of the stream. The InputStream * must support marks, like BufferedInputStream. * * @param in the input stream * @return the archive input stream * @throws ArchiveException if the archiver name is not known * @throws StreamingNotSupportedException if the format cannot be * read from a stream * @throws IllegalArgumentException if the stream is null or does not support mark /* Tar needs an even bigger buffer to check the signature; read the first block*/ <BUGS> final byte[] tarheader = new byte[512]; in.mark(tarheader.length); signatureLength = IOUtils.readFully(in, tarheader); in.reset(); if (TarArchiveInputStream.matches(tarheader, signatureLength)) { <BUGE> return createArchiveInputStream(TAR, in); } /* COMPRESS-117 - improve auto-recognition*/ if (signatureLength >= 512) { TarArchiveInputStream tais = null; try { tais = new TarArchiveInputStream(new ByteArrayInputStream(tarheader)); /* COMPRESS-191 - verify the header checksum*/ if (tais.getNextTarEntry().isCheckSumOK()) { return createArchiveInputStream(TAR, in); } } catch (Exception e) { /* NOPMD*/
throw new ArchiveException("Archiver: " + archiverName + " not found."); }  /** * Create an archive input stream from an input stream, autodetecting * the archive type from the first few bytes of the stream. The InputStream * must support marks, like BufferedInputStream. * * @param in the input stream * @return the archive input stream * @throws ArchiveException if the archiver name is not known * @throws StreamingNotSupportedException if the format cannot be * read from a stream * @throws IllegalArgumentException if the stream is null or does not support mark /* COMPRESS-117 - improve auto-recognition*/ <BUGS> if (signatureLength >= 512) { TarArchiveInputStream tais = null; <BUGE> try { tais = new TarArchiveInputStream(new ByteArrayInputStream(tarheader)); /* COMPRESS-191 - verify the header checksum*/ if (tais.getNextTarEntry().isCheckSumOK()) { return createArchiveInputStream(TAR, in); } } catch (Exception e) { /* NOPMD*/ /* can generate IllegalArgumentException as well*/ /* as IOException*/ /* autodetection, simply not a TAR*/ /* ignored*/ } finally { IOUtils.closeQuietly(tais);
throw new ArchiveException("Archiver: " + archiverName + " not found."); }  /** * Create an archive input stream from an input stream, autodetecting * the archive type from the first few bytes of the stream. The InputStream * must support marks, like BufferedInputStream. * * @param in the input stream * @return the archive input stream * @throws ArchiveException if the archiver name is not known * @throws StreamingNotSupportedException if the format cannot be * read from a stream * @throws IllegalArgumentException if the stream is null or does not support mark try { <BUGS> tais = new TarArchiveInputStream(new ByteArrayInputStream(tarheader)); <BUGE> /* COMPRESS-191 - verify the header checksum*/ if (tais.getNextTarEntry().isCheckSumOK()) { return createArchiveInputStream(TAR, in); } } catch (Exception e) { /* NOPMD*/ /* can generate IllegalArgumentException as well*/ /* as IOException*/ /* autodetection, simply not a TAR*/ /* ignored*/ } finally { IOUtils.closeQuietly(tais); } } } catch (IOException e) {
throw new ArchiveException("Archiver: " + archiverName + " not found."); }  /** * Create an archive input stream from an input stream, autodetecting * the archive type from the first few bytes of the stream. The InputStream * must support marks, like BufferedInputStream. * * @param in the input stream * @return the archive input stream * @throws ArchiveException if the archiver name is not known * @throws StreamingNotSupportedException if the format cannot be * read from a stream * @throws IllegalArgumentException if the stream is null or does not support mark /* COMPRESS-191 - verify the header checksum*/ <BUGS> if (tais.getNextTarEntry().isCheckSumOK()) { <BUGE> return createArchiveInputStream(TAR, in); } } catch (Exception e) { /* NOPMD*/ /* can generate IllegalArgumentException as well*/ /* as IOException*/ /* autodetection, simply not a TAR*/ /* ignored*/ } finally { IOUtils.closeQuietly(tais); } } } catch (IOException e) { throw new ArchiveException("Could not use reset and mark operations.", e); }
throw new ArchiveException("Archiver: " + archiverName + " not found."); }  /** * Create an archive input stream from an input stream, autodetecting * the archive type from the first few bytes of the stream. The InputStream * must support marks, like BufferedInputStream. * * @param in the input stream * @return the archive input stream * @throws ArchiveException if the archiver name is not known * @throws StreamingNotSupportedException if the format cannot be * read from a stream * @throws IllegalArgumentException if the stream is null or does not support mark } finally { <BUGS> IOUtils.closeQuietly(tais); } <BUGE> } } catch (IOException e) { throw new ArchiveException("Could not use reset and mark operations.", e); }  throw new ArchiveException("No Archiver found for the stream signature"); }  }
throw new ArchiveException("Archiver: " + archiverName + " not found."); }  /** * Create an archive input stream from an input stream, autodetecting * the archive type from the first few bytes of the stream. The InputStream * must support marks, like BufferedInputStream. * * @param in the input stream * @return the archive input stream * @throws ArchiveException if the archiver name is not known * @throws StreamingNotSupportedException if the format cannot be * read from a stream * @throws IllegalArgumentException if the stream is null or does not support mark throw new ArchiveException("Could not use reset and mark operations.", e); <BUGS> } <BUGE>  throw new ArchiveException("No Archiver found for the stream signature"); }  }
throw new ArchiveException("Archiver: " + archiverName + " not found."); }  /** * Create an archive input stream from an input stream, autodetecting * the archive type from the first few bytes of the stream. The InputStream * must support marks, like BufferedInputStream. * * @param in the input stream * @return the archive input stream * @throws ArchiveException if the archiver name is not known * @throws StreamingNotSupportedException if the format cannot be * read from a stream * @throws IllegalArgumentException if the stream is null or does not support mark  <BUGS> throw new ArchiveException("No Archiver found for the stream signature"); <BUGE> }  }
private InputStream getCurrentStream() throws IOException { <BUGS> if (deferredBlockStreams.isEmpty()) { throw new IllegalStateException("No current 7z entry (call getNextEntry() first)."); <BUGE> }  while (deferredBlockStreams.size() > 1) { /* In solid compression mode we need to decompress all leading folder'*/ /* streams to get access to an entry. We defer this until really needed*/ /* so that entire blocks can be skipped without wasting time for decompression.*/ final InputStream stream = deferredBlockStreams.remove(0); IOUtils.skip(stream, Long.MAX_VALUE); stream.close(); }  return deferredBlockStreams.get(0); }
private InputStream getCurrentStream() throws IOException { if (deferredBlockStreams.isEmpty()) { throw new IllegalStateException("No current 7z entry (call getNextEntry() first)."); }  <BUGS> while (deferredBlockStreams.size() > 1) { <BUGE> /* In solid compression mode we need to decompress all leading folder'*/ /* streams to get access to an entry. We defer this until really needed*/ /* so that entire blocks can be skipped without wasting time for decompression.*/ final InputStream stream = deferredBlockStreams.remove(0); IOUtils.skip(stream, Long.MAX_VALUE); stream.close(); }  return deferredBlockStreams.get(0); }
private InputStream getCurrentStream() throws IOException { if (deferredBlockStreams.isEmpty()) { throw new IllegalStateException("No current 7z entry (call getNextEntry() first)."); }  while (deferredBlockStreams.size() > 1) { /* In solid compression mode we need to decompress all leading folder'*/ /* streams to get access to an entry. We defer this until really needed*/ /* so that entire blocks can be skipped without wasting time for decompression.*/ <BUGS> final InputStream stream = deferredBlockStreams.remove(0); IOUtils.skip(stream, Long.MAX_VALUE); stream.close(); } <BUGE>  return deferredBlockStreams.get(0); }
private InputStream getCurrentStream() throws IOException { if (deferredBlockStreams.isEmpty()) { throw new IllegalStateException("No current 7z entry (call getNextEntry() first)."); }  while (deferredBlockStreams.size() > 1) { /* In solid compression mode we need to decompress all leading folder'*/ /* streams to get access to an entry. We defer this until really needed*/ /* so that entire blocks can be skipped without wasting time for decompression.*/ final InputStream stream = deferredBlockStreams.remove(0); IOUtils.skip(stream, Long.MAX_VALUE); stream.close(); }  <BUGS> return deferredBlockStreams.get(0); <BUGE> }
@Override public boolean isDirectory() { <BUGS> if (file != null) { <BUGE> return file.isDirectory(); }  if (linkFlag == LF_DIR) { return true; }  if (getName().endsWith("/")) { return true; }  return false; }
@Override public boolean isDirectory() { if (file != null) { return file.isDirectory(); }  <BUGS> if (linkFlag == LF_DIR) { <BUGE> return true; }  if (getName().endsWith("/")) { return true; }  return false; }
@Override public boolean isDirectory() { if (file != null) { return file.isDirectory(); }  if (linkFlag == LF_DIR) { return true; }  <BUGS> if (getName().endsWith("/")) { return true; <BUGE> }  return false; }
*/ public static String sanitize(String s) { <BUGS> final char[] chars = s.toCharArray(); final int len = chars.length; final StringBuilder sb = new StringBuilder(); for (int i = 0; i < len; i++) { final char c = chars[i]; if (!Character.isISOControl(c)) { Character.UnicodeBlock block = Character.UnicodeBlock.of(c); if (block != null && block != Character.UnicodeBlock.SPECIALS) { sb.append(c); continue; <BUGE> } } sb.append('?'); } return sb.toString(); }
*/ public static String sanitize(String s) { final char[] chars = s.toCharArray(); final int len = chars.length; final StringBuilder sb = new StringBuilder(); for (int i = 0; i < len; i++) { final char c = chars[i]; if (!Character.isISOControl(c)) { Character.UnicodeBlock block = Character.UnicodeBlock.of(c); if (block != null && block != Character.UnicodeBlock.SPECIALS) { sb.append(c); continue; } } sb.append('?'); } <BUGS> return sb.toString(); <BUGE> }
*/ public long readBits(final int count) throws IOException { <BUGS> if (count < 0 || count > MAXIMUM_CACHE_SIZE) { <BUGE> throw new IllegalArgumentException("count must not be negative or greater than " + MAXIMUM_CACHE_SIZE); } while (bitsCachedSize < count) { final long nextByte = in.read(); if (nextByte < 0) { return nextByte; } if (byteOrder == ByteOrder.LITTLE_ENDIAN) { bitsCached |= (nextByte << bitsCachedSize); } else { bitsCached <<= 8; bitsCached |= nextByte; } bitsCachedSize += 8; } /* bitsCachedSize >= 57 and left-shifting it 8 bits would cause an overflow*/  final long bitsOut; if (byteOrder == ByteOrder.LITTLE_ENDIAN) { bitsOut = (bitsCached & MASKS[count]); bitsCached >>>= count; } else { bitsOut = (bitsCached >> (bitsCachedSize - count)) & MASKS[count]; } bitsCachedSize -= count; return bitsOut; }
*/ public long readBits(final int count) throws IOException { if (count < 0 || count > MAXIMUM_CACHE_SIZE) { throw new IllegalArgumentException("count must not be negative or greater than " + MAXIMUM_CACHE_SIZE); } <BUGS> while (bitsCachedSize < count) { final long nextByte = in.read(); if (nextByte < 0) { <BUGE> return nextByte; } if (byteOrder == ByteOrder.LITTLE_ENDIAN) { bitsCached |= (nextByte << bitsCachedSize); } else { bitsCached <<= 8; bitsCached |= nextByte; } bitsCachedSize += 8; } /* bitsCachedSize >= 57 and left-shifting it 8 bits would cause an overflow*/  final long bitsOut; if (byteOrder == ByteOrder.LITTLE_ENDIAN) { bitsOut = (bitsCached & MASKS[count]); bitsCached >>>= count; } else { bitsOut = (bitsCached >> (bitsCachedSize - count)) & MASKS[count]; } bitsCachedSize -= count; return bitsOut; }
*/ public long readBits(final int count) throws IOException { if (count < 0 || count > MAXIMUM_CACHE_SIZE) { throw new IllegalArgumentException("count must not be negative or greater than " + MAXIMUM_CACHE_SIZE); } while (bitsCachedSize < count) { final long nextByte = in.read(); if (nextByte < 0) { return nextByte; } <BUGS> if (byteOrder == ByteOrder.LITTLE_ENDIAN) { bitsCached |= (nextByte << bitsCachedSize); <BUGE> } else { bitsCached <<= 8; bitsCached |= nextByte; } bitsCachedSize += 8; } /* bitsCachedSize >= 57 and left-shifting it 8 bits would cause an overflow*/  final long bitsOut; if (byteOrder == ByteOrder.LITTLE_ENDIAN) { bitsOut = (bitsCached & MASKS[count]); bitsCached >>>= count; } else { bitsOut = (bitsCached >> (bitsCachedSize - count)) & MASKS[count]; } bitsCachedSize -= count; return bitsOut; }
*/ public long readBits(final int count) throws IOException { if (count < 0 || count > MAXIMUM_CACHE_SIZE) { throw new IllegalArgumentException("count must not be negative or greater than " + MAXIMUM_CACHE_SIZE); } while (bitsCachedSize < count) { final long nextByte = in.read(); if (nextByte < 0) { return nextByte; } if (byteOrder == ByteOrder.LITTLE_ENDIAN) { bitsCached |= (nextByte << bitsCachedSize); } else { <BUGS> bitsCached <<= 8; bitsCached |= nextByte; <BUGE> } bitsCachedSize += 8; } /* bitsCachedSize >= 57 and left-shifting it 8 bits would cause an overflow*/  final long bitsOut; if (byteOrder == ByteOrder.LITTLE_ENDIAN) { bitsOut = (bitsCached & MASKS[count]); bitsCached >>>= count; } else { bitsOut = (bitsCached >> (bitsCachedSize - count)) & MASKS[count]; } bitsCachedSize -= count; return bitsOut; }
*/ public long readBits(final int count) throws IOException { if (count < 0 || count > MAXIMUM_CACHE_SIZE) { throw new IllegalArgumentException("count must not be negative or greater than " + MAXIMUM_CACHE_SIZE); } while (bitsCachedSize < count) { final long nextByte = in.read(); if (nextByte < 0) { return nextByte; } if (byteOrder == ByteOrder.LITTLE_ENDIAN) { bitsCached |= (nextByte << bitsCachedSize); } else { bitsCached <<= 8; bitsCached |= nextByte; } <BUGS> bitsCachedSize += 8; } <BUGE> /* bitsCachedSize >= 57 and left-shifting it 8 bits would cause an overflow*/  final long bitsOut; if (byteOrder == ByteOrder.LITTLE_ENDIAN) { bitsOut = (bitsCached & MASKS[count]); bitsCached >>>= count; } else { bitsOut = (bitsCached >> (bitsCachedSize - count)) & MASKS[count]; } bitsCachedSize -= count; return bitsOut; }
*/ public long readBits(final int count) throws IOException { if (count < 0 || count > MAXIMUM_CACHE_SIZE) { throw new IllegalArgumentException("count must not be negative or greater than " + MAXIMUM_CACHE_SIZE); } while (bitsCachedSize < count) { final long nextByte = in.read(); if (nextByte < 0) { return nextByte; } if (byteOrder == ByteOrder.LITTLE_ENDIAN) { bitsCached |= (nextByte << bitsCachedSize); } else { bitsCached <<= 8; bitsCached |= nextByte; } bitsCachedSize += 8; } /* bitsCachedSize >= 57 and left-shifting it 8 bits would cause an overflow*/  final long bitsOut; <BUGS> if (byteOrder == ByteOrder.LITTLE_ENDIAN) { bitsOut = (bitsCached & MASKS[count]); bitsCached >>>= count; <BUGE> } else { bitsOut = (bitsCached >> (bitsCachedSize - count)) & MASKS[count]; } bitsCachedSize -= count; return bitsOut; }
*/ public long readBits(final int count) throws IOException { if (count < 0 || count > MAXIMUM_CACHE_SIZE) { throw new IllegalArgumentException("count must not be negative or greater than " + MAXIMUM_CACHE_SIZE); } while (bitsCachedSize < count) { final long nextByte = in.read(); if (nextByte < 0) { return nextByte; } if (byteOrder == ByteOrder.LITTLE_ENDIAN) { bitsCached |= (nextByte << bitsCachedSize); } else { bitsCached <<= 8; bitsCached |= nextByte; } bitsCachedSize += 8; } /* bitsCachedSize >= 57 and left-shifting it 8 bits would cause an overflow*/  final long bitsOut; if (byteOrder == ByteOrder.LITTLE_ENDIAN) { bitsOut = (bitsCached & MASKS[count]); bitsCached >>>= count; } else { <BUGS> bitsOut = (bitsCached >> (bitsCachedSize - count)) & MASKS[count]; <BUGE> } bitsCachedSize -= count; return bitsOut; }
*/ public long readBits(final int count) throws IOException { if (count < 0 || count > MAXIMUM_CACHE_SIZE) { throw new IllegalArgumentException("count must not be negative or greater than " + MAXIMUM_CACHE_SIZE); } while (bitsCachedSize < count) { final long nextByte = in.read(); if (nextByte < 0) { return nextByte; } if (byteOrder == ByteOrder.LITTLE_ENDIAN) { bitsCached |= (nextByte << bitsCachedSize); } else { bitsCached <<= 8; bitsCached |= nextByte; } bitsCachedSize += 8; } /* bitsCachedSize >= 57 and left-shifting it 8 bits would cause an overflow*/  final long bitsOut; if (byteOrder == ByteOrder.LITTLE_ENDIAN) { bitsOut = (bitsCached & MASKS[count]); bitsCached >>>= count; } else { bitsOut = (bitsCached >> (bitsCachedSize - count)) & MASKS[count]; } <BUGS> bitsCachedSize -= count; return bitsOut; <BUGE> }
@Override public long skip(final long value) throws IOException { <BUGS> if (value >= 0) { long skipped = 0; while (skipped < value) { final long rem = value - skipped; final int x = read(SKIP_BUF, 0, (int) (SKIP_BUF.length > rem ? rem : SKIP_BUF.length)); if (x == -1) { return skipped; <BUGE> } skipped += x; } return skipped; } throw new IllegalArgumentException(); }
@Override public long skip(final long value) throws IOException { if (value >= 0) { long skipped = 0; while (skipped < value) { final long rem = value - skipped; final int x = read(SKIP_BUF, 0, (int) (SKIP_BUF.length > rem ? rem : SKIP_BUF.length)); if (x == -1) { return skipped; } <BUGS> skipped += x; } <BUGE> return skipped; } throw new IllegalArgumentException(); }
*/ public boolean isUnixSymlink() { <BUGS> return (getUnixMode() & UnixStat.LINK_FLAG) == UnixStat.LINK_FLAG; <BUGE> }
*/ public InputStream getRawInputStream(final ZipArchiveEntry ze) { <BUGS> if (!(ze instanceof Entry)) { <BUGE> return null; } final long start = ze.getDataOffset(); return createBoundedInputStream(start, ze.getCompressedSize()); }
*/ public InputStream getRawInputStream(final ZipArchiveEntry ze) { if (!(ze instanceof Entry)) { return null; } <BUGS> final long start = ze.getDataOffset(); return createBoundedInputStream(start, ze.getCompressedSize()); <BUGE> }
<BUGS> public ChecksumCalculatingInputStream(final Checksum checksum, final InputStream in) { <BUGE>    this.checksum = checksum; this.in = in; }
public ChecksumCalculatingInputStream(final Checksum checksum, final InputStream in) {    <BUGS> this.checksum = checksum; this.in = in; } <BUGE>
*/ public static int formatLongOctalOrBinaryBytes( final long value, final byte[] buf, final int offset, final int length) {  /* Check whether we are dealing with UID/GID or SIZE field*/ <BUGS> final long maxAsOctalChar = length == TarConstants.UIDLEN ? TarConstants.MAXID : TarConstants.MAXSIZE; <BUGE>  final boolean negative = value < 0; if (!negative && value <= maxAsOctalChar) { /* OK to store as octal chars*/ return formatLongOctalBytes(value, buf, offset, length); }  if (length < 9) { formatLongBinary(value, buf, offset, length, negative); } formatBigIntegerBinary(value, buf, offset, length, negative);  buf[offset] = (byte) (negative ? 0xff : 0x80); return offset + length; }
*/ public static int formatLongOctalOrBinaryBytes( final long value, final byte[] buf, final int offset, final int length) {  /* Check whether we are dealing with UID/GID or SIZE field*/ final long maxAsOctalChar = length == TarConstants.UIDLEN ? TarConstants.MAXID : TarConstants.MAXSIZE;  <BUGS> final boolean negative = value < 0; if (!negative && value <= maxAsOctalChar) { /* OK to store as octal chars*/ return formatLongOctalBytes(value, buf, offset, length); <BUGE> }  if (length < 9) { formatLongBinary(value, buf, offset, length, negative); } formatBigIntegerBinary(value, buf, offset, length, negative);  buf[offset] = (byte) (negative ? 0xff : 0x80); return offset + length; }
*/ public static int formatLongOctalOrBinaryBytes( final long value, final byte[] buf, final int offset, final int length) {  /* Check whether we are dealing with UID/GID or SIZE field*/ final long maxAsOctalChar = length == TarConstants.UIDLEN ? TarConstants.MAXID : TarConstants.MAXSIZE;  final boolean negative = value < 0; if (!negative && value <= maxAsOctalChar) { /* OK to store as octal chars*/ return formatLongOctalBytes(value, buf, offset, length); }  <BUGS> if (length < 9) { formatLongBinary(value, buf, offset, length, negative); <BUGE> } formatBigIntegerBinary(value, buf, offset, length, negative);  buf[offset] = (byte) (negative ? 0xff : 0x80); return offset + length; }
*/ public static int formatLongOctalOrBinaryBytes( final long value, final byte[] buf, final int offset, final int length) {  /* Check whether we are dealing with UID/GID or SIZE field*/ final long maxAsOctalChar = length == TarConstants.UIDLEN ? TarConstants.MAXID : TarConstants.MAXSIZE;  final boolean negative = value < 0; if (!negative && value <= maxAsOctalChar) { /* OK to store as octal chars*/ return formatLongOctalBytes(value, buf, offset, length); }  if (length < 9) { formatLongBinary(value, buf, offset, length, negative); } <BUGS> formatBigIntegerBinary(value, buf, offset, length, negative); <BUGE>  buf[offset] = (byte) (negative ? 0xff : 0x80); return offset + length; }
*/ public static int formatLongOctalOrBinaryBytes( final long value, final byte[] buf, final int offset, final int length) {  /* Check whether we are dealing with UID/GID or SIZE field*/ final long maxAsOctalChar = length == TarConstants.UIDLEN ? TarConstants.MAXID : TarConstants.MAXSIZE;  final boolean negative = value < 0; if (!negative && value <= maxAsOctalChar) { /* OK to store as octal chars*/ return formatLongOctalBytes(value, buf, offset, length); }  if (length < 9) { formatLongBinary(value, buf, offset, length, negative); } formatBigIntegerBinary(value, buf, offset, length, negative);  <BUGS> buf[offset] = (byte) (negative ? 0xff : 0x80); return offset + length; <BUGE> }
*/ <BUGS> public void setModifyJavaTime(final Date d) { setModifyTime(dateToZipLong(d)); } <BUGE>
@Override public boolean canReadEntryData(final ArchiveEntry ae) { <BUGS> if (ae instanceof ZipArchiveEntry) { final ZipArchiveEntry ze = (ZipArchiveEntry) ae; return ZipUtil.canHandleEntryData(ze) <BUGE> && supportsDataDescriptorFor(ze); } return false; }
*/ public static ZipExtraField[] parse(byte[] data, boolean local) throws ZipException { <BUGS> List v = new ArrayList(); int start = 0; while (start <= data.length - WORD) { ZipShort headerId = new ZipShort(data, start); int length = (new ZipShort(data, start + 2)).getValue(); if (start + WORD + length > data.length) { throw new ZipException("data starting at " + start <BUGE> + " is in unknown format"); } try { ZipExtraField ze = createExtraField(headerId); if (local) { ze.parseFromLocalFileData(data, start + WORD, length); } else { ze.parseFromCentralDirectoryData(data, start + WORD, length); } v.add(ze); } catch (InstantiationException ie) { throw new ZipException(ie.getMessage()); } catch (IllegalAccessException iae) { throw new ZipException(iae.getMessage()); } start += (length + WORD); }  ZipExtraField[] result = new ZipExtraField[v.size()];
*/ public static ZipExtraField[] parse(byte[] data, boolean local) throws ZipException { List v = new ArrayList(); int start = 0; while (start <= data.length - WORD) { ZipShort headerId = new ZipShort(data, start); int length = (new ZipShort(data, start + 2)).getValue(); if (start + WORD + length > data.length) { throw new ZipException("data starting at " + start + " is in unknown format"); } try { <BUGS> ZipExtraField ze = createExtraField(headerId); if (local) { ze.parseFromLocalFileData(data, start + WORD, length); <BUGE> } else { ze.parseFromCentralDirectoryData(data, start + WORD, length); } v.add(ze); } catch (InstantiationException ie) { throw new ZipException(ie.getMessage()); } catch (IllegalAccessException iae) { throw new ZipException(iae.getMessage()); } start += (length + WORD); }  ZipExtraField[] result = new ZipExtraField[v.size()];
*/ public static ZipExtraField[] parse(byte[] data, boolean local) throws ZipException { List v = new ArrayList(); int start = 0; while (start <= data.length - WORD) { ZipShort headerId = new ZipShort(data, start); int length = (new ZipShort(data, start + 2)).getValue(); if (start + WORD + length > data.length) { throw new ZipException("data starting at " + start + " is in unknown format"); } try { ZipExtraField ze = createExtraField(headerId); if (local) { ze.parseFromLocalFileData(data, start + WORD, length); } else { ze.parseFromCentralDirectoryData(data, start + WORD, length); } <BUGS> v.add(ze); <BUGE> } catch (InstantiationException ie) { throw new ZipException(ie.getMessage()); } catch (IllegalAccessException iae) { throw new ZipException(iae.getMessage()); } start += (length + WORD); }  ZipExtraField[] result = new ZipExtraField[v.size()];
*/ public static ZipExtraField[] parse(byte[] data, boolean local) throws ZipException { List v = new ArrayList(); int start = 0; while (start <= data.length - WORD) { ZipShort headerId = new ZipShort(data, start); int length = (new ZipShort(data, start + 2)).getValue(); if (start + WORD + length > data.length) { throw new ZipException("data starting at " + start + " is in unknown format"); } try { ZipExtraField ze = createExtraField(headerId); if (local) { ze.parseFromLocalFileData(data, start + WORD, length); } else { ze.parseFromCentralDirectoryData(data, start + WORD, length); } v.add(ze); } catch (InstantiationException ie) { throw new ZipException(ie.getMessage()); } catch (IllegalAccessException iae) { throw new ZipException(iae.getMessage()); <BUGS> } start += (length + WORD); } <BUGE>  ZipExtraField[] result = new ZipExtraField[v.size()];
*/ public static ZipExtraField[] parse(byte[] data, boolean local) throws ZipException { List v = new ArrayList(); int start = 0; while (start <= data.length - WORD) { ZipShort headerId = new ZipShort(data, start); int length = (new ZipShort(data, start + 2)).getValue(); if (start + WORD + length > data.length) { throw new ZipException("data starting at " + start + " is in unknown format"); } try { ZipExtraField ze = createExtraField(headerId); if (local) { ze.parseFromLocalFileData(data, start + WORD, length); } else { ze.parseFromCentralDirectoryData(data, start + WORD, length); } v.add(ze); } catch (InstantiationException ie) { throw new ZipException(ie.getMessage()); } catch (IllegalAccessException iae) { throw new ZipException(iae.getMessage()); } start += (length + WORD); }  <BUGS> ZipExtraField[] result = new ZipExtraField[v.size()];
*/ public TarArchiveInputStream(InputStream is, String encoding) { <BUGS> this(is, TarBuffer.DEFAULT_BLKSIZE, TarBuffer.DEFAULT_RCDSIZE, encoding); } <BUGE>
*/ public void setModTime(Date time) { <BUGS> modTime = time.getTime() / MILLIS_PER_SECOND; } <BUGE>
private void parseTarHeader(byte[] header, ZipEncoding encoding, final boolean oldStyle) throws IOException { <BUGS> int offset = 0; <BUGE>  name = oldStyle ? TarUtils.parseName(header, offset, NAMELEN) : TarUtils.parseName(header, offset, NAMELEN, encoding); offset += NAMELEN; mode = (int) TarUtils.parseOctalOrBinary(header, offset, MODELEN); offset += MODELEN; userId = (int) TarUtils.parseOctalOrBinary(header, offset, UIDLEN); offset += UIDLEN; groupId = (int) TarUtils.parseOctalOrBinary(header, offset, GIDLEN); offset += GIDLEN; size = TarUtils.parseOctalOrBinary(header, offset, SIZELEN); offset += SIZELEN; modTime = TarUtils.parseOctalOrBinary(header, offset, MODTIMELEN); offset += MODTIMELEN; checkSumOK = TarUtils.verifyCheckSum(header); offset += CHKSUMLEN; linkFlag = header[offset++]; linkName = oldStyle ? TarUtils.parseName(header, offset, NAMELEN) : TarUtils.parseName(header, offset, NAMELEN, encoding); offset += NAMELEN; magic = TarUtils.parseName(header, offset, MAGICLEN); offset += MAGICLEN; version = TarUtils.parseName(header, offset, VERSIONLEN); offset += VERSIONLEN; userName = oldStyle ? TarUtils.parseName(header, offset, UNAMELEN)
private void parseTarHeader(byte[] header, ZipEncoding encoding, final boolean oldStyle) throws IOException { int offset = 0;  <BUGS> name = oldStyle ? TarUtils.parseName(header, offset, NAMELEN) <BUGE> : TarUtils.parseName(header, offset, NAMELEN, encoding); offset += NAMELEN; mode = (int) TarUtils.parseOctalOrBinary(header, offset, MODELEN); offset += MODELEN; userId = (int) TarUtils.parseOctalOrBinary(header, offset, UIDLEN); offset += UIDLEN; groupId = (int) TarUtils.parseOctalOrBinary(header, offset, GIDLEN); offset += GIDLEN; size = TarUtils.parseOctalOrBinary(header, offset, SIZELEN); offset += SIZELEN; modTime = TarUtils.parseOctalOrBinary(header, offset, MODTIMELEN); offset += MODTIMELEN; checkSumOK = TarUtils.verifyCheckSum(header); offset += CHKSUMLEN; linkFlag = header[offset++]; linkName = oldStyle ? TarUtils.parseName(header, offset, NAMELEN) : TarUtils.parseName(header, offset, NAMELEN, encoding); offset += NAMELEN; magic = TarUtils.parseName(header, offset, MAGICLEN); offset += MAGICLEN; version = TarUtils.parseName(header, offset, VERSIONLEN); offset += VERSIONLEN; userName = oldStyle ? TarUtils.parseName(header, offset, UNAMELEN)
private void parseTarHeader(byte[] header, ZipEncoding encoding, final boolean oldStyle) throws IOException { int offset = 0;  name = oldStyle ? TarUtils.parseName(header, offset, NAMELEN) : TarUtils.parseName(header, offset, NAMELEN, encoding); <BUGS> offset += NAMELEN; mode = (int) TarUtils.parseOctalOrBinary(header, offset, MODELEN); offset += MODELEN; userId = (int) TarUtils.parseOctalOrBinary(header, offset, UIDLEN); offset += UIDLEN; groupId = (int) TarUtils.parseOctalOrBinary(header, offset, GIDLEN); offset += GIDLEN; size = TarUtils.parseOctalOrBinary(header, offset, SIZELEN); offset += SIZELEN; modTime = TarUtils.parseOctalOrBinary(header, offset, MODTIMELEN); offset += MODTIMELEN; checkSumOK = TarUtils.verifyCheckSum(header); offset += CHKSUMLEN; linkFlag = header[offset++]; linkName = oldStyle ? TarUtils.parseName(header, offset, NAMELEN) <BUGE> : TarUtils.parseName(header, offset, NAMELEN, encoding); offset += NAMELEN; magic = TarUtils.parseName(header, offset, MAGICLEN); offset += MAGICLEN; version = TarUtils.parseName(header, offset, VERSIONLEN); offset += VERSIONLEN; userName = oldStyle ? TarUtils.parseName(header, offset, UNAMELEN)
private void parseTarHeader(byte[] header, ZipEncoding encoding, final boolean oldStyle) throws IOException { int offset = 0;  name = oldStyle ? TarUtils.parseName(header, offset, NAMELEN) : TarUtils.parseName(header, offset, NAMELEN, encoding); offset += NAMELEN; mode = (int) TarUtils.parseOctalOrBinary(header, offset, MODELEN); offset += MODELEN; userId = (int) TarUtils.parseOctalOrBinary(header, offset, UIDLEN); offset += UIDLEN; groupId = (int) TarUtils.parseOctalOrBinary(header, offset, GIDLEN); offset += GIDLEN; size = TarUtils.parseOctalOrBinary(header, offset, SIZELEN); offset += SIZELEN; modTime = TarUtils.parseOctalOrBinary(header, offset, MODTIMELEN); offset += MODTIMELEN; checkSumOK = TarUtils.verifyCheckSum(header); offset += CHKSUMLEN; linkFlag = header[offset++]; linkName = oldStyle ? TarUtils.parseName(header, offset, NAMELEN) : TarUtils.parseName(header, offset, NAMELEN, encoding); <BUGS> offset += NAMELEN; magic = TarUtils.parseName(header, offset, MAGICLEN); offset += MAGICLEN; version = TarUtils.parseName(header, offset, VERSIONLEN); offset += VERSIONLEN; userName = oldStyle ? TarUtils.parseName(header, offset, UNAMELEN) <BUGE>
/** * Parse an entry's header information from a header buffer. * * @param header The tar entry header buffer to get information from. * @param encoding encoding to use for file names * @since 1.4 * @throws IllegalArgumentException if any of the numeric fields * have an invalid format * @throws IOException on error */ public void parseTarHeader(byte[] header, ZipEncoding encoding) throws IOException { parseTarHeader(header, encoding, false); } : TarUtils.parseName(header, offset, UNAMELEN, encoding); <BUGS> offset += UNAMELEN; groupName = oldStyle ? TarUtils.parseName(header, offset, GNAMELEN) <BUGE> : TarUtils.parseName(header, offset, GNAMELEN, encoding); offset += GNAMELEN; devMajor = (int) TarUtils.parseOctalOrBinary(header, offset, DEVLEN); offset += DEVLEN; devMinor = (int) TarUtils.parseOctalOrBinary(header, offset, DEVLEN); offset += DEVLEN;  int type = evaluateType(header); switch (type) { case FORMAT_OLDGNU: { offset += ATIMELEN_GNU; offset += CTIMELEN_GNU; offset += OFFSETLEN_GNU;
* * @param header The tar entry header buffer to get information from. * @param encoding encoding to use for file names * @since 1.4 * @throws IllegalArgumentException if any of the numeric fields * have an invalid format * @throws IOException on error */ public void parseTarHeader(byte[] header, ZipEncoding encoding) throws IOException { parseTarHeader(header, encoding, false); } : TarUtils.parseName(header, offset, GNAMELEN, encoding); <BUGS> offset += GNAMELEN; devMajor = (int) TarUtils.parseOctalOrBinary(header, offset, DEVLEN); offset += DEVLEN; devMinor = (int) TarUtils.parseOctalOrBinary(header, offset, DEVLEN); offset += DEVLEN; <BUGE>  int type = evaluateType(header); switch (type) { case FORMAT_OLDGNU: { offset += ATIMELEN_GNU; offset += CTIMELEN_GNU; offset += OFFSETLEN_GNU; offset += LONGNAMESLEN_GNU; offset += PAD2LEN_GNU; offset += SPARSELEN_GNU; isExtended = TarUtils.parseBoolean(header, offset); offset += ISEXTENDEDLEN_GNU;
/** * Parse an entry's header information from a header buffer. * * @param header The tar entry header buffer to get information from. * @param encoding encoding to use for file names * @since 1.4 * @throws IllegalArgumentException if any of the numeric fields * have an invalid format * @throws IOException on error */ public void parseTarHeader(byte[] header, ZipEncoding encoding) throws IOException { parseTarHeader(header, encoding, false); }  <BUGS> int type = evaluateType(header); switch (type) { <BUGE> case FORMAT_OLDGNU: { offset += ATIMELEN_GNU; offset += CTIMELEN_GNU; offset += OFFSETLEN_GNU; offset += LONGNAMESLEN_GNU; offset += PAD2LEN_GNU; offset += SPARSELEN_GNU; isExtended = TarUtils.parseBoolean(header, offset); offset += ISEXTENDEDLEN_GNU; realSize = TarUtils.parseOctal(header, offset, REALSIZELEN_GNU); offset += REALSIZELEN_GNU; break; }
/** * Parse an entry's header information from a header buffer. * * @param header The tar entry header buffer to get information from. * @param encoding encoding to use for file names * @since 1.4 * @throws IllegalArgumentException if any of the numeric fields * have an invalid format * @throws IOException on error */ public void parseTarHeader(byte[] header, ZipEncoding encoding) throws IOException { parseTarHeader(header, encoding, false); } default: { <BUGS> String prefix = oldStyle <BUGE> ? TarUtils.parseName(header, offset, PREFIXLEN) : TarUtils.parseName(header, offset, PREFIXLEN, encoding); /* SunOS tar -E does not add / to directory names, so fix*/ /* up to be consistent*/ if (isDirectory() && !name.endsWith("/")){ name = name + "/"; } if (prefix.length() > 0){ name = prefix + "/" + name; } } } }
/** * Parse an entry's header information from a header buffer. * * @param header The tar entry header buffer to get information from. * @param encoding encoding to use for file names * @since 1.4 * @throws IllegalArgumentException if any of the numeric fields * have an invalid format * @throws IOException on error */ public void parseTarHeader(byte[] header, ZipEncoding encoding) throws IOException { parseTarHeader(header, encoding, false); } /* up to be consistent*/ <BUGS> if (isDirectory() && !name.endsWith("/")){ <BUGE> name = name + "/"; } if (prefix.length() > 0){ name = prefix + "/" + name; } } } }  /** * Strips Windows' drive letter as well as any leading slashes, * turns path separators into forward slahes. */ private static String normalizeFileName(String fileName,
/** * Parse an entry's header information from a header buffer. * * @param header The tar entry header buffer to get information from. * @param encoding encoding to use for file names * @since 1.4 * @throws IllegalArgumentException if any of the numeric fields * have an invalid format * @throws IOException on error */ public void parseTarHeader(byte[] header, ZipEncoding encoding) throws IOException { parseTarHeader(header, encoding, false); } } <BUGS> if (prefix.length() > 0){ name = prefix + "/" + name; <BUGE> } } } }  /** * Strips Windows' drive letter as well as any leading slashes, * turns path separators into forward slahes. */ private static String normalizeFileName(String fileName, boolean preserveLeadingSlashes) { String osname = System.getProperty("os.name").toLowerCase(Locale.ENGLISH);
/** * Parse an entry's header information from a header buffer. * * @param header The tar entry header buffer to get information from. * @param encoding encoding to use for file names * @since 1.4 * @throws IllegalArgumentException if any of the numeric fields * have an invalid format * @throws IOException on error */ public void parseTarHeader(byte[] header, ZipEncoding encoding) throws IOException { parseTarHeader(header, encoding, false); } } <BUGS> } <BUGE>  /** * Strips Windows' drive letter as well as any leading slashes, * turns path separators into forward slahes. */ private static String normalizeFileName(String fileName, boolean preserveLeadingSlashes) { String osname = System.getProperty("os.name").toLowerCase(Locale.ENGLISH);  if (osname != null) {  /* Strip off drive letters!*/ /* REVIEW Would a better check be "(File.separator == '\')"?*/
@Override public void log(final Log log) { <BUGS> String starting = "Starting Coveralls job"; if (job.getServiceName() != null) { starting += " for " + job.getServiceName(); if (job.getServiceJobId() != null) { starting += " (" + job.getServiceJobId() + ")"; <BUGE> } } log.info(starting);  if (job.getRepoToken() != null) { log.info("Using repository token <secret>"); }  if (job.getGit() != null) { String commit = job.getGit().getHead().getId(); String branch = job.getGit().getBranch(); log.info("Git commit " + commit.substring(0, 7) + " in " + branch); } }
@Override public void log(final Log log) { String starting = "Starting Coveralls job"; if (job.getServiceName() != null) { starting += " for " + job.getServiceName(); if (job.getServiceJobId() != null) { starting += " (" + job.getServiceJobId() + ")"; } } <BUGS> log.info(starting); <BUGE>  if (job.getRepoToken() != null) { log.info("Using repository token <secret>"); }  if (job.getGit() != null) { String commit = job.getGit().getHead().getId(); String branch = job.getGit().getBranch(); log.info("Git commit " + commit.substring(0, 7) + " in " + branch); } }
@Override public void log(final Log log) { String starting = "Starting Coveralls job"; if (job.getServiceName() != null) { starting += " for " + job.getServiceName(); if (job.getServiceJobId() != null) { starting += " (" + job.getServiceJobId() + ")"; } } log.info(starting);  <BUGS> if (job.getRepoToken() != null) { log.info("Using repository token <secret>"); <BUGE> }  if (job.getGit() != null) { String commit = job.getGit().getHead().getId(); String branch = job.getGit().getBranch(); log.info("Git commit " + commit.substring(0, 7) + " in " + branch); } }
@Override public void log(final Log log) { String starting = "Starting Coveralls job"; if (job.getServiceName() != null) { starting += " for " + job.getServiceName(); if (job.getServiceJobId() != null) { starting += " (" + job.getServiceJobId() + ")"; } } log.info(starting);  if (job.getRepoToken() != null) { log.info("Using repository token <secret>"); }  <BUGS> if (job.getGit() != null) { String commit = job.getGit().getHead().getId(); String branch = job.getGit().getBranch(); log.info("Git commit " + commit.substring(0, 7) + " in " + branch); <BUGE> } }
@Override public void log(final Log log) { String starting = "Starting Coveralls job"; if (job.getServiceName() != null) { starting += " for " + job.getServiceName(); if (job.getServiceJobId() != null) { starting += " (" + job.getServiceJobId() + ")"; } } log.info(starting);  if (job.getRepoToken() != null) { log.info("Using repository token <secret>"); }  if (job.getGit() != null) { String commit = job.getGit().getHead().getId(); String branch = job.getGit().getBranch(); log.info("Git commit " + commit.substring(0, 7) + " in " + branch); } <BUGS> } <BUGE>
public boolean isError() { <BUGS> return error; <BUGE> }
public boolean isError() { <BUGS> return error; <BUGE> }
@Override public String getBuildUrl() { <BUGS> return getProperty(WERCKER_BUILD_URL); <BUGE> }
@Override public String getJobId() { <BUGS> return getProperty(WERCKER_BUILD_ID); <BUGE> }
private CoverallsResponse parseResponse(final HttpResponse response) throws ProcessingException, IOException { <BUGS> HttpEntity entity = response.getEntity(); ContentType contentType = ContentType.getOrDefault(entity); InputStreamReader reader = new InputStreamReader(entity.getContent(), contentType.getCharset()); <BUGE> try { return objectMapper.readValue(reader, CoverallsResponse.class); } catch (JsonProcessingException ex) { throw new ProcessingException(ex); } finally { IOUtil.close(reader); } }
private CoverallsResponse parseResponse(final HttpResponse response) throws ProcessingException, IOException { HttpEntity entity = response.getEntity(); ContentType contentType = ContentType.getOrDefault(entity); InputStreamReader reader = new InputStreamReader(entity.getContent(), contentType.getCharset()); try { <BUGS> return objectMapper.readValue(reader, CoverallsResponse.class); <BUGE> } catch (JsonProcessingException ex) { throw new ProcessingException(ex); } finally { IOUtil.close(reader); } }
private CoverallsResponse parseResponse(final HttpResponse response) throws ProcessingException, IOException { HttpEntity entity = response.getEntity(); ContentType contentType = ContentType.getOrDefault(entity); InputStreamReader reader = new InputStreamReader(entity.getContent(), contentType.getCharset()); try { return objectMapper.readValue(reader, CoverallsResponse.class); } catch (JsonProcessingException ex) { throw new ProcessingException(ex); } finally { <BUGS> IOUtil.close(reader); <BUGE> } }
} private void setupSourceDirectories() { <BUGS> if (mojo.sourceDirectories == null || mojo.sourceDirectories.isEmpty()) { List<File> directories = new ArrayList<File>(); collectSourceDirectories(mojo.project, directories); <BUGE> mojo.sourceDirectories = directories; } if (mojo.sourceDirectories == null || mojo.sourceDirectories.isEmpty()) { throw new IllegalArgumentException("No source directories set up"); } logSourceDirectories(); }
*/ public int getLineNumber() { <BUGS> return lexer.getLineNumber(); <BUGE> }
*/ public String get(final String name) { <BUGS> if (mapping == null) { <BUGE> throw new IllegalStateException( "No header mapping was specified, the record values can't be accessed by name"); } final Integer index = mapping.get(name); return index != null ? values[index.intValue()] : null; }
*/ public String get(final String name) { if (mapping == null) { throw new IllegalStateException( "No header mapping was specified, the record values can't be accessed by name"); } <BUGS> final Integer index = mapping.get(name); return index != null ? values[index.intValue()] : null; <BUGE> }
*/ public Map<String, Integer> getHeaderMap() { <BUGS> return new LinkedHashMap<String, Integer>(this.headerMap); <BUGE> }
*/ public String format(final Object... values) { <BUGS> final StringWriter out = new StringWriter(); <BUGE> try { new CSVPrinter(out, this).printRecord(values); return out.toString().trim(); } catch (final IOException e) { /* should not happen because a StringWriter does not do IO.*/ throw new IllegalStateException(e); } }
*/ public String format(final Object... values) { final StringWriter out = new StringWriter(); try { <BUGS> new CSVPrinter(out, this).printRecord(values); return out.toString().trim(); <BUGE> } catch (final IOException e) { /* should not happen because a StringWriter does not do IO.*/ throw new IllegalStateException(e); } }
*/ public Map<String, String> toMap() { <BUGS> return putIn(new HashMap<String, String>(values.length)); <BUGE> }
*/ private Map<String, Integer> initializeHeader() throws IOException { <BUGS> Map<String, Integer> hdrMap = null; final String[] formatHeader = this.format.getHeader(); if (formatHeader != null) { hdrMap = new LinkedHashMap<String, Integer>(); <BUGE>  String[] header = null; if (formatHeader.length == 0) { /* read the header from the first line of the file*/ final CSVRecord nextRecord = this.nextRecord(); if (nextRecord != null) { header = nextRecord.values(); } } else { if (this.format.getSkipHeaderRecord()) { this.nextRecord(); } header = formatHeader; }  /* build the name to index mappings*/ if (header != null) { for (int i = 0; i < header.length; i++) { hdrMap.put(header[i], Integer.valueOf(i)); } } } return hdrMap; }
*/ private Map<String, Integer> initializeHeader() throws IOException { Map<String, Integer> hdrMap = null; final String[] formatHeader = this.format.getHeader(); if (formatHeader != null) { hdrMap = new LinkedHashMap<String, Integer>();  <BUGS> String[] header = null; if (formatHeader.length == 0) { <BUGE> /* read the header from the first line of the file*/ final CSVRecord nextRecord = this.nextRecord(); if (nextRecord != null) { header = nextRecord.values(); } } else { if (this.format.getSkipHeaderRecord()) { this.nextRecord(); } header = formatHeader; }  /* build the name to index mappings*/ if (header != null) { for (int i = 0; i < header.length; i++) { hdrMap.put(header[i], Integer.valueOf(i)); } } } return hdrMap; }
*/ private Map<String, Integer> initializeHeader() throws IOException { Map<String, Integer> hdrMap = null; final String[] formatHeader = this.format.getHeader(); if (formatHeader != null) { hdrMap = new LinkedHashMap<String, Integer>();  String[] header = null; if (formatHeader.length == 0) { /* read the header from the first line of the file*/ <BUGS> final CSVRecord nextRecord = this.nextRecord(); if (nextRecord != null) { header = nextRecord.values(); <BUGE> } } else { if (this.format.getSkipHeaderRecord()) { this.nextRecord(); } header = formatHeader; }  /* build the name to index mappings*/ if (header != null) { for (int i = 0; i < header.length; i++) { hdrMap.put(header[i], Integer.valueOf(i)); } } } return hdrMap; }
*/ private Map<String, Integer> initializeHeader() throws IOException { Map<String, Integer> hdrMap = null; final String[] formatHeader = this.format.getHeader(); if (formatHeader != null) { hdrMap = new LinkedHashMap<String, Integer>();  String[] header = null; if (formatHeader.length == 0) { /* read the header from the first line of the file*/ final CSVRecord nextRecord = this.nextRecord(); if (nextRecord != null) { header = nextRecord.values(); } <BUGS> } else { <BUGE> if (this.format.getSkipHeaderRecord()) { this.nextRecord(); } header = formatHeader; }  /* build the name to index mappings*/ if (header != null) { for (int i = 0; i < header.length; i++) { hdrMap.put(header[i], Integer.valueOf(i)); } } } return hdrMap; }
*/ private Map<String, Integer> initializeHeader() throws IOException { Map<String, Integer> hdrMap = null; final String[] formatHeader = this.format.getHeader(); if (formatHeader != null) { hdrMap = new LinkedHashMap<String, Integer>();  String[] header = null; if (formatHeader.length == 0) { /* read the header from the first line of the file*/ final CSVRecord nextRecord = this.nextRecord(); if (nextRecord != null) { header = nextRecord.values(); } } else { if (this.format.getSkipHeaderRecord()) { this.nextRecord(); } header = formatHeader; }  /* build the name to index mappings*/ <BUGS> if (header != null) { for (int i = 0; i < header.length; i++) { hdrMap.put(header[i], Integer.valueOf(i)); <BUGE> } } } return hdrMap; }
*/ private Map<String, Integer> initializeHeader() throws IOException { Map<String, Integer> hdrMap = null; final String[] formatHeader = this.format.getHeader(); if (formatHeader != null) { hdrMap = new LinkedHashMap<String, Integer>();  String[] header = null; if (formatHeader.length == 0) { /* read the header from the first line of the file*/ final CSVRecord nextRecord = this.nextRecord(); if (nextRecord != null) { header = nextRecord.values(); } } else { if (this.format.getSkipHeaderRecord()) { this.nextRecord(); } header = formatHeader; }  /* build the name to index mappings*/ if (header != null) { for (int i = 0; i < header.length; i++) { hdrMap.put(header[i], Integer.valueOf(i)); } } } <BUGS> return hdrMap; <BUGE> }
*/ public Map<String, String> toMap() { <BUGS> return putIn(new HashMap<String, String>(values.length)); <BUGE> }
private void print(final Object object, final CharSequence value, final int offset, final int len) throws IOException { <BUGS> if (!newRecord) { out.append(format.getDelimiter()); <BUGE> } if (format.isQuoting()) { /* the original object is needed so can check for Number*/ printAndQuote(object, value, offset, len); } else if (format.isEscaping()) { printAndEscape(value, offset, len); } else { out.append(value, offset, offset + len); } newRecord = false; }
private void print(final Object object, final CharSequence value, final int offset, final int len) throws IOException { if (!newRecord) { out.append(format.getDelimiter()); } <BUGS> if (format.isQuoting()) { <BUGE> /* the original object is needed so can check for Number*/ printAndQuote(object, value, offset, len); } else if (format.isEscaping()) { printAndEscape(value, offset, len); } else { out.append(value, offset, offset + len); } newRecord = false; }
private void print(final Object object, final CharSequence value, final int offset, final int len) throws IOException { if (!newRecord) { out.append(format.getDelimiter()); } if (format.isQuoting()) { /* the original object is needed so can check for Number*/ printAndQuote(object, value, offset, len); <BUGS> } else if (format.isEscaping()) { <BUGE> printAndEscape(value, offset, len); } else { out.append(value, offset, offset + len); } newRecord = false; }
private void print(final Object object, final CharSequence value, final int offset, final int len) throws IOException { if (!newRecord) { out.append(format.getDelimiter()); } if (format.isQuoting()) { /* the original object is needed so can check for Number*/ printAndQuote(object, value, offset, len); } else if (format.isEscaping()) { printAndEscape(value, offset, len); } else { <BUGS> out.append(value, offset, offset + len); <BUGE> } newRecord = false; }
private void print(final Object object, final CharSequence value, final int offset, final int len) throws IOException { if (!newRecord) { out.append(format.getDelimiter()); } if (format.isQuoting()) { /* the original object is needed so can check for Number*/ printAndQuote(object, value, offset, len); } else if (format.isEscaping()) { printAndEscape(value, offset, len); } else { out.append(value, offset, offset + len); } <BUGS> newRecord = false; } <BUGE>
*/ public CSVFormat withIgnoreEmptyHeaders(final boolean ignoreEmptyHeaders) { <BUGS> return new CSVFormat(delimiter, quoteChar, quotePolicy, commentStart, escape, <BUGE> ignoreSurroundingSpaces, ignoreEmptyHeaders, recordSeparator, nullString, header, skipHeaderRecord, ignoreEmptyHeaders); }
*/ private Map<String, Integer> initializeHeader() throws IOException { <BUGS> Map<String, Integer> hdrMap = null; final String[] formatHeader = this.format.getHeader(); if (formatHeader != null) { hdrMap = new LinkedHashMap<String, Integer>(); <BUGE>  String[] headerRecord = null; if (formatHeader.length == 0) { /* read the header from the first line of the file*/ final CSVRecord nextRecord = this.nextRecord(); if (nextRecord != null) { headerRecord = nextRecord.values(); } } else { if (this.format.getSkipHeaderRecord()) { this.nextRecord(); } headerRecord = formatHeader; }  /* build the name to index mappings*/ if (headerRecord != null) { for (int i = 0; i < headerRecord.length; i++) { final String header = headerRecord[i]; final boolean containsHeader = hdrMap.containsKey(header); final boolean emptyHeader = header == null || header.trim().isEmpty(); if (containsHeader && (!emptyHeader || (emptyHeader && !this.format.getAllowMissingColumnNames()))) { throw new IllegalArgumentException("The header contains a duplicate name: \"" + header +
*/ private Map<String, Integer> initializeHeader() throws IOException { Map<String, Integer> hdrMap = null; final String[] formatHeader = this.format.getHeader(); if (formatHeader != null) { hdrMap = new LinkedHashMap<String, Integer>();  <BUGS> String[] headerRecord = null; if (formatHeader.length == 0) { <BUGE> /* read the header from the first line of the file*/ final CSVRecord nextRecord = this.nextRecord(); if (nextRecord != null) { headerRecord = nextRecord.values(); } } else { if (this.format.getSkipHeaderRecord()) { this.nextRecord(); } headerRecord = formatHeader; }  /* build the name to index mappings*/ if (headerRecord != null) { for (int i = 0; i < headerRecord.length; i++) { final String header = headerRecord[i]; final boolean containsHeader = hdrMap.containsKey(header); final boolean emptyHeader = header == null || header.trim().isEmpty(); if (containsHeader && (!emptyHeader || (emptyHeader && !this.format.getAllowMissingColumnNames()))) { throw new IllegalArgumentException("The header contains a duplicate name: \"" + header +
*/ private Map<String, Integer> initializeHeader() throws IOException { Map<String, Integer> hdrMap = null; final String[] formatHeader = this.format.getHeader(); if (formatHeader != null) { hdrMap = new LinkedHashMap<String, Integer>();  String[] headerRecord = null; if (formatHeader.length == 0) { /* read the header from the first line of the file*/ <BUGS> final CSVRecord nextRecord = this.nextRecord(); if (nextRecord != null) { headerRecord = nextRecord.values(); <BUGE> } } else { if (this.format.getSkipHeaderRecord()) { this.nextRecord(); } headerRecord = formatHeader; }  /* build the name to index mappings*/ if (headerRecord != null) { for (int i = 0; i < headerRecord.length; i++) { final String header = headerRecord[i]; final boolean containsHeader = hdrMap.containsKey(header); final boolean emptyHeader = header == null || header.trim().isEmpty(); if (containsHeader && (!emptyHeader || (emptyHeader && !this.format.getAllowMissingColumnNames()))) { throw new IllegalArgumentException("The header contains a duplicate name: \"" + header +
*/ private Map<String, Integer> initializeHeader() throws IOException { Map<String, Integer> hdrMap = null; final String[] formatHeader = this.format.getHeader(); if (formatHeader != null) { hdrMap = new LinkedHashMap<String, Integer>();  String[] headerRecord = null; if (formatHeader.length == 0) { /* read the header from the first line of the file*/ final CSVRecord nextRecord = this.nextRecord(); if (nextRecord != null) { headerRecord = nextRecord.values(); } <BUGS> } else { <BUGE> if (this.format.getSkipHeaderRecord()) { this.nextRecord(); } headerRecord = formatHeader; }  /* build the name to index mappings*/ if (headerRecord != null) { for (int i = 0; i < headerRecord.length; i++) { final String header = headerRecord[i]; final boolean containsHeader = hdrMap.containsKey(header); final boolean emptyHeader = header == null || header.trim().isEmpty(); if (containsHeader && (!emptyHeader || (emptyHeader && !this.format.getAllowMissingColumnNames()))) { throw new IllegalArgumentException("The header contains a duplicate name: \"" + header +
*/ private Map<String, Integer> initializeHeader() throws IOException { Map<String, Integer> hdrMap = null; final String[] formatHeader = this.format.getHeader(); if (formatHeader != null) { hdrMap = new LinkedHashMap<String, Integer>();  String[] headerRecord = null; if (formatHeader.length == 0) { /* read the header from the first line of the file*/ final CSVRecord nextRecord = this.nextRecord(); if (nextRecord != null) { headerRecord = nextRecord.values(); } } else { if (this.format.getSkipHeaderRecord()) { this.nextRecord(); } headerRecord = formatHeader; }  /* build the name to index mappings*/ <BUGS> if (headerRecord != null) { for (int i = 0; i < headerRecord.length; i++) { final String header = headerRecord[i]; final boolean containsHeader = hdrMap.containsKey(header); final boolean emptyHeader = header == null || header.trim().isEmpty(); if (containsHeader && <BUGE> (!emptyHeader || (emptyHeader && !this.format.getAllowMissingColumnNames()))) { throw new IllegalArgumentException("The header contains a duplicate name: \"" + header +
*/ private Map<String, Integer> initializeHeader() throws IOException { Map<String, Integer> hdrMap = null; final String[] formatHeader = this.format.getHeader(); if (formatHeader != null) { hdrMap = new LinkedHashMap<String, Integer>();  String[] headerRecord = null; if (formatHeader.length == 0) { /* read the header from the first line of the file*/ final CSVRecord nextRecord = this.nextRecord(); if (nextRecord != null) { headerRecord = nextRecord.values(); } } else { if (this.format.getSkipHeaderRecord()) { this.nextRecord(); } headerRecord = formatHeader; }  /* build the name to index mappings*/ if (headerRecord != null) { for (int i = 0; i < headerRecord.length; i++) { final String header = headerRecord[i]; final boolean containsHeader = hdrMap.containsKey(header); final boolean emptyHeader = header == null || header.trim().isEmpty(); if (containsHeader && (!emptyHeader || (emptyHeader && !this.format.getAllowMissingColumnNames()))) { <BUGS> throw new IllegalArgumentException("The header contains a duplicate name: \"" + header + <BUGE>
public List<CSVRecord> getRecords() throws IOException { CSVRecord rec; List<CSVRecord> records = new ArrayList<CSVRecord>(); while ((rec = this.nextRecord()) != null) { records.add(rec); } return records; }  /** * Initializes the name to index mapping if the format defines a header. * * @return null if the format has no header. * @throws IOException if there is a problem reading the header or skipping the first record } <BUGS> hdrMap.put(header, Integer.valueOf(i)); <BUGE> } } } return hdrMap; }  public boolean isClosed() { return this.lexer.isClosed(); }  /** * Returns an iterator on the records. * * <p>IOExceptions occurring during the iteration are wrapped in a
/* the original object is needed so can check for Number*/ private void printAndQuote(final Object object, final CharSequence value, final int offset, final int len) throws IOException { <BUGS> boolean quote = false; int start = offset; int pos = offset; final int end = offset + len; <BUGE>  final char delimChar = format.getDelimiter(); final char quoteChar = format.getQuoteCharacter().charValue();  QuoteMode quoteModePolicy = format.getQuoteMode(); if (quoteModePolicy == null) { quoteModePolicy = QuoteMode.MINIMAL; } switch (quoteModePolicy) { case ALL: quote = true; break; case NON_NUMERIC: quote = !(object instanceof Number); break; case NONE: /* Use the existing escaping code*/ printAndEscape(value, offset, len); return; case MINIMAL: if (len <= 0) { /* always quote an empty token that is the first*/ /* on the line, as it may be the only thing on the*/
/* the original object is needed so can check for Number*/ private void printAndQuote(final Object object, final CharSequence value, final int offset, final int len) throws IOException { boolean quote = false; int start = offset; int pos = offset; final int end = offset + len;  <BUGS> final char delimChar = format.getDelimiter(); final char quoteChar = format.getQuoteCharacter().charValue(); <BUGE>  QuoteMode quoteModePolicy = format.getQuoteMode(); if (quoteModePolicy == null) { quoteModePolicy = QuoteMode.MINIMAL; } switch (quoteModePolicy) { case ALL: quote = true; break; case NON_NUMERIC: quote = !(object instanceof Number); break; case NONE: /* Use the existing escaping code*/ printAndEscape(value, offset, len); return; case MINIMAL: if (len <= 0) { /* always quote an empty token that is the first*/ /* on the line, as it may be the only thing on the*/
/* the original object is needed so can check for Number*/ private void printAndQuote(final Object object, final CharSequence value, final int offset, final int len) throws IOException { boolean quote = false; int start = offset; int pos = offset; final int end = offset + len;  final char delimChar = format.getDelimiter(); final char quoteChar = format.getQuoteCharacter().charValue();  <BUGS> QuoteMode quoteModePolicy = format.getQuoteMode(); if (quoteModePolicy == null) { <BUGE> quoteModePolicy = QuoteMode.MINIMAL; } switch (quoteModePolicy) { case ALL: quote = true; break; case NON_NUMERIC: quote = !(object instanceof Number); break; case NONE: /* Use the existing escaping code*/ printAndEscape(value, offset, len); return; case MINIMAL: if (len <= 0) { /* always quote an empty token that is the first*/ /* on the line, as it may be the only thing on the*/
/* the original object is needed so can check for Number*/ private void printAndQuote(final Object object, final CharSequence value, final int offset, final int len) throws IOException { boolean quote = false; int start = offset; int pos = offset; final int end = offset + len;  final char delimChar = format.getDelimiter(); final char quoteChar = format.getQuoteCharacter().charValue();  QuoteMode quoteModePolicy = format.getQuoteMode(); if (quoteModePolicy == null) { quoteModePolicy = QuoteMode.MINIMAL; } <BUGS> switch (quoteModePolicy) { <BUGE> case ALL: quote = true; break; case NON_NUMERIC: quote = !(object instanceof Number); break; case NONE: /* Use the existing escaping code*/ printAndEscape(value, offset, len); return; case MINIMAL: if (len <= 0) { /* always quote an empty token that is the first*/ /* on the line, as it may be the only thing on the*/
/* the original object is needed so can check for Number*/ private void printAndQuote(final Object object, final CharSequence value, final int offset, final int len) throws IOException { boolean quote = false; int start = offset; int pos = offset; final int end = offset + len;  final char delimChar = format.getDelimiter(); final char quoteChar = format.getQuoteCharacter().charValue();  QuoteMode quoteModePolicy = format.getQuoteMode(); if (quoteModePolicy == null) { quoteModePolicy = QuoteMode.MINIMAL; } switch (quoteModePolicy) { case ALL: quote = true; break; case NON_NUMERIC: <BUGS> quote = !(object instanceof Number); break; <BUGE> case NONE: /* Use the existing escaping code*/ printAndEscape(value, offset, len); return; case MINIMAL: if (len <= 0) { /* always quote an empty token that is the first*/ /* on the line, as it may be the only thing on the*/
}  pos++; }  /* write last segment*/ if (pos > start) { out.append(value, start, pos); } }  /* * Note: must only be called if quoting is enabled, otherwise will generate NPE */  <BUGS> if (!quote) { <BUGE> /* no encapsulation needed - write out the original value*/ out.append(value, start, end); return; }  /* we hit something that needed encapsulation*/ out.append(quoteChar);  /* Pick up where we left off: pos should be positioned on the first character that caused*/ /* the need for encapsulation.*/ while (pos < end) { final char c = value.charAt(pos); if (c == quoteChar) { /* write out the chunk up until this point*/
}  pos++; }  /* write last segment*/ if (pos > start) { out.append(value, start, pos); } }  /* * Note: must only be called if quoting is enabled, otherwise will generate NPE */ /* we hit something that needed encapsulation*/ <BUGS> out.append(quoteChar); <BUGE>  /* Pick up where we left off: pos should be positioned on the first character that caused*/ /* the need for encapsulation.*/ while (pos < end) { final char c = value.charAt(pos); if (c == quoteChar) { /* write out the chunk up until this point*/  /* add 1 to the length to write out the encapsulator also*/ out.append(value, start, pos + 1); /* put the next starting position on the encapsulator so we will*/ /* write it out again with the next string (effectively doubling it)*/ start = pos; }
pos++; }  /* write last segment*/ if (pos > start) { out.append(value, start, pos); } }  /* * Note: must only be called if quoting is enabled, otherwise will generate NPE */ /* the need for encapsulation.*/ <BUGS> while (pos < end) { final char c = value.charAt(pos); if (c == quoteChar) { <BUGE> /* write out the chunk up until this point*/  /* add 1 to the length to write out the encapsulator also*/ out.append(value, start, pos + 1); /* put the next starting position on the encapsulator so we will*/ /* write it out again with the next string (effectively doubling it)*/ start = pos; } pos++; }  /* write the last segment*/ out.append(value, start, pos);
}  pos++; }  /* write last segment*/ if (pos > start) { out.append(value, start, pos); } }  /* * Note: must only be called if quoting is enabled, otherwise will generate NPE */ } <BUGS> pos++; } <BUGE>  /* write the last segment*/ out.append(value, start, pos); out.append(quoteChar); }  /** * Prints a comment on a new line among the delimiter separated values. * * <p> * Comments will always begin on a new line and occupy a least one full line. The character specified to start * comments and a space will be inserted at the beginning of each new line in the comment. * </p>
pos++; }  /* write last segment*/ if (pos > start) { out.append(value, start, pos); } }  /* * Note: must only be called if quoting is enabled, otherwise will generate NPE */ /* write the last segment*/ <BUGS> out.append(value, start, pos); out.append(quoteChar); } <BUGE>  /** * Prints a comment on a new line among the delimiter separated values. * * <p> * Comments will always begin on a new line and occupy a least one full line. The character specified to start * comments and a space will be inserted at the beginning of each new line in the comment. * </p> * * If comments are disabled in the current CSV format this method does nothing. * * @param comment *            the comment to output
/* the original object is needed so can check for Number*/ private void printAndQuote(final Object object, final CharSequence value, final int offset, final int len, final Appendable out, final boolean newRecord) throws IOException { <BUGS> boolean quote = false; int start = offset; int pos = offset; final int end = offset + len; <BUGE>  final char delimChar = getDelimiter(); final char quoteChar = getQuoteCharacter().charValue();  QuoteMode quoteModePolicy = getQuoteMode(); if (quoteModePolicy == null) { quoteModePolicy = QuoteMode.MINIMAL; } switch (quoteModePolicy) { case ALL: quote = true; break; case NON_NUMERIC: quote = !(object instanceof Number); break; case NONE: /* Use the existing escaping code*/ printAndEscape(value, offset, len, out); return; case MINIMAL: if (len <= 0) { /* always quote an empty token that is the first*/ /* on the line, as it may be the only thing on the*/
/* the original object is needed so can check for Number*/ private void printAndQuote(final Object object, final CharSequence value, final int offset, final int len, final Appendable out, final boolean newRecord) throws IOException { boolean quote = false; int start = offset; int pos = offset; final int end = offset + len;  <BUGS> final char delimChar = getDelimiter(); final char quoteChar = getQuoteCharacter().charValue(); <BUGE>  QuoteMode quoteModePolicy = getQuoteMode(); if (quoteModePolicy == null) { quoteModePolicy = QuoteMode.MINIMAL; } switch (quoteModePolicy) { case ALL: quote = true; break; case NON_NUMERIC: quote = !(object instanceof Number); break; case NONE: /* Use the existing escaping code*/ printAndEscape(value, offset, len, out); return; case MINIMAL: if (len <= 0) { /* always quote an empty token that is the first*/ /* on the line, as it may be the only thing on the*/
/* the original object is needed so can check for Number*/ private void printAndQuote(final Object object, final CharSequence value, final int offset, final int len, final Appendable out, final boolean newRecord) throws IOException { boolean quote = false; int start = offset; int pos = offset; final int end = offset + len;  final char delimChar = getDelimiter(); final char quoteChar = getQuoteCharacter().charValue();  <BUGS> QuoteMode quoteModePolicy = getQuoteMode(); if (quoteModePolicy == null) { quoteModePolicy = QuoteMode.MINIMAL; <BUGE> } switch (quoteModePolicy) { case ALL: quote = true; break; case NON_NUMERIC: quote = !(object instanceof Number); break; case NONE: /* Use the existing escaping code*/ printAndEscape(value, offset, len, out); return; case MINIMAL: if (len <= 0) { /* always quote an empty token that is the first*/ /* on the line, as it may be the only thing on the*/
/* the original object is needed so can check for Number*/ private void printAndQuote(final Object object, final CharSequence value, final int offset, final int len, final Appendable out, final boolean newRecord) throws IOException { boolean quote = false; int start = offset; int pos = offset; final int end = offset + len;  final char delimChar = getDelimiter(); final char quoteChar = getQuoteCharacter().charValue();  QuoteMode quoteModePolicy = getQuoteMode(); if (quoteModePolicy == null) { quoteModePolicy = QuoteMode.MINIMAL; } <BUGS> switch (quoteModePolicy) { <BUGE> case ALL: quote = true; break; case NON_NUMERIC: quote = !(object instanceof Number); break; case NONE: /* Use the existing escaping code*/ printAndEscape(value, offset, len, out); return; case MINIMAL: if (len <= 0) { /* always quote an empty token that is the first*/ /* on the line, as it may be the only thing on the*/
/* the original object is needed so can check for Number*/ private void printAndQuote(final Object object, final CharSequence value, final int offset, final int len, final Appendable out, final boolean newRecord) throws IOException { boolean quote = false; int start = offset; int pos = offset; final int end = offset + len;  final char delimChar = getDelimiter(); final char quoteChar = getQuoteCharacter().charValue();  QuoteMode quoteModePolicy = getQuoteMode(); if (quoteModePolicy == null) { quoteModePolicy = QuoteMode.MINIMAL; } switch (quoteModePolicy) { case ALL: quote = true; break; case NON_NUMERIC: quote = !(object instanceof Number); break; case NONE: /* Use the existing escaping code*/ printAndEscape(value, offset, len, out); return; case MINIMAL: <BUGS> if (len <= 0) { <BUGE> /* always quote an empty token that is the first*/ /* on the line, as it may be the only thing on the*/
}  pos++; }  /* write last segment*/ if (pos > start) { out.append(value, start, pos); } }  /* * Note: must only be called if quoting is enabled, otherwise will generate NPE */ } else { <BUGS> char c = value.charAt(pos); <BUGE>  // RFC4180 (https:/*tools.ietf.org/html/rfc4180) TEXTDATA =  %x20-21 / %x23-2B / %x2D-7E*/ if (newRecord && (c < '0' || c > '9' && c < 'A' || c > 'Z' && c < 'a' || c > 'z')) { quote = true; } else if (c <= COMMENT) { /* Some other chars at the start of a value caused the parser to fail, so for now*/ /* encapsulate if we start in anything less than '#'. We are being conservative*/ /* by including the default comment char too.*/ quote = true; } else { while (pos < end) { c = value.charAt(pos); if (c == LF || c == CR || c == quoteChar || c == delimChar) { quote = true;
}  pos++; }  /* write last segment*/ if (pos > start) { out.append(value, start, pos); } }  /* * Note: must only be called if quoting is enabled, otherwise will generate NPE */ // RFC4180 (https:/*tools.ietf.org/html/rfc4180) TEXTDATA =  %x20-21 / %x23-2B / %x2D-7E*/ <BUGS> if (newRecord && (c < '0' || c > '9' && c < 'A' || c > 'Z' && c < 'a' || c > 'z')) { quote = true; <BUGE> } else if (c <= COMMENT) { /* Some other chars at the start of a value caused the parser to fail, so for now*/ /* encapsulate if we start in anything less than '#'. We are being conservative*/ /* by including the default comment char too.*/ quote = true; } else { while (pos < end) { c = value.charAt(pos); if (c == LF || c == CR || c == quoteChar || c == delimChar) { quote = true; break; } pos++;
}  pos++; }  /* write last segment*/ if (pos > start) { out.append(value, start, pos); } }  /* * Note: must only be called if quoting is enabled, otherwise will generate NPE */  <BUGS> if (!quote) { <BUGE> /* no encapsulation needed - write out the original value*/ out.append(value, start, end); return; } break; default: throw new IllegalStateException("Unexpected Quote value: " + quoteModePolicy); }  if (!quote) { /* no encapsulation needed - write out the original value*/ out.append(value, start, end); return; }
}  pos++; }  /* write last segment*/ if (pos > start) { out.append(value, start, pos); } }  /* * Note: must only be called if quoting is enabled, otherwise will generate NPE */  <BUGS> if (!quote) { <BUGE> /* no encapsulation needed - write out the original value*/ out.append(value, start, end); return; }  /* we hit something that needed encapsulation*/ out.append(quoteChar);  /* Pick up where we left off: pos should be positioned on the first character that caused*/ /* the need for encapsulation.*/ while (pos < end) { final char c = value.charAt(pos); if (c == quoteChar) { /* write out the chunk up until this point*/
}  pos++; }  /* write last segment*/ if (pos > start) { out.append(value, start, pos); } }  /* * Note: must only be called if quoting is enabled, otherwise will generate NPE */ /* we hit something that needed encapsulation*/ <BUGS> out.append(quoteChar); <BUGE>  /* Pick up where we left off: pos should be positioned on the first character that caused*/ /* the need for encapsulation.*/ while (pos < end) { final char c = value.charAt(pos); if (c == quoteChar) { /* write out the chunk up until this point*/  /* add 1 to the length to write out the encapsulator also*/ out.append(value, start, pos + 1); /* put the next starting position on the encapsulator so we will*/ /* write it out again with the next string (effectively doubling it)*/ start = pos; }
pos++; }  /* write last segment*/ if (pos > start) { out.append(value, start, pos); } }  /* * Note: must only be called if quoting is enabled, otherwise will generate NPE */ /* the need for encapsulation.*/ <BUGS> while (pos < end) { final char c = value.charAt(pos); if (c == quoteChar) { <BUGE> /* write out the chunk up until this point*/  /* add 1 to the length to write out the encapsulator also*/ out.append(value, start, pos + 1); /* put the next starting position on the encapsulator so we will*/ /* write it out again with the next string (effectively doubling it)*/ start = pos; } pos++; }  /* write the last segment*/ out.append(value, start, pos);
}  pos++; }  /* write last segment*/ if (pos > start) { out.append(value, start, pos); } }  /* * Note: must only be called if quoting is enabled, otherwise will generate NPE */ } <BUGS> pos++; } <BUGE>  /* write the last segment*/ out.append(value, start, pos); out.append(quoteChar); }  /** * Outputs the record separator. * * @param out *            where to write * @throws IOException *             If an I/O error occurs
pos++; }  /* write last segment*/ if (pos > start) { out.append(value, start, pos); } }  /* * Note: must only be called if quoting is enabled, otherwise will generate NPE */ /* write the last segment*/ <BUGS> out.append(value, start, pos); out.append(quoteChar); } <BUGE>  /** * Outputs the record separator. * * @param out *            where to write * @throws IOException *             If an I/O error occurs * @since 1.4 */ public void println(final Appendable out) throws IOException { if (getTrailingDelimiter()) { out.append(getDelimiter());
/* the original object is needed so can check for Number*/ private void printAndQuote(final Object object, final CharSequence value, final int offset, final int len, final Appendable out, final boolean newRecord) throws IOException { <BUGS> boolean quote = false; int start = offset; int pos = offset; final int end = offset + len; <BUGE>  final char delimChar = getDelimiter(); final char quoteChar = getQuoteCharacter().charValue();  QuoteMode quoteModePolicy = getQuoteMode(); if (quoteModePolicy == null) { quoteModePolicy = QuoteMode.MINIMAL; } switch (quoteModePolicy) { case ALL: case ALL_NON_NULL: quote = true; break; case NON_NUMERIC: quote = !(object instanceof Number); break; case NONE: /* Use the existing escaping code*/ printAndEscape(value, offset, len, out); return; case MINIMAL: if (len <= 0) { /* always quote an empty token that is the first*/
/* the original object is needed so can check for Number*/ private void printAndQuote(final Object object, final CharSequence value, final int offset, final int len, final Appendable out, final boolean newRecord) throws IOException { boolean quote = false; int start = offset; int pos = offset; final int end = offset + len;  <BUGS> final char delimChar = getDelimiter(); final char quoteChar = getQuoteCharacter().charValue(); <BUGE>  QuoteMode quoteModePolicy = getQuoteMode(); if (quoteModePolicy == null) { quoteModePolicy = QuoteMode.MINIMAL; } switch (quoteModePolicy) { case ALL: case ALL_NON_NULL: quote = true; break; case NON_NUMERIC: quote = !(object instanceof Number); break; case NONE: /* Use the existing escaping code*/ printAndEscape(value, offset, len, out); return; case MINIMAL: if (len <= 0) { /* always quote an empty token that is the first*/
/* the original object is needed so can check for Number*/ private void printAndQuote(final Object object, final CharSequence value, final int offset, final int len, final Appendable out, final boolean newRecord) throws IOException { boolean quote = false; int start = offset; int pos = offset; final int end = offset + len;  final char delimChar = getDelimiter(); final char quoteChar = getQuoteCharacter().charValue();  <BUGS> QuoteMode quoteModePolicy = getQuoteMode(); if (quoteModePolicy == null) { quoteModePolicy = QuoteMode.MINIMAL; <BUGE> } switch (quoteModePolicy) { case ALL: case ALL_NON_NULL: quote = true; break; case NON_NUMERIC: quote = !(object instanceof Number); break; case NONE: /* Use the existing escaping code*/ printAndEscape(value, offset, len, out); return; case MINIMAL: if (len <= 0) { /* always quote an empty token that is the first*/
/* the original object is needed so can check for Number*/ private void printAndQuote(final Object object, final CharSequence value, final int offset, final int len, final Appendable out, final boolean newRecord) throws IOException { boolean quote = false; int start = offset; int pos = offset; final int end = offset + len;  final char delimChar = getDelimiter(); final char quoteChar = getQuoteCharacter().charValue();  QuoteMode quoteModePolicy = getQuoteMode(); if (quoteModePolicy == null) { quoteModePolicy = QuoteMode.MINIMAL; } <BUGS> switch (quoteModePolicy) { <BUGE> case ALL: case ALL_NON_NULL: quote = true; break; case NON_NUMERIC: quote = !(object instanceof Number); break; case NONE: /* Use the existing escaping code*/ printAndEscape(value, offset, len, out); return; case MINIMAL: if (len <= 0) { /* always quote an empty token that is the first*/
/* the original object is needed so can check for Number*/ private void printAndQuote(final Object object, final CharSequence value, final int offset, final int len, final Appendable out, final boolean newRecord) throws IOException { boolean quote = false; int start = offset; int pos = offset; final int end = offset + len;  final char delimChar = getDelimiter(); final char quoteChar = getQuoteCharacter().charValue();  QuoteMode quoteModePolicy = getQuoteMode(); if (quoteModePolicy == null) { quoteModePolicy = QuoteMode.MINIMAL; } switch (quoteModePolicy) { case ALL: case ALL_NON_NULL: quote = true; break; case NON_NUMERIC: quote = !(object instanceof Number); break; case NONE: /* Use the existing escaping code*/ printAndEscape(value, offset, len, out); return; case MINIMAL: <BUGS> if (len <= 0) { <BUGE> /* always quote an empty token that is the first*/
}  pos++; }  /* write last segment*/ if (pos > start) { out.append(value, start, pos); } }  /* * Note: must only be called if quoting is enabled, otherwise will generate NPE */ } else { <BUGS> char c = value.charAt(pos); <BUGE>  if (newRecord && (c < 0x20 || c > 0x21 && c < 0x23 || c > 0x2B && c < 0x2D || c > 0x7E)) { quote = true; } else if (c <= COMMENT) { /* Some other chars at the start of a value caused the parser to fail, so for now*/ /* encapsulate if we start in anything less than '#'. We are being conservative*/ /* by including the default comment char too.*/ quote = true; } else { while (pos < end) { c = value.charAt(pos); if (c == LF || c == CR || c == quoteChar || c == delimChar) { quote = true; break;
pos++; }  /* write last segment*/ if (pos > start) { out.append(value, start, pos); } }  /* * Note: must only be called if quoting is enabled, otherwise will generate NPE */  <BUGS> if (newRecord && (c < 0x20 || c > 0x21 && c < 0x23 || c > 0x2B && c < 0x2D || c > 0x7E)) { quote = true; } else if (c <= COMMENT) { <BUGE> /* Some other chars at the start of a value caused the parser to fail, so for now*/ /* encapsulate if we start in anything less than '#'. We are being conservative*/ /* by including the default comment char too.*/ quote = true; } else { while (pos < end) { c = value.charAt(pos); if (c == LF || c == CR || c == quoteChar || c == delimChar) { quote = true; break; } pos++; }
pos++; }  /* write last segment*/ if (pos > start) { out.append(value, start, pos); } }  /* * Note: must only be called if quoting is enabled, otherwise will generate NPE */ } else { <BUGS> while (pos < end) { c = value.charAt(pos); if (c == LF || c == CR || c == quoteChar || c == delimChar) { <BUGE> quote = true; break; } pos++; }  if (!quote) { pos = end - 1; c = value.charAt(pos); /* Some other chars at the end caused the parser to fail, so for now*/ /* encapsulate if we end in anything less than ' '*/ if (c <= SP) { quote = true;
}  pos++; }  /* write last segment*/ if (pos > start) { out.append(value, start, pos); } }  /* * Note: must only be called if quoting is enabled, otherwise will generate NPE */ } <BUGS> pos++; <BUGE> }  if (!quote) { pos = end - 1; c = value.charAt(pos); /* Some other chars at the end caused the parser to fail, so for now*/ /* encapsulate if we end in anything less than ' '*/ if (c <= SP) { quote = true; } } } }
pos++; }  /* write last segment*/ if (pos > start) { out.append(value, start, pos); } }  /* * Note: must only be called if quoting is enabled, otherwise will generate NPE */  <BUGS> if (!quote) { pos = end - 1; c = value.charAt(pos); <BUGE> /* Some other chars at the end caused the parser to fail, so for now*/ /* encapsulate if we end in anything less than ' '*/ if (c <= SP) { quote = true; } } } }  if (!quote) { /* no encapsulation needed - write out the original value*/ out.append(value, start, end); return;
}  pos++; }  /* write last segment*/ if (pos > start) { out.append(value, start, pos); } }  /* * Note: must only be called if quoting is enabled, otherwise will generate NPE */ /* encapsulate if we end in anything less than ' '*/ <BUGS> if (c <= SP) { <BUGE> quote = true; } } } }  if (!quote) { /* no encapsulation needed - write out the original value*/ out.append(value, start, end); return; } break; default: throw new IllegalStateException("Unexpected Quote value: " + quoteModePolicy);
}  pos++; }  /* write last segment*/ if (pos > start) { out.append(value, start, pos); } }  /* * Note: must only be called if quoting is enabled, otherwise will generate NPE */  <BUGS> if (!quote) { <BUGE> /* no encapsulation needed - write out the original value*/ out.append(value, start, end); return; } break; default: throw new IllegalStateException("Unexpected Quote value: " + quoteModePolicy); }  if (!quote) { /* no encapsulation needed - write out the original value*/ out.append(value, start, end); return; }
}  pos++; }  /* write last segment*/ if (pos > start) { out.append(value, start, pos); } }  /* * Note: must only be called if quoting is enabled, otherwise will generate NPE */ /* no encapsulation needed - write out the original value*/ <BUGS> out.append(value, start, end); return; <BUGE> } break; default: throw new IllegalStateException("Unexpected Quote value: " + quoteModePolicy); }  if (!quote) { /* no encapsulation needed - write out the original value*/ out.append(value, start, end); return; }  /* we hit something that needed encapsulation*/
}  pos++; }  /* write last segment*/ if (pos > start) { out.append(value, start, pos); } }  /* * Note: must only be called if quoting is enabled, otherwise will generate NPE */  <BUGS> if (!quote) { <BUGE> /* no encapsulation needed - write out the original value*/ out.append(value, start, end); return; }  /* we hit something that needed encapsulation*/ out.append(quoteChar);  /* Pick up where we left off: pos should be positioned on the first character that caused*/ /* the need for encapsulation.*/ while (pos < end) { final char c = value.charAt(pos); if (c == quoteChar) { /* write out the chunk up until this point*/
}  pos++; }  /* write last segment*/ if (pos > start) { out.append(value, start, pos); } }  /* * Note: must only be called if quoting is enabled, otherwise will generate NPE */ /* we hit something that needed encapsulation*/ <BUGS> out.append(quoteChar); <BUGE>  /* Pick up where we left off: pos should be positioned on the first character that caused*/ /* the need for encapsulation.*/ while (pos < end) { final char c = value.charAt(pos); if (c == quoteChar) { /* write out the chunk up until this point*/  /* add 1 to the length to write out the encapsulator also*/ out.append(value, start, pos + 1); /* put the next starting position on the encapsulator so we will*/ /* write it out again with the next string (effectively doubling it)*/ start = pos; }
pos++; }  /* write last segment*/ if (pos > start) { out.append(value, start, pos); } }  /* * Note: must only be called if quoting is enabled, otherwise will generate NPE */ /* the need for encapsulation.*/ <BUGS> while (pos < end) { final char c = value.charAt(pos); if (c == quoteChar) { <BUGE> /* write out the chunk up until this point*/  /* add 1 to the length to write out the encapsulator also*/ out.append(value, start, pos + 1); /* put the next starting position on the encapsulator so we will*/ /* write it out again with the next string (effectively doubling it)*/ start = pos; } pos++; }  /* write the last segment*/ out.append(value, start, pos);
}  pos++; }  /* write last segment*/ if (pos > start) { out.append(value, start, pos); } }  /* * Note: must only be called if quoting is enabled, otherwise will generate NPE */ } <BUGS> pos++; } <BUGE>  /* write the last segment*/ out.append(value, start, pos); out.append(quoteChar); }  /** * Outputs the trailing delimiter (if set) followed by the record separator (if set). * * @param out *            where to write * @throws IOException *             If an I/O error occurs
pos++; }  /* write last segment*/ if (pos > start) { out.append(value, start, pos); } }  /* * Note: must only be called if quoting is enabled, otherwise will generate NPE */ /* write the last segment*/ <BUGS> out.append(value, start, pos); out.append(quoteChar); } <BUGE>  /** * Outputs the trailing delimiter (if set) followed by the record separator (if set). * * @param out *            where to write * @throws IOException *             If an I/O error occurs * @since 1.4 */ public void println(final Appendable out) throws IOException { if (getTrailingDelimiter()) { out.append(getDelimiter());
*/ public String get(final int i) { <BUGS> return values[i]; <BUGE> }
private String[] toStringArray(final Object[] values) { <BUGS> if (values == null) { return null; <BUGE> } final String[] strings = new String[values.length]; for (int i = 0; i < values.length; i++) { final Object value = values[i]; strings[i] = value == null ? null : value.toString(); } return strings; }
private String[] toStringArray(final Object[] values) { if (values == null) { return null; } <BUGS> final String[] strings = new String[values.length]; for (int i = 0; i < values.length; i++) { final Object value = values[i]; strings[i] = value == null ? null : value.toString(); <BUGE> } return strings; }
private String[] toStringArray(final Object[] values) { if (values == null) { return null; } final String[] strings = new String[values.length]; for (int i = 0; i < values.length; i++) { final Object value = values[i]; strings[i] = value == null ? null : value.toString(); } <BUGS> return strings; <BUGE> }
@Override public Map<String, Object> toMap(ResultSet rs) throws SQLException { <BUGS> Map<String, Object> result = new CaseInsensitiveHashMap(); ResultSetMetaData rsmd = rs.getMetaData(); int cols = rsmd.getColumnCount(); <BUGE>  for (int i = 1; i <= cols; i++) { String columnName = rsmd.getColumnLabel(i); if (null == columnName || 0 == columnName.length()) { columnName = rsmd.getColumnName(i); } result.put(columnName, rs.getObject(i)); }  return result; }
@Override public Map<String, Object> toMap(ResultSet rs) throws SQLException { Map<String, Object> result = new CaseInsensitiveHashMap(); ResultSetMetaData rsmd = rs.getMetaData(); int cols = rsmd.getColumnCount();  <BUGS> for (int i = 1; i <= cols; i++) { String columnName = rsmd.getColumnLabel(i); if (null == columnName || 0 == columnName.length()) { columnName = rsmd.getColumnName(i); <BUGE> } result.put(columnName, rs.getObject(i)); }  return result; }
@Override public Map<String, Object> toMap(ResultSet rs) throws SQLException { Map<String, Object> result = new CaseInsensitiveHashMap(); ResultSetMetaData rsmd = rs.getMetaData(); int cols = rsmd.getColumnCount();  for (int i = 1; i <= cols; i++) { String columnName = rsmd.getColumnLabel(i); if (null == columnName || 0 == columnName.length()) { columnName = rsmd.getColumnName(i); } <BUGS> result.put(columnName, rs.getObject(i)); <BUGE> }  return result; }
@Override public Map<String, Object> toMap(ResultSet rs) throws SQLException { Map<String, Object> result = new CaseInsensitiveHashMap(); ResultSetMetaData rsmd = rs.getMetaData(); int cols = rsmd.getColumnCount();  for (int i = 1; i <= cols; i++) { String columnName = rsmd.getColumnLabel(i); if (null == columnName || 0 == columnName.length()) { columnName = rsmd.getColumnName(i); } result.put(columnName, rs.getObject(i)); }  <BUGS> return result; <BUGE> }
*/ public synchronized void close() throws IOException { <BUGS> if (journalWriter == null) { <BUGE> return; /* already closed*/ } for (Entry entry : new ArrayList<Entry>(lruEntries.values())) { if (entry.currentEditor != null) { entry.currentEditor.abort(); } } trimToSize(); journalWriter.close(); journalWriter = null; }
*/ public synchronized void close() throws IOException { if (journalWriter == null) { return; /* already closed*/ } <BUGS> for (Entry entry : new ArrayList<Entry>(lruEntries.values())) { if (entry.currentEditor != null) { entry.currentEditor.abort(); <BUGE> } } trimToSize(); journalWriter.close(); journalWriter = null; }
*/ public synchronized void close() throws IOException { if (journalWriter == null) { return; /* already closed*/ } for (Entry entry : new ArrayList<Entry>(lruEntries.values())) { if (entry.currentEditor != null) { entry.currentEditor.abort(); } <BUGS> } trimToSize(); journalWriter.close(); journalWriter = null; } <BUGE>
*/ public synchronized void close() throws IOException { if (journalWriter == null) { return; /* already closed*/ } for (Entry entry : new ArrayList<Entry>(lruEntries.values())) { if (entry.currentEditor != null) { entry.currentEditor.abort(); } } trimToSize(); journalWriter.close(); journalWriter = null; }
*/ public synchronized void close() throws IOException { if (journalWriter == null) { return; /* already closed*/ } for (Entry entry : new ArrayList<Entry>(lruEntries.values())) { if (entry.currentEditor != null) { entry.currentEditor.abort(); } } trimToSize(); journalWriter.close(); journalWriter = null; }
private synchronized void completeEdit(Editor editor, boolean success) throws IOException { <BUGS> Entry entry = editor.entry; if (entry.currentEditor != editor) { <BUGE> throw new IllegalStateException(); }  /* if this edit is creating the entry for the first time, every index must have a value*/ if (success && !entry.readable) { for (int i = 0; i < valueCount; i++) { if (!editor.written[i]) { editor.abort(); throw new IllegalStateException("Newly created entry didn't create value for index " + i); } if (!entry.getDirtyFile(i).exists()) { editor.abort(); return; } } }  for (int i = 0; i < valueCount; i++) { File dirty = entry.getDirtyFile(i); if (success) { if (dirty.exists()) { File clean = entry.getCleanFile(i); dirty.renameTo(clean); long oldLength = entry.lengths[i]; long newLength = clean.length(); entry.lengths[i] = newLength;
private synchronized void completeEdit(Editor editor, boolean success) throws IOException { Entry entry = editor.entry; if (entry.currentEditor != editor) { throw new IllegalStateException(); }  /* if this edit is creating the entry for the first time, every index must have a value*/ <BUGS> if (success && !entry.readable) { for (int i = 0; i < valueCount; i++) { if (!editor.written[i]) { <BUGE> editor.abort(); throw new IllegalStateException("Newly created entry didn't create value for index " + i); } if (!entry.getDirtyFile(i).exists()) { editor.abort(); return; } } }  for (int i = 0; i < valueCount; i++) { File dirty = entry.getDirtyFile(i); if (success) { if (dirty.exists()) { File clean = entry.getCleanFile(i); dirty.renameTo(clean); long oldLength = entry.lengths[i]; long newLength = clean.length(); entry.lengths[i] = newLength;
private synchronized void completeEdit(Editor editor, boolean success) throws IOException { Entry entry = editor.entry; if (entry.currentEditor != editor) { throw new IllegalStateException(); }  /* if this edit is creating the entry for the first time, every index must have a value*/ if (success && !entry.readable) { for (int i = 0; i < valueCount; i++) { if (!editor.written[i]) { editor.abort(); throw new IllegalStateException("Newly created entry didn't create value for index " + i); } <BUGS> if (!entry.getDirtyFile(i).exists()) { editor.abort(); return; <BUGE> } } }  for (int i = 0; i < valueCount; i++) { File dirty = entry.getDirtyFile(i); if (success) { if (dirty.exists()) { File clean = entry.getCleanFile(i); dirty.renameTo(clean); long oldLength = entry.lengths[i]; long newLength = clean.length(); entry.lengths[i] = newLength;
private synchronized void completeEdit(Editor editor, boolean success) throws IOException { Entry entry = editor.entry; if (entry.currentEditor != editor) { throw new IllegalStateException(); }  /* if this edit is creating the entry for the first time, every index must have a value*/ if (success && !entry.readable) { for (int i = 0; i < valueCount; i++) { if (!editor.written[i]) { editor.abort(); throw new IllegalStateException("Newly created entry didn't create value for index " + i); } if (!entry.getDirtyFile(i).exists()) { editor.abort(); return; } } }  <BUGS> for (int i = 0; i < valueCount; i++) { File dirty = entry.getDirtyFile(i); if (success) { <BUGE> if (dirty.exists()) { File clean = entry.getCleanFile(i); dirty.renameTo(clean); long oldLength = entry.lengths[i]; long newLength = clean.length(); entry.lengths[i] = newLength;
*/ public synchronized void setMaxSize(long maxSize) { this.maxSize = maxSize; executorService.submit(cleanupCallable); }  /** * Returns the number of bytes currently being used to store the values in * this cache. This may be greater than the max size if a background * deletion is pending. */ public synchronized long size() { return size; } } else { <BUGS> deleteIfExists(dirty); <BUGE> } }  redundantOpCount++; entry.currentEditor = null; if (entry.readable | success) { entry.readable = true; journalWriter.write(CLEAN + ' ' + entry.key + entry.getLengths() + '\n'); if (success) { entry.sequenceNumber = nextSequenceNumber++; } } else { lruEntries.remove(entry.key); journalWriter.write(REMOVE + ' ' + entry.key + '\n');
public synchronized void setMaxSize(long maxSize) { this.maxSize = maxSize; executorService.submit(cleanupCallable); }  /** * Returns the number of bytes currently being used to store the values in * this cache. This may be greater than the max size if a background * deletion is pending. */ public synchronized long size() { return size; }  <BUGS> redundantOpCount++; entry.currentEditor = null; if (entry.readable | success) { <BUGE> entry.readable = true; journalWriter.write(CLEAN + ' ' + entry.key + entry.getLengths() + '\n'); if (success) { entry.sequenceNumber = nextSequenceNumber++; } } else { lruEntries.remove(entry.key); journalWriter.write(REMOVE + ' ' + entry.key + '\n'); }  if (size > maxSize || journalRebuildRequired()) { executorService.submit(cleanupCallable); }
*/ public synchronized void setMaxSize(long maxSize) { this.maxSize = maxSize; executorService.submit(cleanupCallable); }  /** * Returns the number of bytes currently being used to store the values in * this cache. This may be greater than the max size if a background * deletion is pending. */ public synchronized long size() { return size; } } else { <BUGS> lruEntries.remove(entry.key); journalWriter.write(REMOVE + ' ' + entry.key + '\n'); <BUGE> }  if (size > maxSize || journalRebuildRequired()) { executorService.submit(cleanupCallable); } }  /** * We only rebuild the journal when it will halve the size of the journal * and eliminate at least 2000 ops. */ private boolean journalRebuildRequired() { final int REDUNDANT_OP_COMPACT_THRESHOLD = 2000;
*/ public synchronized void setMaxSize(long maxSize) { this.maxSize = maxSize; executorService.submit(cleanupCallable); }  /** * Returns the number of bytes currently being used to store the values in * this cache. This may be greater than the max size if a background * deletion is pending. */ public synchronized long size() { return size; }  <BUGS> if (size > maxSize || journalRebuildRequired()) { <BUGE> executorService.submit(cleanupCallable); } }  /** * We only rebuild the journal when it will halve the size of the journal * and eliminate at least 2000 ops. */ private boolean journalRebuildRequired() { final int REDUNDANT_OP_COMPACT_THRESHOLD = 2000; return redundantOpCount >= REDUNDANT_OP_COMPACT_THRESHOLD && redundantOpCount >= lruEntries.size(); }
*/ public synchronized void setMaxSize(long maxSize) { this.maxSize = maxSize; executorService.submit(cleanupCallable); }  /** * Returns the number of bytes currently being used to store the values in * this cache. This may be greater than the max size if a background * deletion is pending. */ public synchronized long size() { return size; } } <BUGS> } <BUGE>  /** * We only rebuild the journal when it will halve the size of the journal * and eliminate at least 2000 ops. */ private boolean journalRebuildRequired() { final int REDUNDANT_OP_COMPACT_THRESHOLD = 2000; return redundantOpCount >= REDUNDANT_OP_COMPACT_THRESHOLD && redundantOpCount >= lruEntries.size(); }  /** * Drops the entry for {@code key} if it exists and can be removed. Entries * actively being edited cannot be removed.
private void validateKey(String key) { <BUGS> Matcher matcher = LEGAL_KEY_PATTERN.matcher(key); if (!matcher.matches()) { throw new IllegalArgumentException( <BUGE> "keys must match regex [a-z0-9_]{1,64}: \"" + key + "\""); } }
*/ private void processJournal() throws IOException { <BUGS> deleteIfExists(journalFileTmp); for (Iterator<Entry> i = lruEntries.values().iterator(); i.hasNext(); ) { Entry entry = i.next(); if (entry.currentEditor == null) { <BUGE> for (int t = 0; t < valueCount; t++) { size += entry.lengths[t]; } } else { entry.currentEditor = null; for (int t = 0; t < valueCount; t++) { deleteIfExists(entry.getCleanFile(t)); deleteIfExists(entry.getDirtyFile(t)); } i.remove(); } } }
*/ private void processJournal() throws IOException { deleteIfExists(journalFileTmp); for (Iterator<Entry> i = lruEntries.values().iterator(); i.hasNext(); ) { Entry entry = i.next(); if (entry.currentEditor == null) { for (int t = 0; t < valueCount; t++) { size += entry.lengths[t]; } } else { <BUGS> entry.currentEditor = null; for (int t = 0; t < valueCount; t++) { deleteIfExists(entry.getCleanFile(t)); deleteIfExists(entry.getDirtyFile(t)); <BUGE> } i.remove(); } } }
*/ private void processJournal() throws IOException { deleteIfExists(journalFileTmp); for (Iterator<Entry> i = lruEntries.values().iterator(); i.hasNext(); ) { Entry entry = i.next(); if (entry.currentEditor == null) { for (int t = 0; t < valueCount; t++) { size += entry.lengths[t]; } } else { entry.currentEditor = null; for (int t = 0; t < valueCount; t++) { deleteIfExists(entry.getCleanFile(t)); deleteIfExists(entry.getDirtyFile(t)); } <BUGS> i.remove(); <BUGE> } } }
*/ private void processJournal() throws IOException { deleteIfExists(journalFileTmp); for (Iterator<Entry> i = lruEntries.values().iterator(); i.hasNext(); ) { Entry entry = i.next(); if (entry.currentEditor == null) { for (int t = 0; t < valueCount; t++) { size += entry.lengths[t]; } } else { entry.currentEditor = null; for (int t = 0; t < valueCount; t++) { deleteIfExists(entry.getCleanFile(t)); deleteIfExists(entry.getDirtyFile(t)); } i.remove(); } <BUGS> } } <BUGE>
*/ public synchronized boolean remove(String key) throws IOException { <BUGS> checkNotClosed(); validateKey(key); Entry entry = lruEntries.get(key); if (entry == null || entry.currentEditor != null) { <BUGE> return false; }  for (int i = 0; i < valueCount; i++) { File file = entry.getCleanFile(i); if (!file.delete()) { throw new IOException("failed to delete " + file); } size -= entry.lengths[i]; entry.lengths[i] = 0; }  redundantOpCount++; journalWriter.append(REMOVE + ' ' + key + '\n'); lruEntries.remove(key);  if (journalRebuildRequired()) { executorService.submit(cleanupCallable); }  return true; }
*/ public synchronized boolean remove(String key) throws IOException { checkNotClosed(); validateKey(key); Entry entry = lruEntries.get(key); if (entry == null || entry.currentEditor != null) { return false; }  <BUGS> for (int i = 0; i < valueCount; i++) { File file = entry.getCleanFile(i); if (!file.delete()) { throw new IOException("failed to delete " + file); <BUGE> } size -= entry.lengths[i]; entry.lengths[i] = 0; }  redundantOpCount++; journalWriter.append(REMOVE + ' ' + key + '\n'); lruEntries.remove(key);  if (journalRebuildRequired()) { executorService.submit(cleanupCallable); }  return true; }
/** Set lengths using decimal numbers like "10123". */ private void setLengths(String[] strings) throws IOException { <BUGS> if (strings.length != valueCount) { throw invalidLengths(strings); <BUGE> }  try { for (int i = 0; i < strings.length; i++) { lengths[i] = Long.parseLong(strings[i]); } } catch (NumberFormatException e) { throw invalidLengths(strings); } }
@Override public Container create(final String image) throws IOException { <BUGS> return this.create( <BUGE> "", Json.createObjectBuilder() .add("Image", image) .build() ); }
@Override public Container create(final String image) throws IOException { return this.create( "", <BUGS> Json.createObjectBuilder() .add("Image", image) .build() <BUGE> ); }
@Override public Container create( final String name, final String image ) throws IOException { <BUGS> return this.create( <BUGE> name, Json.createObjectBuilder() .add("Image", image) .build() ); }
@Override public Container create( final String name, final String image ) throws IOException { return this.create( name, <BUGS> Json.createObjectBuilder() .add("Image", image) .build() <BUGE> ); }
/* @checkstyle ParameterNumber (3 lines)*/ public UnexpectedResponseException( final String endpoint, final int actualStatus, final int expectedStatus, final JsonObject body ) { /* @checkstyle LineLength (1 line)*/ <BUGS> super("Expected status " + expectedStatus + " but got " + actualStatus + " when calling " + endpoint); <BUGE> this.endpoint = endpoint; this.actualStatus = actualStatus; this.expectedStatus = expectedStatus; this.payload = body; }
@Override public void upgrade(final String remote, final JsonArray properties) throws IOException, UnexpectedResponseException { <BUGS> throw new UnsupportedOperationException( String.join(" ", <BUGE> "RtPlugin.upgrade() is not yet implemented.", "If you can contribute please", "do it here: https:/*www.github.com/amihaiemil/docker-java-api"*/ ) ); }
@Override public final Execs execs() { <BUGS> throw new UnsupportedOperationException( <BUGE> "Exec API is not yet implemented. If you can contribute please," + " do it here: https:/*www.github.com/amihaiemil/docker-java-api"*/ ); }
*/ public void addHeader(String name, String value) { <BUGS> if (EmailUtils.isEmpty(name)) <BUGE> { throw new IllegalArgumentException("name can not be null"); } if (EmailUtils.isEmpty(value)) { throw new IllegalArgumentException("value can not be null"); }  this.headers.put(name, createFoldedHeaderValue(name, value)); }
*/ public void addHeader(String name, String value) { if (EmailUtils.isEmpty(name)) { throw new IllegalArgumentException("name can not be null"); } <BUGS> if (EmailUtils.isEmpty(value)) <BUGE> { throw new IllegalArgumentException("value can not be null"); }  this.headers.put(name, createFoldedHeaderValue(name, value)); }
*/ public void addHeader(String name, String value) { if (EmailUtils.isEmpty(name)) { throw new IllegalArgumentException("name can not be null"); } if (EmailUtils.isEmpty(value)) { throw new IllegalArgumentException("value can not be null"); }  <BUGS> this.headers.put(name, createFoldedHeaderValue(name, value)); } <BUGE>
*/ public void setHeaders(Map<String, String> map) { <BUGS> this.headers.clear(); <BUGE>  Iterator<Map.Entry<String, String>> iterKeyBad = map.entrySet().iterator();  while (iterKeyBad.hasNext()) { Map.Entry<String, String> entry = iterKeyBad.next(); this.headers.put(entry.getKey(), entry.getValue()); }  }
*/ public void setHeaders(Map<String, String> map) { this.headers.clear();  <BUGS> Iterator<Map.Entry<String, String>> iterKeyBad = map.entrySet().iterator(); <BUGE>  while (iterKeyBad.hasNext()) { Map.Entry<String, String> entry = iterKeyBad.next(); this.headers.put(entry.getKey(), entry.getValue()); }  }
*/ public void setHeaders(Map<String, String> map) { this.headers.clear();  Iterator<Map.Entry<String, String>> iterKeyBad = map.entrySet().iterator();  <BUGS> while (iterKeyBad.hasNext()) <BUGE> { Map.Entry<String, String> entry = iterKeyBad.next(); this.headers.put(entry.getKey(), entry.getValue()); }  }
*/ public void setHeaders(Map<String, String> map) { this.headers.clear();  Iterator<Map.Entry<String, String>> iterKeyBad = map.entrySet().iterator();  while (iterKeyBad.hasNext()) { <BUGS> Map.Entry<String, String> entry = iterKeyBad.next(); this.headers.put(entry.getKey(), entry.getValue()); } <BUGE>  }
*/ public void setHeaders(Map<String, String> map) { this.headers.clear();  Iterator<Map.Entry<String, String>> iterKeyBad = map.entrySet().iterator();  while (iterKeyBad.hasNext()) { Map.Entry<String, String> entry = iterKeyBad.next(); this.headers.put(entry.getKey(), entry.getValue()); }  <BUGS> } <BUGE>
@Override public int hashCode() { <BUGS> int result = "TransformedGenerator".hashCode(); result <<= 2; result ^= getWrappedGenerator().hashCode(); result <<= 2; result ^= func.hashCode(); return result; <BUGE> }
@Override public String toString() { <BUGS> return "UnarySequence<" + list + ">"; <BUGE> }
public static String computeRepositoryId(String id) { <BUGS> Matcher matcher = REPOSITORY_PATTERN.matcher(id); if (matcher.matches()) { return matcher.group(3); <BUGE> } else { return id; } }
public static String computeRepositoryId(String id) { Matcher matcher = REPOSITORY_PATTERN.matcher(id); if (matcher.matches()) { return matcher.group(3); } else { <BUGS> return id; <BUGE> } }
public static String computeRepositoryId(String id) { <BUGS> Matcher matcher = REPOSITORY_PATTERN.matcher(id); if (matcher.matches()) { return matcher.group(3); <BUGE> } else { return id; } }
public static String computeRepositoryId(String id) { Matcher matcher = REPOSITORY_PATTERN.matcher(id); if (matcher.matches()) { return matcher.group(3); } else { <BUGS> return id; <BUGE> } }
*/ public static <V extends Vertex, E extends Edge> ColoredVertices<V> coloring( UndirectedGraph<V, E> g ) { <BUGS> final ColoredVertices<V> coloredVertices = new ColoredVertices<V>(); <BUGE>  /* decreasing sorting all vertices by degree.*/ final UncoloredOrderedVertices<V> uncoloredOrderedVertices = new UncoloredOrderedVertices<V>();  for ( V v : g.getVertices() ) { uncoloredOrderedVertices.addVertexDegree( v, g.getDegree( v ) ); }  /* search coloring*/ int currrentColorIndex = 0;  Iterator<V> it = uncoloredOrderedVertices.iterator(); while ( it.hasNext() ) { /* consume the vertex.*/ V v = it.next();  /* this list contains all vertex colore with the current color.*/ it.remove(); coloredVertices.addColor( v, currrentColorIndex );  /* we've found that 'uncoloredVtx' is adiacent to 'currentColoredVtx'*/ Iterator<V> it2 = uncoloredOrderedVertices.iterator(); while ( it2.hasNext() ) {
*/ public static <V extends Vertex, E extends Edge> ColoredVertices<V> coloring( UndirectedGraph<V, E> g ) { final ColoredVertices<V> coloredVertices = new ColoredVertices<V>();  /* decreasing sorting all vertices by degree.*/ <BUGS> final UncoloredOrderedVertices<V> uncoloredOrderedVertices = new UncoloredOrderedVertices<V>(); <BUGE>  for ( V v : g.getVertices() ) { uncoloredOrderedVertices.addVertexDegree( v, g.getDegree( v ) ); }  /* search coloring*/ int currrentColorIndex = 0;  Iterator<V> it = uncoloredOrderedVertices.iterator(); while ( it.hasNext() ) { /* consume the vertex.*/ V v = it.next();  /* this list contains all vertex colore with the current color.*/ it.remove(); coloredVertices.addColor( v, currrentColorIndex );  /* we've found that 'uncoloredVtx' is adiacent to 'currentColoredVtx'*/ Iterator<V> it2 = uncoloredOrderedVertices.iterator(); while ( it2.hasNext() ) {
*/ public static <V extends Vertex, E extends Edge> ColoredVertices<V> coloring( UndirectedGraph<V, E> g ) { final ColoredVertices<V> coloredVertices = new ColoredVertices<V>();  /* decreasing sorting all vertices by degree.*/ final UncoloredOrderedVertices<V> uncoloredOrderedVertices = new UncoloredOrderedVertices<V>();  <BUGS> for ( V v : g.getVertices() ) <BUGE> { uncoloredOrderedVertices.addVertexDegree( v, g.getDegree( v ) ); }  /* search coloring*/ int currrentColorIndex = 0;  Iterator<V> it = uncoloredOrderedVertices.iterator(); while ( it.hasNext() ) { /* consume the vertex.*/ V v = it.next();  /* this list contains all vertex colore with the current color.*/ it.remove(); coloredVertices.addColor( v, currrentColorIndex );  /* we've found that 'uncoloredVtx' is adiacent to 'currentColoredVtx'*/ Iterator<V> it2 = uncoloredOrderedVertices.iterator(); while ( it2.hasNext() ) {
*/ public static <V extends Vertex, E extends Edge> ColoredVertices<V> coloring( UndirectedGraph<V, E> g ) { final ColoredVertices<V> coloredVertices = new ColoredVertices<V>();  /* decreasing sorting all vertices by degree.*/ final UncoloredOrderedVertices<V> uncoloredOrderedVertices = new UncoloredOrderedVertices<V>();  for ( V v : g.getVertices() ) { <BUGS> uncoloredOrderedVertices.addVertexDegree( v, g.getDegree( v ) ); } <BUGE>  /* search coloring*/ int currrentColorIndex = 0;  Iterator<V> it = uncoloredOrderedVertices.iterator(); while ( it.hasNext() ) { /* consume the vertex.*/ V v = it.next();  /* this list contains all vertex colore with the current color.*/ it.remove(); coloredVertices.addColor( v, currrentColorIndex );  /* we've found that 'uncoloredVtx' is adiacent to 'currentColoredVtx'*/ Iterator<V> it2 = uncoloredOrderedVertices.iterator(); while ( it2.hasNext() ) {
*/ public static <V extends Vertex, E extends Edge> ColoredVertices<V> coloring( UndirectedGraph<V, E> g ) { final ColoredVertices<V> coloredVertices = new ColoredVertices<V>();  /* decreasing sorting all vertices by degree.*/ final UncoloredOrderedVertices<V> uncoloredOrderedVertices = new UncoloredOrderedVertices<V>();  for ( V v : g.getVertices() ) { uncoloredOrderedVertices.addVertexDegree( v, g.getDegree( v ) ); }  /* search coloring*/ <BUGS> int currrentColorIndex = 0; <BUGE>  Iterator<V> it = uncoloredOrderedVertices.iterator(); while ( it.hasNext() ) { /* consume the vertex.*/ V v = it.next();  /* this list contains all vertex colore with the current color.*/ it.remove(); coloredVertices.addColor( v, currrentColorIndex );  /* we've found that 'uncoloredVtx' is adiacent to 'currentColoredVtx'*/ Iterator<V> it2 = uncoloredOrderedVertices.iterator(); while ( it2.hasNext() ) {
*/ public static <V extends Vertex, E extends Edge> ColoredVertices<V> coloring( UndirectedGraph<V, E> g ) { final ColoredVertices<V> coloredVertices = new ColoredVertices<V>();  /* decreasing sorting all vertices by degree.*/ final UncoloredOrderedVertices<V> uncoloredOrderedVertices = new UncoloredOrderedVertices<V>();  for ( V v : g.getVertices() ) { uncoloredOrderedVertices.addVertexDegree( v, g.getDegree( v ) ); }  /* search coloring*/ int currrentColorIndex = 0;  <BUGS> Iterator<V> it = uncoloredOrderedVertices.iterator(); while ( it.hasNext() ) <BUGE> { /* consume the vertex.*/ V v = it.next();  /* this list contains all vertex colore with the current color.*/ it.remove(); coloredVertices.addColor( v, currrentColorIndex );  /* we've found that 'uncoloredVtx' is adiacent to 'currentColoredVtx'*/ Iterator<V> it2 = uncoloredOrderedVertices.iterator(); while ( it2.hasNext() ) {
*/ public static <V extends Vertex, E extends Edge> ColoredVertices<V> coloring( UndirectedGraph<V, E> g ) { final ColoredVertices<V> coloredVertices = new ColoredVertices<V>();  /* decreasing sorting all vertices by degree.*/ final UncoloredOrderedVertices<V> uncoloredOrderedVertices = new UncoloredOrderedVertices<V>();  for ( V v : g.getVertices() ) { uncoloredOrderedVertices.addVertexDegree( v, g.getDegree( v ) ); }  /* search coloring*/ int currrentColorIndex = 0;  Iterator<V> it = uncoloredOrderedVertices.iterator(); while ( it.hasNext() ) { /* consume the vertex.*/ <BUGS> V v = it.next(); <BUGE>  /* this list contains all vertex colore with the current color.*/ it.remove(); coloredVertices.addColor( v, currrentColorIndex );  /* we've found that 'uncoloredVtx' is adiacent to 'currentColoredVtx'*/ Iterator<V> it2 = uncoloredOrderedVertices.iterator(); while ( it2.hasNext() ) {
*/ public static <V extends Vertex, E extends Edge> ColoredVertices<V> coloring( UndirectedGraph<V, E> g ) { final ColoredVertices<V> coloredVertices = new ColoredVertices<V>();  /* decreasing sorting all vertices by degree.*/ final UncoloredOrderedVertices<V> uncoloredOrderedVertices = new UncoloredOrderedVertices<V>();  for ( V v : g.getVertices() ) { uncoloredOrderedVertices.addVertexDegree( v, g.getDegree( v ) ); }  /* search coloring*/ int currrentColorIndex = 0;  Iterator<V> it = uncoloredOrderedVertices.iterator(); while ( it.hasNext() ) { /* consume the vertex.*/ V v = it.next();  /* this list contains all vertex colore with the current color.*/ <BUGS> it.remove(); coloredVertices.addColor( v, currrentColorIndex ); <BUGE>  /* we've found that 'uncoloredVtx' is adiacent to 'currentColoredVtx'*/ Iterator<V> it2 = uncoloredOrderedVertices.iterator(); while ( it2.hasNext() ) {
*/ public static <V extends Vertex, E extends Edge> ColoredVertices<V> coloring( UndirectedGraph<V, E> g ) { final ColoredVertices<V> coloredVertices = new ColoredVertices<V>();  /* decreasing sorting all vertices by degree.*/ final UncoloredOrderedVertices<V> uncoloredOrderedVertices = new UncoloredOrderedVertices<V>();  for ( V v : g.getVertices() ) { uncoloredOrderedVertices.addVertexDegree( v, g.getDegree( v ) ); }  /* search coloring*/ int currrentColorIndex = 0;  Iterator<V> it = uncoloredOrderedVertices.iterator(); while ( it.hasNext() ) { /* consume the vertex.*/ V v = it.next();  /* this list contains all vertex colore with the current color.*/ it.remove(); coloredVertices.addColor( v, currrentColorIndex );  /* we've found that 'uncoloredVtx' is adiacent to 'currentColoredVtx'*/ <BUGS> Iterator<V> it2 = uncoloredOrderedVertices.iterator(); while ( it2.hasNext() ) <BUGE> {
/** * Contains the graph coloring implementation. This is a greedy implementation for the graph coloring problem. This * algorithm couldn't find the mimium coloring for the given graph since this is an NP-complete problem. <a * href="http:/*scienceblogs.com/goodmath/2007/06/graph_coloring_algorithms_1.php">*/ */ public final class GraphColoring {  /** * Colors the graph such that no two adjacent vertices share the same color. * * @param g The graph. * @return The color - vertex association. { <BUGS> V v2 = it2.next(); if ( g.getEdge( v, v2 ) == null ) <BUGE> { /* It's possible to color the vertex 'uncoloredVtx', it has no connected vertex into*/ /* 'currentcoloredvtx'*/ it2.remove(); coloredVertices.addColor( v2, currrentColorIndex ); } }  it = uncoloredOrderedVertices.iterator(); currrentColorIndex++; }  return coloredVertices;
/** * Contains the graph coloring implementation. This is a greedy implementation for the graph coloring problem. This * algorithm couldn't find the mimium coloring for the given graph since this is an NP-complete problem. <a * href="http:/*scienceblogs.com/goodmath/2007/06/graph_coloring_algorithms_1.php">*/ */ public final class GraphColoring {  /** * Colors the graph such that no two adjacent vertices share the same color. * * @param g The graph. * @return The color - vertex association. /* 'currentcoloredvtx'*/ <BUGS> it2.remove(); coloredVertices.addColor( v2, currrentColorIndex ); <BUGE> } }  it = uncoloredOrderedVertices.iterator(); currrentColorIndex++; }  return coloredVertices; }  /** * This class can not be instantiated. */
/** * Contains the graph coloring implementation. This is a greedy implementation for the graph coloring problem. This * algorithm couldn't find the mimium coloring for the given graph since this is an NP-complete problem. <a * href="http:/*scienceblogs.com/goodmath/2007/06/graph_coloring_algorithms_1.php">*/ */ public final class GraphColoring {  /** * Colors the graph such that no two adjacent vertices share the same color. * * @param g The graph. * @return The color - vertex association. } <BUGS> } <BUGE>  it = uncoloredOrderedVertices.iterator(); currrentColorIndex++; }  return coloredVertices; }  /** * This class can not be instantiated. */ private GraphColoring() { /* do nothing*/
/** * Contains the graph coloring implementation. This is a greedy implementation for the graph coloring problem. This * algorithm couldn't find the mimium coloring for the given graph since this is an NP-complete problem. <a * href="http:/*scienceblogs.com/goodmath/2007/06/graph_coloring_algorithms_1.php">*/ */ public final class GraphColoring {  /** * Colors the graph such that no two adjacent vertices share the same color. * * @param g The graph. * @return The color - vertex association.  <BUGS> it = uncoloredOrderedVertices.iterator(); currrentColorIndex++; } <BUGE>  return coloredVertices; }  /** * This class can not be instantiated. */ private GraphColoring() { /* do nothing*/ }  }
/** * Contains the graph coloring implementation. This is a greedy implementation for the graph coloring problem. This * algorithm couldn't find the mimium coloring for the given graph since this is an NP-complete problem. <a * href="http:/*scienceblogs.com/goodmath/2007/06/graph_coloring_algorithms_1.php">*/ */ public final class GraphColoring {  /** * Colors the graph such that no two adjacent vertices share the same color. * * @param g The graph. * @return The color - vertex association.  <BUGS> return coloredVertices; <BUGE> }  /** * This class can not be instantiated. */ private GraphColoring() { /* do nothing*/ }  }
*/ public int getSize() { <BUGS> return allEdges.size(); <BUGE> }
*/ public final void removeEdge( E e ) { <BUGS> checkGraphCondition( e != null, "Impossible to remove a null Edge from the Graph" ); <BUGE>   decorateRemoveEdge( e );  }
*/ public final void removeEdge( E e ) { checkGraphCondition( e != null, "Impossible to remove a null Edge from the Graph" );   <BUGS> decorateRemoveEdge( e ); <BUGE>  }
*/ public final void removeEdge( E e ) { checkGraphCondition( e != null, "Impossible to remove a null Edge from the Graph" );   decorateRemoveEdge( e );  <BUGS> } <BUGE>
protected static void checkGraphCondition( boolean expression, String errorMessageTemplate, Object...errorMessageArgs ) { <BUGS> if ( !expression ) <BUGE> { throw new GraphException( format( errorMessageTemplate, errorMessageArgs ) ); } }
protected static void checkGraphCondition( boolean expression, String errorMessageTemplate, Object...errorMessageArgs ) { if ( !expression ) { <BUGS> throw new GraphException( format( errorMessageTemplate, errorMessageArgs ) ); <BUGE> } }
protected static void checkGraphCondition( boolean expression, String errorMessageTemplate, Object...errorMessageArgs ) { if ( !expression ) { throw new GraphException( format( errorMessageTemplate, errorMessageArgs ) ); } <BUGS> } <BUGE>
@Override public void writeImage(BufferedImage src, OutputStream os, Map params) throws ImageWriteException, IOException { /* make copy of params; we'll clear keys as we consume them.*/ <BUGS> params = (params == null) ? new HashMap() : new HashMap(params); <BUGE>  PixelDensity pixelDensity = null;  /* clear format key.*/ if (params.containsKey(PARAM_KEY_FORMAT)) params.remove(PARAM_KEY_FORMAT); if (params.containsKey(PARAM_KEY_PIXEL_DENSITY)) pixelDensity = (PixelDensity) params .remove(PARAM_KEY_PIXEL_DENSITY);  if (params.size() > 0) { Object firstKey = params.keySet().iterator().next(); throw new ImageWriteException("Unknown parameter: " + firstKey); }  final SimplePalette palette = new PaletteFactory().makePaletteSimple( src, 256);  BmpWriter writer = null; if (palette == null) writer = new BmpWriterRgb(); else writer = new BmpWriterPalette(palette);  byte imagedata[] = writer.getImageData(src);
@Override public void writeImage(BufferedImage src, OutputStream os, Map params) throws ImageWriteException, IOException { /* make copy of params; we'll clear keys as we consume them.*/ params = (params == null) ? new HashMap() : new HashMap(params);  <BUGS> PixelDensity pixelDensity = null; <BUGE>  /* clear format key.*/ if (params.containsKey(PARAM_KEY_FORMAT)) params.remove(PARAM_KEY_FORMAT); if (params.containsKey(PARAM_KEY_PIXEL_DENSITY)) pixelDensity = (PixelDensity) params .remove(PARAM_KEY_PIXEL_DENSITY);  if (params.size() > 0) { Object firstKey = params.keySet().iterator().next(); throw new ImageWriteException("Unknown parameter: " + firstKey); }  final SimplePalette palette = new PaletteFactory().makePaletteSimple( src, 256);  BmpWriter writer = null; if (palette == null) writer = new BmpWriterRgb(); else writer = new BmpWriterPalette(palette);  byte imagedata[] = writer.getImageData(src);
@Override public void writeImage(BufferedImage src, OutputStream os, Map params) throws ImageWriteException, IOException { /* make copy of params; we'll clear keys as we consume them.*/ params = (params == null) ? new HashMap() : new HashMap(params);  PixelDensity pixelDensity = null;  /* clear format key.*/ <BUGS> if (params.containsKey(PARAM_KEY_FORMAT)) params.remove(PARAM_KEY_FORMAT); if (params.containsKey(PARAM_KEY_PIXEL_DENSITY)) pixelDensity = (PixelDensity) params .remove(PARAM_KEY_PIXEL_DENSITY); <BUGE>  if (params.size() > 0) { Object firstKey = params.keySet().iterator().next(); throw new ImageWriteException("Unknown parameter: " + firstKey); }  final SimplePalette palette = new PaletteFactory().makePaletteSimple( src, 256);  BmpWriter writer = null; if (palette == null) writer = new BmpWriterRgb(); else writer = new BmpWriterPalette(palette);  byte imagedata[] = writer.getImageData(src);
@Override public void writeImage(BufferedImage src, OutputStream os, Map params) throws ImageWriteException, IOException { /* make copy of params; we'll clear keys as we consume them.*/ params = (params == null) ? new HashMap() : new HashMap(params);  PixelDensity pixelDensity = null;  /* clear format key.*/ if (params.containsKey(PARAM_KEY_FORMAT)) params.remove(PARAM_KEY_FORMAT); if (params.containsKey(PARAM_KEY_PIXEL_DENSITY)) pixelDensity = (PixelDensity) params .remove(PARAM_KEY_PIXEL_DENSITY);  <BUGS> if (params.size() > 0) { <BUGE> Object firstKey = params.keySet().iterator().next(); throw new ImageWriteException("Unknown parameter: " + firstKey); }  final SimplePalette palette = new PaletteFactory().makePaletteSimple( src, 256);  BmpWriter writer = null; if (palette == null) writer = new BmpWriterRgb(); else writer = new BmpWriterPalette(palette);  byte imagedata[] = writer.getImageData(src);
@Override public void writeImage(BufferedImage src, OutputStream os, Map params) throws ImageWriteException, IOException { /* make copy of params; we'll clear keys as we consume them.*/ params = (params == null) ? new HashMap() : new HashMap(params);  PixelDensity pixelDensity = null;  /* clear format key.*/ if (params.containsKey(PARAM_KEY_FORMAT)) params.remove(PARAM_KEY_FORMAT); if (params.containsKey(PARAM_KEY_PIXEL_DENSITY)) pixelDensity = (PixelDensity) params .remove(PARAM_KEY_PIXEL_DENSITY);  if (params.size() > 0) { Object firstKey = params.keySet().iterator().next(); throw new ImageWriteException("Unknown parameter: " + firstKey); }  <BUGS> final SimplePalette palette = new PaletteFactory().makePaletteSimple( <BUGE> src, 256);  BmpWriter writer = null; if (palette == null) writer = new BmpWriterRgb(); else writer = new BmpWriterPalette(palette);  byte imagedata[] = writer.getImageData(src);
@Override public void writeImage(BufferedImage src, OutputStream os, Map params) throws ImageWriteException, IOException { /* make copy of params; we'll clear keys as we consume them.*/ params = (params == null) ? new HashMap() : new HashMap(params);  PixelDensity pixelDensity = null;  /* clear format key.*/ if (params.containsKey(PARAM_KEY_FORMAT)) params.remove(PARAM_KEY_FORMAT); if (params.containsKey(PARAM_KEY_PIXEL_DENSITY)) pixelDensity = (PixelDensity) params .remove(PARAM_KEY_PIXEL_DENSITY);  if (params.size() > 0) { Object firstKey = params.keySet().iterator().next(); throw new ImageWriteException("Unknown parameter: " + firstKey); }  final SimplePalette palette = new PaletteFactory().makePaletteSimple( src, 256);  <BUGS> BmpWriter writer = null; if (palette == null) <BUGE> writer = new BmpWriterRgb(); else writer = new BmpWriterPalette(palette);  byte imagedata[] = writer.getImageData(src);
@Override public void writeImage(BufferedImage src, OutputStream os, Map params) throws ImageWriteException, IOException { /* make copy of params; we'll clear keys as we consume them.*/ params = (params == null) ? new HashMap() : new HashMap(params);  PixelDensity pixelDensity = null;  /* clear format key.*/ if (params.containsKey(PARAM_KEY_FORMAT)) params.remove(PARAM_KEY_FORMAT); if (params.containsKey(PARAM_KEY_PIXEL_DENSITY)) pixelDensity = (PixelDensity) params .remove(PARAM_KEY_PIXEL_DENSITY);  if (params.size() > 0) { Object firstKey = params.keySet().iterator().next(); throw new ImageWriteException("Unknown parameter: " + firstKey); }  final SimplePalette palette = new PaletteFactory().makePaletteSimple( src, 256);  BmpWriter writer = null; if (palette == null) writer = new BmpWriterRgb(); else <BUGS> writer = new BmpWriterPalette(palette); <BUGE>  byte imagedata[] = writer.getImageData(src);
@Override public void writeImage(BufferedImage src, OutputStream os, Map params) throws ImageWriteException, IOException { /* make copy of params; we'll clear keys as we consume them.*/ params = (params == null) ? new HashMap() : new HashMap(params);  PixelDensity pixelDensity = null;  /* clear format key.*/ if (params.containsKey(PARAM_KEY_FORMAT)) params.remove(PARAM_KEY_FORMAT); if (params.containsKey(PARAM_KEY_PIXEL_DENSITY)) pixelDensity = (PixelDensity) params .remove(PARAM_KEY_PIXEL_DENSITY);  if (params.size() > 0) { Object firstKey = params.keySet().iterator().next(); throw new ImageWriteException("Unknown parameter: " + firstKey); }  final SimplePalette palette = new PaletteFactory().makePaletteSimple( src, 256);  BmpWriter writer = null; if (palette == null) writer = new BmpWriterRgb(); else writer = new BmpWriterPalette(palette);  <BUGS> byte imagedata[] = writer.getImageData(src);
System.out.println("width*height*4: " + width * height * 4); }  PixelParser pixelParser = ic.pixelParser; ImageBuilder imageBuilder = new ImageBuilder(width, height, true); pixelParser.processImage(imageBuilder);  return imageBuilder.getBufferedImage();  }  private static final int BITMAP_FILE_HEADER_SIZE = 14; private static final int BITMAP_INFO_HEADER_SIZE = 40;  /* write BitmapFileHeader*/ <BUGS> os.write(0x42); /* B, Windows 3.1x, 95, NT, Bitmap*/ os.write(0x4d); /* M <BUGE>*/  int filesize = BITMAP_FILE_HEADER_SIZE + BITMAP_INFO_HEADER_SIZE + /* header*/ /* size*/ 4 * writer.getPaletteSize() + /* palette size in bytes*/ imagedata.length; bos.write4Bytes(filesize);  bos.write4Bytes(0); /* reserved*/ bos.write4Bytes(BITMAP_FILE_HEADER_SIZE + BITMAP_INFO_HEADER_SIZE + 4 * writer.getPaletteSize()); /* Bitmap Data Offset*/ }  int width = src.getWidth();
System.out.println("width*height*4: " + width * height * 4); }  PixelParser pixelParser = ic.pixelParser; ImageBuilder imageBuilder = new ImageBuilder(width, height, true); pixelParser.processImage(imageBuilder);  return imageBuilder.getBufferedImage();  }  private static final int BITMAP_FILE_HEADER_SIZE = 14; private static final int BITMAP_INFO_HEADER_SIZE = 40;   <BUGS> int filesize = BITMAP_FILE_HEADER_SIZE + BITMAP_INFO_HEADER_SIZE + /* header <BUGE>*/ /* size*/ 4 * writer.getPaletteSize() + /* palette size in bytes*/ imagedata.length; bos.write4Bytes(filesize);  bos.write4Bytes(0); /* reserved*/ bos.write4Bytes(BITMAP_FILE_HEADER_SIZE + BITMAP_INFO_HEADER_SIZE + 4 * writer.getPaletteSize()); /* Bitmap Data Offset*/ }  int width = src.getWidth(); int height = src.getHeight();  { /* write BitmapInfoHeader*/
System.out.println("width*height*4: " + width * height * 4); }  PixelParser pixelParser = ic.pixelParser; ImageBuilder imageBuilder = new ImageBuilder(width, height, true); pixelParser.processImage(imageBuilder);  return imageBuilder.getBufferedImage();  }  private static final int BITMAP_FILE_HEADER_SIZE = 14; private static final int BITMAP_INFO_HEADER_SIZE = 40;  /* size*/ <BUGS> 4 * writer.getPaletteSize() + /* palette size in bytes <BUGE>*/ imagedata.length; bos.write4Bytes(filesize);  bos.write4Bytes(0); /* reserved*/ bos.write4Bytes(BITMAP_FILE_HEADER_SIZE + BITMAP_INFO_HEADER_SIZE + 4 * writer.getPaletteSize()); /* Bitmap Data Offset*/ }  int width = src.getWidth(); int height = src.getHeight();  { /* write BitmapInfoHeader*/ bos.write4Bytes(BITMAP_INFO_HEADER_SIZE); /* Bitmap Info Header Size*/ bos.write4Bytes(width); /* width*/
System.out.println("width*height*4: " + width * height * 4); }  PixelParser pixelParser = ic.pixelParser; ImageBuilder imageBuilder = new ImageBuilder(width, height, true); pixelParser.processImage(imageBuilder);  return imageBuilder.getBufferedImage();  }  private static final int BITMAP_FILE_HEADER_SIZE = 14; private static final int BITMAP_INFO_HEADER_SIZE = 40;  imagedata.length; <BUGS> bos.write4Bytes(filesize); <BUGE>  bos.write4Bytes(0); /* reserved*/ bos.write4Bytes(BITMAP_FILE_HEADER_SIZE + BITMAP_INFO_HEADER_SIZE + 4 * writer.getPaletteSize()); /* Bitmap Data Offset*/ }  int width = src.getWidth(); int height = src.getHeight();  { /* write BitmapInfoHeader*/ bos.write4Bytes(BITMAP_INFO_HEADER_SIZE); /* Bitmap Info Header Size*/ bos.write4Bytes(width); /* width*/ bos.write4Bytes(height); /* height*/ bos.write2Bytes(1); /* Number of Planes*/
}  PixelParser pixelParser = ic.pixelParser; ImageBuilder imageBuilder = new ImageBuilder(width, height, true); pixelParser.processImage(imageBuilder);  return imageBuilder.getBufferedImage();  }  private static final int BITMAP_FILE_HEADER_SIZE = 14; private static final int BITMAP_INFO_HEADER_SIZE = 40;   <BUGS> bos.write4Bytes(0); /* reserved*/ bos.write4Bytes(BITMAP_FILE_HEADER_SIZE + BITMAP_INFO_HEADER_SIZE + 4 * writer.getPaletteSize()); /* Bitmap Data Offset <BUGE>*/ }  int width = src.getWidth(); int height = src.getHeight();  { /* write BitmapInfoHeader*/ bos.write4Bytes(BITMAP_INFO_HEADER_SIZE); /* Bitmap Info Header Size*/ bos.write4Bytes(width); /* width*/ bos.write4Bytes(height); /* height*/ bos.write2Bytes(1); /* Number of Planes*/ bos.write2Bytes(writer.getBitsPerPixel()); /* Bits Per Pixel*/  bos.write4Bytes(BI_RGB); /* Compression*/
System.out.println("width*height*4: " + width * height * 4); }  PixelParser pixelParser = ic.pixelParser; ImageBuilder imageBuilder = new ImageBuilder(width, height, true); pixelParser.processImage(imageBuilder);  return imageBuilder.getBufferedImage();  }  private static final int BITMAP_FILE_HEADER_SIZE = 14; private static final int BITMAP_INFO_HEADER_SIZE = 40;   <BUGS> int width = src.getWidth(); int height = src.getHeight(); <BUGE>  { /* write BitmapInfoHeader*/ bos.write4Bytes(BITMAP_INFO_HEADER_SIZE); /* Bitmap Info Header Size*/ bos.write4Bytes(width); /* width*/ bos.write4Bytes(height); /* height*/ bos.write2Bytes(1); /* Number of Planes*/ bos.write2Bytes(writer.getBitsPerPixel()); /* Bits Per Pixel*/  bos.write4Bytes(BI_RGB); /* Compression*/ bos.write4Bytes(imagedata.length); /* Bitmap Data Size*/ bos.write4Bytes(pixelDensity != null ? (int) Math .round(pixelDensity.horizontalDensityMetres()) : 0); /* HResolution*/ bos.write4Bytes(pixelDensity != null ? (int) Math
PixelParser pixelParser = ic.pixelParser; ImageBuilder imageBuilder = new ImageBuilder(width, height, true); pixelParser.processImage(imageBuilder);  return imageBuilder.getBufferedImage();  }  private static final int BITMAP_FILE_HEADER_SIZE = 14; private static final int BITMAP_INFO_HEADER_SIZE = 40;  { /* write BitmapInfoHeader*/ <BUGS> bos.write4Bytes(BITMAP_INFO_HEADER_SIZE); /* Bitmap Info Header Size*/ bos.write4Bytes(width); /* width*/ bos.write4Bytes(height); /* height*/ bos.write2Bytes(1); /* Number of Planes*/ bos.write2Bytes(writer.getBitsPerPixel()); /* Bits Per Pixel <BUGE>*/  bos.write4Bytes(BI_RGB); /* Compression*/ bos.write4Bytes(imagedata.length); /* Bitmap Data Size*/ bos.write4Bytes(pixelDensity != null ? (int) Math .round(pixelDensity.horizontalDensityMetres()) : 0); /* HResolution*/ bos.write4Bytes(pixelDensity != null ? (int) Math .round(pixelDensity.verticalDensityMetres()) : 0); /* VResolution*/ if (palette == null) bos.write4Bytes(0); /* Colors*/ else bos.write4Bytes(palette.length()); /* Colors*/ bos.write4Bytes(0); /* Important Colors*/
PixelParser pixelParser = ic.pixelParser; ImageBuilder imageBuilder = new ImageBuilder(width, height, true); pixelParser.processImage(imageBuilder);  return imageBuilder.getBufferedImage();  }  private static final int BITMAP_FILE_HEADER_SIZE = 14; private static final int BITMAP_INFO_HEADER_SIZE = 40;   <BUGS> bos.write4Bytes(BI_RGB); /* Compression*/ bos.write4Bytes(imagedata.length); /* Bitmap Data Size*/ bos.write4Bytes(pixelDensity != null ? (int) Math .round(pixelDensity.horizontalDensityMetres()) : 0); /* HResolution*/ bos.write4Bytes(pixelDensity != null ? (int) Math .round(pixelDensity.verticalDensityMetres()) : 0); /* VResolution*/ if (palette == null) <BUGE> bos.write4Bytes(0); /* Colors*/ else bos.write4Bytes(palette.length()); /* Colors*/ bos.write4Bytes(0); /* Important Colors*/ // bos.write_4_bytes(0); /* Compression*/ }  { /* write Palette*/ writer.writePalette(bos); } { /* write Image Data*/
System.out.println("width*height*4: " + width * height * 4); }  PixelParser pixelParser = ic.pixelParser; ImageBuilder imageBuilder = new ImageBuilder(width, height, true); pixelParser.processImage(imageBuilder);  return imageBuilder.getBufferedImage();  }  private static final int BITMAP_FILE_HEADER_SIZE = 14; private static final int BITMAP_INFO_HEADER_SIZE = 40;  else <BUGS> bos.write4Bytes(palette.length()); /* Colors*/ bos.write4Bytes(0); /* Important Colors <BUGE>*/ // bos.write_4_bytes(0); /* Compression*/ }  { /* write Palette*/ writer.writePalette(bos); } { /* write Image Data*/ bos.writeByteArray(imagedata); } }  /** * Extracts embedded XML metadata as XML string.
System.out.println("width*height*4: " + width * height * 4); }  PixelParser pixelParser = ic.pixelParser; ImageBuilder imageBuilder = new ImageBuilder(width, height, true); pixelParser.processImage(imageBuilder);  return imageBuilder.getBufferedImage();  }  private static final int BITMAP_FILE_HEADER_SIZE = 14; private static final int BITMAP_INFO_HEADER_SIZE = 40;  { /* write Palette*/ <BUGS> writer.writePalette(bos); <BUGE> } { /* write Image Data*/ bos.writeByteArray(imagedata); } }  /** * Extracts embedded XML metadata as XML string. * <p> * * @param byteSource *            File containing image data. * @param params *            Map of optional parameters, defined in SanselanConstants.
System.out.println("width*height*4: " + width * height * 4); }  PixelParser pixelParser = ic.pixelParser; ImageBuilder imageBuilder = new ImageBuilder(width, height, true); pixelParser.processImage(imageBuilder);  return imageBuilder.getBufferedImage();  }  private static final int BITMAP_FILE_HEADER_SIZE = 14; private static final int BITMAP_INFO_HEADER_SIZE = 40;  { /* write Image Data*/ <BUGS> bos.writeByteArray(imagedata); <BUGE> } }  /** * Extracts embedded XML metadata as XML string. * <p> * * @param byteSource *            File containing image data. * @param params *            Map of optional parameters, defined in SanselanConstants. * @return Xmp Xml as String, if present. Otherwise, returns null. */ @Override
System.out.println("width*height*4: " + width * height * 4); }  PixelParser pixelParser = ic.pixelParser; ImageBuilder imageBuilder = new ImageBuilder(width, height, true); pixelParser.processImage(imageBuilder);  return imageBuilder.getBufferedImage();  }  private static final int BITMAP_FILE_HEADER_SIZE = 14; private static final int BITMAP_INFO_HEADER_SIZE = 40;  } <BUGS> } <BUGE>  /** * Extracts embedded XML metadata as XML string. * <p> * * @param byteSource *            File containing image data. * @param params *            Map of optional parameters, defined in SanselanConstants. * @return Xmp Xml as String, if present. Otherwise, returns null. */ @Override public String getXmpXml(ByteSource byteSource, Map params) throws ImageReadException, IOException {
private FileInfo readHeader(final ByteSource byteSource) throws ImageReadException, IOException { <BUGS> InputStream is = null; boolean canThrow = false; <BUGE> try { is = byteSource.getInputStream();  final FileInfo ret = readHeader(is); canThrow = true; return ret; } finally { IoUtils.closeQuietly(canThrow, is); } }
private FileInfo readHeader(final ByteSource byteSource) throws ImageReadException, IOException { InputStream is = null; boolean canThrow = false; try { <BUGS> is = byteSource.getInputStream(); <BUGE>  final FileInfo ret = readHeader(is); canThrow = true; return ret; } finally { IoUtils.closeQuietly(canThrow, is); } }
private FileInfo readHeader(final ByteSource byteSource) throws ImageReadException, IOException { InputStream is = null; boolean canThrow = false; try { is = byteSource.getInputStream();  <BUGS> final FileInfo ret = readHeader(is); <BUGE> canThrow = true; return ret; } finally { IoUtils.closeQuietly(canThrow, is); } }
private FileInfo readHeader(final ByteSource byteSource) throws ImageReadException, IOException { InputStream is = null; boolean canThrow = false; try { is = byteSource.getInputStream();  final FileInfo ret = readHeader(is); canThrow = true; return ret; } finally { <BUGS> IoUtils.closeQuietly(canThrow, is); } <BUGE> }
private FileInfo readHeader(final ByteSource byteSource) throws ImageReadException, IOException { <BUGS> InputStream is = null; boolean canThrow = false; <BUGE> try { is = byteSource.getInputStream();  final FileInfo ret = readHeader(is); canThrow = true; return ret; } finally { IoUtils.closeQuietly(canThrow, is); } }
private FileInfo readHeader(final ByteSource byteSource) throws ImageReadException, IOException { InputStream is = null; boolean canThrow = false; try { <BUGS> is = byteSource.getInputStream(); <BUGE>  final FileInfo ret = readHeader(is); canThrow = true; return ret; } finally { IoUtils.closeQuietly(canThrow, is); } }
private FileInfo readHeader(final ByteSource byteSource) throws ImageReadException, IOException { InputStream is = null; boolean canThrow = false; try { is = byteSource.getInputStream();  <BUGS> final FileInfo ret = readHeader(is); <BUGE> canThrow = true; return ret; } finally { IoUtils.closeQuietly(canThrow, is); } }
private FileInfo readHeader(final ByteSource byteSource) throws ImageReadException, IOException { InputStream is = null; boolean canThrow = false; try { is = byteSource.getInputStream();  final FileInfo ret = readHeader(is); canThrow = true; return ret; } finally { <BUGS> IoUtils.closeQuietly(canThrow, is); } <BUGE> }
private String getValueDescription(final Object o) { <BUGS> if (o == null) { <BUGE> return null; }  if (o instanceof Number) { return o.toString(); } else if (o instanceof String) { return "'" + o.toString().trim() + "'"; } else if (o instanceof Date) { final DateFormat df = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSSZ", Locale.ENGLISH); return df.format((Date) o); } else if (o instanceof Object[]) { final Object[] objects = (Object[]) o; final StringBuilder result = new StringBuilder();  for (int i = 0; i < objects.length; i++) { final Object object = objects[i];  if (i > 50) { result.append("... (" + objects.length + ")"); break; } if (i > 0) { result.append(", "); } result.append(object.toString()); } return result.toString();
private String getValueDescription(final Object o) { if (o == null) { return null; }  <BUGS> if (o instanceof Number) { return o.toString(); } else if (o instanceof String) { return "'" + o.toString().trim() + "'"; } else if (o instanceof Date) { <BUGE> final DateFormat df = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSSZ", Locale.ENGLISH); return df.format((Date) o); } else if (o instanceof Object[]) { final Object[] objects = (Object[]) o; final StringBuilder result = new StringBuilder();  for (int i = 0; i < objects.length; i++) { final Object object = objects[i];  if (i > 50) { result.append("... (" + objects.length + ")"); break; } if (i > 0) { result.append(", "); } result.append(object.toString()); } return result.toString();
private String getValueDescription(final Object o) { if (o == null) { return null; }  if (o instanceof Number) { return o.toString(); } else if (o instanceof String) { return "'" + o.toString().trim() + "'"; } else if (o instanceof Date) { final DateFormat df = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSSZ", Locale.ENGLISH); return df.format((Date) o); <BUGS> } else if (o instanceof Object[]) { <BUGE> final Object[] objects = (Object[]) o; final StringBuilder result = new StringBuilder();  for (int i = 0; i < objects.length; i++) { final Object object = objects[i];  if (i > 50) { result.append("... (" + objects.length + ")"); break; } if (i > 0) { result.append(", "); } result.append(object.toString()); } return result.toString();
return null; }  return new OversizeValueElement(getOffset(), value.length); }  public String getValueDescription() { try { return getValueDescription(getValue()); } catch (final ImageReadException e) { return "Invalid value: " + e.getMessage(); } } /* }*/ <BUGS> } else if (o instanceof short[]) { final short[] values = (short[]) o; final StringBuilder result = new StringBuilder(); <BUGE>  for (int i = 0; i < values.length; i++) { final short sval = values[i];  if (i > 50) { result.append("... (" + values.length + ")"); break; } if (i > 0) { result.append(", "); } result.append(Short.toString(sval)); }
if (isLocalValue()) { return null; }  return new OversizeValueElement(getOffset(), value.length); }  public String getValueDescription() { try { return getValueDescription(getValue()); } catch (final ImageReadException e) { return "Invalid value: " + e.getMessage(); } }  <BUGS> for (int i = 0; i < values.length; i++) { final short sval = values[i]; <BUGE>  if (i > 50) { result.append("... (" + values.length + ")"); break; } if (i > 0) { result.append(", "); } result.append(Short.toString(sval)); } return result.toString(); } else if (o instanceof int[]) { final int[] values = (int[]) o;
if (isLocalValue()) { return null; }  return new OversizeValueElement(getOffset(), value.length); }  public String getValueDescription() { try { return getValueDescription(getValue()); } catch (final ImageReadException e) { return "Invalid value: " + e.getMessage(); } }  <BUGS> if (i > 50) { <BUGE> result.append("... (" + values.length + ")"); break; } if (i > 0) { result.append(", "); } result.append(Short.toString(sval)); } return result.toString(); } else if (o instanceof int[]) { final int[] values = (int[]) o; final StringBuilder result = new StringBuilder();  for (int i = 0; i < values.length; i++) {
if (isLocalValue()) { return null; }  return new OversizeValueElement(getOffset(), value.length); }  public String getValueDescription() { try { return getValueDescription(getValue()); } catch (final ImageReadException e) { return "Invalid value: " + e.getMessage(); } } } <BUGS> if (i > 0) { result.append(", "); <BUGE> } result.append(Short.toString(sval)); } return result.toString(); } else if (o instanceof int[]) { final int[] values = (int[]) o; final StringBuilder result = new StringBuilder();  for (int i = 0; i < values.length; i++) { final int iVal = values[i];  if (i > 50) { result.append("... (" + values.length + ")");
if (isLocalValue()) { return null; }  return new OversizeValueElement(getOffset(), value.length); }  public String getValueDescription() { try { return getValueDescription(getValue()); } catch (final ImageReadException e) { return "Invalid value: " + e.getMessage(); } } } <BUGS> result.append(Short.toString(sval)); <BUGE> } return result.toString(); } else if (o instanceof int[]) { final int[] values = (int[]) o; final StringBuilder result = new StringBuilder();  for (int i = 0; i < values.length; i++) { final int iVal = values[i];  if (i > 50) { result.append("... (" + values.length + ")"); break; } if (i > 0) {
return null; }  return new OversizeValueElement(getOffset(), value.length); }  public String getValueDescription() { try { return getValueDescription(getValue()); } catch (final ImageReadException e) { return "Invalid value: " + e.getMessage(); } } } <BUGS> return result.toString(); } else if (o instanceof int[]) { final int[] values = (int[]) o; final StringBuilder result = new StringBuilder(); <BUGE>  for (int i = 0; i < values.length; i++) { final int iVal = values[i];  if (i > 50) { result.append("... (" + values.length + ")"); break; } if (i > 0) { result.append(", "); } result.append(Integer.toString(iVal));
if (isLocalValue()) { return null; }  return new OversizeValueElement(getOffset(), value.length); }  public String getValueDescription() { try { return getValueDescription(getValue()); } catch (final ImageReadException e) { return "Invalid value: " + e.getMessage(); } }  <BUGS> for (int i = 0; i < values.length; i++) { final int iVal = values[i]; <BUGE>  if (i > 50) { result.append("... (" + values.length + ")"); break; } if (i > 0) { result.append(", "); } result.append(Integer.toString(iVal)); } return result.toString(); } else if (o instanceof long[]) { final long[] values = (long[]) o;
if (isLocalValue()) { return null; }  return new OversizeValueElement(getOffset(), value.length); }  public String getValueDescription() { try { return getValueDescription(getValue()); } catch (final ImageReadException e) { return "Invalid value: " + e.getMessage(); } }  <BUGS> if (i > 50) { <BUGE> result.append("... (" + values.length + ")"); break; } if (i > 0) { result.append(", "); } result.append(Integer.toString(iVal)); } return result.toString(); } else if (o instanceof long[]) { final long[] values = (long[]) o; final StringBuilder result = new StringBuilder();  for (int i = 0; i < values.length; i++) {
if (isLocalValue()) { return null; }  return new OversizeValueElement(getOffset(), value.length); }  public String getValueDescription() { try { return getValueDescription(getValue()); } catch (final ImageReadException e) { return "Invalid value: " + e.getMessage(); } } } <BUGS> if (i > 0) { result.append(", "); <BUGE> } result.append(Integer.toString(iVal)); } return result.toString(); } else if (o instanceof long[]) { final long[] values = (long[]) o; final StringBuilder result = new StringBuilder();  for (int i = 0; i < values.length; i++) { final long lVal = values[i];  if (i > 50) { result.append("... (" + values.length + ")");
if (isLocalValue()) { return null; }  return new OversizeValueElement(getOffset(), value.length); }  public String getValueDescription() { try { return getValueDescription(getValue()); } catch (final ImageReadException e) { return "Invalid value: " + e.getMessage(); } } } <BUGS> result.append(Integer.toString(iVal)); <BUGE> } return result.toString(); } else if (o instanceof long[]) { final long[] values = (long[]) o; final StringBuilder result = new StringBuilder();  for (int i = 0; i < values.length; i++) { final long lVal = values[i];  if (i > 50) { result.append("... (" + values.length + ")"); break; } if (i > 0) {
if (isLocalValue()) { return null; }  return new OversizeValueElement(getOffset(), value.length); }  public String getValueDescription() { try { return getValueDescription(getValue()); } catch (final ImageReadException e) { return "Invalid value: " + e.getMessage(); } } } <BUGS> return result.toString(); <BUGE> } else if (o instanceof long[]) { final long[] values = (long[]) o; final StringBuilder result = new StringBuilder();  for (int i = 0; i < values.length; i++) { final long lVal = values[i];  if (i > 50) { result.append("... (" + values.length + ")"); break; } if (i > 0) { result.append(", "); }
@Override public void writeImage(final BufferedImage src, final OutputStream os, Map<String, Object> params) throws ImageWriteException, IOException { <BUGS> PnmWriter writer = null; boolean useRawbits = true; final boolean hasAlpha = new PaletteFactory().hasTransparency(src); <BUGE>  if (params != null) { final Object useRawbitsParam = params.get(PARAM_KEY_PNM_RAWBITS); if (useRawbitsParam != null) { if (useRawbitsParam.equals(PARAM_VALUE_PNM_RAWBITS_NO)) { useRawbits = false; } }  final Object subtype = params.get(PARAM_KEY_FORMAT); if (subtype != null) { if (subtype.equals(ImageFormats.PBM)) { writer = new PbmWriter(useRawbits); } else if (subtype.equals(ImageFormats.PGM)) { writer = new PgmWriter(useRawbits); } else if (subtype.equals(ImageFormats.PPM)) { writer = new PpmWriter(useRawbits); } else if (subtype.equals(ImageFormats.PAM)) { writer = new PamWriter(); } } }  if (writer == null) {
@Override public void writeImage(final BufferedImage src, final OutputStream os, Map<String, Object> params) throws ImageWriteException, IOException { PnmWriter writer = null; boolean useRawbits = true; final boolean hasAlpha = new PaletteFactory().hasTransparency(src);  <BUGS> if (params != null) { final Object useRawbitsParam = params.get(PARAM_KEY_PNM_RAWBITS); if (useRawbitsParam != null) { if (useRawbitsParam.equals(PARAM_VALUE_PNM_RAWBITS_NO)) { <BUGE> useRawbits = false; } }  final Object subtype = params.get(PARAM_KEY_FORMAT); if (subtype != null) { if (subtype.equals(ImageFormats.PBM)) { writer = new PbmWriter(useRawbits); } else if (subtype.equals(ImageFormats.PGM)) { writer = new PgmWriter(useRawbits); } else if (subtype.equals(ImageFormats.PPM)) { writer = new PpmWriter(useRawbits); } else if (subtype.equals(ImageFormats.PAM)) { writer = new PamWriter(); } } }  if (writer == null) {
@Override public void writeImage(final BufferedImage src, final OutputStream os, Map<String, Object> params) throws ImageWriteException, IOException { PnmWriter writer = null; boolean useRawbits = true; final boolean hasAlpha = new PaletteFactory().hasTransparency(src);  if (params != null) { final Object useRawbitsParam = params.get(PARAM_KEY_PNM_RAWBITS); if (useRawbitsParam != null) { if (useRawbitsParam.equals(PARAM_VALUE_PNM_RAWBITS_NO)) { useRawbits = false; } }  <BUGS> final Object subtype = params.get(PARAM_KEY_FORMAT); if (subtype != null) { if (subtype.equals(ImageFormats.PBM)) { <BUGE> writer = new PbmWriter(useRawbits); } else if (subtype.equals(ImageFormats.PGM)) { writer = new PgmWriter(useRawbits); } else if (subtype.equals(ImageFormats.PPM)) { writer = new PpmWriter(useRawbits); } else if (subtype.equals(ImageFormats.PAM)) { writer = new PamWriter(); } } }  if (writer == null) {
@Override public void writeImage(final BufferedImage src, final OutputStream os, Map<String, Object> params) throws ImageWriteException, IOException { PnmWriter writer = null; boolean useRawbits = true; final boolean hasAlpha = new PaletteFactory().hasTransparency(src);  if (params != null) { final Object useRawbitsParam = params.get(PARAM_KEY_PNM_RAWBITS); if (useRawbitsParam != null) { if (useRawbitsParam.equals(PARAM_VALUE_PNM_RAWBITS_NO)) { useRawbits = false; } }  final Object subtype = params.get(PARAM_KEY_FORMAT); if (subtype != null) { if (subtype.equals(ImageFormats.PBM)) { writer = new PbmWriter(useRawbits); <BUGS> } else if (subtype.equals(ImageFormats.PGM)) { <BUGE> writer = new PgmWriter(useRawbits); } else if (subtype.equals(ImageFormats.PPM)) { writer = new PpmWriter(useRawbits); } else if (subtype.equals(ImageFormats.PAM)) { writer = new PamWriter(); } } }  if (writer == null) {
@Override public void writeImage(final BufferedImage src, final OutputStream os, Map<String, Object> params) throws ImageWriteException, IOException { PnmWriter writer = null; boolean useRawbits = true; final boolean hasAlpha = new PaletteFactory().hasTransparency(src);  if (params != null) { final Object useRawbitsParam = params.get(PARAM_KEY_PNM_RAWBITS); if (useRawbitsParam != null) { if (useRawbitsParam.equals(PARAM_VALUE_PNM_RAWBITS_NO)) { useRawbits = false; } }  final Object subtype = params.get(PARAM_KEY_FORMAT); if (subtype != null) { if (subtype.equals(ImageFormats.PBM)) { writer = new PbmWriter(useRawbits); } else if (subtype.equals(ImageFormats.PGM)) { writer = new PgmWriter(useRawbits); <BUGS> } else if (subtype.equals(ImageFormats.PPM)) { <BUGE> writer = new PpmWriter(useRawbits); } else if (subtype.equals(ImageFormats.PAM)) { writer = new PamWriter(); } } }  if (writer == null) {
@Override public void writeImage(final BufferedImage src, final OutputStream os, Map<String, Object> params) throws ImageWriteException, IOException { PnmWriter writer = null; boolean useRawbits = true; final boolean hasAlpha = new PaletteFactory().hasTransparency(src);  if (params != null) { final Object useRawbitsParam = params.get(PARAM_KEY_PNM_RAWBITS); if (useRawbitsParam != null) { if (useRawbitsParam.equals(PARAM_VALUE_PNM_RAWBITS_NO)) { useRawbits = false; } }  final Object subtype = params.get(PARAM_KEY_FORMAT); if (subtype != null) { if (subtype.equals(ImageFormats.PBM)) { writer = new PbmWriter(useRawbits); } else if (subtype.equals(ImageFormats.PGM)) { writer = new PgmWriter(useRawbits); } else if (subtype.equals(ImageFormats.PPM)) { writer = new PpmWriter(useRawbits); <BUGS> } else if (subtype.equals(ImageFormats.PAM)) { <BUGE> writer = new PamWriter(); } } }  if (writer == null) {
final int width = info.width; final int height = info.height;  final boolean hasAlpha = info.hasAlpha(); final ImageBuilder imageBuilder = new ImageBuilder(width, height, hasAlpha); info.readImage(imageBuilder, is);  final BufferedImage ret = imageBuilder.getBufferedImage(); return ret; } }   <BUGS> if (writer == null) { if (hasAlpha) { writer = new PamWriter(); <BUGE> } else { writer = new PpmWriter(useRawbits); } }  /* make copy of params; we'll clear keys as we consume them.*/ if (params != null) { params = new HashMap<>(params); } else { params = new HashMap<>(); }  /* clear format key.*/
final int width = info.width; final int height = info.height;  final boolean hasAlpha = info.hasAlpha(); final ImageBuilder imageBuilder = new ImageBuilder(width, height, hasAlpha); info.readImage(imageBuilder, is);  final BufferedImage ret = imageBuilder.getBufferedImage(); return ret; } }  /* make copy of params; we'll clear keys as we consume them.*/ <BUGS> if (params != null) { params = new HashMap<>(params); <BUGE> } else { params = new HashMap<>(); }  /* clear format key.*/ if (params.containsKey(PARAM_KEY_FORMAT)) { params.remove(PARAM_KEY_FORMAT); }  /* clear rawbits key.*/  if (!params.isEmpty()) { final Object firstKey = params.keySet().iterator().next();
final int width = info.width; final int height = info.height;  final boolean hasAlpha = info.hasAlpha(); final ImageBuilder imageBuilder = new ImageBuilder(width, height, hasAlpha); info.readImage(imageBuilder, is);  final BufferedImage ret = imageBuilder.getBufferedImage(); return ret; } }  /* clear format key.*/ <BUGS> if (params.containsKey(PARAM_KEY_FORMAT)) { params.remove(PARAM_KEY_FORMAT); <BUGE> }  /* clear rawbits key.*/  if (!params.isEmpty()) { final Object firstKey = params.keySet().iterator().next(); throw new ImageWriteException("Unknown parameter: " + firstKey); }  writer.writeImage(src, os, params); }  /**
final int width = info.width; final int height = info.height;  final boolean hasAlpha = info.hasAlpha(); final ImageBuilder imageBuilder = new ImageBuilder(width, height, hasAlpha); info.readImage(imageBuilder, is);  final BufferedImage ret = imageBuilder.getBufferedImage(); return ret; } }   <BUGS> if (!params.isEmpty()) { final Object firstKey = params.keySet().iterator().next(); throw new ImageWriteException("Unknown parameter: " + firstKey); <BUGE> }  writer.writeImage(src, os, params); }  /** * Extracts embedded XML metadata as XML string. * <p> * * @param byteSource *            File containing image data. * @param params *            Map of optional parameters, defined in ImagingConstants.
@Override public int read() throws IOException { <BUGS> if (null == block) { if (readFirst) { <BUGE> return -1; } block = getFirstBlock(); readFirst = true; }  if (block != null && blockIndex >= block.bytes.length) { block = block.getNext(); blockIndex = 0; }  if (null == block) { return -1; }  if (blockIndex >= block.bytes.length) { return -1; }  return 0xff & block.bytes[blockIndex++]; }
@Override public int read() throws IOException { if (null == block) { if (readFirst) { return -1; } <BUGS> block = getFirstBlock(); readFirst = true; <BUGE> }  if (block != null && blockIndex >= block.bytes.length) { block = block.getNext(); blockIndex = 0; }  if (null == block) { return -1; }  if (blockIndex >= block.bytes.length) { return -1; }  return 0xff & block.bytes[blockIndex++]; }
@Override public int read() throws IOException { if (null == block) { if (readFirst) { return -1; } block = getFirstBlock(); readFirst = true; }  <BUGS> if (block != null && blockIndex >= block.bytes.length) { <BUGE> block = block.getNext(); blockIndex = 0; }  if (null == block) { return -1; }  if (blockIndex >= block.bytes.length) { return -1; }  return 0xff & block.bytes[blockIndex++]; }
@Override public int read() throws IOException { if (null == block) { if (readFirst) { return -1; } block = getFirstBlock(); readFirst = true; }  if (block != null && blockIndex >= block.bytes.length) { block = block.getNext(); blockIndex = 0; }  <BUGS> if (null == block) { <BUGE> return -1; }  if (blockIndex >= block.bytes.length) { return -1; }  return 0xff & block.bytes[blockIndex++]; }
@Override public int read() throws IOException { if (null == block) { if (readFirst) { return -1; } block = getFirstBlock(); readFirst = true; }  if (block != null && blockIndex >= block.bytes.length) { block = block.getNext(); blockIndex = 0; }  if (null == block) { return -1; }  <BUGS> if (blockIndex >= block.bytes.length) { <BUGE> return -1; }  return 0xff & block.bytes[blockIndex++]; }
@Override public int read() throws IOException { if (null == block) { if (readFirst) { return -1; } block = getFirstBlock(); readFirst = true; }  if (block != null && blockIndex >= block.bytes.length) { block = block.getNext(); blockIndex = 0; }  if (null == block) { return -1; }  if (blockIndex >= block.bytes.length) { return -1; }  <BUGS> return 0xff & block.bytes[blockIndex++]; <BUGE> }
public static void debug(final String message) { <BUGS> if (LOGGER.isLoggable(Level.FINEST)) { <BUGE> LOGGER.finest(message); } }
public static void debug(final String message) { if (LOGGER.isLoggable(Level.FINEST)) { LOGGER.finest(message); } <BUGS> } <BUGE>
@Override public ImageMetadata getMetadata(final ByteSource byteSource, final Map<String, Object> params) throws ImageReadException, IOException { <BUGS> final List<PngChunk> chunks = readChunks(byteSource, new ChunkType[] { ChunkType.tEXt, ChunkType.zTXt, }, true); <BUGE>  if ((chunks == null) || (chunks.isEmpty())) { return null; }  final GenericImageMetadata result = new GenericImageMetadata();  for (final PngChunk chunk : chunks) { final PngTextChunk textChunk = (PngTextChunk) chunk;  result.add(textChunk.getKeyword(), textChunk.getText()); }  return result; }
@Override public ImageMetadata getMetadata(final ByteSource byteSource, final Map<String, Object> params) throws ImageReadException, IOException { final List<PngChunk> chunks = readChunks(byteSource, new ChunkType[] { ChunkType.tEXt, ChunkType.zTXt, }, true);  <BUGS> if ((chunks == null) || (chunks.isEmpty())) { <BUGE> return null; }  final GenericImageMetadata result = new GenericImageMetadata();  for (final PngChunk chunk : chunks) { final PngTextChunk textChunk = (PngTextChunk) chunk;  result.add(textChunk.getKeyword(), textChunk.getText()); }  return result; }
@Override public ImageMetadata getMetadata(final ByteSource byteSource, final Map<String, Object> params) throws ImageReadException, IOException { final List<PngChunk> chunks = readChunks(byteSource, new ChunkType[] { ChunkType.tEXt, ChunkType.zTXt, }, true);  if ((chunks == null) || (chunks.isEmpty())) { return null; }  <BUGS> final GenericImageMetadata result = new GenericImageMetadata(); <BUGE>  for (final PngChunk chunk : chunks) { final PngTextChunk textChunk = (PngTextChunk) chunk;  result.add(textChunk.getKeyword(), textChunk.getText()); }  return result; }
@Override public ImageMetadata getMetadata(final ByteSource byteSource, final Map<String, Object> params) throws ImageReadException, IOException { final List<PngChunk> chunks = readChunks(byteSource, new ChunkType[] { ChunkType.tEXt, ChunkType.zTXt, }, true);  if ((chunks == null) || (chunks.isEmpty())) { return null; }  final GenericImageMetadata result = new GenericImageMetadata();  <BUGS> for (final PngChunk chunk : chunks) { final PngTextChunk textChunk = (PngTextChunk) chunk; <BUGE>  result.add(textChunk.getKeyword(), textChunk.getText()); }  return result; }
@Override public ImageMetadata getMetadata(final ByteSource byteSource, final Map<String, Object> params) throws ImageReadException, IOException { final List<PngChunk> chunks = readChunks(byteSource, new ChunkType[] { ChunkType.tEXt, ChunkType.zTXt, }, true);  if ((chunks == null) || (chunks.isEmpty())) { return null; }  final GenericImageMetadata result = new GenericImageMetadata();  for (final PngChunk chunk : chunks) { final PngTextChunk textChunk = (PngTextChunk) chunk;  <BUGS> result.add(textChunk.getKeyword(), textChunk.getText()); } <BUGE>  return result; }
@Override public ImageMetadata getMetadata(final ByteSource byteSource, final Map<String, Object> params) throws ImageReadException, IOException { final List<PngChunk> chunks = readChunks(byteSource, new ChunkType[] { ChunkType.tEXt, ChunkType.zTXt, }, true);  if ((chunks == null) || (chunks.isEmpty())) { return null; }  final GenericImageMetadata result = new GenericImageMetadata();  for (final PngChunk chunk : chunks) { final PngTextChunk textChunk = (PngTextChunk) chunk;  result.add(textChunk.getKeyword(), textChunk.getText()); }  <BUGS> return result; <BUGE> }
*/ public static BufferedImage getBufferedImage(final File file, final Map<String, Object> params) throws ImageReadException, IOException { <BUGS> return getBufferedImage(new ByteSourceFile(file), params); <BUGE> }
*/ public static BufferedImage getBufferedImage(final File file, final Map<String, Object> params) throws ImageReadException, IOException { <BUGS> return getBufferedImage(new ByteSourceFile(file), params); <BUGE> }
*/ protected JsonToken _handleUnexpectedValue(int i) throws IOException, JsonParseException { /* Most likely an error, unless we are to allow single-quote-strings*/ <BUGS> switch (i) { <BUGE> case '\'': /* [JACKSON-173]: allow single quotes. Unlike with regular * Strings, we'll eagerly parse contents; this so that there's * no need to store information on quote char used. * * Also, no separation to fast/slow parsing; we'll just do * one regular (~= slowish) parsing, to keep code simple */ if (isEnabled(Feature.ALLOW_SINGLE_QUOTES)) { return _handleApostropheValue(); } break; case 'N': _matchToken("NaN", 1); if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) { return resetAsNaN("NaN", Double.NaN); } _reportError("Non-standard token 'NaN': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow"); break; case 'I': _matchToken("Infinity", 1); if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) { return resetAsNaN("Infinity", Double.POSITIVE_INFINITY); }
*/ protected JsonToken _handleUnexpectedValue(int i) throws IOException, JsonParseException { /* Most likely an error, unless we are to allow single-quote-strings*/ switch (i) { case '\'': /* [JACKSON-173]: allow single quotes. Unlike with regular * Strings, we'll eagerly parse contents; this so that there's * no need to store information on quote char used. * * Also, no separation to fast/slow parsing; we'll just do * one regular (~= slowish) parsing, to keep code simple */ if (isEnabled(Feature.ALLOW_SINGLE_QUOTES)) { return _handleApostropheValue(); } break; case 'N': <BUGS> _matchToken("NaN", 1); if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) { return resetAsNaN("NaN", Double.NaN); <BUGE> } _reportError("Non-standard token 'NaN': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow"); break; case 'I': _matchToken("Infinity", 1); if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) { return resetAsNaN("Infinity", Double.POSITIVE_INFINITY); }
*/ protected JsonToken _handleUnexpectedValue(int i) throws IOException, JsonParseException { /* Most likely an error, unless we are to allow single-quote-strings*/ switch (i) { case '\'': /* [JACKSON-173]: allow single quotes. Unlike with regular * Strings, we'll eagerly parse contents; this so that there's * no need to store information on quote char used. * * Also, no separation to fast/slow parsing; we'll just do * one regular (~= slowish) parsing, to keep code simple */ if (isEnabled(Feature.ALLOW_SINGLE_QUOTES)) { return _handleApostropheValue(); } break; case 'N': _matchToken("NaN", 1); if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) { return resetAsNaN("NaN", Double.NaN); } <BUGS> _reportError("Non-standard token 'NaN': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow"); <BUGE> break; case 'I': _matchToken("Infinity", 1); if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) { return resetAsNaN("Infinity", Double.POSITIVE_INFINITY); }
*/ protected JsonToken _parseNumber(int ch) throws IOException { /* Although we will always be complete with respect to textual * representation (that is, all characters will be parsed), * actual conversion to a number is deferred. Thus, need to * note that no representations are valid yet */ <BUGS> boolean negative = (ch == INT_MINUS); int ptr = _inputPtr; int startPtr = ptr-1; /* to include sign/digit already read*/ final int inputLen = _inputEnd; <BUGE>  dummy_loop: do { /* dummy loop, to be able to break out*/ if (negative) { /* need to read the next digit*/ if (ptr >= _inputEnd) { break dummy_loop; } ch = _inputBuffer[ptr++]; /* First check: must have a digit to follow minus sign*/ if (ch > INT_9 || ch < INT_0) { _inputPtr = ptr; return _handleInvalidNumberStart(ch, true); } /* (note: has been checked for non-negative already, in * the dispatching code that determined it should be * a numeric value) */ }
*/ protected JsonToken _parseNumber(int ch) throws IOException { /* Although we will always be complete with respect to textual * representation (that is, all characters will be parsed), * actual conversion to a number is deferred. Thus, need to * note that no representations are valid yet */ boolean negative = (ch == INT_MINUS); int ptr = _inputPtr; int startPtr = ptr-1; /* to include sign/digit already read*/ final int inputLen = _inputEnd;  dummy_loop: do { /* dummy loop, to be able to break out*/ <BUGS> if (negative) { /* need to read the next digit <BUGE>*/ if (ptr >= _inputEnd) { break dummy_loop; } ch = _inputBuffer[ptr++]; /* First check: must have a digit to follow minus sign*/ if (ch > INT_9 || ch < INT_0) { _inputPtr = ptr; return _handleInvalidNumberStart(ch, true); } /* (note: has been checked for non-negative already, in * the dispatching code that determined it should be * a numeric value) */ }
/** * Initial parsing method for number values. It needs to be able * to parse enough input to be able to determine whether the * value is to be considered a simple integer value, or a more * generic decimal value: latter of which needs to be expressed * as a floating point number. The basic rule is that if the number * has no fractional or exponential part, it is an integer; otherwise * a floating point number. *<p> * Because much of input has to be processed in any case, no partial * parsing is done: all input text will be stored for further * processing. However, actual numeric value conversion will be * deferred, since it is usually the most complicated and costliest * part of processing. /* One special case, leading zero(es):*/ <BUGS> if (ch == INT_0) { <BUGE> break dummy_loop; }  /* First, let's see if the whole number is contained within * the input buffer unsplit. This should be the common case; * and to simplify processing, we will just reparse contents * in the alternative case (number split on buffer boundary) */  int intLen = 1; /* already got one*/  /* First let's get the obligatory integer part:*/  int_loop:
/** * Initial parsing method for number values. It needs to be able * to parse enough input to be able to determine whether the * value is to be considered a simple integer value, or a more * generic decimal value: latter of which needs to be expressed * as a floating point number. The basic rule is that if the number * has no fractional or exponential part, it is an integer; otherwise * a floating point number. *<p> * Because much of input has to be processed in any case, no partial * parsing is done: all input text will be stored for further * processing. However, actual numeric value conversion will be * deferred, since it is usually the most complicated and costliest * part of processing.  <BUGS> int intLen = 1; /* already got one <BUGE>*/  /* First let's get the obligatory integer part:*/  int_loop: while (true) { if (ptr >= _inputEnd) { break dummy_loop; } ch = (int) _inputBuffer[ptr++]; if (ch < INT_0 || ch > INT_9) { break int_loop; } ++intLen; }
/** * Initial parsing method for number values. It needs to be able * to parse enough input to be able to determine whether the * value is to be considered a simple integer value, or a more * generic decimal value: latter of which needs to be expressed * as a floating point number. The basic rule is that if the number * has no fractional or exponential part, it is an integer; otherwise * a floating point number. *<p> * Because much of input has to be processed in any case, no partial * parsing is done: all input text will be stored for further * processing. However, actual numeric value conversion will be * deferred, since it is usually the most complicated and costliest * part of processing. while (true) { <BUGS> if (ptr >= _inputEnd) { <BUGE> break dummy_loop; } ch = (int) _inputBuffer[ptr++]; if (ch < INT_0 || ch > INT_9) { break int_loop; } ++intLen; }  int fractLen = 0;  /* And then see if we get other parts*/ if (ch == '.') { /* yes, fraction*/ fract_loop:
* Initial parsing method for number values. It needs to be able * to parse enough input to be able to determine whether the * value is to be considered a simple integer value, or a more * generic decimal value: latter of which needs to be expressed * as a floating point number. The basic rule is that if the number * has no fractional or exponential part, it is an integer; otherwise * a floating point number. *<p> * Because much of input has to be processed in any case, no partial * parsing is done: all input text will be stored for further * processing. However, actual numeric value conversion will be * deferred, since it is usually the most complicated and costliest * part of processing. } <BUGS> ch = (int) _inputBuffer[ptr++]; if (ch < INT_0 || ch > INT_9) { break int_loop; <BUGE> } ++intLen; }  int fractLen = 0;  /* And then see if we get other parts*/ if (ch == '.') { /* yes, fraction*/ fract_loop: while (true) { if (ptr >= inputLen) { break dummy_loop; }
/** * Initial parsing method for number values. It needs to be able * to parse enough input to be able to determine whether the * value is to be considered a simple integer value, or a more * generic decimal value: latter of which needs to be expressed * as a floating point number. The basic rule is that if the number * has no fractional or exponential part, it is an integer; otherwise * a floating point number. *<p> * Because much of input has to be processed in any case, no partial * parsing is done: all input text will be stored for further * processing. However, actual numeric value conversion will be * deferred, since it is usually the most complicated and costliest * part of processing. } <BUGS> ++intLen; <BUGE> }  int fractLen = 0;  /* And then see if we get other parts*/ if (ch == '.') { /* yes, fraction*/ fract_loop: while (true) { if (ptr >= inputLen) { break dummy_loop; } ch = (int) _inputBuffer[ptr++]; if (ch < INT_0 || ch > INT_9) { break fract_loop;
/** * Initial parsing method for number values. It needs to be able * to parse enough input to be able to determine whether the * value is to be considered a simple integer value, or a more * generic decimal value: latter of which needs to be expressed * as a floating point number. The basic rule is that if the number * has no fractional or exponential part, it is an integer; otherwise * a floating point number. *<p> * Because much of input has to be processed in any case, no partial * parsing is done: all input text will be stored for further * processing. However, actual numeric value conversion will be * deferred, since it is usually the most complicated and costliest * part of processing.  <BUGS> int fractLen = 0; <BUGE>  /* And then see if we get other parts*/ if (ch == '.') { /* yes, fraction*/ fract_loop: while (true) { if (ptr >= inputLen) { break dummy_loop; } ch = (int) _inputBuffer[ptr++]; if (ch < INT_0 || ch > INT_9) { break fract_loop; } ++fractLen; }
/** * Initial parsing method for number values. It needs to be able * to parse enough input to be able to determine whether the * value is to be considered a simple integer value, or a more * generic decimal value: latter of which needs to be expressed * as a floating point number. The basic rule is that if the number * has no fractional or exponential part, it is an integer; otherwise * a floating point number. *<p> * Because much of input has to be processed in any case, no partial * parsing is done: all input text will be stored for further * processing. However, actual numeric value conversion will be * deferred, since it is usually the most complicated and costliest * part of processing. /* And then see if we get other parts*/ <BUGS> if (ch == '.') { /* yes, fraction <BUGE>*/ fract_loop: while (true) { if (ptr >= inputLen) { break dummy_loop; } ch = (int) _inputBuffer[ptr++]; if (ch < INT_0 || ch > INT_9) { break fract_loop; } ++fractLen; } /* must be followed by sequence of ints, one minimum*/ if (fractLen == 0) { reportUnexpectedNumberChar(ch, "Decimal point not followed by a digit");
/** * Initial parsing method for number values. It needs to be able * to parse enough input to be able to determine whether the * value is to be considered a simple integer value, or a more * generic decimal value: latter of which needs to be expressed * as a floating point number. The basic rule is that if the number * has no fractional or exponential part, it is an integer; otherwise * a floating point number. *<p> * Because much of input has to be processed in any case, no partial * parsing is done: all input text will be stored for further * processing. However, actual numeric value conversion will be * deferred, since it is usually the most complicated and costliest * part of processing.  <BUGS> int expLen = 0; if (ch == 'e' || ch == 'E') { /* and/or exponent <BUGE>*/ if (ptr >= inputLen) { break dummy_loop; } /* Sign indicator?*/ ch = (int) _inputBuffer[ptr++]; if (ch == INT_MINUS || ch == INT_PLUS) { /* yup, skip for now*/ if (ptr >= inputLen) { break dummy_loop; } ch = (int) _inputBuffer[ptr++]; } while (ch <= INT_9 && ch >= INT_0) { ++expLen;
/** * Initial parsing method for number values. It needs to be able * to parse enough input to be able to determine whether the * value is to be considered a simple integer value, or a more * generic decimal value: latter of which needs to be expressed * as a floating point number. The basic rule is that if the number * has no fractional or exponential part, it is an integer; otherwise * a floating point number. *<p> * Because much of input has to be processed in any case, no partial * parsing is done: all input text will be stored for further * processing. However, actual numeric value conversion will be * deferred, since it is usually the most complicated and costliest * part of processing. /* Got it all: let's add to text buffer for parsing, access*/ <BUGS> --ptr; /* need to push back following separator*/ _inputPtr = ptr; <BUGE> /* As per #105, need separating space between root values; check here*/ int len = ptr-startPtr; _textBuffer.resetWithShared(_inputBuffer, startPtr, len); return reset(negative, intLen, fractLen, expLen); } while (false);  _inputPtr = negative ? (startPtr+1) : startPtr; return _parseNumber2(negative); }  /** * Method called to parse a number, when the primary parse * method has failed to parse it, due to it being split on
* Initial parsing method for number values. It needs to be able * to parse enough input to be able to determine whether the * value is to be considered a simple integer value, or a more * generic decimal value: latter of which needs to be expressed * as a floating point number. The basic rule is that if the number * has no fractional or exponential part, it is an integer; otherwise * a floating point number. *<p> * Because much of input has to be processed in any case, no partial * parsing is done: all input text will be stored for further * processing. However, actual numeric value conversion will be * deferred, since it is usually the most complicated and costliest * part of processing. /* As per #105, need separating space between root values; check here*/ <BUGS> int len = ptr-startPtr; _textBuffer.resetWithShared(_inputBuffer, startPtr, len); return reset(negative, intLen, fractLen, expLen); <BUGE> } while (false);  _inputPtr = negative ? (startPtr+1) : startPtr; return _parseNumber2(negative); }  /** * Method called to parse a number, when the primary parse * method has failed to parse it, due to it being split on * buffer boundary. As a result code is very similar, except * that it has to explicitly copy contents to the text buffer * instead of just sharing the main input buffer. */
*/ public JsonParser createParser(byte[] data, int offset, int len) throws IOException, JsonParseException { <BUGS> IOContext ctxt = _createContext(data, true); <BUGE> /* [JACKSON-512]: allow wrapping with InputDecorator*/ if (_inputDecorator != null) { InputStream in = _inputDecorator.decorate(ctxt, data, offset, len); if (in != null) { return _createParser(in, ctxt); } } return _createParser(data, offset, len, ctxt); }
*/ public JsonParser createParser(byte[] data, int offset, int len) throws IOException, JsonParseException { IOContext ctxt = _createContext(data, true); /* [JACKSON-512]: allow wrapping with InputDecorator*/ <BUGS> if (_inputDecorator != null) { <BUGE> InputStream in = _inputDecorator.decorate(ctxt, data, offset, len); if (in != null) { return _createParser(in, ctxt); } } return _createParser(data, offset, len, ctxt); }
*/ public JsonParser createParser(byte[] data, int offset, int len) throws IOException, JsonParseException { IOContext ctxt = _createContext(data, true); /* [JACKSON-512]: allow wrapping with InputDecorator*/ if (_inputDecorator != null) { InputStream in = _inputDecorator.decorate(ctxt, data, offset, len); if (in != null) { return _createParser(in, ctxt); } } <BUGS> return _createParser(data, offset, len, ctxt); <BUGE> }
*/ public char[] expandCurrentSegment() { <BUGS> final char[] curr = _currentSegment; <BUGE> /* Let's grow by 50% by default*/ final int len = curr.length; /* but above intended maximum, slow to increase by 25%*/ int newLen = (len == MAX_SEGMENT_LEN) ? (MAX_SEGMENT_LEN+1) : Math.min(MAX_SEGMENT_LEN, len + (len >> 1)); return (_currentSegment = Arrays.copyOf(curr, newLen)); }
*/ public char[] expandCurrentSegment() { final char[] curr = _currentSegment; /* Let's grow by 50% by default*/ <BUGS> final int len = curr.length; <BUGE> /* but above intended maximum, slow to increase by 25%*/ int newLen = (len == MAX_SEGMENT_LEN) ? (MAX_SEGMENT_LEN+1) : Math.min(MAX_SEGMENT_LEN, len + (len >> 1)); return (_currentSegment = Arrays.copyOf(curr, newLen)); }
*/ public char[] expandCurrentSegment() { final char[] curr = _currentSegment; /* Let's grow by 50% by default*/ final int len = curr.length; /* but above intended maximum, slow to increase by 25%*/ <BUGS> int newLen = (len == MAX_SEGMENT_LEN) ? (MAX_SEGMENT_LEN+1) : Math.min(MAX_SEGMENT_LEN, len + (len >> 1)); return (_currentSegment = Arrays.copyOf(curr, newLen)); <BUGE> }
private final static int _parseIndex(String str) { <BUGS> final int len = str.length(); <BUGE> /* [Issue#133]: beware of super long indexes; assume we never*/ /* have arrays over 2 billion entries so ints are fine.*/ if (len == 0 || len > 10) { return -1; } for (int i = 0; i < len; ++i) { char c = str.charAt(i++); if (c > '9' || c < '0') { return -1; } } if (len == 10) { long l = NumberInput.parseLong(str); if (l > Integer.MAX_VALUE) { return -1; } } return NumberInput.parseInt(str); }
private final static int _parseIndex(String str) { final int len = str.length(); /* [Issue#133]: beware of super long indexes; assume we never*/ /* have arrays over 2 billion entries so ints are fine.*/ <BUGS> if (len == 0 || len > 10) { <BUGE> return -1; } for (int i = 0; i < len; ++i) { char c = str.charAt(i++); if (c > '9' || c < '0') { return -1; } } if (len == 10) { long l = NumberInput.parseLong(str); if (l > Integer.MAX_VALUE) { return -1; } } return NumberInput.parseInt(str); }
private final static int _parseIndex(String str) { final int len = str.length(); /* [Issue#133]: beware of super long indexes; assume we never*/ /* have arrays over 2 billion entries so ints are fine.*/ if (len == 0 || len > 10) { return -1; } <BUGS> for (int i = 0; i < len; ++i) { char c = str.charAt(i++); if (c > '9' || c < '0') { <BUGE> return -1; } } if (len == 10) { long l = NumberInput.parseLong(str); if (l > Integer.MAX_VALUE) { return -1; } } return NumberInput.parseInt(str); }
private final static int _parseIndex(String str) { final int len = str.length(); /* [Issue#133]: beware of super long indexes; assume we never*/ /* have arrays over 2 billion entries so ints are fine.*/ if (len == 0 || len > 10) { return -1; } for (int i = 0; i < len; ++i) { char c = str.charAt(i++); if (c > '9' || c < '0') { return -1; } } <BUGS> if (len == 10) { <BUGE> long l = NumberInput.parseLong(str); if (l > Integer.MAX_VALUE) { return -1; } } return NumberInput.parseInt(str); }
private final static int _parseIndex(String str) { final int len = str.length(); /* [Issue#133]: beware of super long indexes; assume we never*/ /* have arrays over 2 billion entries so ints are fine.*/ if (len == 0 || len > 10) { return -1; } for (int i = 0; i < len; ++i) { char c = str.charAt(i++); if (c > '9' || c < '0') { return -1; } } if (len == 10) { long l = NumberInput.parseLong(str); if (l > Integer.MAX_VALUE) { return -1; } } <BUGS> return NumberInput.parseInt(str); <BUGE> }
private final static int _parseIndex(String str) { <BUGS> final int len = str.length(); <BUGE> /* [core#133]: beware of super long indexes; assume we never*/ /* have arrays over 2 billion entries so ints are fine.*/ if (len == 0 || len > 10) { return -1; } /* [core#176]: no leading zeroes allowed*/ for (int i = 0; i < len; ++i) { char c = str.charAt(i); if (c > '9' || c < '0') { return -1; } } if (len == 10) { long l = NumberInput.parseLong(str); if (l > Integer.MAX_VALUE) { return -1; } } return NumberInput.parseInt(str); }
private final static int _parseIndex(String str) { final int len = str.length(); /* [core#133]: beware of super long indexes; assume we never*/ /* have arrays over 2 billion entries so ints are fine.*/ <BUGS> if (len == 0 || len > 10) { <BUGE> return -1; } /* [core#176]: no leading zeroes allowed*/ for (int i = 0; i < len; ++i) { char c = str.charAt(i); if (c > '9' || c < '0') { return -1; } } if (len == 10) { long l = NumberInput.parseLong(str); if (l > Integer.MAX_VALUE) { return -1; } } return NumberInput.parseInt(str); }
private final static int _parseIndex(String str) { final int len = str.length(); /* [core#133]: beware of super long indexes; assume we never*/ /* have arrays over 2 billion entries so ints are fine.*/ if (len == 0 || len > 10) { return -1; } /* [core#176]: no leading zeroes allowed*/ <BUGS> for (int i = 0; i < len; ++i) { char c = str.charAt(i); if (c > '9' || c < '0') { <BUGE> return -1; } } if (len == 10) { long l = NumberInput.parseLong(str); if (l > Integer.MAX_VALUE) { return -1; } } return NumberInput.parseInt(str); }
private final static int _parseIndex(String str) { final int len = str.length(); /* [core#133]: beware of super long indexes; assume we never*/ /* have arrays over 2 billion entries so ints are fine.*/ if (len == 0 || len > 10) { return -1; } /* [core#176]: no leading zeroes allowed*/ for (int i = 0; i < len; ++i) { char c = str.charAt(i); if (c > '9' || c < '0') { return -1; } } <BUGS> if (len == 10) { <BUGE> long l = NumberInput.parseLong(str); if (l > Integer.MAX_VALUE) { return -1; } } return NumberInput.parseInt(str); }
private final static int _parseIndex(String str) { final int len = str.length(); /* [core#133]: beware of super long indexes; assume we never*/ /* have arrays over 2 billion entries so ints are fine.*/ if (len == 0 || len > 10) { return -1; } /* [core#176]: no leading zeroes allowed*/ for (int i = 0; i < len; ++i) { char c = str.charAt(i); if (c > '9' || c < '0') { return -1; } } if (len == 10) { long l = NumberInput.parseLong(str); if (l > Integer.MAX_VALUE) { return -1; } } <BUGS> return NumberInput.parseInt(str); <BUGE> }
@Override public void flush() throws IOException { <BUGS> _flushBuffer(); if (_outputStream != null) { if (isEnabled(Feature.FLUSH_PASSED_TO_STREAM)) { _outputStream.flush(); <BUGE> } } }
@Override public void flush() throws IOException { _flushBuffer(); if (_outputStream != null) { if (isEnabled(Feature.FLUSH_PASSED_TO_STREAM)) { _outputStream.flush(); } } <BUGS> } <BUGE>
public char[] getTextBuffer() { /* Are we just using shared input buffer?*/ <BUGS> if (_inputStart >= 0) return _inputBuffer; if (_resultArray != null)  return _resultArray; if (_resultString != null) { <BUGE> return (_resultArray = _resultString.toCharArray()); } /* Nope; but does it fit in just one segment?*/ if (!_hasSegments)  return _currentSegment; /* Nope, need to have/create a non-segmented array and return it*/ return contentsAsArray(); }
public char[] getTextBuffer() { /* Are we just using shared input buffer?*/ if (_inputStart >= 0) return _inputBuffer; if (_resultArray != null)  return _resultArray; if (_resultString != null) { return (_resultArray = _resultString.toCharArray()); } /* Nope; but does it fit in just one segment?*/ <BUGS> if (!_hasSegments)  return _currentSegment; <BUGE> /* Nope, need to have/create a non-segmented array and return it*/ return contentsAsArray(); }
@Override public String getValueAsString(String defaultValue) throws IOException { <BUGS> if (_currToken == JsonToken.VALUE_STRING) { <BUGE> return getText(); } if (_currToken == null || _currToken == JsonToken.VALUE_NULL || !_currToken.isScalarValue()) { return defaultValue; } return getText(); }
@Override public String getValueAsString(String defaultValue) throws IOException { if (_currToken == JsonToken.VALUE_STRING) { return getText(); } <BUGS> if (_currToken == null || _currToken == JsonToken.VALUE_NULL || !_currToken.isScalarValue()) { return defaultValue; <BUGE> } return getText(); }
private void rehash() { <BUGS> _needRehash = false; <BUGE> /* Note: since we'll make copies, no need to unshare, can just mark as such:*/ _hashShared = false;  /* And then we can first deal with the main hash area. Since we are expanding*/ /* linearly (double up), we know there'll be no collisions during this phase.*/ final int[] oldHashArea = _hashArea; final String[] oldNames = _names; final int oldSize = _hashSize; final int oldCount = _count; final int newSize = oldSize + oldSize; final int oldEnd = _spilloverEnd;  /* 13-Mar-2010, tatu: Let's guard against OOME that could be caused by *    large documents with unique (or mostly so) names */ if (newSize > MAX_T_SIZE) { nukeSymbols(true); return; } /* double up main hash area, but do not expand long-name area:*/ _hashArea = new int[oldHashArea.length + (oldSize<<3)]; _hashSize = newSize; _secondaryStart = (newSize << 2); /* 4 ints per entry*/ _tertiaryStart = _secondaryStart + (_secondaryStart >> 1); /* right after secondary*/ _tertiaryShift = _calcTertiaryShift(newSize);
private void rehash() { _needRehash = false; /* Note: since we'll make copies, no need to unshare, can just mark as such:*/ <BUGS> _hashShared = false; <BUGE>  /* And then we can first deal with the main hash area. Since we are expanding*/ /* linearly (double up), we know there'll be no collisions during this phase.*/ final int[] oldHashArea = _hashArea; final String[] oldNames = _names; final int oldSize = _hashSize; final int oldCount = _count; final int newSize = oldSize + oldSize; final int oldEnd = _spilloverEnd;  /* 13-Mar-2010, tatu: Let's guard against OOME that could be caused by *    large documents with unique (or mostly so) names */ if (newSize > MAX_T_SIZE) { nukeSymbols(true); return; } /* double up main hash area, but do not expand long-name area:*/ _hashArea = new int[oldHashArea.length + (oldSize<<3)]; _hashSize = newSize; _secondaryStart = (newSize << 2); /* 4 ints per entry*/ _tertiaryStart = _secondaryStart + (_secondaryStart >> 1); /* right after secondary*/ _tertiaryShift = _calcTertiaryShift(newSize);
private void rehash() { _needRehash = false; /* Note: since we'll make copies, no need to unshare, can just mark as such:*/ _hashShared = false;  /* And then we can first deal with the main hash area. Since we are expanding*/ /* linearly (double up), we know there'll be no collisions during this phase.*/ <BUGS> final int[] oldHashArea = _hashArea; final String[] oldNames = _names; final int oldSize = _hashSize; final int oldCount = _count; final int newSize = oldSize + oldSize; final int oldEnd = _spilloverEnd; <BUGE>  /* 13-Mar-2010, tatu: Let's guard against OOME that could be caused by *    large documents with unique (or mostly so) names */ if (newSize > MAX_T_SIZE) { nukeSymbols(true); return; } /* double up main hash area, but do not expand long-name area:*/ _hashArea = new int[oldHashArea.length + (oldSize<<3)]; _hashSize = newSize; _secondaryStart = (newSize << 2); /* 4 ints per entry*/ _tertiaryStart = _secondaryStart + (_secondaryStart >> 1); /* right after secondary*/ _tertiaryShift = _calcTertiaryShift(newSize);
private void rehash() { _needRehash = false; /* Note: since we'll make copies, no need to unshare, can just mark as such:*/ _hashShared = false;  /* And then we can first deal with the main hash area. Since we are expanding*/ /* linearly (double up), we know there'll be no collisions during this phase.*/ final int[] oldHashArea = _hashArea; final String[] oldNames = _names; final int oldSize = _hashSize; final int oldCount = _count; final int newSize = oldSize + oldSize; final int oldEnd = _spilloverEnd;  /* 13-Mar-2010, tatu: Let's guard against OOME that could be caused by *    large documents with unique (or mostly so) names */ <BUGS> if (newSize > MAX_T_SIZE) { <BUGE> nukeSymbols(true); return; } /* double up main hash area, but do not expand long-name area:*/ _hashArea = new int[oldHashArea.length + (oldSize<<3)]; _hashSize = newSize; _secondaryStart = (newSize << 2); /* 4 ints per entry*/ _tertiaryStart = _secondaryStart + (_secondaryStart >> 1); /* right after secondary*/ _tertiaryShift = _calcTertiaryShift(newSize);
private void rehash() { _needRehash = false; /* Note: since we'll make copies, no need to unshare, can just mark as such:*/ _hashShared = false;  /* And then we can first deal with the main hash area. Since we are expanding*/ /* linearly (double up), we know there'll be no collisions during this phase.*/ final int[] oldHashArea = _hashArea; final String[] oldNames = _names; final int oldSize = _hashSize; final int oldCount = _count; final int newSize = oldSize + oldSize; final int oldEnd = _spilloverEnd;  /* 13-Mar-2010, tatu: Let's guard against OOME that could be caused by *    large documents with unique (or mostly so) names */ if (newSize > MAX_T_SIZE) { nukeSymbols(true); return; } /* double up main hash area, but do not expand long-name area:*/ <BUGS> _hashArea = new int[oldHashArea.length + (oldSize<<3)]; _hashSize = newSize; _secondaryStart = (newSize << 2); /* 4 ints per entry*/ _tertiaryStart = _secondaryStart + (_secondaryStart >> 1); /* right after secondary*/ _tertiaryShift = _calcTertiaryShift(newSize); <BUGE>
} hash *= MULT2;  /* and finally shuffle some more once done*/ hash += (hash >>> 19); hash ^= (hash << 5); return hash; }  /* /********************************************************** /* Rehashing /********************************************************** */ /* and simply double up name array*/ <BUGS> _names = new String[oldNames.length << 1]; nukeSymbols(false); <BUGE>  /* Plus we can scan only through the primary hash area, looking for non-empty*/ /* slots, without worrying about ordering. This should never reduce priority*/ /* of existing entries: primaries remain primaries; however, due to increased*/ /* space, secondaries may become primaries etc*/  int copyCount = 0; int[] q = new int[16]; for (int offset = 0, end = oldEnd; offset < end; offset += 4) { int len = oldHashArea[offset+3]; if (len == 0) { /* empty slot, skip*/ continue; }
/* and finally shuffle some more once done*/ hash += (hash >>> 19); hash ^= (hash << 5); return hash; }  /* /********************************************************** /* Rehashing /********************************************************** */  <BUGS> int copyCount = 0; int[] q = new int[16]; for (int offset = 0, end = oldEnd; offset < end; offset += 4) { int len = oldHashArea[offset+3]; if (len == 0) { /* empty slot, skip*/ continue; <BUGE> } ++copyCount; String name = oldNames[offset>>2]; switch (len) { case 1: q[0] = oldHashArea[offset]; addName(name, q, 1); break; case 2: q[0] = oldHashArea[offset]; q[1] = oldHashArea[offset+1];
hash *= MULT2;  /* and finally shuffle some more once done*/ hash += (hash >>> 19); hash ^= (hash << 5); return hash; }  /* /********************************************************** /* Rehashing /********************************************************** */ } <BUGS> ++copyCount; String name = oldNames[offset>>2]; switch (len) { <BUGE> case 1: q[0] = oldHashArea[offset]; addName(name, q, 1); break; case 2: q[0] = oldHashArea[offset]; q[1] = oldHashArea[offset+1]; addName(name, q, 2); break; case 3: q[0] = oldHashArea[offset]; q[1] = oldHashArea[offset+1]; q[2] = oldHashArea[offset+2];
hash *= MULT2;  /* and finally shuffle some more once done*/ hash += (hash >>> 19); hash ^= (hash << 5); return hash; }  /* /********************************************************** /* Rehashing /********************************************************** */ case 1: <BUGS> q[0] = oldHashArea[offset]; addName(name, q, 1); break; <BUGE> case 2: q[0] = oldHashArea[offset]; q[1] = oldHashArea[offset+1]; addName(name, q, 2); break; case 3: q[0] = oldHashArea[offset]; q[1] = oldHashArea[offset+1]; q[2] = oldHashArea[offset+2]; addName(name, q, 3); break; default: if (len > q.length) {
hash *= MULT2;  /* and finally shuffle some more once done*/ hash += (hash >>> 19); hash ^= (hash << 5); return hash; }  /* /********************************************************** /* Rehashing /********************************************************** */ case 2: <BUGS> q[0] = oldHashArea[offset]; q[1] = oldHashArea[offset+1]; addName(name, q, 2); break; <BUGE> case 3: q[0] = oldHashArea[offset]; q[1] = oldHashArea[offset+1]; q[2] = oldHashArea[offset+2]; addName(name, q, 3); break; default: if (len > q.length) { q = new int[len]; } /* #0 is hash, #1 offset*/ int qoff = oldHashArea[offset+1];
/* and finally shuffle some more once done*/ hash += (hash >>> 19); hash ^= (hash << 5); return hash; }  /* /********************************************************** /* Rehashing /********************************************************** */ case 3: <BUGS> q[0] = oldHashArea[offset]; q[1] = oldHashArea[offset+1]; q[2] = oldHashArea[offset+2]; addName(name, q, 3); break; <BUGE> default: if (len > q.length) { q = new int[len]; } /* #0 is hash, #1 offset*/ int qoff = oldHashArea[offset+1]; System.arraycopy(oldHashArea, qoff, q, 0, len); addName(name, q, len); break; } }
} hash *= MULT2;  /* and finally shuffle some more once done*/ hash += (hash >>> 19); hash ^= (hash << 5); return hash; }  /* /********************************************************** /* Rehashing /********************************************************** */ default: <BUGS> if (len > q.length) { <BUGE> q = new int[len]; } /* #0 is hash, #1 offset*/ int qoff = oldHashArea[offset+1]; System.arraycopy(oldHashArea, qoff, q, 0, len); addName(name, q, len); break; } }  /* Sanity checks: since corruption difficult to detect, assert explicitly*/ /* with production code*/ if (copyCount != oldCount) { throw new IllegalStateException("Failed rehash(): old count="+oldCount+", copyCount="+copyCount);
hash *= MULT2;  /* and finally shuffle some more once done*/ hash += (hash >>> 19); hash ^= (hash << 5); return hash; }  /* /********************************************************** /* Rehashing /********************************************************** */ /* #0 is hash, #1 offset*/ <BUGS> int qoff = oldHashArea[offset+1]; System.arraycopy(oldHashArea, qoff, q, 0, len); addName(name, q, len); <BUGE> break; } }  /* Sanity checks: since corruption difficult to detect, assert explicitly*/ /* with production code*/ if (copyCount != oldCount) { throw new IllegalStateException("Failed rehash(): old count="+oldCount+", copyCount="+copyCount); } }  /** * Helper method called to empty all shared symbols, but to leave
} hash *= MULT2;  /* and finally shuffle some more once done*/ hash += (hash >>> 19); hash ^= (hash << 5); return hash; }  /* /********************************************************** /* Rehashing /********************************************************** */ /* with production code*/ <BUGS> if (copyCount != oldCount) { <BUGE> throw new IllegalStateException("Failed rehash(): old count="+oldCount+", copyCount="+copyCount); } }  /** * Helper method called to empty all shared symbols, but to leave * arrays allocated */ private void nukeSymbols(boolean fill) { _count = 0; /* reset spill-over to empty (starting at 7/8 of hash area)*/ _spilloverEnd = _spilloverStart(); /* and long name area to empty, starting immediately after hash area*/ _longNameOffset = _hashSize << 3;
} hash *= MULT2;  /* and finally shuffle some more once done*/ hash += (hash >>> 19); hash ^= (hash << 5); return hash; }  /* /********************************************************** /* Rehashing /********************************************************** */ } <BUGS> } <BUGE>  /** * Helper method called to empty all shared symbols, but to leave * arrays allocated */ private void nukeSymbols(boolean fill) { _count = 0; /* reset spill-over to empty (starting at 7/8 of hash area)*/ _spilloverEnd = _spilloverStart(); /* and long name area to empty, starting immediately after hash area*/ _longNameOffset = _hashSize << 3; if (fill) { Arrays.fill(_hashArea, 0); Arrays.fill(_names, null);
private String _findSecondary(int origOffset, int q1) { /* tertiary area division is dynamic. First; its size is N/4 compared to*/ /* primary hash size; and offsets are for 4 int slots. So to get to logical*/ /* index would shift by 4. But! Tertiary area is further split into buckets,*/ /* determined by shift value. And finally, from bucket back into physical offsets*/ <BUGS> int offset = _tertiaryStart + ((origOffset >> (_tertiaryShift + 2)) << _tertiaryShift); final int[] hashArea = _hashArea; final int bucketSize = (1 << _tertiaryShift); for (int end = offset + bucketSize; offset < end; offset += 4) { int len = hashArea[offset+3]; if ((q1 == hashArea[offset]) && (1 == len)) { <BUGE> return _names[offset >> 2]; } if (len == 0) { return null; } } /* but if tertiary full, check out spill-over area as last resort*/ /* shared spillover starts at 7/8 of the main hash area*/ /* (which is sized at 2 * _hashSize), so:*/ for (offset = _spilloverStart(); offset < _spilloverEnd; offset += 4) { if ((q1 == hashArea[offset]) && (1 == hashArea[offset+3])) { return _names[offset >> 2]; } } return null; }
private String _findSecondary(int origOffset, int q1) { /* tertiary area division is dynamic. First; its size is N/4 compared to*/ /* primary hash size; and offsets are for 4 int slots. So to get to logical*/ /* index would shift by 4. But! Tertiary area is further split into buckets,*/ /* determined by shift value. And finally, from bucket back into physical offsets*/ int offset = _tertiaryStart + ((origOffset >> (_tertiaryShift + 2)) << _tertiaryShift); final int[] hashArea = _hashArea; final int bucketSize = (1 << _tertiaryShift); for (int end = offset + bucketSize; offset < end; offset += 4) { int len = hashArea[offset+3]; if ((q1 == hashArea[offset]) && (1 == len)) { return _names[offset >> 2]; } <BUGS> if (len == 0) { return null; <BUGE> } } /* but if tertiary full, check out spill-over area as last resort*/ /* shared spillover starts at 7/8 of the main hash area*/ /* (which is sized at 2 * _hashSize), so:*/ for (offset = _spilloverStart(); offset < _spilloverEnd; offset += 4) { if ((q1 == hashArea[offset]) && (1 == hashArea[offset+3])) { return _names[offset >> 2]; } } return null; }
private String _findSecondary(int origOffset, int q1) { /* tertiary area division is dynamic. First; its size is N/4 compared to*/ /* primary hash size; and offsets are for 4 int slots. So to get to logical*/ /* index would shift by 4. But! Tertiary area is further split into buckets,*/ /* determined by shift value. And finally, from bucket back into physical offsets*/ int offset = _tertiaryStart + ((origOffset >> (_tertiaryShift + 2)) << _tertiaryShift); final int[] hashArea = _hashArea; final int bucketSize = (1 << _tertiaryShift); for (int end = offset + bucketSize; offset < end; offset += 4) { int len = hashArea[offset+3]; if ((q1 == hashArea[offset]) && (1 == len)) { return _names[offset >> 2]; } if (len == 0) { return null; } } /* but if tertiary full, check out spill-over area as last resort*/ /* shared spillover starts at 7/8 of the main hash area*/ /* (which is sized at 2 * _hashSize), so:*/ <BUGS> for (offset = _spilloverStart(); offset < _spilloverEnd; offset += 4) { if ((q1 == hashArea[offset]) && (1 == hashArea[offset+3])) { <BUGE> return _names[offset >> 2]; } } return null; }
private String _findSecondary(int origOffset, int q1) { /* tertiary area division is dynamic. First; its size is N/4 compared to*/ /* primary hash size; and offsets are for 4 int slots. So to get to logical*/ /* index would shift by 4. But! Tertiary area is further split into buckets,*/ /* determined by shift value. And finally, from bucket back into physical offsets*/ int offset = _tertiaryStart + ((origOffset >> (_tertiaryShift + 2)) << _tertiaryShift); final int[] hashArea = _hashArea; final int bucketSize = (1 << _tertiaryShift); for (int end = offset + bucketSize; offset < end; offset += 4) { int len = hashArea[offset+3]; if ((q1 == hashArea[offset]) && (1 == len)) { return _names[offset >> 2]; } if (len == 0) { return null; } } /* but if tertiary full, check out spill-over area as last resort*/ /* shared spillover starts at 7/8 of the main hash area*/ /* (which is sized at 2 * _hashSize), so:*/ for (offset = _spilloverStart(); offset < _spilloverEnd; offset += 4) { if ((q1 == hashArea[offset]) && (1 == hashArea[offset+3])) { return _names[offset >> 2]; } } <BUGS> return null; <BUGE> }
*/ public JsonParser createParser(char[] content) throws IOException { <BUGS> return createParser(content, 0, content.length); <BUGE> }
@Override public JsonGenerator disable(Feature f) { <BUGS> final int mask = f.getMask(); _features &= ~mask; if ((mask & DERIVED_FEATURES_MASK) != 0) { <BUGE> if (f == Feature.WRITE_NUMBERS_AS_STRINGS) { _cfgNumbersAsStrings = false; } else if (f == Feature.ESCAPE_NON_ASCII) { setHighestNonEscapedChar(0); } else if (f == Feature.STRICT_DUPLICATE_DETECTION) { _writeContext = _writeContext.withDupDetector(null); } } return this; }
@Override public JsonGenerator disable(Feature f) { final int mask = f.getMask(); _features &= ~mask; if ((mask & DERIVED_FEATURES_MASK) != 0) { if (f == Feature.WRITE_NUMBERS_AS_STRINGS) { _cfgNumbersAsStrings = false; } else if (f == Feature.ESCAPE_NON_ASCII) { setHighestNonEscapedChar(0); } else if (f == Feature.STRICT_DUPLICATE_DETECTION) { _writeContext = _writeContext.withDupDetector(null); } } <BUGS> return this; <BUGE> }
private IllegalArgumentException wrongBuf() { /* sanity check failed; trying to return different, smaller buffer.*/ <BUGS> return new IllegalArgumentException("Trying to release buffer not owned by the context"); <BUGE> }
@Override <BUGS> public final String getValue() { return _value; } <BUGE>
protected final JsonToken reset(boolean negative, int intLen, int fractLen, int expLen) { <BUGS> if (fractLen < 1 && expLen < 1) { /* integer*/ return resetInt(negative, intLen); <BUGE> } return resetFloat(negative, intLen, fractLen, expLen); }
private void writeRawLong(String text) throws IOException { <BUGS> int room = _outputEnd - _outputTail; <BUGE> /* If not, need to do it by looping*/ text.getChars(0, room, _outputBuffer, _outputTail); _outputTail += room; _flushBuffer(); int offset = room; int len = text.length() - room;  while (len > _outputEnd) { int amount = _outputEnd; text.getChars(offset, offset+amount, _outputBuffer, 0); _outputHead = 0; _outputTail = amount; _flushBuffer(); offset += amount; len -= amount; } /* And last piece (at most length of buffer)*/ text.getChars(offset, offset+len, _outputBuffer, 0); _outputHead = 0; _outputTail = len; }
private void writeRawLong(String text) throws IOException { int room = _outputEnd - _outputTail; /* If not, need to do it by looping*/ <BUGS> text.getChars(0, room, _outputBuffer, _outputTail); _outputTail += room; _flushBuffer(); int offset = room; int len = text.length() - room; <BUGE>  while (len > _outputEnd) { int amount = _outputEnd; text.getChars(offset, offset+amount, _outputBuffer, 0); _outputHead = 0; _outputTail = amount; _flushBuffer(); offset += amount; len -= amount; } /* And last piece (at most length of buffer)*/ text.getChars(offset, offset+len, _outputBuffer, 0); _outputHead = 0; _outputTail = len; }
private void writeRawLong(String text) throws IOException { int room = _outputEnd - _outputTail; /* If not, need to do it by looping*/ text.getChars(0, room, _outputBuffer, _outputTail); _outputTail += room; _flushBuffer(); int offset = room; int len = text.length() - room;  <BUGS> while (len > _outputEnd) { int amount = _outputEnd; text.getChars(offset, offset+amount, _outputBuffer, 0); _outputHead = 0; _outputTail = amount; _flushBuffer(); offset += amount; len -= amount; } <BUGE> /* And last piece (at most length of buffer)*/ text.getChars(offset, offset+len, _outputBuffer, 0); _outputHead = 0; _outputTail = len; }
private void writeRawLong(String text) throws IOException { int room = _outputEnd - _outputTail; /* If not, need to do it by looping*/ text.getChars(0, room, _outputBuffer, _outputTail); _outputTail += room; _flushBuffer(); int offset = room; int len = text.length() - room;  while (len > _outputEnd) { int amount = _outputEnd; text.getChars(offset, offset+amount, _outputBuffer, 0); _outputHead = 0; _outputTail = amount; _flushBuffer(); offset += amount; len -= amount; } /* And last piece (at most length of buffer)*/ <BUGS> text.getChars(offset, offset+len, _outputBuffer, 0); _outputHead = 0; _outputTail = len; } <BUGE>
private final JsonToken _parseFloat(int ch, int startPtr, int ptr, boolean neg, int intLen) throws IOException { <BUGS> final int inputLen = _inputEnd; int fractLen = 0; <BUGE>  /* And then see if we get other parts*/ if (ch == '.') { /* yes, fraction*/ fract_loop: while (true) { if (ptr >= inputLen) { return _parseNumber2(neg, startPtr); } ch = (int) _inputBuffer[ptr++]; if (ch < INT_0 || ch > INT_9) { break fract_loop; } ++fractLen; } /* must be followed by sequence of ints, one minimum*/ if (fractLen == 0) { reportUnexpectedNumberChar(ch, "Decimal point not followed by a digit"); } } int expLen = 0; if (ch == 'e' || ch == 'E') { /* and/or exponent*/ if (ptr >= inputLen) { _inputPtr = startPtr; return _parseNumber2(neg, startPtr);
private final JsonToken _parseFloat(int ch, int startPtr, int ptr, boolean neg, int intLen) throws IOException { final int inputLen = _inputEnd; int fractLen = 0;  /* And then see if we get other parts*/ <BUGS> if (ch == '.') { /* yes, fraction <BUGE>*/ fract_loop: while (true) { if (ptr >= inputLen) { return _parseNumber2(neg, startPtr); } ch = (int) _inputBuffer[ptr++]; if (ch < INT_0 || ch > INT_9) { break fract_loop; } ++fractLen; } /* must be followed by sequence of ints, one minimum*/ if (fractLen == 0) { reportUnexpectedNumberChar(ch, "Decimal point not followed by a digit"); } } int expLen = 0; if (ch == 'e' || ch == 'E') { /* and/or exponent*/ if (ptr >= inputLen) { _inputPtr = startPtr; return _parseNumber2(neg, startPtr);
private final JsonToken _parseFloat(int ch, int startPtr, int ptr, boolean neg, int intLen) throws IOException { final int inputLen = _inputEnd; int fractLen = 0;  /* And then see if we get other parts*/ if (ch == '.') { /* yes, fraction*/ fract_loop: while (true) { <BUGS> if (ptr >= inputLen) { return _parseNumber2(neg, startPtr); <BUGE> } ch = (int) _inputBuffer[ptr++]; if (ch < INT_0 || ch > INT_9) { break fract_loop; } ++fractLen; } /* must be followed by sequence of ints, one minimum*/ if (fractLen == 0) { reportUnexpectedNumberChar(ch, "Decimal point not followed by a digit"); } } int expLen = 0; if (ch == 'e' || ch == 'E') { /* and/or exponent*/ if (ptr >= inputLen) { _inputPtr = startPtr; return _parseNumber2(neg, startPtr);
private final JsonToken _parseFloat(int ch, int startPtr, int ptr, boolean neg, int intLen) throws IOException { final int inputLen = _inputEnd; int fractLen = 0;  /* And then see if we get other parts*/ if (ch == '.') { /* yes, fraction*/ fract_loop: while (true) { if (ptr >= inputLen) { return _parseNumber2(neg, startPtr); } <BUGS> ch = (int) _inputBuffer[ptr++]; if (ch < INT_0 || ch > INT_9) { <BUGE> break fract_loop; } ++fractLen; } /* must be followed by sequence of ints, one minimum*/ if (fractLen == 0) { reportUnexpectedNumberChar(ch, "Decimal point not followed by a digit"); } } int expLen = 0; if (ch == 'e' || ch == 'E') { /* and/or exponent*/ if (ptr >= inputLen) { _inputPtr = startPtr; return _parseNumber2(neg, startPtr);
private final JsonToken _parseFloat(int ch, int startPtr, int ptr, boolean neg, int intLen) throws IOException { final int inputLen = _inputEnd; int fractLen = 0;  /* And then see if we get other parts*/ if (ch == '.') { /* yes, fraction*/ fract_loop: while (true) { if (ptr >= inputLen) { return _parseNumber2(neg, startPtr); } ch = (int) _inputBuffer[ptr++]; if (ch < INT_0 || ch > INT_9) { break fract_loop; } <BUGS> ++fractLen; <BUGE> } /* must be followed by sequence of ints, one minimum*/ if (fractLen == 0) { reportUnexpectedNumberChar(ch, "Decimal point not followed by a digit"); } } int expLen = 0; if (ch == 'e' || ch == 'E') { /* and/or exponent*/ if (ptr >= inputLen) { _inputPtr = startPtr; return _parseNumber2(neg, startPtr);
*/ public void writeEmbeddedObject(Object object) throws IOException { /* 01-Sep-2016, tatu: As per [core#318], handle small number of cases*/ <BUGS> throw new JsonGenerationException("No native support for writing embedded objects", <BUGE> this); }
*/ public int getMatchCount() { <BUGS> return _matchCount; <BUGE> }
@Override public DefaultPrettyPrinter createInstance() { <BUGS> return new DefaultPrettyPrinter(this); <BUGE> }
/* @since 2.9.8*/ protected String _longIntegerDesc(String rawNum) { <BUGS> int rawLen = rawNum.length(); if (rawLen < 1000) { return rawNum; <BUGE> } if (rawNum.startsWith("-")) { rawLen -= 1; } return String.format("[Integer with %d digits]", rawLen); }
/* @since 2.9.8*/ protected String _longIntegerDesc(String rawNum) { int rawLen = rawNum.length(); if (rawLen < 1000) { return rawNum; } <BUGS> if (rawNum.startsWith("-")) { <BUGE> rawLen -= 1; } return String.format("[Integer with %d digits]", rawLen); }
/* @since 2.9.8*/ protected String _longIntegerDesc(String rawNum) { int rawLen = rawNum.length(); if (rawLen < 1000) { return rawNum; } if (rawNum.startsWith("-")) { rawLen -= 1; } <BUGS> return String.format("[Integer with %d digits]", rawLen); <BUGE> }
*/ protected String _handleOddName(int i) throws IOException { /* [JACKSON-173]: allow single quotes*/ <BUGS> if (i == '\'' && isEnabled(Feature.ALLOW_SINGLE_QUOTES)) { <BUGE> return _parseAposName(); } /* [JACKSON-69]: allow unquoted names if feature enabled:*/ if (!isEnabled(Feature.ALLOW_UNQUOTED_FIELD_NAMES)) { _reportUnexpectedChar(i, "was expecting double-quote to start field name"); } final int[] codes = CharTypes.getInputCodeLatin1JsNames(); final int maxCode = codes.length;  /* Also: first char must be a valid name char, but NOT be number*/ boolean firstOk;  if (i < maxCode) { /* identifier, or a number ([Issue#102])*/ firstOk = (codes[i] == 0); } else { firstOk = Character.isJavaIdentifierPart((char) i); } if (!firstOk) { _reportUnexpectedChar(i, "was expecting either valid name character (for unquoted name) or double-quote (for quoted) to start field name"); } int ptr = _inputPtr; int hash = _hashSeed; final int inputLen = _inputEnd;  if (ptr < inputLen) {
*/ protected String _handleOddName(int i) throws IOException { /* [JACKSON-173]: allow single quotes*/ if (i == '\'' && isEnabled(Feature.ALLOW_SINGLE_QUOTES)) { return _parseAposName(); } /* [JACKSON-69]: allow unquoted names if feature enabled:*/ <BUGS> if (!isEnabled(Feature.ALLOW_UNQUOTED_FIELD_NAMES)) { <BUGE> _reportUnexpectedChar(i, "was expecting double-quote to start field name"); } final int[] codes = CharTypes.getInputCodeLatin1JsNames(); final int maxCode = codes.length;  /* Also: first char must be a valid name char, but NOT be number*/ boolean firstOk;  if (i < maxCode) { /* identifier, or a number ([Issue#102])*/ firstOk = (codes[i] == 0); } else { firstOk = Character.isJavaIdentifierPart((char) i); } if (!firstOk) { _reportUnexpectedChar(i, "was expecting either valid name character (for unquoted name) or double-quote (for quoted) to start field name"); } int ptr = _inputPtr; int hash = _hashSeed; final int inputLen = _inputEnd;  if (ptr < inputLen) {
*/ protected String _handleOddName(int i) throws IOException { /* [JACKSON-173]: allow single quotes*/ if (i == '\'' && isEnabled(Feature.ALLOW_SINGLE_QUOTES)) { return _parseAposName(); } /* [JACKSON-69]: allow unquoted names if feature enabled:*/ if (!isEnabled(Feature.ALLOW_UNQUOTED_FIELD_NAMES)) { _reportUnexpectedChar(i, "was expecting double-quote to start field name"); } <BUGS> final int[] codes = CharTypes.getInputCodeLatin1JsNames(); final int maxCode = codes.length; <BUGE>  /* Also: first char must be a valid name char, but NOT be number*/ boolean firstOk;  if (i < maxCode) { /* identifier, or a number ([Issue#102])*/ firstOk = (codes[i] == 0); } else { firstOk = Character.isJavaIdentifierPart((char) i); } if (!firstOk) { _reportUnexpectedChar(i, "was expecting either valid name character (for unquoted name) or double-quote (for quoted) to start field name"); } int ptr = _inputPtr; int hash = _hashSeed; final int inputLen = _inputEnd;  if (ptr < inputLen) {
*/ protected String _handleOddName(int i) throws IOException { /* [JACKSON-173]: allow single quotes*/ if (i == '\'' && isEnabled(Feature.ALLOW_SINGLE_QUOTES)) { return _parseAposName(); } /* [JACKSON-69]: allow unquoted names if feature enabled:*/ if (!isEnabled(Feature.ALLOW_UNQUOTED_FIELD_NAMES)) { _reportUnexpectedChar(i, "was expecting double-quote to start field name"); } final int[] codes = CharTypes.getInputCodeLatin1JsNames(); final int maxCode = codes.length;  /* Also: first char must be a valid name char, but NOT be number*/ boolean firstOk;  <BUGS> if (i < maxCode) { /* identifier, or a number ([Issue#102])*/ firstOk = (codes[i] == 0); <BUGE> } else { firstOk = Character.isJavaIdentifierPart((char) i); } if (!firstOk) { _reportUnexpectedChar(i, "was expecting either valid name character (for unquoted name) or double-quote (for quoted) to start field name"); } int ptr = _inputPtr; int hash = _hashSeed; final int inputLen = _inputEnd;  if (ptr < inputLen) {
*/ protected String _handleOddName(int i) throws IOException { /* [JACKSON-173]: allow single quotes*/ if (i == '\'' && isEnabled(Feature.ALLOW_SINGLE_QUOTES)) { return _parseAposName(); } /* [JACKSON-69]: allow unquoted names if feature enabled:*/ if (!isEnabled(Feature.ALLOW_UNQUOTED_FIELD_NAMES)) { _reportUnexpectedChar(i, "was expecting double-quote to start field name"); } final int[] codes = CharTypes.getInputCodeLatin1JsNames(); final int maxCode = codes.length;  /* Also: first char must be a valid name char, but NOT be number*/ boolean firstOk;  if (i < maxCode) { /* identifier, or a number ([Issue#102])*/ firstOk = (codes[i] == 0); } else { firstOk = Character.isJavaIdentifierPart((char) i); } <BUGS> if (!firstOk) { <BUGE> _reportUnexpectedChar(i, "was expecting either valid name character (for unquoted name) or double-quote (for quoted) to start field name"); } int ptr = _inputPtr; int hash = _hashSeed; final int inputLen = _inputEnd;  if (ptr < inputLen) {
*/ protected String _handleOddName(int i) throws IOException { /* [JACKSON-173]: allow single quotes*/ if (i == '\'' && isEnabled(Feature.ALLOW_SINGLE_QUOTES)) { return _parseAposName(); } /* [JACKSON-69]: allow unquoted names if feature enabled:*/ if (!isEnabled(Feature.ALLOW_UNQUOTED_FIELD_NAMES)) { _reportUnexpectedChar(i, "was expecting double-quote to start field name"); } final int[] codes = CharTypes.getInputCodeLatin1JsNames(); final int maxCode = codes.length;  /* Also: first char must be a valid name char, but NOT be number*/ boolean firstOk;  if (i < maxCode) { /* identifier, or a number ([Issue#102])*/ firstOk = (codes[i] == 0); } else { firstOk = Character.isJavaIdentifierPart((char) i); } if (!firstOk) { _reportUnexpectedChar(i, "was expecting either valid name character (for unquoted name) or double-quote (for quoted) to start field name"); } <BUGS> int ptr = _inputPtr; int hash = _hashSeed; final int inputLen = _inputEnd; <BUGE>  if (ptr < inputLen) {
*/ protected String _handleOddName(int i) throws IOException { /* [JACKSON-173]: allow single quotes*/ if (i == '\'' && isEnabled(Feature.ALLOW_SINGLE_QUOTES)) { return _parseAposName(); } /* [JACKSON-69]: allow unquoted names if feature enabled:*/ if (!isEnabled(Feature.ALLOW_UNQUOTED_FIELD_NAMES)) { _reportUnexpectedChar(i, "was expecting double-quote to start field name"); } final int[] codes = CharTypes.getInputCodeLatin1JsNames(); final int maxCode = codes.length;  /* Also: first char must be a valid name char, but NOT be number*/ boolean firstOk;  if (i < maxCode) { /* identifier, or a number ([Issue#102])*/ firstOk = (codes[i] == 0); } else { firstOk = Character.isJavaIdentifierPart((char) i); } if (!firstOk) { _reportUnexpectedChar(i, "was expecting either valid name character (for unquoted name) or double-quote (for quoted) to start field name"); } int ptr = _inputPtr; int hash = _hashSeed; final int inputLen = _inputEnd;  <BUGS> if (ptr < inputLen) { <BUGE>
TextBuffer tb = _textBuffer; char[] buf = tb.getTextBuffer(); int start = tb.getTextOffset(); int len = tb.size(); return _symbols.findSymbol(buf, start, len, hash); } }  /** * Method called when we see non-white space character other * than double quote, when expecting a field name. * In standard mode will just throw an expection; but * in non-standard modes may be able to parse name. } <BUGS> int start = _inputPtr-1; _inputPtr = ptr; return _handleOddName2(start, hash, codes); <BUGE> }  protected String _parseAposName() throws IOException { /* Note: mostly copy of_parseFieldName*/ int ptr = _inputPtr; int hash = _hashSeed; final int inputLen = _inputEnd;  if (ptr < inputLen) { final int[] codes = _icLatin1; final int maxCode = codes.length;
*/ public long getByteOffset() { <BUGS> return _totalBytes; <BUGE> }
private boolean _verifyLongName(int[] q, int qlen, int spillOffset) { <BUGS> final int[] hashArea = _hashArea; <BUGE> /* spillOffset assumed to be physical index right into quad string*/ int ix = 0;  switch (qlen) { default: return _verifyLongName2(q, qlen, spillOffset); case 8: if (q[ix++] != hashArea[spillOffset++]) return false; case 7: if (q[ix++] != hashArea[spillOffset++]) return false; case 6: if (q[ix++] != hashArea[spillOffset++]) return false; case 5: if (q[ix++] != hashArea[spillOffset++]) return false; case 4: /* always at least 4*/ if (q[ix++] != hashArea[spillOffset++]) return false; if (q[ix++] != hashArea[spillOffset++]) return false; if (q[ix++] != hashArea[spillOffset++]) return false; if (q[ix++] != hashArea[spillOffset++]) return false; } return true; }
private boolean _verifyLongName(int[] q, int qlen, int spillOffset) { final int[] hashArea = _hashArea; /* spillOffset assumed to be physical index right into quad string*/ <BUGS> int ix = 0; <BUGE>  switch (qlen) { default: return _verifyLongName2(q, qlen, spillOffset); case 8: if (q[ix++] != hashArea[spillOffset++]) return false; case 7: if (q[ix++] != hashArea[spillOffset++]) return false; case 6: if (q[ix++] != hashArea[spillOffset++]) return false; case 5: if (q[ix++] != hashArea[spillOffset++]) return false; case 4: /* always at least 4*/ if (q[ix++] != hashArea[spillOffset++]) return false; if (q[ix++] != hashArea[spillOffset++]) return false; if (q[ix++] != hashArea[spillOffset++]) return false; if (q[ix++] != hashArea[spillOffset++]) return false; } return true; }
private boolean _verifyLongName(int[] q, int qlen, int spillOffset) { final int[] hashArea = _hashArea; /* spillOffset assumed to be physical index right into quad string*/ int ix = 0;  <BUGS> switch (qlen) { <BUGE> default: return _verifyLongName2(q, qlen, spillOffset); case 8: if (q[ix++] != hashArea[spillOffset++]) return false; case 7: if (q[ix++] != hashArea[spillOffset++]) return false; case 6: if (q[ix++] != hashArea[spillOffset++]) return false; case 5: if (q[ix++] != hashArea[spillOffset++]) return false; case 4: /* always at least 4*/ if (q[ix++] != hashArea[spillOffset++]) return false; if (q[ix++] != hashArea[spillOffset++]) return false; if (q[ix++] != hashArea[spillOffset++]) return false; if (q[ix++] != hashArea[spillOffset++]) return false; } return true; }
private boolean _verifyLongName(int[] q, int qlen, int spillOffset) { final int[] hashArea = _hashArea; /* spillOffset assumed to be physical index right into quad string*/ int ix = 0;  switch (qlen) { default: return _verifyLongName2(q, qlen, spillOffset); case 8: if (q[ix++] != hashArea[spillOffset++]) return false; case 7: if (q[ix++] != hashArea[spillOffset++]) return false; case 6: if (q[ix++] != hashArea[spillOffset++]) return false; case 5: <BUGS> if (q[ix++] != hashArea[spillOffset++]) return false; <BUGE> case 4: /* always at least 4*/ if (q[ix++] != hashArea[spillOffset++]) return false; if (q[ix++] != hashArea[spillOffset++]) return false; if (q[ix++] != hashArea[spillOffset++]) return false; if (q[ix++] != hashArea[spillOffset++]) return false; } return true; }
private boolean _verifyLongName(int[] q, int qlen, int spillOffset) { final int[] hashArea = _hashArea; /* spillOffset assumed to be physical index right into quad string*/ int ix = 0;  switch (qlen) { default: return _verifyLongName2(q, qlen, spillOffset); case 8: if (q[ix++] != hashArea[spillOffset++]) return false; case 7: if (q[ix++] != hashArea[spillOffset++]) return false; case 6: if (q[ix++] != hashArea[spillOffset++]) return false; case 5: if (q[ix++] != hashArea[spillOffset++]) return false; case 4: /* always at least 4*/ <BUGS> if (q[ix++] != hashArea[spillOffset++]) return false; if (q[ix++] != hashArea[spillOffset++]) return false; if (q[ix++] != hashArea[spillOffset++]) return false; <BUGE> if (q[ix++] != hashArea[spillOffset++]) return false; } return true; }
*/ public JsonFactory copy() { <BUGS> _checkInvalidCopy(JsonFactory.class); <BUGE> /* as per above, do clear ObjectCodec*/ return new JsonFactory(this, null); }
*/ public JsonFactory copy() { _checkInvalidCopy(JsonFactory.class); /* as per above, do clear ObjectCodec*/ <BUGS> return new JsonFactory(this, null); <BUGE> }
@Override public Boolean nextBooleanValue() throws IOException { /* two distinct cases; either got name and we know next type, or 'other'*/ <BUGS> if (_currToken == JsonToken.FIELD_NAME) { /* mostly copied from '_nextAfterName' <BUGE>*/ _nameCopied = false; JsonToken t = _nextToken; _nextToken = null; _currToken = t; if (t == JsonToken.VALUE_TRUE) { return Boolean.TRUE; } if (t == JsonToken.VALUE_FALSE) { return Boolean.FALSE; } if (t == JsonToken.START_ARRAY) { _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); } else if (t == JsonToken.START_OBJECT) { _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); } return null; }  JsonToken t = nextToken(); if (t == JsonToken.VALUE_TRUE) { return Boolean.TRUE; } if (t == JsonToken.VALUE_FALSE) { return Boolean.FALSE; }
@Override public Boolean nextBooleanValue() throws IOException { /* two distinct cases; either got name and we know next type, or 'other'*/ if (_currToken == JsonToken.FIELD_NAME) { /* mostly copied from '_nextAfterName'*/ _nameCopied = false; JsonToken t = _nextToken; _nextToken = null; _currToken = t; if (t == JsonToken.VALUE_TRUE) { return Boolean.TRUE; } if (t == JsonToken.VALUE_FALSE) { return Boolean.FALSE; } if (t == JsonToken.START_ARRAY) { _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); } else if (t == JsonToken.START_OBJECT) { _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); } return null; }  <BUGS> JsonToken t = nextToken(); <BUGE> if (t == JsonToken.VALUE_TRUE) { return Boolean.TRUE; } if (t == JsonToken.VALUE_FALSE) { return Boolean.FALSE; }
*/ <BUGS> public JsonFactory() { this((ObjectCodec) null); } <BUGE>
*/ public void serializeAsColumn(Object bean, JsonGenerator jgen, SerializerProvider prov) throws Exception { <BUGS> Object value = get(bean); if (value == null) { /* nulls need specialized handling*/ if (_nullSerializer != null) { _nullSerializer.serialize(null, jgen, prov); <BUGE> } else { /* can NOT suppress entries in tabular output*/ jgen.writeNull(); } } /* otherwise find serializer to use*/ JsonSerializer<Object> ser = _serializer; if (ser == null) { Class<?> cls = value.getClass(); PropertySerializerMap map = _dynamicSerializers; ser = map.serializerFor(cls); if (ser == null) { ser = _findAndAddDynamic(map, cls, prov); } } /* and then see if we must suppress certain values (default, empty)*/ if (_suppressableValue != null) { if (MARKER_FOR_EMPTY == _suppressableValue) { if (ser.isEmpty(value)) { /* can NOT suppress entries in tabular output*/ serializeAsPlaceholder(bean, jgen, prov); return; } } else if (_suppressableValue.equals(value)) { /* can NOT suppress entries in tabular output*/
*/ public void serializeAsColumn(Object bean, JsonGenerator jgen, SerializerProvider prov) throws Exception { Object value = get(bean); if (value == null) { /* nulls need specialized handling*/ if (_nullSerializer != null) { _nullSerializer.serialize(null, jgen, prov); } else { /* can NOT suppress entries in tabular output*/ jgen.writeNull(); } } /* otherwise find serializer to use*/ <BUGS> JsonSerializer<Object> ser = _serializer; if (ser == null) { <BUGE> Class<?> cls = value.getClass(); PropertySerializerMap map = _dynamicSerializers; ser = map.serializerFor(cls); if (ser == null) { ser = _findAndAddDynamic(map, cls, prov); } } /* and then see if we must suppress certain values (default, empty)*/ if (_suppressableValue != null) { if (MARKER_FOR_EMPTY == _suppressableValue) { if (ser.isEmpty(value)) { /* can NOT suppress entries in tabular output*/ serializeAsPlaceholder(bean, jgen, prov); return; } } else if (_suppressableValue.equals(value)) { /* can NOT suppress entries in tabular output*/
*/ public void serializeAsColumn(Object bean, JsonGenerator jgen, SerializerProvider prov) throws Exception { Object value = get(bean); if (value == null) { /* nulls need specialized handling*/ if (_nullSerializer != null) { _nullSerializer.serialize(null, jgen, prov); } else { /* can NOT suppress entries in tabular output*/ jgen.writeNull(); } } /* otherwise find serializer to use*/ JsonSerializer<Object> ser = _serializer; if (ser == null) { Class<?> cls = value.getClass(); PropertySerializerMap map = _dynamicSerializers; ser = map.serializerFor(cls); if (ser == null) { ser = _findAndAddDynamic(map, cls, prov); } } /* and then see if we must suppress certain values (default, empty)*/ <BUGS> if (_suppressableValue != null) { <BUGE> if (MARKER_FOR_EMPTY == _suppressableValue) { if (ser.isEmpty(value)) { /* can NOT suppress entries in tabular output*/ serializeAsPlaceholder(bean, jgen, prov); return; } } else if (_suppressableValue.equals(value)) { /* can NOT suppress entries in tabular output*/
jgen.writeFieldName(_name); if (_typeSerializer == null) { ser.serialize(value, jgen, prov); } else { ser.serializeWithType(value, jgen, prov, _typeSerializer); } }  /** * Alternative to {@link #serializeAsField} that is used when a POJO * is serialized as JSON Array; the difference is that no field names * are written. * * @since 2.1 /* For non-nulls: simple check for direct cycles*/ <BUGS> if (value == bean) { <BUGE> _handleSelfReference(bean, ser); } if (_typeSerializer == null) { ser.serialize(value, jgen, prov); } else { ser.serializeWithType(value, jgen, prov, _typeSerializer); } }  /** * Method called to serialize a placeholder used in tabular output when * real value is not to be included (is filtered out), but when we need * an entry so that field indexes will not be off. Typically this should * output null or empty String, depending on datatype.
jgen.writeFieldName(_name); if (_typeSerializer == null) { ser.serialize(value, jgen, prov); } else { ser.serializeWithType(value, jgen, prov, _typeSerializer); } }  /** * Alternative to {@link #serializeAsField} that is used when a POJO * is serialized as JSON Array; the difference is that no field names * are written. * * @since 2.1 } <BUGS> if (_typeSerializer == null) { ser.serialize(value, jgen, prov); <BUGE> } else { ser.serializeWithType(value, jgen, prov, _typeSerializer); } }  /** * Method called to serialize a placeholder used in tabular output when * real value is not to be included (is filtered out), but when we need * an entry so that field indexes will not be off. Typically this should * output null or empty String, depending on datatype. * * @since 2.1 */
jgen.writeFieldName(_name); if (_typeSerializer == null) { ser.serialize(value, jgen, prov); } else { ser.serializeWithType(value, jgen, prov, _typeSerializer); } }  /** * Alternative to {@link #serializeAsField} that is used when a POJO * is serialized as JSON Array; the difference is that no field names * are written. * * @since 2.1 } <BUGS> } <BUGE>  /** * Method called to serialize a placeholder used in tabular output when * real value is not to be included (is filtered out), but when we need * an entry so that field indexes will not be off. Typically this should * output null or empty String, depending on datatype. * * @since 2.1 */ public void serializeAsPlaceholder(Object bean, JsonGenerator jgen, SerializerProvider prov) throws Exception { if (_nullSerializer != null) { _nullSerializer.serialize(null, jgen, prov);
@Override public JsonNodeType getNodeType() { <BUGS> return JsonNodeType.POJO; <BUGE> }
@Override public String[] deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException { /* Ok: must point to START_ARRAY (or equivalent)*/ <BUGS> if (!jp.isExpectedStartArrayToken()) { <BUGE> return handleNonArray(jp, ctxt); } if (_elementDeserializer != null) { return _deserializeCustom(jp, ctxt); }  final ObjectBuffer buffer = ctxt.leaseObjectBuffer(); Object[] chunk = buffer.resetAndStart();  int ix = 0; JsonToken t;  while ((t = jp.nextToken()) != JsonToken.END_ARRAY) { /* Ok: no need to convert Strings, but must recognize nulls*/ String value; if (t == JsonToken.VALUE_STRING) { value = jp.getText(); } else if (t == JsonToken.VALUE_NULL) { value = _elementDeserializer.getNullValue(); } else { value = _parseString(jp, ctxt); } if (ix >= chunk.length) { chunk = buffer.appendCompletedChunk(chunk); ix = 0;
@Override public String[] deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException { /* Ok: must point to START_ARRAY (or equivalent)*/ if (!jp.isExpectedStartArrayToken()) { return handleNonArray(jp, ctxt); } <BUGS> if (_elementDeserializer != null) { <BUGE> return _deserializeCustom(jp, ctxt); }  final ObjectBuffer buffer = ctxt.leaseObjectBuffer(); Object[] chunk = buffer.resetAndStart();  int ix = 0; JsonToken t;  while ((t = jp.nextToken()) != JsonToken.END_ARRAY) { /* Ok: no need to convert Strings, but must recognize nulls*/ String value; if (t == JsonToken.VALUE_STRING) { value = jp.getText(); } else if (t == JsonToken.VALUE_NULL) { value = _elementDeserializer.getNullValue(); } else { value = _parseString(jp, ctxt); } if (ix >= chunk.length) { chunk = buffer.appendCompletedChunk(chunk); ix = 0;
@Override public String[] deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException { /* Ok: must point to START_ARRAY (or equivalent)*/ if (!jp.isExpectedStartArrayToken()) { return handleNonArray(jp, ctxt); } if (_elementDeserializer != null) { return _deserializeCustom(jp, ctxt); }  <BUGS> final ObjectBuffer buffer = ctxt.leaseObjectBuffer(); Object[] chunk = buffer.resetAndStart(); <BUGE>  int ix = 0; JsonToken t;  while ((t = jp.nextToken()) != JsonToken.END_ARRAY) { /* Ok: no need to convert Strings, but must recognize nulls*/ String value; if (t == JsonToken.VALUE_STRING) { value = jp.getText(); } else if (t == JsonToken.VALUE_NULL) { value = _elementDeserializer.getNullValue(); } else { value = _parseString(jp, ctxt); } if (ix >= chunk.length) { chunk = buffer.appendCompletedChunk(chunk); ix = 0;
@Override public String[] deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException { /* Ok: must point to START_ARRAY (or equivalent)*/ if (!jp.isExpectedStartArrayToken()) { return handleNonArray(jp, ctxt); } if (_elementDeserializer != null) { return _deserializeCustom(jp, ctxt); }  final ObjectBuffer buffer = ctxt.leaseObjectBuffer(); Object[] chunk = buffer.resetAndStart();  <BUGS> int ix = 0; <BUGE> JsonToken t;  while ((t = jp.nextToken()) != JsonToken.END_ARRAY) { /* Ok: no need to convert Strings, but must recognize nulls*/ String value; if (t == JsonToken.VALUE_STRING) { value = jp.getText(); } else if (t == JsonToken.VALUE_NULL) { value = _elementDeserializer.getNullValue(); } else { value = _parseString(jp, ctxt); } if (ix >= chunk.length) { chunk = buffer.appendCompletedChunk(chunk); ix = 0;
@Override public String[] deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException { /* Ok: must point to START_ARRAY (or equivalent)*/ if (!jp.isExpectedStartArrayToken()) { return handleNonArray(jp, ctxt); } if (_elementDeserializer != null) { return _deserializeCustom(jp, ctxt); }  final ObjectBuffer buffer = ctxt.leaseObjectBuffer(); Object[] chunk = buffer.resetAndStart();  int ix = 0; JsonToken t;  <BUGS> while ((t = jp.nextToken()) != JsonToken.END_ARRAY) { <BUGE> /* Ok: no need to convert Strings, but must recognize nulls*/ String value; if (t == JsonToken.VALUE_STRING) { value = jp.getText(); } else if (t == JsonToken.VALUE_NULL) { value = _elementDeserializer.getNullValue(); } else { value = _parseString(jp, ctxt); } if (ix >= chunk.length) { chunk = buffer.appendCompletedChunk(chunk); ix = 0;
@Override public String[] deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException { /* Ok: must point to START_ARRAY (or equivalent)*/ if (!jp.isExpectedStartArrayToken()) { return handleNonArray(jp, ctxt); } if (_elementDeserializer != null) { return _deserializeCustom(jp, ctxt); }  final ObjectBuffer buffer = ctxt.leaseObjectBuffer(); Object[] chunk = buffer.resetAndStart();  int ix = 0; JsonToken t;  while ((t = jp.nextToken()) != JsonToken.END_ARRAY) { /* Ok: no need to convert Strings, but must recognize nulls*/ String value; <BUGS> if (t == JsonToken.VALUE_STRING) { value = jp.getText(); } else if (t == JsonToken.VALUE_NULL) { value = _elementDeserializer.getNullValue(); <BUGE> } else { value = _parseString(jp, ctxt); } if (ix >= chunk.length) { chunk = buffer.appendCompletedChunk(chunk); ix = 0;
@Override public String[] deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException { /* Ok: must point to START_ARRAY (or equivalent)*/ if (!jp.isExpectedStartArrayToken()) { return handleNonArray(jp, ctxt); } if (_elementDeserializer != null) { return _deserializeCustom(jp, ctxt); }  final ObjectBuffer buffer = ctxt.leaseObjectBuffer(); Object[] chunk = buffer.resetAndStart();  int ix = 0; JsonToken t;  while ((t = jp.nextToken()) != JsonToken.END_ARRAY) { /* Ok: no need to convert Strings, but must recognize nulls*/ String value; if (t == JsonToken.VALUE_STRING) { value = jp.getText(); } else if (t == JsonToken.VALUE_NULL) { value = _elementDeserializer.getNullValue(); } else { value = _parseString(jp, ctxt); } <BUGS> if (ix >= chunk.length) { <BUGE> chunk = buffer.appendCompletedChunk(chunk); ix = 0;
public StringArrayDeserializer() { super(String[].class); _elementDeserializer = null; }  @SuppressWarnings("unchecked") protected StringArrayDeserializer(JsonDeserializer<?> deser) { super(String[].class); _elementDeserializer = (JsonDeserializer<String>) deser; }  } <BUGS> chunk[ix++] = value; } String[] result = buffer.completeAndClearBuffer(chunk, ix, String.class); ctxt.returnObjectBuffer(buffer); return result; <BUGE> }  /** * Offlined version used when we do not use the default deserialization method. */ protected final String[] _deserializeCustom(JsonParser jp, DeserializationContext ctxt) throws IOException { final ObjectBuffer buffer = ctxt.leaseObjectBuffer(); Object[] chunk = buffer.resetAndStart(); final JsonDeserializer<String> deser = _elementDeserializer;  int ix = 0;
*/ protected final String _parseString(JsonParser jp, DeserializationContext ctxt) throws IOException { <BUGS> JsonToken t = jp.getCurrentToken(); if (t == JsonToken.VALUE_STRING) { <BUGE> return jp.getText(); }  /* Issue#381*/ if (t == JsonToken.START_ARRAY && ctxt.isEnabled(DeserializationFeature.UNWRAP_SINGLE_VALUE_ARRAYS)) { jp.nextToken(); final String parsed = _parseString(jp, ctxt); if (jp.nextToken() != JsonToken.END_ARRAY) { throw ctxt.wrongTokenException(jp, JsonToken.END_ARRAY, "Attempted to unwrap single value array for single 'String' value but there was more than a single value in the array"); } return parsed; } String value = jp.getValueAsString(); if (value != null) { return value; } throw ctxt.mappingException(String.class, jp.getCurrentToken()); }
*/ protected final String _parseString(JsonParser jp, DeserializationContext ctxt) throws IOException { JsonToken t = jp.getCurrentToken(); if (t == JsonToken.VALUE_STRING) { return jp.getText(); }  /* Issue#381*/ <BUGS> if (t == JsonToken.START_ARRAY && ctxt.isEnabled(DeserializationFeature.UNWRAP_SINGLE_VALUE_ARRAYS)) { <BUGE> jp.nextToken(); final String parsed = _parseString(jp, ctxt); if (jp.nextToken() != JsonToken.END_ARRAY) { throw ctxt.wrongTokenException(jp, JsonToken.END_ARRAY, "Attempted to unwrap single value array for single 'String' value but there was more than a single value in the array"); } return parsed; } String value = jp.getValueAsString(); if (value != null) { return value; } throw ctxt.mappingException(String.class, jp.getCurrentToken()); }
*/ protected final String _parseString(JsonParser jp, DeserializationContext ctxt) throws IOException { JsonToken t = jp.getCurrentToken(); if (t == JsonToken.VALUE_STRING) { return jp.getText(); }  /* Issue#381*/ if (t == JsonToken.START_ARRAY && ctxt.isEnabled(DeserializationFeature.UNWRAP_SINGLE_VALUE_ARRAYS)) { jp.nextToken(); final String parsed = _parseString(jp, ctxt); if (jp.nextToken() != JsonToken.END_ARRAY) { throw ctxt.wrongTokenException(jp, JsonToken.END_ARRAY, "Attempted to unwrap single value array for single 'String' value but there was more than a single value in the array"); } return parsed; } <BUGS> String value = jp.getValueAsString(); if (value != null) { <BUGE> return value; } throw ctxt.mappingException(String.class, jp.getCurrentToken()); }
*/ protected final String _parseString(JsonParser jp, DeserializationContext ctxt) throws IOException { JsonToken t = jp.getCurrentToken(); if (t == JsonToken.VALUE_STRING) { return jp.getText(); }  /* Issue#381*/ if (t == JsonToken.START_ARRAY && ctxt.isEnabled(DeserializationFeature.UNWRAP_SINGLE_VALUE_ARRAYS)) { jp.nextToken(); final String parsed = _parseString(jp, ctxt); if (jp.nextToken() != JsonToken.END_ARRAY) { throw ctxt.wrongTokenException(jp, JsonToken.END_ARRAY, "Attempted to unwrap single value array for single 'String' value but there was more than a single value in the array"); } return parsed; } String value = jp.getValueAsString(); if (value != null) { return value; } <BUGS> throw ctxt.mappingException(String.class, jp.getCurrentToken()); <BUGE> }
protected Date parseAsISO8601(String dateStr, ParsePosition pos) { /* 21-May-2009, tatu: DateFormat has very strict handling of * timezone  modifiers for ISO-8601. So we need to do some scrubbing. */  /* First: do we have "zulu" format ('Z' == "GMT")? If yes, that's * quite simple because we already set date format timezone to be * GMT, and hence can just strip out 'Z' altogether */ <BUGS> int len = dateStr.length(); char c = dateStr.charAt(len-1); <BUGE> DateFormat df;  /* [JACKSON-200]: need to support "plain" date...*/ if (len <= 10 && Character.isDigit(c)) { df = _formatPlain; if (df == null) { df = _formatPlain = _cloneFormat(DATE_FORMAT_PLAIN, DATE_FORMAT_STR_PLAIN, _timezone, _locale); } } else if (c == 'Z') { df = _formatISO8601_z; if (df == null) { df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, DATE_FORMAT_STR_ISO8601_Z, _timezone, _locale); } /* [JACKSON-334]: may be missing milliseconds... if so, add*/ if (dateStr.charAt(len-4) == ':') { StringBuilder sb = new StringBuilder(dateStr); sb.insert(len-1, ".000");
protected Date parseAsISO8601(String dateStr, ParsePosition pos) { /* 21-May-2009, tatu: DateFormat has very strict handling of * timezone  modifiers for ISO-8601. So we need to do some scrubbing. */  /* First: do we have "zulu" format ('Z' == "GMT")? If yes, that's * quite simple because we already set date format timezone to be * GMT, and hence can just strip out 'Z' altogether */ int len = dateStr.length(); char c = dateStr.charAt(len-1); DateFormat df;  /* [JACKSON-200]: need to support "plain" date...*/ <BUGS> if (len <= 10 && Character.isDigit(c)) { <BUGE> df = _formatPlain; if (df == null) { df = _formatPlain = _cloneFormat(DATE_FORMAT_PLAIN, DATE_FORMAT_STR_PLAIN, _timezone, _locale); } } else if (c == 'Z') { df = _formatISO8601_z; if (df == null) { df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, DATE_FORMAT_STR_ISO8601_Z, _timezone, _locale); } /* [JACKSON-334]: may be missing milliseconds... if so, add*/ if (dateStr.charAt(len-4) == ':') { StringBuilder sb = new StringBuilder(dateStr); sb.insert(len-1, ".000");
protected Date parseAsISO8601(String dateStr, ParsePosition pos) { /* 21-May-2009, tatu: DateFormat has very strict handling of * timezone  modifiers for ISO-8601. So we need to do some scrubbing. */  /* First: do we have "zulu" format ('Z' == "GMT")? If yes, that's * quite simple because we already set date format timezone to be * GMT, and hence can just strip out 'Z' altogether */ int len = dateStr.length(); char c = dateStr.charAt(len-1); DateFormat df;  /* [JACKSON-200]: need to support "plain" date...*/ if (len <= 10 && Character.isDigit(c)) { df = _formatPlain; if (df == null) { df = _formatPlain = _cloneFormat(DATE_FORMAT_PLAIN, DATE_FORMAT_STR_PLAIN, _timezone, _locale); } <BUGS> } else if (c == 'Z') { <BUGE> df = _formatISO8601_z; if (df == null) { df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, DATE_FORMAT_STR_ISO8601_Z, _timezone, _locale); } /* [JACKSON-334]: may be missing milliseconds... if so, add*/ if (dateStr.charAt(len-4) == ':') { StringBuilder sb = new StringBuilder(dateStr); sb.insert(len-1, ".000");
* formats is the likeliest match. */ protected boolean looksLikeISO8601(String dateStr) { if (dateStr.length() >= 5 && Character.isDigit(dateStr.charAt(0)) && Character.isDigit(dateStr.charAt(3)) && dateStr.charAt(4) == '-' ) { return true; } return false; } /* Let's see if we have timezone indicator or not...*/ <BUGS> if (hasTimeZone(dateStr)) { c = dateStr.charAt(len-3); if (c == ':') { /* remove optional colon <BUGE>*/ /* remove colon*/ StringBuilder sb = new StringBuilder(dateStr); sb.delete(len-3, len-2); dateStr = sb.toString(); } else if (c == '+' || c == '-') { /* missing minutes*/ /* let's just append '00'*/ dateStr += "00"; } /* Milliseconds partial or missing; and even seconds are optional*/ len = dateStr.length(); /* remove 'T', '+'/'-' and 4-digit timezone-offset*/ c = dateStr.charAt(len-9); if (Character.isDigit(c)) {
* formats is the likeliest match. */ protected boolean looksLikeISO8601(String dateStr) { if (dateStr.length() >= 5 && Character.isDigit(dateStr.charAt(0)) && Character.isDigit(dateStr.charAt(3)) && dateStr.charAt(4) == '-' ) { return true; } return false; } /* remove colon*/ <BUGS> StringBuilder sb = new StringBuilder(dateStr); sb.delete(len-3, len-2); dateStr = sb.toString(); } else if (c == '+' || c == '-') { /* missing minutes <BUGE>*/ /* let's just append '00'*/ dateStr += "00"; } /* Milliseconds partial or missing; and even seconds are optional*/ len = dateStr.length(); /* remove 'T', '+'/'-' and 4-digit timezone-offset*/ c = dateStr.charAt(len-9); if (Character.isDigit(c)) { StringBuilder sb = new StringBuilder(dateStr); sb.insert(len-5, ".000"); dateStr = sb.toString(); }
* Overridable helper method used to figure out which of supported * formats is the likeliest match. */ protected boolean looksLikeISO8601(String dateStr) { if (dateStr.length() >= 5 && Character.isDigit(dateStr.charAt(0)) && Character.isDigit(dateStr.charAt(3)) && dateStr.charAt(4) == '-' ) { return true; } return false; } /* Milliseconds partial or missing; and even seconds are optional*/ <BUGS> len = dateStr.length(); <BUGE> /* remove 'T', '+'/'-' and 4-digit timezone-offset*/ c = dateStr.charAt(len-9); if (Character.isDigit(c)) { StringBuilder sb = new StringBuilder(dateStr); sb.insert(len-5, ".000"); dateStr = sb.toString(); } df = _formatISO8601; if (_formatISO8601 == null) { df = _formatISO8601 = _cloneFormat(DATE_FORMAT_ISO8601, DATE_FORMAT_STR_ISO8601, _timezone, _locale); } } else { /* If not, plain date. Easiest to just patch 'Z' in the end?*/ StringBuilder sb = new StringBuilder(dateStr);
*/ protected boolean looksLikeISO8601(String dateStr) { if (dateStr.length() >= 5 && Character.isDigit(dateStr.charAt(0)) && Character.isDigit(dateStr.charAt(3)) && dateStr.charAt(4) == '-' ) { return true; } return false; } /* remove 'T', '+'/'-' and 4-digit timezone-offset*/ <BUGS> c = dateStr.charAt(len-9); if (Character.isDigit(c)) { StringBuilder sb = new StringBuilder(dateStr); sb.insert(len-5, ".000"); dateStr = sb.toString(); <BUGE> } df = _formatISO8601; if (_formatISO8601 == null) { df = _formatISO8601 = _cloneFormat(DATE_FORMAT_ISO8601, DATE_FORMAT_STR_ISO8601, _timezone, _locale); } } else { /* If not, plain date. Easiest to just patch 'Z' in the end?*/ StringBuilder sb = new StringBuilder(dateStr); /* And possible also millisecond part if missing*/ int timeLen = len - dateStr.lastIndexOf('T') - 1; if (timeLen <= 8) { sb.append(".000");
* formats is the likeliest match. */ protected boolean looksLikeISO8601(String dateStr) { if (dateStr.length() >= 5 && Character.isDigit(dateStr.charAt(0)) && Character.isDigit(dateStr.charAt(3)) && dateStr.charAt(4) == '-' ) { return true; } return false; } } <BUGS> df = _formatISO8601; if (_formatISO8601 == null) { df = _formatISO8601 = _cloneFormat(DATE_FORMAT_ISO8601, DATE_FORMAT_STR_ISO8601, _timezone, _locale); <BUGE> } } else { /* If not, plain date. Easiest to just patch 'Z' in the end?*/ StringBuilder sb = new StringBuilder(dateStr); /* And possible also millisecond part if missing*/ int timeLen = len - dateStr.lastIndexOf('T') - 1; if (timeLen <= 8) { sb.append(".000"); } sb.append('Z'); dateStr = sb.toString(); df = _formatISO8601_z; if (df == null) {
* Overridable helper method used to figure out which of supported * formats is the likeliest match. */ protected boolean looksLikeISO8601(String dateStr) { if (dateStr.length() >= 5 && Character.isDigit(dateStr.charAt(0)) && Character.isDigit(dateStr.charAt(3)) && dateStr.charAt(4) == '-' ) { return true; } return false; } } <BUGS> return df.parse(dateStr, pos); <BUGE> }  protected Date parseAsRFC1123(String dateStr, ParsePosition pos) { if (_formatRFC1123 == null) { _formatRFC1123 = _cloneFormat(DATE_FORMAT_RFC1123, DATE_FORMAT_STR_RFC1123, _timezone, _locale); } return _formatRFC1123.parse(dateStr, pos); }  private final static boolean hasTimeZone(String str) { /* Only accept "+hh", "+hhmm" and "+hh:mm" (and with minus), so*/ int len = str.length();
@Override public String toString() { <BUGS> if (_annotations == null) { return "[null]"; <BUGE> } return _annotations.toString(); }
@SuppressWarnings("unchecked") public static JsonSerializer<Object> getStdKeySerializer(SerializationConfig config, Class<?> rawKeyType, boolean useDefault) { <BUGS> if (rawKeyType != null) { if (rawKeyType == String.class) { <BUGE> return DEFAULT_STRING_SERIALIZER; } if (rawKeyType == Object.class || rawKeyType.isPrimitive() || Number.class.isAssignableFrom(rawKeyType)) { return DEFAULT_KEY_SERIALIZER; } if (rawKeyType == Class.class) { return (JsonSerializer<Object>) ClassKeySerializer.instance; } if (Date.class.isAssignableFrom(rawKeyType)) { return (JsonSerializer<Object>) DateKeySerializer.instance; } if (Calendar.class.isAssignableFrom(rawKeyType)) { return (JsonSerializer<Object>) CalendarKeySerializer.instance; } } return useDefault ? DEFAULT_KEY_SERIALIZER : null; }
@SuppressWarnings("unchecked") public static JsonSerializer<Object> getStdKeySerializer(SerializationConfig config, Class<?> rawKeyType, boolean useDefault) { if (rawKeyType != null) { if (rawKeyType == String.class) { return DEFAULT_STRING_SERIALIZER; } <BUGS> if (rawKeyType == Object.class || rawKeyType.isPrimitive() <BUGE> || Number.class.isAssignableFrom(rawKeyType)) { return DEFAULT_KEY_SERIALIZER; } if (rawKeyType == Class.class) { return (JsonSerializer<Object>) ClassKeySerializer.instance; } if (Date.class.isAssignableFrom(rawKeyType)) { return (JsonSerializer<Object>) DateKeySerializer.instance; } if (Calendar.class.isAssignableFrom(rawKeyType)) { return (JsonSerializer<Object>) CalendarKeySerializer.instance; } } return useDefault ? DEFAULT_KEY_SERIALIZER : null; }
@SuppressWarnings("unchecked") public static JsonSerializer<Object> getStdKeySerializer(SerializationConfig config, Class<?> rawKeyType, boolean useDefault) { if (rawKeyType != null) { if (rawKeyType == String.class) { return DEFAULT_STRING_SERIALIZER; } if (rawKeyType == Object.class || rawKeyType.isPrimitive() || Number.class.isAssignableFrom(rawKeyType)) { <BUGS> return DEFAULT_KEY_SERIALIZER; <BUGE> } if (rawKeyType == Class.class) { return (JsonSerializer<Object>) ClassKeySerializer.instance; } if (Date.class.isAssignableFrom(rawKeyType)) { return (JsonSerializer<Object>) DateKeySerializer.instance; } if (Calendar.class.isAssignableFrom(rawKeyType)) { return (JsonSerializer<Object>) CalendarKeySerializer.instance; } } return useDefault ? DEFAULT_KEY_SERIALIZER : null; }
public JavaType findType(String name, boolean mustFind) { <BUGS> if (_bindings == null) { _resolve(); <BUGE> } JavaType t = _bindings.get(name); if (t != null) { return t; } if (_placeholders != null && _placeholders.contains(name)) { return UNBOUND; } if (_parentBindings != null) { return _parentBindings.findType(name); } /* nothing found, so...*/ /* Should we throw an exception or just return null?*/  /* [JACKSON-499] 18-Feb-2011, tatu: There are some tricky type bindings within *   java.util, such as HashMap$KeySet; so let's punt the problem *   (honestly not sure what to do -- they are unbound for good, I think) */ if (_contextClass != null) { Class<?> enclosing = _contextClass.getEnclosingClass(); if (enclosing != null) { /* [JACKSON-572]: Actually, let's skip this for all non-static inner classes*/ /*   (which will also cover 'java.util' type cases...*/ if (!Modifier.isStatic(_contextClass.getModifiers())) { return UNBOUND;
public JavaType findType(String name, boolean mustFind) { if (_bindings == null) { _resolve(); } <BUGS> JavaType t = _bindings.get(name); if (t != null) { return t; <BUGE> } if (_placeholders != null && _placeholders.contains(name)) { return UNBOUND; } if (_parentBindings != null) { return _parentBindings.findType(name); } /* nothing found, so...*/ /* Should we throw an exception or just return null?*/  /* [JACKSON-499] 18-Feb-2011, tatu: There are some tricky type bindings within *   java.util, such as HashMap$KeySet; so let's punt the problem *   (honestly not sure what to do -- they are unbound for good, I think) */ if (_contextClass != null) { Class<?> enclosing = _contextClass.getEnclosingClass(); if (enclosing != null) { /* [JACKSON-572]: Actually, let's skip this for all non-static inner classes*/ /*   (which will also cover 'java.util' type cases...*/ if (!Modifier.isStatic(_contextClass.getModifiers())) { return UNBOUND;
public JavaType findType(String name, boolean mustFind) { if (_bindings == null) { _resolve(); } JavaType t = _bindings.get(name); if (t != null) { return t; } <BUGS> if (_placeholders != null && _placeholders.contains(name)) { <BUGE> return UNBOUND; } if (_parentBindings != null) { return _parentBindings.findType(name); } /* nothing found, so...*/ /* Should we throw an exception or just return null?*/  /* [JACKSON-499] 18-Feb-2011, tatu: There are some tricky type bindings within *   java.util, such as HashMap$KeySet; so let's punt the problem *   (honestly not sure what to do -- they are unbound for good, I think) */ if (_contextClass != null) { Class<?> enclosing = _contextClass.getEnclosingClass(); if (enclosing != null) { /* [JACKSON-572]: Actually, let's skip this for all non-static inner classes*/ /*   (which will also cover 'java.util' type cases...*/ if (!Modifier.isStatic(_contextClass.getModifiers())) { return UNBOUND;
public JavaType findType(String name, boolean mustFind) { if (_bindings == null) { _resolve(); } JavaType t = _bindings.get(name); if (t != null) { return t; } if (_placeholders != null && _placeholders.contains(name)) { return UNBOUND; } <BUGS> if (_parentBindings != null) { <BUGE> return _parentBindings.findType(name); } /* nothing found, so...*/ /* Should we throw an exception or just return null?*/  /* [JACKSON-499] 18-Feb-2011, tatu: There are some tricky type bindings within *   java.util, such as HashMap$KeySet; so let's punt the problem *   (honestly not sure what to do -- they are unbound for good, I think) */ if (_contextClass != null) { Class<?> enclosing = _contextClass.getEnclosingClass(); if (enclosing != null) { /* [JACKSON-572]: Actually, let's skip this for all non-static inner classes*/ /*   (which will also cover 'java.util' type cases...*/ if (!Modifier.isStatic(_contextClass.getModifiers())) { return UNBOUND;
public JavaType findType(String name, boolean mustFind) { if (_bindings == null) { _resolve(); } JavaType t = _bindings.get(name); if (t != null) { return t; } if (_placeholders != null && _placeholders.contains(name)) { return UNBOUND; } if (_parentBindings != null) { return _parentBindings.findType(name); } /* nothing found, so...*/ /* Should we throw an exception or just return null?*/  /* [JACKSON-499] 18-Feb-2011, tatu: There are some tricky type bindings within *   java.util, such as HashMap$KeySet; so let's punt the problem *   (honestly not sure what to do -- they are unbound for good, I think) */ <BUGS> if (_contextClass != null) { Class<?> enclosing = _contextClass.getEnclosingClass(); if (enclosing != null) { <BUGE> /* [JACKSON-572]: Actually, let's skip this for all non-static inner classes*/ /*   (which will also cover 'java.util' type cases...*/ if (!Modifier.isStatic(_contextClass.getModifiers())) { return UNBOUND;
public JavaType findType(String name, boolean mustFind) { if (_bindings == null) { _resolve(); } JavaType t = _bindings.get(name); if (t != null) { return t; } if (_placeholders != null && _placeholders.contains(name)) { return UNBOUND; } if (_parentBindings != null) { return _parentBindings.findType(name); } /* nothing found, so...*/ /* Should we throw an exception or just return null?*/  /* [JACKSON-499] 18-Feb-2011, tatu: There are some tricky type bindings within *   java.util, such as HashMap$KeySet; so let's punt the problem *   (honestly not sure what to do -- they are unbound for good, I think) */ if (_contextClass != null) { Class<?> enclosing = _contextClass.getEnclosingClass(); if (enclosing != null) { /* [JACKSON-572]: Actually, let's skip this for all non-static inner classes*/ /*   (which will also cover 'java.util' type cases...*/ <BUGS> if (!Modifier.isStatic(_contextClass.getModifiers())) { <BUGE> return UNBOUND;
/********************************************************** */  public int getBindingCount() { if (_bindings == null) { _resolve(); } return _bindings.size(); }  @Deprecated /* since 2.6, remove from 2.7*/ public JavaType findType(String name) { return findType(name, true); }  <BUGS> if (!mustFind) { <BUGE> return null; }  String className; if (_contextClass != null) { className = _contextClass.getName(); } else if (_contextType != null) { className = _contextType.toString(); } else { className = "UNKNOWN"; } throw new IllegalArgumentException("Type variable '"+name +"' can not be resolved (with context of class "+className+")"); /*t = UNBOUND;                */
/********************************************************** */  public int getBindingCount() { if (_bindings == null) { _resolve(); } return _bindings.size(); }  @Deprecated /* since 2.6, remove from 2.7*/ public JavaType findType(String name) { return findType(name, true); } String className; <BUGS> if (_contextClass != null) { className = _contextClass.getName(); <BUGE> } else if (_contextType != null) { className = _contextType.toString(); } else { className = "UNKNOWN"; } throw new IllegalArgumentException("Type variable '"+name +"' can not be resolved (with context of class "+className+")"); /*t = UNBOUND;                */ }  public void addBinding(String name, JavaType type) { /* note: emptyMap() is unmodifiable, hence second check is needed:*/
/********************************************************** */  public int getBindingCount() { if (_bindings == null) { _resolve(); } return _bindings.size(); }  @Deprecated /* since 2.6, remove from 2.7*/ public JavaType findType(String name) { return findType(name, true); } } <BUGS> throw new IllegalArgumentException("Type variable '"+name <BUGE> +"' can not be resolved (with context of class "+className+")"); /*t = UNBOUND;                */ }  public void addBinding(String name, JavaType type) { /* note: emptyMap() is unmodifiable, hence second check is needed:*/ if (_bindings == null || _bindings.size() == 0) { _bindings = new LinkedHashMap<String,JavaType>(); } _bindings.put(name, type); }  public JavaType[] typesAsArray()
@Override public MapType withContentValueHandler(Object h) { <BUGS> return new MapType(_class, _keyType, _valueType.withValueHandler(h), <BUGE> _valueHandler, _typeHandler, _asStatic); }
*/ public static JsonMappingException wrapWithPath(Throwable src, Reference ref) { JsonMappingException jme; <BUGS> if (src instanceof JsonMappingException) { <BUGE> jme = (JsonMappingException) src; } else { String msg = src.getMessage(); /* Related to [JACKSON-62], let's use a more meaningful placeholder * if all we have is null */ if (msg == null || msg.length() == 0) { msg = "(was "+src.getClass().getName()+")"; } jme = new JsonMappingException(msg, null, src); } jme.prependPath(ref); return jme; }
*/ public static JsonMappingException wrapWithPath(Throwable src, Reference ref) { JsonMappingException jme; if (src instanceof JsonMappingException) { jme = (JsonMappingException) src; } else { <BUGS> String msg = src.getMessage(); <BUGE> /* Related to [JACKSON-62], let's use a more meaningful placeholder * if all we have is null */ if (msg == null || msg.length() == 0) { msg = "(was "+src.getClass().getName()+")"; } jme = new JsonMappingException(msg, null, src); } jme.prependPath(ref); return jme; }
*/ public static JsonMappingException wrapWithPath(Throwable src, Reference ref) { JsonMappingException jme; if (src instanceof JsonMappingException) { jme = (JsonMappingException) src; } else { String msg = src.getMessage(); /* Related to [JACKSON-62], let's use a more meaningful placeholder * if all we have is null */ <BUGS> if (msg == null || msg.length() == 0) { msg = "(was "+src.getClass().getName()+")"; <BUGE> } jme = new JsonMappingException(msg, null, src); } jme.prependPath(ref); return jme; }
*/ public static JsonMappingException wrapWithPath(Throwable src, Reference ref) { JsonMappingException jme; if (src instanceof JsonMappingException) { jme = (JsonMappingException) src; } else { String msg = src.getMessage(); /* Related to [JACKSON-62], let's use a more meaningful placeholder * if all we have is null */ if (msg == null || msg.length() == 0) { msg = "(was "+src.getClass().getName()+")"; } <BUGS> jme = new JsonMappingException(msg, null, src); <BUGE> } jme.prependPath(ref); return jme; }
*/ public static JsonMappingException wrapWithPath(Throwable src, Reference ref) { JsonMappingException jme; if (src instanceof JsonMappingException) { jme = (JsonMappingException) src; } else { String msg = src.getMessage(); /* Related to [JACKSON-62], let's use a more meaningful placeholder * if all we have is null */ if (msg == null || msg.length() == 0) { msg = "(was "+src.getClass().getName()+")"; } jme = new JsonMappingException(msg, null, src); } <BUGS> jme.prependPath(ref); return jme; <BUGE> }
@Override public JsonParser treeAsTokens(TreeNode n) { <BUGS> return new TreeTraversingParser((JsonNode) n, this); <BUGE> }
@Override public String toString() { <BUGS> return getClass().getName()+": "+getMessage(); <BUGE> }
*/ protected void _addFieldMixIns(Class<?> targetClass, Class<?> mixInCls, Map<String,AnnotatedField> fields) { <BUGS> List<Class<?>> parents = new ArrayList<Class<?>>(); parents.add(mixInCls); ClassUtil.findSuperTypes(mixInCls, targetClass, parents); for (Class<?> mixin : parents) { for (Field mixinField : mixin.getDeclaredFields()) { <BUGE> /* there are some dummy things (static, synthetic); better ignore*/ if (!_isIncludableField(mixinField)) { continue; } String name = mixinField.getName(); /* anything to mask? (if not, quietly ignore)*/ AnnotatedField maskedField = fields.get(name); if (maskedField != null) { _addOrOverrideAnnotations(maskedField, mixinField.getDeclaredAnnotations()); } } } }
*/ protected void _addFieldMixIns(Class<?> targetClass, Class<?> mixInCls, Map<String,AnnotatedField> fields) { List<Class<?>> parents = new ArrayList<Class<?>>(); parents.add(mixInCls); ClassUtil.findSuperTypes(mixInCls, targetClass, parents); for (Class<?> mixin : parents) { for (Field mixinField : mixin.getDeclaredFields()) { /* there are some dummy things (static, synthetic); better ignore*/ <BUGS> if (!_isIncludableField(mixinField)) { continue; <BUGE> } String name = mixinField.getName(); /* anything to mask? (if not, quietly ignore)*/ AnnotatedField maskedField = fields.get(name); if (maskedField != null) { _addOrOverrideAnnotations(maskedField, mixinField.getDeclaredAnnotations()); } } } }
*/ protected void _addFieldMixIns(Class<?> targetClass, Class<?> mixInCls, Map<String,AnnotatedField> fields) { List<Class<?>> parents = new ArrayList<Class<?>>(); parents.add(mixInCls); ClassUtil.findSuperTypes(mixInCls, targetClass, parents); for (Class<?> mixin : parents) { for (Field mixinField : mixin.getDeclaredFields()) { /* there are some dummy things (static, synthetic); better ignore*/ if (!_isIncludableField(mixinField)) { continue; } String name = mixinField.getName(); /* anything to mask? (if not, quietly ignore)*/ AnnotatedField maskedField = fields.get(name); if (maskedField != null) { _addOrOverrideAnnotations(maskedField, mixinField.getDeclaredAnnotations()); } } <BUGS> } } <BUGE>
protected final String _locateTypeId(JsonParser jp, DeserializationContext ctxt) throws IOException { <BUGS> if (!jp.isExpectedStartArrayToken()) { <BUGE> /* [JACKSON-712] Need to allow even more customized handling, if something unexpected seen...*/ /* but should there be a way to limit this to likely success cases?*/ if (_defaultImpl != null) { return _idResolver.idFromBaseType(); } throw ctxt.wrongTokenException(jp, JsonToken.START_ARRAY, "need JSON Array to contain As.WRAPPER_ARRAY type information for class "+baseTypeName()); } /* And then type id as a String*/ JsonToken t = jp.nextToken(); if (t == JsonToken.VALUE_STRING) { String result = jp.getText(); jp.nextToken(); return result; } if (_defaultImpl != null) { return _idResolver.idFromBaseType(); } throw ctxt.wrongTokenException(jp, JsonToken.VALUE_STRING, "need JSON String that contains type id (for subtype of "+baseTypeName()+")"); }
protected final String _locateTypeId(JsonParser jp, DeserializationContext ctxt) throws IOException { if (!jp.isExpectedStartArrayToken()) { /* [JACKSON-712] Need to allow even more customized handling, if something unexpected seen...*/ /* but should there be a way to limit this to likely success cases?*/ if (_defaultImpl != null) { return _idResolver.idFromBaseType(); } throw ctxt.wrongTokenException(jp, JsonToken.START_ARRAY, "need JSON Array to contain As.WRAPPER_ARRAY type information for class "+baseTypeName()); } /* And then type id as a String*/ <BUGS> JsonToken t = jp.nextToken(); if (t == JsonToken.VALUE_STRING) { <BUGE> String result = jp.getText(); jp.nextToken(); return result; } if (_defaultImpl != null) { return _idResolver.idFromBaseType(); } throw ctxt.wrongTokenException(jp, JsonToken.VALUE_STRING, "need JSON String that contains type id (for subtype of "+baseTypeName()+")"); }
protected final String _locateTypeId(JsonParser jp, DeserializationContext ctxt) throws IOException { if (!jp.isExpectedStartArrayToken()) { /* [JACKSON-712] Need to allow even more customized handling, if something unexpected seen...*/ /* but should there be a way to limit this to likely success cases?*/ if (_defaultImpl != null) { return _idResolver.idFromBaseType(); } throw ctxt.wrongTokenException(jp, JsonToken.START_ARRAY, "need JSON Array to contain As.WRAPPER_ARRAY type information for class "+baseTypeName()); } /* And then type id as a String*/ JsonToken t = jp.nextToken(); if (t == JsonToken.VALUE_STRING) { String result = jp.getText(); jp.nextToken(); return result; } <BUGS> if (_defaultImpl != null) { <BUGE> return _idResolver.idFromBaseType(); } throw ctxt.wrongTokenException(jp, JsonToken.VALUE_STRING, "need JSON String that contains type id (for subtype of "+baseTypeName()+")"); }
protected final String _locateTypeId(JsonParser jp, DeserializationContext ctxt) throws IOException { if (!jp.isExpectedStartArrayToken()) { /* [JACKSON-712] Need to allow even more customized handling, if something unexpected seen...*/ /* but should there be a way to limit this to likely success cases?*/ if (_defaultImpl != null) { return _idResolver.idFromBaseType(); } throw ctxt.wrongTokenException(jp, JsonToken.START_ARRAY, "need JSON Array to contain As.WRAPPER_ARRAY type information for class "+baseTypeName()); } /* And then type id as a String*/ JsonToken t = jp.nextToken(); if (t == JsonToken.VALUE_STRING) { String result = jp.getText(); jp.nextToken(); return result; } if (_defaultImpl != null) { return _idResolver.idFromBaseType(); } <BUGS> throw ctxt.wrongTokenException(jp, JsonToken.VALUE_STRING, "need JSON String that contains type id (for subtype of "+baseTypeName()+")"); <BUGE> }
*/ public LinkedNode<DeserializationProblemHandler> getProblemHandlers() { <BUGS> return _problemHandlers; <BUGE> }
*/ public JsonMappingException mappingException(Class<?> targetClass) { <BUGS> return mappingException(targetClass, _parser.getCurrentToken()); <BUGE> }
protected Object _readMapAndClose(JsonParser jp, JavaType valueType) throws IOException, JsonParseException, JsonMappingException { try { Object result; <BUGS> JsonToken t = _initForReading(jp); if (t == JsonToken.VALUE_NULL) { <BUGE> /* [JACKSON-643]: Ask JsonDeserializer what 'null value' to use:*/ DeserializationContext ctxt = createDeserializationContext(jp, getDeserializationConfig()); result = _findRootDeserializer(ctxt, valueType).getNullValue(ctxt); } else if (t == JsonToken.END_ARRAY || t == JsonToken.END_OBJECT) { result = null; } else { DeserializationConfig cfg = getDeserializationConfig(); DeserializationContext ctxt = createDeserializationContext(jp, cfg); JsonDeserializer<Object> deser = _findRootDeserializer(ctxt, valueType); if (cfg.useRootWrapping()) { result = _unwrapAndDeserialize(jp, ctxt, cfg, valueType, deser); } else { result = deser.deserialize(jp, ctxt); } ctxt.checkUnresolvedObjectId(); } /* Need to consume the token too*/ jp.clearCurrentToken(); return result; } finally { try {
protected Object _readMapAndClose(JsonParser jp, JavaType valueType) throws IOException, JsonParseException, JsonMappingException { try { Object result; JsonToken t = _initForReading(jp); if (t == JsonToken.VALUE_NULL) { /* [JACKSON-643]: Ask JsonDeserializer what 'null value' to use:*/ DeserializationContext ctxt = createDeserializationContext(jp, getDeserializationConfig()); result = _findRootDeserializer(ctxt, valueType).getNullValue(ctxt); <BUGS> } else if (t == JsonToken.END_ARRAY || t == JsonToken.END_OBJECT) { <BUGE> result = null; } else { DeserializationConfig cfg = getDeserializationConfig(); DeserializationContext ctxt = createDeserializationContext(jp, cfg); JsonDeserializer<Object> deser = _findRootDeserializer(ctxt, valueType); if (cfg.useRootWrapping()) { result = _unwrapAndDeserialize(jp, ctxt, cfg, valueType, deser); } else { result = deser.deserialize(jp, ctxt); } ctxt.checkUnresolvedObjectId(); } /* Need to consume the token too*/ jp.clearCurrentToken(); return result; } finally { try {
protected Object _readMapAndClose(JsonParser jp, JavaType valueType) throws IOException, JsonParseException, JsonMappingException { try { Object result; JsonToken t = _initForReading(jp); if (t == JsonToken.VALUE_NULL) { /* [JACKSON-643]: Ask JsonDeserializer what 'null value' to use:*/ DeserializationContext ctxt = createDeserializationContext(jp, getDeserializationConfig()); result = _findRootDeserializer(ctxt, valueType).getNullValue(ctxt); } else if (t == JsonToken.END_ARRAY || t == JsonToken.END_OBJECT) { result = null; } else { <BUGS> DeserializationConfig cfg = getDeserializationConfig(); DeserializationContext ctxt = createDeserializationContext(jp, cfg); JsonDeserializer<Object> deser = _findRootDeserializer(ctxt, valueType); if (cfg.useRootWrapping()) { <BUGE> result = _unwrapAndDeserialize(jp, ctxt, cfg, valueType, deser); } else { result = deser.deserialize(jp, ctxt); } ctxt.checkUnresolvedObjectId(); } /* Need to consume the token too*/ jp.clearCurrentToken(); return result; } finally { try {
protected Object _readMapAndClose(JsonParser jp, JavaType valueType) throws IOException, JsonParseException, JsonMappingException { try { Object result; JsonToken t = _initForReading(jp); if (t == JsonToken.VALUE_NULL) { /* [JACKSON-643]: Ask JsonDeserializer what 'null value' to use:*/ DeserializationContext ctxt = createDeserializationContext(jp, getDeserializationConfig()); result = _findRootDeserializer(ctxt, valueType).getNullValue(ctxt); } else if (t == JsonToken.END_ARRAY || t == JsonToken.END_OBJECT) { result = null; } else { DeserializationConfig cfg = getDeserializationConfig(); DeserializationContext ctxt = createDeserializationContext(jp, cfg); JsonDeserializer<Object> deser = _findRootDeserializer(ctxt, valueType); if (cfg.useRootWrapping()) { result = _unwrapAndDeserialize(jp, ctxt, cfg, valueType, deser); } else { <BUGS> result = deser.deserialize(jp, ctxt); <BUGE> } ctxt.checkUnresolvedObjectId(); } /* Need to consume the token too*/ jp.clearCurrentToken(); return result; } finally { try {
DeserializationContext ctxt = createDeserializationContext(jp, cfg); JsonDeserializer<Object> deser = _findRootDeserializer(ctxt, valueType); /* ok, let's get the value*/ if (cfg.useRootWrapping()) { result = _unwrapAndDeserialize(jp, ctxt, cfg, valueType, deser); } else { result = deser.deserialize(jp, ctxt); } } /* Need to consume the token too*/ jp.clearCurrentToken(); return result; } } finally { <BUGS> try { jp.close(); } catch (IOException ioe) { } } <BUGE> }  /** * Method called to ensure that given parser is ready for reading * content for data binding. * * @return First token to be used for data binding after this call: *  can never be null as exception will be thrown if parser can not *  provide more tokens. * * @throws IOException if the underlying input source has problems during *   parsing
*/ public boolean findDeserializeAndSet(JsonParser p, DeserializationContext ctxt, Object bean, String key) throws IOException { <BUGS> if (_caseInsensitive) { <BUGE> key = key.toLowerCase(); } int index = key.hashCode() & _hashMask; Bucket bucket = _buckets[index]; /* Let's unroll first lookup since that is null or match in 90+% cases*/ if (bucket == null) { return false; } /* Primarily we do just identity comparison as keys should be interned*/ if (bucket.key == key) { try { bucket.value.deserializeAndSet(p, ctxt, bean); } catch (Exception e) { wrapAndThrow(e, bean, key, ctxt); } return true; } return _findDeserializeAndSet2(p, ctxt, bean, key, index); }
*/ public boolean findDeserializeAndSet(JsonParser p, DeserializationContext ctxt, Object bean, String key) throws IOException { if (_caseInsensitive) { key = key.toLowerCase(); } <BUGS> int index = key.hashCode() & _hashMask; Bucket bucket = _buckets[index]; <BUGE> /* Let's unroll first lookup since that is null or match in 90+% cases*/ if (bucket == null) { return false; } /* Primarily we do just identity comparison as keys should be interned*/ if (bucket.key == key) { try { bucket.value.deserializeAndSet(p, ctxt, bean); } catch (Exception e) { wrapAndThrow(e, bean, key, ctxt); } return true; } return _findDeserializeAndSet2(p, ctxt, bean, key, index); }
*/ public boolean findDeserializeAndSet(JsonParser p, DeserializationContext ctxt, Object bean, String key) throws IOException { if (_caseInsensitive) { key = key.toLowerCase(); } int index = key.hashCode() & _hashMask; Bucket bucket = _buckets[index]; /* Let's unroll first lookup since that is null or match in 90+% cases*/ <BUGS> if (bucket == null) { <BUGE> return false; } /* Primarily we do just identity comparison as keys should be interned*/ if (bucket.key == key) { try { bucket.value.deserializeAndSet(p, ctxt, bean); } catch (Exception e) { wrapAndThrow(e, bean, key, ctxt); } return true; } return _findDeserializeAndSet2(p, ctxt, bean, key, index); }
*/ public boolean findDeserializeAndSet(JsonParser p, DeserializationContext ctxt, Object bean, String key) throws IOException { if (_caseInsensitive) { key = key.toLowerCase(); } int index = key.hashCode() & _hashMask; Bucket bucket = _buckets[index]; /* Let's unroll first lookup since that is null or match in 90+% cases*/ if (bucket == null) { return false; } /* Primarily we do just identity comparison as keys should be interned*/ <BUGS> if (bucket.key == key) { <BUGE> try { bucket.value.deserializeAndSet(p, ctxt, bean); } catch (Exception e) { wrapAndThrow(e, bean, key, ctxt); } return true; } return _findDeserializeAndSet2(p, ctxt, bean, key, index); }
*/ public boolean findDeserializeAndSet(JsonParser p, DeserializationContext ctxt, Object bean, String key) throws IOException { if (_caseInsensitive) { key = key.toLowerCase(); } int index = key.hashCode() & _hashMask; Bucket bucket = _buckets[index]; /* Let's unroll first lookup since that is null or match in 90+% cases*/ if (bucket == null) { return false; } /* Primarily we do just identity comparison as keys should be interned*/ if (bucket.key == key) { try { <BUGS> bucket.value.deserializeAndSet(p, ctxt, bean); } catch (Exception e) { wrapAndThrow(e, bean, key, ctxt); <BUGE> } return true; } return _findDeserializeAndSet2(p, ctxt, bean, key, index); }
*/ public LinkedNode<DeserializationProblemHandler> getProblemHandlers() { <BUGS> return _problemHandlers; <BUGE> }
protected final Integer _parseInteger(JsonParser p, DeserializationContext ctxt) throws IOException { <BUGS> switch (p.getCurrentTokenId()) { <BUGE> /* NOTE: caller assumed to usually check VALUE_NUMBER_INT in fast path*/ case JsonTokenId.ID_NUMBER_INT: return Integer.valueOf(p.getIntValue()); case JsonTokenId.ID_NUMBER_FLOAT: /* coercing may work too*/ if (!ctxt.isEnabled(DeserializationFeature.ACCEPT_FLOAT_AS_INT)) { _failDoubleToIntCoercion(p, ctxt, "Integer"); } return Integer.valueOf(p.getValueAsInt()); case JsonTokenId.ID_STRING: /* let's do implicit re-parse*/ String text = p.getText().trim(); try { int len = text.length(); if (_hasTextualNull(text)) { return (Integer) getNullValue(ctxt); } if (len > 9) { long l = Long.parseLong(text); if (l < Integer.MIN_VALUE || l > Integer.MAX_VALUE) { throw ctxt.weirdStringException(text, _valueClass, "Overflow: numeric value ("+text+") out of range of Integer ("+Integer.MIN_VALUE+" - "+Integer.MAX_VALUE+")"); } return Integer.valueOf((int) l); } if (len == 0) { return (Integer) getEmptyValue(ctxt);
protected final Integer _parseInteger(JsonParser p, DeserializationContext ctxt) throws IOException { switch (p.getCurrentTokenId()) { /* NOTE: caller assumed to usually check VALUE_NUMBER_INT in fast path*/ case JsonTokenId.ID_NUMBER_INT: return Integer.valueOf(p.getIntValue()); case JsonTokenId.ID_NUMBER_FLOAT: /* coercing may work too*/ if (!ctxt.isEnabled(DeserializationFeature.ACCEPT_FLOAT_AS_INT)) { _failDoubleToIntCoercion(p, ctxt, "Integer"); } return Integer.valueOf(p.getValueAsInt()); case JsonTokenId.ID_STRING: /* let's do implicit re-parse*/ <BUGS> String text = p.getText().trim(); <BUGE> try { int len = text.length(); if (_hasTextualNull(text)) { return (Integer) getNullValue(ctxt); } if (len > 9) { long l = Long.parseLong(text); if (l < Integer.MIN_VALUE || l > Integer.MAX_VALUE) { throw ctxt.weirdStringException(text, _valueClass, "Overflow: numeric value ("+text+") out of range of Integer ("+Integer.MIN_VALUE+" - "+Integer.MAX_VALUE+")"); } return Integer.valueOf((int) l); } if (len == 0) { return (Integer) getEmptyValue(ctxt);
protected final Integer _parseInteger(JsonParser p, DeserializationContext ctxt) throws IOException { switch (p.getCurrentTokenId()) { /* NOTE: caller assumed to usually check VALUE_NUMBER_INT in fast path*/ case JsonTokenId.ID_NUMBER_INT: return Integer.valueOf(p.getIntValue()); case JsonTokenId.ID_NUMBER_FLOAT: /* coercing may work too*/ if (!ctxt.isEnabled(DeserializationFeature.ACCEPT_FLOAT_AS_INT)) { _failDoubleToIntCoercion(p, ctxt, "Integer"); } return Integer.valueOf(p.getValueAsInt()); case JsonTokenId.ID_STRING: /* let's do implicit re-parse*/ String text = p.getText().trim(); try { <BUGS> int len = text.length(); if (_hasTextualNull(text)) { <BUGE> return (Integer) getNullValue(ctxt); } if (len > 9) { long l = Long.parseLong(text); if (l < Integer.MIN_VALUE || l > Integer.MAX_VALUE) { throw ctxt.weirdStringException(text, _valueClass, "Overflow: numeric value ("+text+") out of range of Integer ("+Integer.MIN_VALUE+" - "+Integer.MAX_VALUE+")"); } return Integer.valueOf((int) l); } if (len == 0) { return (Integer) getEmptyValue(ctxt);
protected final Integer _parseInteger(JsonParser p, DeserializationContext ctxt) throws IOException { switch (p.getCurrentTokenId()) { /* NOTE: caller assumed to usually check VALUE_NUMBER_INT in fast path*/ case JsonTokenId.ID_NUMBER_INT: return Integer.valueOf(p.getIntValue()); case JsonTokenId.ID_NUMBER_FLOAT: /* coercing may work too*/ if (!ctxt.isEnabled(DeserializationFeature.ACCEPT_FLOAT_AS_INT)) { _failDoubleToIntCoercion(p, ctxt, "Integer"); } return Integer.valueOf(p.getValueAsInt()); case JsonTokenId.ID_STRING: /* let's do implicit re-parse*/ String text = p.getText().trim(); try { int len = text.length(); if (_hasTextualNull(text)) { return (Integer) getNullValue(ctxt); } <BUGS> if (len > 9) { <BUGE> long l = Long.parseLong(text); if (l < Integer.MIN_VALUE || l > Integer.MAX_VALUE) { throw ctxt.weirdStringException(text, _valueClass, "Overflow: numeric value ("+text+") out of range of Integer ("+Integer.MIN_VALUE+" - "+Integer.MAX_VALUE+")"); } return Integer.valueOf((int) l); } if (len == 0) { return (Integer) getEmptyValue(ctxt);
protected final Integer _parseInteger(JsonParser p, DeserializationContext ctxt) throws IOException { switch (p.getCurrentTokenId()) { /* NOTE: caller assumed to usually check VALUE_NUMBER_INT in fast path*/ case JsonTokenId.ID_NUMBER_INT: return Integer.valueOf(p.getIntValue()); case JsonTokenId.ID_NUMBER_FLOAT: /* coercing may work too*/ if (!ctxt.isEnabled(DeserializationFeature.ACCEPT_FLOAT_AS_INT)) { _failDoubleToIntCoercion(p, ctxt, "Integer"); } return Integer.valueOf(p.getValueAsInt()); case JsonTokenId.ID_STRING: /* let's do implicit re-parse*/ String text = p.getText().trim(); try { int len = text.length(); if (_hasTextualNull(text)) { return (Integer) getNullValue(ctxt); } if (len > 9) { long l = Long.parseLong(text); if (l < Integer.MIN_VALUE || l > Integer.MAX_VALUE) { throw ctxt.weirdStringException(text, _valueClass, "Overflow: numeric value ("+text+") out of range of Integer ("+Integer.MIN_VALUE+" - "+Integer.MAX_VALUE+")"); } return Integer.valueOf((int) l); } <BUGS> if (len == 0) { return (Integer) getEmptyValue(ctxt); <BUGE>
protected T _deserializeFromEmptyString() throws IOException { <BUGS> return null; <BUGE> }
protected T _deserializeFromEmptyString() throws IOException { return null; }
protected T _deserializeFromEmptyString() throws IOException { return null; }
@Override public Object deserializeFromObject(JsonParser p, DeserializationContext ctxt) throws IOException { /* 09-Dec-2014, tatu: As per [#622], we need to allow Object Id references *   to come in as JSON Objects as well; but for now assume they will *   be simple, single-property references, which means that we can *   recognize them without having to buffer anything. *   Once again, if we must, we can do more complex handling with buffering, *   but let's only do that if and when that becomes necessary. */ <BUGS> if (_objectIdReader != null && _objectIdReader.maySerializeAsObject()) { <BUGE> if (p.hasTokenId(JsonTokenId.ID_FIELD_NAME) && _objectIdReader.isValidReferencePropertyName(p.getCurrentName(), p)) { return deserializeFromObjectId(p, ctxt); } } if (_nonStandardCreation) { if (_unwrappedPropertyHandler != null) { return deserializeWithUnwrapped(p, ctxt); } if (_externalTypeIdHandler != null) { return deserializeWithExternalTypeId(p, ctxt); } Object bean = deserializeFromObjectUsingNonDefault(p, ctxt); if (_injectables != null) { injectValues(ctxt, bean); } /* 27-May-2014, tatu: I don't think view processing would work *   at this point, so commenting it out; but leaving in place *   just in case I forgot something fundamental...
@Override public Object deserializeFromObject(JsonParser p, DeserializationContext ctxt) throws IOException { /* 09-Dec-2014, tatu: As per [#622], we need to allow Object Id references *   to come in as JSON Objects as well; but for now assume they will *   be simple, single-property references, which means that we can *   recognize them without having to buffer anything. *   Once again, if we must, we can do more complex handling with buffering, *   but let's only do that if and when that becomes necessary. */ if (_objectIdReader != null && _objectIdReader.maySerializeAsObject()) { if (p.hasTokenId(JsonTokenId.ID_FIELD_NAME) && _objectIdReader.isValidReferencePropertyName(p.getCurrentName(), p)) { return deserializeFromObjectId(p, ctxt); } } <BUGS> if (_nonStandardCreation) { <BUGE> if (_unwrappedPropertyHandler != null) { return deserializeWithUnwrapped(p, ctxt); } if (_externalTypeIdHandler != null) { return deserializeWithExternalTypeId(p, ctxt); } Object bean = deserializeFromObjectUsingNonDefault(p, ctxt); if (_injectables != null) { injectValues(ctxt, bean); } /* 27-May-2014, tatu: I don't think view processing would work *   at this point, so commenting it out; but leaving in place *   just in case I forgot something fundamental...
} catch (Exception e) { wrapAndThrow(e, bean, propName, ctxt); } continue; } handleUnknownVanilla(p, ctxt, bean, propName); } while ((propName = p.nextFieldName()) != null); } return bean; }  /** * General version used when handling needs more advanced features. */ } <BUGS> final Object bean = _valueInstantiator.createUsingDefault(ctxt); <BUGE> /* [databind#631]: Assign current value, to be accessible by custom deserializers*/ p.setCurrentValue(bean); if (p.canReadObjectId()) { Object id = p.getObjectId(); if (id != null) { _handleTypedObjectId(p, ctxt, bean, id); } } if (_injectables != null) { injectValues(ctxt, bean); } if (_needViewProcesing) { Class<?> view = ctxt.getActiveView(); if (view != null) {
} catch (Exception e) { wrapAndThrow(e, bean, propName, ctxt); } continue; } handleUnknownVanilla(p, ctxt, bean, propName); } while ((propName = p.nextFieldName()) != null); } return bean; }  /** * General version used when handling needs more advanced features. */ /* [databind#631]: Assign current value, to be accessible by custom deserializers*/ <BUGS> p.setCurrentValue(bean); if (p.canReadObjectId()) { <BUGE> Object id = p.getObjectId(); if (id != null) { _handleTypedObjectId(p, ctxt, bean, id); } } if (_injectables != null) { injectValues(ctxt, bean); } if (_needViewProcesing) { Class<?> view = ctxt.getActiveView(); if (view != null) { return deserializeWithView(p, ctxt, bean, view); }
} catch (Exception e) { wrapAndThrow(e, bean, propName, ctxt); } continue; } handleUnknownVanilla(p, ctxt, bean, propName); } while ((propName = p.nextFieldName()) != null); } return bean; }  /** * General version used when handling needs more advanced features. */ } <BUGS> if (_injectables != null) { <BUGE> injectValues(ctxt, bean); } if (_needViewProcesing) { Class<?> view = ctxt.getActiveView(); if (view != null) { return deserializeWithView(p, ctxt, bean, view); } } if (p.hasTokenId(JsonTokenId.ID_FIELD_NAME)) { String propName = p.getCurrentName(); do { p.nextToken(); SettableBeanProperty prop = _beanProperties.find(propName); if (prop != null) { /* normal case*/
} catch (Exception e) { wrapAndThrow(e, bean, propName, ctxt); } continue; } handleUnknownVanilla(p, ctxt, bean, propName); } while ((propName = p.nextFieldName()) != null); } return bean; }  /** * General version used when handling needs more advanced features. */ } <BUGS> if (_needViewProcesing) { <BUGE> Class<?> view = ctxt.getActiveView(); if (view != null) { return deserializeWithView(p, ctxt, bean, view); } } if (p.hasTokenId(JsonTokenId.ID_FIELD_NAME)) { String propName = p.getCurrentName(); do { p.nextToken(); SettableBeanProperty prop = _beanProperties.find(propName); if (prop != null) { /* normal case*/ try { prop.deserializeAndSet(p, ctxt, bean); } catch (Exception e) {
} catch (Exception e) { wrapAndThrow(e, bean, propName, ctxt); } continue; } handleUnknownVanilla(p, ctxt, bean, propName); } while ((propName = p.nextFieldName()) != null); } return bean; }  /** * General version used when handling needs more advanced features. */ } <BUGS> if (p.hasTokenId(JsonTokenId.ID_FIELD_NAME)) { String propName = p.getCurrentName(); <BUGE> do { p.nextToken(); SettableBeanProperty prop = _beanProperties.find(propName); if (prop != null) { /* normal case*/ try { prop.deserializeAndSet(p, ctxt, bean); } catch (Exception e) { wrapAndThrow(e, bean, propName, ctxt); } continue; } handleUnknownVanilla(p, ctxt, bean, propName); } while ((propName = p.nextFieldName()) != null);
wrapAndThrow(e, bean, propName, ctxt); } continue; } handleUnknownVanilla(p, ctxt, bean, propName); } while ((propName = p.nextFieldName()) != null); } return bean; }  /** * General version used when handling needs more advanced features. */ do { <BUGS> p.nextToken(); SettableBeanProperty prop = _beanProperties.find(propName); if (prop != null) { /* normal case <BUGE>*/ try { prop.deserializeAndSet(p, ctxt, bean); } catch (Exception e) { wrapAndThrow(e, bean, propName, ctxt); } continue; } handleUnknownVanilla(p, ctxt, bean, propName); } while ((propName = p.nextFieldName()) != null); } return bean; }
wrapAndThrow(e, bean, propName, ctxt); } continue; } handleUnknownVanilla(p, ctxt, bean, propName); } while ((propName = p.nextFieldName()) != null); } return bean; }  /** * General version used when handling needs more advanced features. */ try { <BUGS> prop.deserializeAndSet(p, ctxt, bean); } catch (Exception e) { wrapAndThrow(e, bean, propName, ctxt); } <BUGE> continue; } handleUnknownVanilla(p, ctxt, bean, propName); } while ((propName = p.nextFieldName()) != null); } return bean; }  /** * Method called to deserialize bean using "property-based creator": * this means that a non-default constructor or factory method is * called, and then possibly other setters. The trick is that
} catch (Exception e) { wrapAndThrow(e, bean, propName, ctxt); } continue; } handleUnknownVanilla(p, ctxt, bean, propName); } while ((propName = p.nextFieldName()) != null); } return bean; }  /** * General version used when handling needs more advanced features. */ handleUnknownVanilla(p, ctxt, bean, propName); <BUGS> } while ((propName = p.nextFieldName()) != null); <BUGE> } return bean; }  /** * Method called to deserialize bean using "property-based creator": * this means that a non-default constructor or factory method is * called, and then possibly other setters. The trick is that * values for creator method need to be buffered, first; and * due to non-guaranteed ordering possibly some other properties * as well. */ @Override @SuppressWarnings("resource")
public ObjectIdInfo withAlwaysAsId(boolean state) { <BUGS> if (_alwaysAsId == state) { return this; <BUGE> } return new ObjectIdInfo(_propertyName, _scope, _generator, state, _resolver); }
public ObjectIdInfo withAlwaysAsId(boolean state) { if (_alwaysAsId == state) { return this; } <BUGS> return new ObjectIdInfo(_propertyName, _scope, _generator, state, _resolver); <BUGE> }
*/ protected void _throwAsIOE(JsonParser p, Exception e, Object value) throws IOException { <BUGS> if (e instanceof IllegalArgumentException) { String actType = (value == null) ? "[NULL]" : value.getClass().getName(); StringBuilder msg = new StringBuilder("Problem deserializing property '").append(getName()); msg.append("' (expected type: ").append(getType()); msg.append("; actual type: ").append(actType).append(")"); String origMsg = e.getMessage(); if (origMsg != null) { msg.append(", problem: ").append(origMsg); <BUGE> } else { msg.append(" (no error message provided)"); } throw JsonMappingException.from(p, msg.toString(), e); } _throwAsIOE(p, e); }
*/ protected void _throwAsIOE(JsonParser p, Exception e, Object value) throws IOException { if (e instanceof IllegalArgumentException) { String actType = (value == null) ? "[NULL]" : value.getClass().getName(); StringBuilder msg = new StringBuilder("Problem deserializing property '").append(getName()); msg.append("' (expected type: ").append(getType()); msg.append("; actual type: ").append(actType).append(")"); String origMsg = e.getMessage(); if (origMsg != null) { msg.append(", problem: ").append(origMsg); } else { msg.append(" (no error message provided)"); } <BUGS> throw JsonMappingException.from(p, msg.toString(), e); <BUGE> } _throwAsIOE(p, e); }
@Override public ReferenceType withStaticTyping() { <BUGS> if (_asStatic) { <BUGE> return this; } return new ReferenceType(_class, _bindings, _superClass, _superInterfaces, _referencedType.withStaticTyping(), _anchorType, _valueHandler, _typeHandler, true); }
@Override public ReferenceType withStaticTyping() { if (_asStatic) { return this; } <BUGS> return new ReferenceType(_class, _bindings, _superClass, _superInterfaces, _referencedType.withStaticTyping(), _anchorType, <BUGE> _valueHandler, _typeHandler, true); }
@SuppressWarnings("unchecked") public static JsonSerializer<Object> getFallbackKeySerializer(SerializationConfig config, Class<?> rawKeyType) { <BUGS> if (rawKeyType != null) { <BUGE> /* 29-Sep-2015, tatu: Odd case here, of `Enum`, which we may get for `EnumMap`; not sure*/ /*   if that is a bug or feature. Regardless, it seems to require dynamic handling*/ /*   (compared to getting actual fully typed Enum).*/ /*  Note that this might even work from the earlier point, but let's play it safe for now*/ /* 11-Aug-2016, tatu: Turns out we get this if `EnumMap` is the root value because*/ /*    then there is no static type*/ if (rawKeyType == Enum.class) { return new Dynamic(); } if (rawKeyType.isEnum()) { return new Default(Default.TYPE_ENUM, rawKeyType); } } return DEFAULT_KEY_SERIALIZER; }
@SuppressWarnings("unchecked") public static JsonSerializer<Object> getFallbackKeySerializer(SerializationConfig config, Class<?> rawKeyType) { if (rawKeyType != null) { /* 29-Sep-2015, tatu: Odd case here, of `Enum`, which we may get for `EnumMap`; not sure*/ /*   if that is a bug or feature. Regardless, it seems to require dynamic handling*/ /*   (compared to getting actual fully typed Enum).*/ /*  Note that this might even work from the earlier point, but let's play it safe for now*/ /* 11-Aug-2016, tatu: Turns out we get this if `EnumMap` is the root value because*/ /*    then there is no static type*/ <BUGS> if (rawKeyType == Enum.class) { return new Dynamic(); <BUGE> } if (rawKeyType.isEnum()) { return new Default(Default.TYPE_ENUM, rawKeyType); } } return DEFAULT_KEY_SERIALIZER; }
@SuppressWarnings("unchecked") public static JsonSerializer<Object> getFallbackKeySerializer(SerializationConfig config, Class<?> rawKeyType) { if (rawKeyType != null) { /* 29-Sep-2015, tatu: Odd case here, of `Enum`, which we may get for `EnumMap`; not sure*/ /*   if that is a bug or feature. Regardless, it seems to require dynamic handling*/ /*   (compared to getting actual fully typed Enum).*/ /*  Note that this might even work from the earlier point, but let's play it safe for now*/ /* 11-Aug-2016, tatu: Turns out we get this if `EnumMap` is the root value because*/ /*    then there is no static type*/ if (rawKeyType == Enum.class) { return new Dynamic(); } <BUGS> if (rawKeyType.isEnum()) { return new Default(Default.TYPE_ENUM, rawKeyType); <BUGE> } } return DEFAULT_KEY_SERIALIZER; }
@Override protected Object _deserialize(String value, DeserializationContext ctxt) throws IOException { <BUGS> switch (_kind) { <BUGE> case STD_FILE: return new File(value); case STD_URL: return new URL(value); case STD_URI: return URI.create(value); case STD_CLASS: try { return ctxt.findClass(value); } catch (Exception e) { throw ctxt.instantiationException(_valueClass, ClassUtil.getRootCause(e)); } case STD_JAVA_TYPE: return ctxt.getTypeFactory().constructFromCanonical(value); case STD_CURRENCY: /* will throw IAE if unknown:*/ return Currency.getInstance(value); case STD_PATTERN: /* will throw IAE (or its subclass) if malformed*/ return Pattern.compile(value); case STD_LOCALE: { int ix = value.indexOf('_'); if (ix < 0) { /* single argument*/ return new Locale(value); }
@Override protected Object _deserialize(String value, DeserializationContext ctxt) throws IOException { switch (_kind) { case STD_FILE: return new File(value); case STD_URL: return new URL(value); case STD_URI: return URI.create(value); case STD_CLASS: try { return ctxt.findClass(value); } catch (Exception e) { throw ctxt.instantiationException(_valueClass, ClassUtil.getRootCause(e)); } case STD_JAVA_TYPE: return ctxt.getTypeFactory().constructFromCanonical(value); case STD_CURRENCY: /* will throw IAE if unknown:*/ return Currency.getInstance(value); case STD_PATTERN: /* will throw IAE (or its subclass) if malformed*/ return Pattern.compile(value); case STD_LOCALE: { <BUGS> int ix = value.indexOf('_'); if (ix < 0) { /* single argument*/ return new Locale(value); <BUGE> }
public final static int STD_CHARSET = 9; public final static int STD_TIME_ZONE = 10; public final static int STD_INET_ADDRESS = 11; public final static int STD_INET_SOCKET_ADDRESS = 12;  protected final int _kind;  protected Std(Class<?> valueType, int kind) { super(valueType); _kind = kind; }  } <BUGS> String first = value.substring(0, ix); value = value.substring(ix+1); ix = value.indexOf('_'); if (ix < 0) { /* two pieces*/ return new Locale(first, value); <BUGE> } String second = value.substring(0, ix); return new Locale(first, second, value.substring(ix+1)); } case STD_CHARSET: return Charset.forName(value); case STD_TIME_ZONE: return TimeZone.getTimeZone(value); case STD_INET_ADDRESS: return InetAddress.getByName(value); case STD_INET_SOCKET_ADDRESS: if (value.startsWith("[")) {
public final static int STD_PATTERN = 7; public final static int STD_LOCALE = 8; public final static int STD_CHARSET = 9; public final static int STD_TIME_ZONE = 10; public final static int STD_INET_ADDRESS = 11; public final static int STD_INET_SOCKET_ADDRESS = 12;  protected final int _kind;  protected Std(Class<?> valueType, int kind) { super(valueType); _kind = kind; }  } <BUGS> String second = value.substring(0, ix); return new Locale(first, second, value.substring(ix+1)); <BUGE> } case STD_CHARSET: return Charset.forName(value); case STD_TIME_ZONE: return TimeZone.getTimeZone(value); case STD_INET_ADDRESS: return InetAddress.getByName(value); case STD_INET_SOCKET_ADDRESS: if (value.startsWith("[")) { /* bracketed IPv6 (with port number)*/  int i = value.lastIndexOf(']'); if (i == -1) {
*/ public static Object defaultValue(Class<?> cls) { <BUGS> if (cls == Integer.TYPE) { return Integer.valueOf(0); <BUGE> } if (cls == Long.TYPE) { return Long.valueOf(0L); } if (cls == Boolean.TYPE) { return Boolean.FALSE; } if (cls == Double.TYPE) { return Double.valueOf(0.0); } if (cls == Float.TYPE) { return Float.valueOf(0.0f); } if (cls == Byte.TYPE) { return Byte.valueOf((byte) 0); } if (cls == Short.TYPE) { return Short.valueOf((short) 0); } if (cls == Character.TYPE) { return '\0'; } throw new IllegalArgumentException("Class "+cls.getName()+" is not a primitive type"); }
*/ public static Object defaultValue(Class<?> cls) { if (cls == Integer.TYPE) { return Integer.valueOf(0); } <BUGS> if (cls == Long.TYPE) { <BUGE> return Long.valueOf(0L); } if (cls == Boolean.TYPE) { return Boolean.FALSE; } if (cls == Double.TYPE) { return Double.valueOf(0.0); } if (cls == Float.TYPE) { return Float.valueOf(0.0f); } if (cls == Byte.TYPE) { return Byte.valueOf((byte) 0); } if (cls == Short.TYPE) { return Short.valueOf((short) 0); } if (cls == Character.TYPE) { return '\0'; } throw new IllegalArgumentException("Class "+cls.getName()+" is not a primitive type"); }
*/ public static Object defaultValue(Class<?> cls) { if (cls == Integer.TYPE) { return Integer.valueOf(0); } if (cls == Long.TYPE) { return Long.valueOf(0L); } <BUGS> if (cls == Boolean.TYPE) { <BUGE> return Boolean.FALSE; } if (cls == Double.TYPE) { return Double.valueOf(0.0); } if (cls == Float.TYPE) { return Float.valueOf(0.0f); } if (cls == Byte.TYPE) { return Byte.valueOf((byte) 0); } if (cls == Short.TYPE) { return Short.valueOf((short) 0); } if (cls == Character.TYPE) { return '\0'; } throw new IllegalArgumentException("Class "+cls.getName()+" is not a primitive type"); }
*/ public static Object defaultValue(Class<?> cls) { if (cls == Integer.TYPE) { return Integer.valueOf(0); } if (cls == Long.TYPE) { return Long.valueOf(0L); } if (cls == Boolean.TYPE) { return Boolean.FALSE; } <BUGS> if (cls == Double.TYPE) { return Double.valueOf(0.0); <BUGE> } if (cls == Float.TYPE) { return Float.valueOf(0.0f); } if (cls == Byte.TYPE) { return Byte.valueOf((byte) 0); } if (cls == Short.TYPE) { return Short.valueOf((short) 0); } if (cls == Character.TYPE) { return '\0'; } throw new IllegalArgumentException("Class "+cls.getName()+" is not a primitive type"); }
*/ protected void addBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException { <BUGS> final SettableBeanProperty[] creatorProps = builder.getValueInstantiator().getFromObjectArguments(ctxt.getConfig()); final boolean isConcrete = !beanDesc.getType().isAbstract(); <BUGE>  /* Things specified as "ok to ignore"?*/ AnnotationIntrospector intr = ctxt.getAnnotationIntrospector(); if (intr != null) { Boolean B = intr.findIgnoreUnknownProperties(beanDesc.getClassInfo()); if (B != null) { builder.setIgnoreUnknownProperties(B.booleanValue()); } } /* Or explicit/implicit definitions?*/ Set<String> ignored = ArrayBuilders.arrayToSet(intr.findPropertiesToIgnore(beanDesc.getClassInfo(), false)); for (String propName : ignored) { builder.addIgnorable(propName); } /* Also, do we have a fallback "any" setter?*/ AnnotatedMethod anySetter = beanDesc.findAnySetter(); if (anySetter != null) { builder.setAnySetter(constructAnySetter(ctxt, beanDesc, anySetter)); } /* NOTE: we do NOT add @JsonIgnore'd properties into blocked ones if there's any-setter*/ /* Implicit ones via @JsonIgnore and equivalent?*/ if (anySetter == null) {
*/ protected void addBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException { final SettableBeanProperty[] creatorProps = builder.getValueInstantiator().getFromObjectArguments(ctxt.getConfig()); final boolean isConcrete = !beanDesc.getType().isAbstract();  /* Things specified as "ok to ignore"?*/ <BUGS> AnnotationIntrospector intr = ctxt.getAnnotationIntrospector(); if (intr != null) { Boolean B = intr.findIgnoreUnknownProperties(beanDesc.getClassInfo()); if (B != null) { <BUGE> builder.setIgnoreUnknownProperties(B.booleanValue()); } } /* Or explicit/implicit definitions?*/ Set<String> ignored = ArrayBuilders.arrayToSet(intr.findPropertiesToIgnore(beanDesc.getClassInfo(), false)); for (String propName : ignored) { builder.addIgnorable(propName); } /* Also, do we have a fallback "any" setter?*/ AnnotatedMethod anySetter = beanDesc.findAnySetter(); if (anySetter != null) { builder.setAnySetter(constructAnySetter(ctxt, beanDesc, anySetter)); } /* NOTE: we do NOT add @JsonIgnore'd properties into blocked ones if there's any-setter*/ /* Implicit ones via @JsonIgnore and equivalent?*/ if (anySetter == null) {
*/ protected void addBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException { final SettableBeanProperty[] creatorProps = builder.getValueInstantiator().getFromObjectArguments(ctxt.getConfig()); final boolean isConcrete = !beanDesc.getType().isAbstract();  /* Things specified as "ok to ignore"?*/ AnnotationIntrospector intr = ctxt.getAnnotationIntrospector(); if (intr != null) { Boolean B = intr.findIgnoreUnknownProperties(beanDesc.getClassInfo()); if (B != null) { builder.setIgnoreUnknownProperties(B.booleanValue()); } } /* Or explicit/implicit definitions?*/ <BUGS> Set<String> ignored = ArrayBuilders.arrayToSet(intr.findPropertiesToIgnore(beanDesc.getClassInfo(), false)); for (String propName : ignored) { <BUGE> builder.addIgnorable(propName); } /* Also, do we have a fallback "any" setter?*/ AnnotatedMethod anySetter = beanDesc.findAnySetter(); if (anySetter != null) { builder.setAnySetter(constructAnySetter(ctxt, beanDesc, anySetter)); } /* NOTE: we do NOT add @JsonIgnore'd properties into blocked ones if there's any-setter*/ /* Implicit ones via @JsonIgnore and equivalent?*/ if (anySetter == null) {
*/ protected void addBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException { final SettableBeanProperty[] creatorProps = builder.getValueInstantiator().getFromObjectArguments(ctxt.getConfig()); final boolean isConcrete = !beanDesc.getType().isAbstract();  /* Things specified as "ok to ignore"?*/ AnnotationIntrospector intr = ctxt.getAnnotationIntrospector(); if (intr != null) { Boolean B = intr.findIgnoreUnknownProperties(beanDesc.getClassInfo()); if (B != null) { builder.setIgnoreUnknownProperties(B.booleanValue()); } } /* Or explicit/implicit definitions?*/ Set<String> ignored = ArrayBuilders.arrayToSet(intr.findPropertiesToIgnore(beanDesc.getClassInfo(), false)); for (String propName : ignored) { builder.addIgnorable(propName); } /* Also, do we have a fallback "any" setter?*/ <BUGS> AnnotatedMethod anySetter = beanDesc.findAnySetter(); if (anySetter != null) { <BUGE> builder.setAnySetter(constructAnySetter(ctxt, beanDesc, anySetter)); } /* NOTE: we do NOT add @JsonIgnore'd properties into blocked ones if there's any-setter*/ /* Implicit ones via @JsonIgnore and equivalent?*/ if (anySetter == null) {
* instance. */ protected BeanDeserializerBuilder constructBeanDeserializerBuilder(DeserializationContext ctxt, BeanDescription beanDesc) { return new BeanDeserializerBuilder(beanDesc, ctxt.getConfig()); }  /** * Method called to figure out settable properties for the * bean deserializer to use. *<p> * Note: designed to be overridable, and effort is made to keep interface * similar between versions. /* Implicit ones via @JsonIgnore and equivalent?*/ <BUGS> if (anySetter == null) { Collection<String> ignored2 = beanDesc.getIgnoredPropertyNames(); if (ignored2 != null) { for (String propName : ignored2) { <BUGE> /* allow ignoral of similarly named JSON property, but do not force;*/ /* latter means NOT adding this to 'ignored':*/ builder.addIgnorable(propName); } } } final boolean useGettersAsSetters = (ctxt.isEnabled(MapperFeature.USE_GETTERS_AS_SETTERS) && ctxt.isEnabled(MapperFeature.AUTO_DETECT_GETTERS));  /* Ok: let's then filter out property definitions*/ List<BeanPropertyDefinition> propDefs = filterBeanProps(ctxt, beanDesc, builder, beanDesc.findProperties(), ignored);
* which is used to accumulate information needed to create deserializer * instance. */ protected BeanDeserializerBuilder constructBeanDeserializerBuilder(DeserializationContext ctxt, BeanDescription beanDesc) { return new BeanDeserializerBuilder(beanDesc, ctxt.getConfig()); }  /** * Method called to figure out settable properties for the * bean deserializer to use. *<p> * Note: designed to be overridable, and effort is made to keep interface * similar between versions. } <BUGS> final boolean useGettersAsSetters = (ctxt.isEnabled(MapperFeature.USE_GETTERS_AS_SETTERS) && ctxt.isEnabled(MapperFeature.AUTO_DETECT_GETTERS)); <BUGE>  /* Ok: let's then filter out property definitions*/ List<BeanPropertyDefinition> propDefs = filterBeanProps(ctxt, beanDesc, builder, beanDesc.findProperties(), ignored);  /* After which we can let custom code change the set*/ if (_factoryConfig.hasDeserializerModifiers()) { for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) { propDefs = mod.updateProperties(ctxt.getConfig(), beanDesc, propDefs); } }  /* At which point we still have all kinds of properties; not all with mutators:*/
* which is used to accumulate information needed to create deserializer * instance. */ protected BeanDeserializerBuilder constructBeanDeserializerBuilder(DeserializationContext ctxt, BeanDescription beanDesc) { return new BeanDeserializerBuilder(beanDesc, ctxt.getConfig()); }  /** * Method called to figure out settable properties for the * bean deserializer to use. *<p> * Note: designed to be overridable, and effort is made to keep interface * similar between versions. /* Ok: let's then filter out property definitions*/ <BUGS> List<BeanPropertyDefinition> propDefs = filterBeanProps(ctxt, beanDesc, builder, beanDesc.findProperties(), ignored); <BUGE>  /* After which we can let custom code change the set*/ if (_factoryConfig.hasDeserializerModifiers()) { for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) { propDefs = mod.updateProperties(ctxt.getConfig(), beanDesc, propDefs); } }  /* At which point we still have all kinds of properties; not all with mutators:*/ for (BeanPropertyDefinition propDef : propDefs) { SettableBeanProperty prop = null; /* 18-Oct-2013, tatu: Although constructor parameters have highest precedence, *   we need to do linkage (as per [databind#318]), and so need to start with
* which is used to accumulate information needed to create deserializer * instance. */ protected BeanDeserializerBuilder constructBeanDeserializerBuilder(DeserializationContext ctxt, BeanDescription beanDesc) { return new BeanDeserializerBuilder(beanDesc, ctxt.getConfig()); }  /** * Method called to figure out settable properties for the * bean deserializer to use. *<p> * Note: designed to be overridable, and effort is made to keep interface * similar between versions. /* After which we can let custom code change the set*/ <BUGS> if (_factoryConfig.hasDeserializerModifiers()) { <BUGE> for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) { propDefs = mod.updateProperties(ctxt.getConfig(), beanDesc, propDefs); } }  /* At which point we still have all kinds of properties; not all with mutators:*/ for (BeanPropertyDefinition propDef : propDefs) { SettableBeanProperty prop = null; /* 18-Oct-2013, tatu: Although constructor parameters have highest precedence, *   we need to do linkage (as per [databind#318]), and so need to start with *   other types, and only then create constructor parameter, if any. */ if (propDef.hasSetter()) { JavaType propertyType = propDef.getSetter().getParameterType(0);
* which is used to accumulate information needed to create deserializer * instance. */ protected BeanDeserializerBuilder constructBeanDeserializerBuilder(DeserializationContext ctxt, BeanDescription beanDesc) { return new BeanDeserializerBuilder(beanDesc, ctxt.getConfig()); }  /** * Method called to figure out settable properties for the * bean deserializer to use. *<p> * Note: designed to be overridable, and effort is made to keep interface * similar between versions. /* At which point we still have all kinds of properties; not all with mutators:*/ <BUGS> for (BeanPropertyDefinition propDef : propDefs) { SettableBeanProperty prop = null; <BUGE> /* 18-Oct-2013, tatu: Although constructor parameters have highest precedence, *   we need to do linkage (as per [databind#318]), and so need to start with *   other types, and only then create constructor parameter, if any. */ if (propDef.hasSetter()) { JavaType propertyType = propDef.getSetter().getParameterType(0); prop = constructSettableProperty(ctxt, beanDesc, propDef, propertyType); } else if (propDef.hasField()) { JavaType propertyType = propDef.getField().getType(); prop = constructSettableProperty(ctxt, beanDesc, propDef, propertyType); } else if (useGettersAsSetters && propDef.hasGetter()) { /* May also need to consider getters * for Map/Collection properties; but with lowest precedence
* which is used to accumulate information needed to create deserializer * instance. */ protected BeanDeserializerBuilder constructBeanDeserializerBuilder(DeserializationContext ctxt, BeanDescription beanDesc) { return new BeanDeserializerBuilder(beanDesc, ctxt.getConfig()); }  /** * Method called to figure out settable properties for the * bean deserializer to use. *<p> * Note: designed to be overridable, and effort is made to keep interface * similar between versions. */ <BUGS> if (propDef.hasSetter()) { <BUGE> JavaType propertyType = propDef.getSetter().getParameterType(0); prop = constructSettableProperty(ctxt, beanDesc, propDef, propertyType); } else if (propDef.hasField()) { JavaType propertyType = propDef.getField().getType(); prop = constructSettableProperty(ctxt, beanDesc, propDef, propertyType); } else if (useGettersAsSetters && propDef.hasGetter()) { /* May also need to consider getters * for Map/Collection properties; but with lowest precedence */ AnnotatedMethod getter = propDef.getGetter(); /* should only consider Collections and Maps, for now?*/ Class<?> rawPropertyType = getter.getRawType(); if (Collection.class.isAssignableFrom(rawPropertyType) || Map.class.isAssignableFrom(rawPropertyType)) {
* instance. */ protected BeanDeserializerBuilder constructBeanDeserializerBuilder(DeserializationContext ctxt, BeanDescription beanDesc) { return new BeanDeserializerBuilder(beanDesc, ctxt.getConfig()); }  /** * Method called to figure out settable properties for the * bean deserializer to use. *<p> * Note: designed to be overridable, and effort is made to keep interface * similar between versions. prop = constructSettableProperty(ctxt, beanDesc, propDef, propertyType); <BUGS> } else if (propDef.hasField()) { JavaType propertyType = propDef.getField().getType(); prop = constructSettableProperty(ctxt, beanDesc, propDef, propertyType); } else if (useGettersAsSetters && propDef.hasGetter()) { <BUGE> /* May also need to consider getters * for Map/Collection properties; but with lowest precedence */ AnnotatedMethod getter = propDef.getGetter(); /* should only consider Collections and Maps, for now?*/ Class<?> rawPropertyType = getter.getRawType(); if (Collection.class.isAssignableFrom(rawPropertyType) || Map.class.isAssignableFrom(rawPropertyType)) { prop = constructSetterlessProperty(ctxt, beanDesc, propDef); } } /* 25-Sep-2014, tatu: No point in finding constructor parameters for abstract types*/
* which is used to accumulate information needed to create deserializer * instance. */ protected BeanDeserializerBuilder constructBeanDeserializerBuilder(DeserializationContext ctxt, BeanDescription beanDesc) { return new BeanDeserializerBuilder(beanDesc, ctxt.getConfig()); }  /** * Method called to figure out settable properties for the * bean deserializer to use. *<p> * Note: designed to be overridable, and effort is made to keep interface * similar between versions. /*   (since they are never used anyway)*/ <BUGS> if (isConcrete && propDef.hasConstructorParameter()) { <BUGE> /* If property is passed via constructor parameter, we must * handle things in special way. Not sure what is the most optimal way... * for now, let's just call a (new) method in builder, which does nothing. */ /* but let's call a method just to allow custom builders to be aware...*/ final String name = propDef.getName(); CreatorProperty cprop = null; if (creatorProps != null) { for (SettableBeanProperty cp : creatorProps) { if (name.equals(cp.getName()) && (cp instanceof CreatorProperty)) { cprop = (CreatorProperty) cp; break; } }
*/ protected BeanDeserializerBuilder constructBeanDeserializerBuilder(DeserializationContext ctxt, BeanDescription beanDesc) { return new BeanDeserializerBuilder(beanDesc, ctxt.getConfig()); }  /** * Method called to figure out settable properties for the * bean deserializer to use. *<p> * Note: designed to be overridable, and effort is made to keep interface * similar between versions. /* but let's call a method just to allow custom builders to be aware...*/ <BUGS> final String name = propDef.getName(); CreatorProperty cprop = null; if (creatorProps != null) { for (SettableBeanProperty cp : creatorProps) { if (name.equals(cp.getName()) && (cp instanceof CreatorProperty)) { <BUGE> cprop = (CreatorProperty) cp; break; } } } if (cprop == null) { throw ctxt.mappingException("Could not find creator property with name '%s' (in class %s)", name, beanDesc.getBeanClass().getName()); } if (prop != null) { cprop.setFallbackSetter(prop); }
* instance. */ protected BeanDeserializerBuilder constructBeanDeserializerBuilder(DeserializationContext ctxt, BeanDescription beanDesc) { return new BeanDeserializerBuilder(beanDesc, ctxt.getConfig()); }  /** * Method called to figure out settable properties for the * bean deserializer to use. *<p> * Note: designed to be overridable, and effort is made to keep interface * similar between versions. } <BUGS> if (cprop == null) { throw ctxt.mappingException("Could not find creator property with name '%s' (in class %s)", name, beanDesc.getBeanClass().getName()); <BUGE> } if (prop != null) { cprop.setFallbackSetter(prop); } prop = cprop; builder.addCreatorProperty(cprop); continue; }  if (prop != null) { Class<?>[] views = propDef.findViews(); if (views == null) { /* one more twist: if default inclusion disabled, need to force empty set of views*/
*/ public void remove(SettableBeanProperty propToRm) { <BUGS> ArrayList<SettableBeanProperty> props = new ArrayList<SettableBeanProperty>(_size); String key = getPropertyName(propToRm); boolean found = false; <BUGE>  for (int i = 1, end = _hashArea.length; i < end; i += 2) { SettableBeanProperty prop = (SettableBeanProperty) _hashArea[i]; if (prop == null) { continue; } if (!found) { /* 09-Jan-2017, tatu: Important: must check name slot and NOT property name,*/ /*   as only former is lower-case in case-insensitive case*/ found = key.equals(prop.getName()); if (found) { /* need to leave a hole here*/ _propsInOrder[_findFromOrdered(prop)] = null; continue; } } props.add(prop); } if (!found) { throw new NoSuchElementException("No entry '"+propToRm.getName()+"' found, can't remove"); } init(props); }
*/ public void remove(SettableBeanProperty propToRm) { ArrayList<SettableBeanProperty> props = new ArrayList<SettableBeanProperty>(_size); String key = getPropertyName(propToRm); boolean found = false;  <BUGS> for (int i = 1, end = _hashArea.length; i < end; i += 2) { SettableBeanProperty prop = (SettableBeanProperty) _hashArea[i]; if (prop == null) { continue; <BUGE> } if (!found) { /* 09-Jan-2017, tatu: Important: must check name slot and NOT property name,*/ /*   as only former is lower-case in case-insensitive case*/ found = key.equals(prop.getName()); if (found) { /* need to leave a hole here*/ _propsInOrder[_findFromOrdered(prop)] = null; continue; } } props.add(prop); } if (!found) { throw new NoSuchElementException("No entry '"+propToRm.getName()+"' found, can't remove"); } init(props); }
*/ public void remove(SettableBeanProperty propToRm) { ArrayList<SettableBeanProperty> props = new ArrayList<SettableBeanProperty>(_size); String key = getPropertyName(propToRm); boolean found = false;  for (int i = 1, end = _hashArea.length; i < end; i += 2) { SettableBeanProperty prop = (SettableBeanProperty) _hashArea[i]; if (prop == null) { continue; } <BUGS> if (!found) { <BUGE> /* 09-Jan-2017, tatu: Important: must check name slot and NOT property name,*/ /*   as only former is lower-case in case-insensitive case*/ found = key.equals(prop.getName()); if (found) { /* need to leave a hole here*/ _propsInOrder[_findFromOrdered(prop)] = null; continue; } } props.add(prop); } if (!found) { throw new NoSuchElementException("No entry '"+propToRm.getName()+"' found, can't remove"); } init(props); }
*/ public void remove(SettableBeanProperty propToRm) { ArrayList<SettableBeanProperty> props = new ArrayList<SettableBeanProperty>(_size); String key = getPropertyName(propToRm); boolean found = false;  for (int i = 1, end = _hashArea.length; i < end; i += 2) { SettableBeanProperty prop = (SettableBeanProperty) _hashArea[i]; if (prop == null) { continue; } if (!found) { /* 09-Jan-2017, tatu: Important: must check name slot and NOT property name,*/ /*   as only former is lower-case in case-insensitive case*/ <BUGS> found = key.equals(prop.getName()); if (found) { <BUGE> /* need to leave a hole here*/ _propsInOrder[_findFromOrdered(prop)] = null; continue; } } props.add(prop); } if (!found) { throw new NoSuchElementException("No entry '"+propToRm.getName()+"' found, can't remove"); } init(props); }
*/ public void remove(SettableBeanProperty propToRm) { ArrayList<SettableBeanProperty> props = new ArrayList<SettableBeanProperty>(_size); String key = getPropertyName(propToRm); boolean found = false;  for (int i = 1, end = _hashArea.length; i < end; i += 2) { SettableBeanProperty prop = (SettableBeanProperty) _hashArea[i]; if (prop == null) { continue; } if (!found) { /* 09-Jan-2017, tatu: Important: must check name slot and NOT property name,*/ /*   as only former is lower-case in case-insensitive case*/ found = key.equals(prop.getName()); if (found) { /* need to leave a hole here*/ _propsInOrder[_findFromOrdered(prop)] = null; continue; } } <BUGS> props.add(prop); <BUGE> } if (!found) { throw new NoSuchElementException("No entry '"+propToRm.getName()+"' found, can't remove"); } init(props); }
*/ public void remove(SettableBeanProperty propToRm) { ArrayList<SettableBeanProperty> props = new ArrayList<SettableBeanProperty>(_size); String key = getPropertyName(propToRm); boolean found = false;  for (int i = 1, end = _hashArea.length; i < end; i += 2) { SettableBeanProperty prop = (SettableBeanProperty) _hashArea[i]; if (prop == null) { continue; } if (!found) { /* 09-Jan-2017, tatu: Important: must check name slot and NOT property name,*/ /*   as only former is lower-case in case-insensitive case*/ found = key.equals(prop.getName()); if (found) { /* need to leave a hole here*/ _propsInOrder[_findFromOrdered(prop)] = null; continue; } } props.add(prop); } <BUGS> if (!found) { throw new NoSuchElementException("No entry '"+propToRm.getName()+"' found, can't remove"); <BUGE> } init(props); }
@Override public Method findFactoryMethod(Class<?>... expArgTypes) { /* So, of all single-arg static methods:*/ <BUGS> for (AnnotatedMethod am : _classInfo.getStaticMethods()) { <BUGE> if (isFactoryMethod(am)) { /* And must take one of expected arg types (or supertype)*/ Class<?> actualArgType = am.getRawParameterType(0); for (Class<?> expArgType : expArgTypes) { /* And one that matches what we would pass in*/ if (actualArgType.isAssignableFrom(expArgType)) { return am.getAnnotated(); } } } } return null; }
@Override public Method findFactoryMethod(Class<?>... expArgTypes) { /* So, of all single-arg static methods:*/ for (AnnotatedMethod am : _classInfo.getStaticMethods()) { if (isFactoryMethod(am)) { /* And must take one of expected arg types (or supertype)*/ Class<?> actualArgType = am.getRawParameterType(0); for (Class<?> expArgType : expArgTypes) { /* And one that matches what we would pass in*/ if (actualArgType.isAssignableFrom(expArgType)) { return am.getAnnotated(); } } } } <BUGS> return null; <BUGE> }
*/ public int getCreatorIndex() { /* changed from 'return -1' in 2.7.9 / 2.8.7*/ <BUGS> throw new IllegalStateException(String.format( <BUGE> "Internal error: no creator index for property '%s' (of type %s)", this.getName(), getClass().getName())); }
*/ public int getCreatorIndex() { /* changed from 'return -1' in 2.7.9 / 2.8.7*/ throw new IllegalStateException(String.format( "Internal error: no creator index for property '%s' (of type %s)", <BUGS> this.getName(), getClass().getName())); <BUGE> }
@Override public String toString() { return getClass().getName()+": "+getMessage(); }
@Override public String toString() { <BUGS> return getClass().getName()+": "+getMessage(); <BUGE> }
@SuppressWarnings("resource") protected Object deserializeUsingPropertyBasedWithUnwrapped(JsonParser p, DeserializationContext ctxt) throws IOException, JsonProcessingException { <BUGS> final PropertyBasedCreator creator = _propertyBasedCreator; PropertyValueBuffer buffer = creator.startBuilding(p, ctxt, _objectIdReader); <BUGE>  TokenBuffer tokens = new TokenBuffer(p, ctxt); tokens.writeStartObject();  JsonToken t = p.getCurrentToken(); for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) { String propName = p.getCurrentName(); p.nextToken(); /* to point to value*/ /* creator property?*/ SettableBeanProperty creatorProp = creator.findCreatorProperty(propName); if (creatorProp != null) { if (buffer.assignParameter(creatorProp, creatorProp.deserialize(p, ctxt))) { t = p.nextToken(); Object bean; try { bean = creator.build(ctxt, buffer); } catch (Exception e) { wrapAndThrow(e, _beanType.getRawClass(), propName, ctxt); continue; } while (t == JsonToken.FIELD_NAME) { p.nextToken(); tokens.copyCurrentStructure(p);
@SuppressWarnings("resource") protected Object deserializeUsingPropertyBasedWithUnwrapped(JsonParser p, DeserializationContext ctxt) throws IOException, JsonProcessingException { final PropertyBasedCreator creator = _propertyBasedCreator; PropertyValueBuffer buffer = creator.startBuilding(p, ctxt, _objectIdReader);  <BUGS> TokenBuffer tokens = new TokenBuffer(p, ctxt); tokens.writeStartObject(); <BUGE>  JsonToken t = p.getCurrentToken(); for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) { String propName = p.getCurrentName(); p.nextToken(); /* to point to value*/ /* creator property?*/ SettableBeanProperty creatorProp = creator.findCreatorProperty(propName); if (creatorProp != null) { if (buffer.assignParameter(creatorProp, creatorProp.deserialize(p, ctxt))) { t = p.nextToken(); Object bean; try { bean = creator.build(ctxt, buffer); } catch (Exception e) { wrapAndThrow(e, _beanType.getRawClass(), propName, ctxt); continue; } while (t == JsonToken.FIELD_NAME) { p.nextToken(); tokens.copyCurrentStructure(p);
@SuppressWarnings("resource") protected Object deserializeUsingPropertyBasedWithUnwrapped(JsonParser p, DeserializationContext ctxt) throws IOException, JsonProcessingException { final PropertyBasedCreator creator = _propertyBasedCreator; PropertyValueBuffer buffer = creator.startBuilding(p, ctxt, _objectIdReader);  TokenBuffer tokens = new TokenBuffer(p, ctxt); tokens.writeStartObject();  <BUGS> JsonToken t = p.getCurrentToken(); for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) { String propName = p.getCurrentName(); p.nextToken(); /* to point to value <BUGE>*/ /* creator property?*/ SettableBeanProperty creatorProp = creator.findCreatorProperty(propName); if (creatorProp != null) { if (buffer.assignParameter(creatorProp, creatorProp.deserialize(p, ctxt))) { t = p.nextToken(); Object bean; try { bean = creator.build(ctxt, buffer); } catch (Exception e) { wrapAndThrow(e, _beanType.getRawClass(), propName, ctxt); continue; } while (t == JsonToken.FIELD_NAME) { p.nextToken(); tokens.copyCurrentStructure(p);
@SuppressWarnings("resource") protected Object deserializeUsingPropertyBasedWithUnwrapped(JsonParser p, DeserializationContext ctxt) throws IOException, JsonProcessingException { final PropertyBasedCreator creator = _propertyBasedCreator; PropertyValueBuffer buffer = creator.startBuilding(p, ctxt, _objectIdReader);  TokenBuffer tokens = new TokenBuffer(p, ctxt); tokens.writeStartObject();  JsonToken t = p.getCurrentToken(); for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) { String propName = p.getCurrentName(); p.nextToken(); /* to point to value*/ /* creator property?*/ <BUGS> SettableBeanProperty creatorProp = creator.findCreatorProperty(propName); if (creatorProp != null) { if (buffer.assignParameter(creatorProp, creatorProp.deserialize(p, ctxt))) { t = p.nextToken(); <BUGE> Object bean; try { bean = creator.build(ctxt, buffer); } catch (Exception e) { wrapAndThrow(e, _beanType.getRawClass(), propName, ctxt); continue; } while (t == JsonToken.FIELD_NAME) { p.nextToken(); tokens.copyCurrentStructure(p);
@SuppressWarnings("resource") protected Object deserializeUsingPropertyBasedWithUnwrapped(JsonParser p, DeserializationContext ctxt) throws IOException, JsonProcessingException { final PropertyBasedCreator creator = _propertyBasedCreator; PropertyValueBuffer buffer = creator.startBuilding(p, ctxt, _objectIdReader);  TokenBuffer tokens = new TokenBuffer(p, ctxt); tokens.writeStartObject();  JsonToken t = p.getCurrentToken(); for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) { String propName = p.getCurrentName(); p.nextToken(); /* to point to value*/ /* creator property?*/ SettableBeanProperty creatorProp = creator.findCreatorProperty(propName); if (creatorProp != null) { if (buffer.assignParameter(creatorProp, creatorProp.deserialize(p, ctxt))) { t = p.nextToken(); Object bean; try { <BUGS> bean = creator.build(ctxt, buffer); <BUGE> } catch (Exception e) { wrapAndThrow(e, _beanType.getRawClass(), propName, ctxt); continue; } while (t == JsonToken.FIELD_NAME) { p.nextToken(); tokens.copyCurrentStructure(p);
@SuppressWarnings("resource") protected Object deserializeUsingPropertyBasedWithUnwrapped(JsonParser p, DeserializationContext ctxt) throws IOException, JsonProcessingException { final PropertyBasedCreator creator = _propertyBasedCreator; PropertyValueBuffer buffer = creator.startBuilding(p, ctxt, _objectIdReader);  TokenBuffer tokens = new TokenBuffer(p, ctxt); tokens.writeStartObject();  JsonToken t = p.getCurrentToken(); for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) { String propName = p.getCurrentName(); p.nextToken(); /* to point to value*/ /* creator property?*/ SettableBeanProperty creatorProp = creator.findCreatorProperty(propName); if (creatorProp != null) { if (buffer.assignParameter(creatorProp, creatorProp.deserialize(p, ctxt))) { t = p.nextToken(); Object bean; try { bean = creator.build(ctxt, buffer); } catch (Exception e) { wrapAndThrow(e, _beanType.getRawClass(), propName, ctxt); continue; <BUGS> } while (t == JsonToken.FIELD_NAME) { p.nextToken(); tokens.copyCurrentStructure(p);
} /* but... others should be passed to unwrapped property deserializers*/ tokens.writeFieldName(propName); tokens.copyCurrentStructure(p); /* how about any setter? We'll get copies but...*/ if (_anySetter != null) { _anySetter.deserializeAndSet(p, ctxt, bean, propName); } } tokens.writeEndObject(); _unwrappedPropertyHandler.processUnwrapped(p, ctxt, bean, tokens); return bean; }  } <BUGS> tokens.writeEndObject(); if (bean.getClass() != _beanType.getRawClass()) { <BUGE> ctxt.reportMappingException("Can not create polymorphic instances with unwrapped values"); return null; } return _unwrappedPropertyHandler.processUnwrapped(p, ctxt, bean, tokens); } continue; } /* Object Id property?*/ if (buffer.readIdProperty(propName)) { continue; } /* regular property? needs buffering*/ SettableBeanProperty prop = _beanProperties.find(propName);
} /* but... others should be passed to unwrapped property deserializers*/ tokens.writeFieldName(propName); tokens.copyCurrentStructure(p); /* how about any setter? We'll get copies but...*/ if (_anySetter != null) { _anySetter.deserializeAndSet(p, ctxt, bean, propName); } } tokens.writeEndObject(); _unwrappedPropertyHandler.processUnwrapped(p, ctxt, bean, tokens); return bean; }  } <BUGS> return _unwrappedPropertyHandler.processUnwrapped(p, ctxt, bean, tokens); <BUGE> } continue; } /* Object Id property?*/ if (buffer.readIdProperty(propName)) { continue; } /* regular property? needs buffering*/ SettableBeanProperty prop = _beanProperties.find(propName); if (prop != null) { buffer.bufferProperty(prop, prop.deserialize(p, ctxt)); continue; } if (_ignorableProps != null && _ignorableProps.contains(propName)) {
} /* but... others should be passed to unwrapped property deserializers*/ tokens.writeFieldName(propName); tokens.copyCurrentStructure(p); /* how about any setter? We'll get copies but...*/ if (_anySetter != null) { _anySetter.deserializeAndSet(p, ctxt, bean, propName); } } tokens.writeEndObject(); _unwrappedPropertyHandler.processUnwrapped(p, ctxt, bean, tokens); return bean; }  /* Object Id property?*/ <BUGS> if (buffer.readIdProperty(propName)) { <BUGE> continue; } /* regular property? needs buffering*/ SettableBeanProperty prop = _beanProperties.find(propName); if (prop != null) { buffer.bufferProperty(prop, prop.deserialize(p, ctxt)); continue; } if (_ignorableProps != null && _ignorableProps.contains(propName)) { handleIgnoredProperty(p, ctxt, handledType(), propName); continue; } tokens.writeFieldName(propName); tokens.copyCurrentStructure(p);
} /* but... others should be passed to unwrapped property deserializers*/ tokens.writeFieldName(propName); tokens.copyCurrentStructure(p); /* how about any setter? We'll get copies but...*/ if (_anySetter != null) { _anySetter.deserializeAndSet(p, ctxt, bean, propName); } } tokens.writeEndObject(); _unwrappedPropertyHandler.processUnwrapped(p, ctxt, bean, tokens); return bean; }  /* regular property? needs buffering*/ <BUGS> SettableBeanProperty prop = _beanProperties.find(propName); if (prop != null) { <BUGE> buffer.bufferProperty(prop, prop.deserialize(p, ctxt)); continue; } if (_ignorableProps != null && _ignorableProps.contains(propName)) { handleIgnoredProperty(p, ctxt, handledType(), propName); continue; } tokens.writeFieldName(propName); tokens.copyCurrentStructure(p); /* "any property"?*/ if (_anySetter != null) { buffer.bufferAnyProperty(_anySetter, propName, _anySetter.deserialize(p, ctxt)); }
} /* but... others should be passed to unwrapped property deserializers*/ tokens.writeFieldName(propName); tokens.copyCurrentStructure(p); /* how about any setter? We'll get copies but...*/ if (_anySetter != null) { _anySetter.deserializeAndSet(p, ctxt, bean, propName); } } tokens.writeEndObject(); _unwrappedPropertyHandler.processUnwrapped(p, ctxt, bean, tokens); return bean; }  } <BUGS> if (_ignorableProps != null && _ignorableProps.contains(propName)) { <BUGE> handleIgnoredProperty(p, ctxt, handledType(), propName); continue; } tokens.writeFieldName(propName); tokens.copyCurrentStructure(p); /* "any property"?*/ if (_anySetter != null) { buffer.bufferAnyProperty(_anySetter, propName, _anySetter.deserialize(p, ctxt)); } }  /* We hit END_OBJECT, so:*/ Object bean; /* !!! 15-Feb-2012, tatu: Need to modify creator to use Builder!*/
} /* but... others should be passed to unwrapped property deserializers*/ tokens.writeFieldName(propName); tokens.copyCurrentStructure(p); /* how about any setter? We'll get copies but...*/ if (_anySetter != null) { _anySetter.deserializeAndSet(p, ctxt, bean, propName); } } tokens.writeEndObject(); _unwrappedPropertyHandler.processUnwrapped(p, ctxt, bean, tokens); return bean; }  } <BUGS> tokens.writeFieldName(propName); tokens.copyCurrentStructure(p); <BUGE> /* "any property"?*/ if (_anySetter != null) { buffer.bufferAnyProperty(_anySetter, propName, _anySetter.deserialize(p, ctxt)); } }  /* We hit END_OBJECT, so:*/ Object bean; /* !!! 15-Feb-2012, tatu: Need to modify creator to use Builder!*/ try { bean = creator.build(ctxt, buffer); } catch (Exception e) { return wrapInstantiationProblem(e, ctxt);
} /* but... others should be passed to unwrapped property deserializers*/ tokens.writeFieldName(propName); tokens.copyCurrentStructure(p); /* how about any setter? We'll get copies but...*/ if (_anySetter != null) { _anySetter.deserializeAndSet(p, ctxt, bean, propName); } } tokens.writeEndObject(); _unwrappedPropertyHandler.processUnwrapped(p, ctxt, bean, tokens); return bean; }  /* "any property"?*/ <BUGS> if (_anySetter != null) { <BUGE> buffer.bufferAnyProperty(_anySetter, propName, _anySetter.deserialize(p, ctxt)); } }  /* We hit END_OBJECT, so:*/ Object bean; /* !!! 15-Feb-2012, tatu: Need to modify creator to use Builder!*/ try { bean = creator.build(ctxt, buffer); } catch (Exception e) { return wrapInstantiationProblem(e, ctxt); } return _unwrappedPropertyHandler.processUnwrapped(p, ctxt, bean, tokens); }
*/ public ObjectMapper() { <BUGS> this(null, null, null); <BUGE> }
*/ protected void _throwAsIOE(JsonParser p, Exception e, Object value) throws IOException { <BUGS> if (e instanceof IllegalArgumentException) { String actType = (value == null) ? "[NULL]" : value.getClass().getName(); StringBuilder msg = new StringBuilder("Problem deserializing property '").append(getName()); msg.append("' (expected type: ").append(getType()); msg.append("; actual type: ").append(actType).append(")"); String origMsg = e.getMessage(); if (origMsg != null) { msg.append(", problem: ").append(origMsg); <BUGE> } else { msg.append(" (no error message provided)"); } throw JsonMappingException.from(p, msg.toString(), e); } _throwAsIOE(p, e); }
*/ protected void _throwAsIOE(JsonParser p, Exception e, Object value) throws IOException { if (e instanceof IllegalArgumentException) { String actType = (value == null) ? "[NULL]" : value.getClass().getName(); StringBuilder msg = new StringBuilder("Problem deserializing property '").append(getName()); msg.append("' (expected type: ").append(getType()); msg.append("; actual type: ").append(actType).append(")"); String origMsg = e.getMessage(); if (origMsg != null) { msg.append(", problem: ").append(origMsg); } else { msg.append(" (no error message provided)"); } <BUGS> throw JsonMappingException.from(p, msg.toString(), e); <BUGE> } _throwAsIOE(p, e); }
public void validateSubType(DeserializationContext ctxt, JavaType type) throws JsonMappingException { /* There are certain nasty classes that could cause problems, mostly*/ /* via default typing -- catch them here.*/ <BUGS> final Class<?> raw = type.getRawClass(); String full = raw.getName(); <BUGE>  main_check: do { if (_cfgIllegalClassNames.contains(full)) { break; }  /* 18-Dec-2017, tatu: As per [databind#1855], need bit more sophisticated handling*/ /*    for some Spring framework types*/ /* 05-Jan-2017, tatu: ... also, only applies to classes, not interfaces*/ if (full.startsWith(PREFIX_STRING)) { for (Class<?> cls = raw; cls != Object.class; cls = cls.getSuperclass()) { String name = cls.getSimpleName(); /* looking for "AbstractBeanFactoryPointcutAdvisor" but no point to allow any is there?*/ if ("AbstractPointcutAdvisor".equals(name) /* ditto  for "FileSystemXmlApplicationContext": block all ApplicationContexts*/ || "AbstractApplicationContext".equals(name)) { break main_check; } } } return; } while (false);
public void validateSubType(DeserializationContext ctxt, JavaType type) throws JsonMappingException { /* There are certain nasty classes that could cause problems, mostly*/ /* via default typing -- catch them here.*/ final Class<?> raw = type.getRawClass(); String full = raw.getName();  main_check: do { <BUGS> if (_cfgIllegalClassNames.contains(full)) { <BUGE> break; }  /* 18-Dec-2017, tatu: As per [databind#1855], need bit more sophisticated handling*/ /*    for some Spring framework types*/ /* 05-Jan-2017, tatu: ... also, only applies to classes, not interfaces*/ if (full.startsWith(PREFIX_STRING)) { for (Class<?> cls = raw; cls != Object.class; cls = cls.getSuperclass()) { String name = cls.getSimpleName(); /* looking for "AbstractBeanFactoryPointcutAdvisor" but no point to allow any is there?*/ if ("AbstractPointcutAdvisor".equals(name) /* ditto  for "FileSystemXmlApplicationContext": block all ApplicationContexts*/ || "AbstractApplicationContext".equals(name)) { break main_check; } } } return; } while (false);
public void validateSubType(DeserializationContext ctxt, JavaType type) throws JsonMappingException { /* There are certain nasty classes that could cause problems, mostly*/ /* via default typing -- catch them here.*/ final Class<?> raw = type.getRawClass(); String full = raw.getName();  main_check: do { if (_cfgIllegalClassNames.contains(full)) { break; }  /* 18-Dec-2017, tatu: As per [databind#1855], need bit more sophisticated handling*/ /*    for some Spring framework types*/ /* 05-Jan-2017, tatu: ... also, only applies to classes, not interfaces*/ <BUGS> if (full.startsWith(PREFIX_STRING)) { for (Class<?> cls = raw; cls != Object.class; cls = cls.getSuperclass()) { String name = cls.getSimpleName(); <BUGE> /* looking for "AbstractBeanFactoryPointcutAdvisor" but no point to allow any is there?*/ if ("AbstractPointcutAdvisor".equals(name) /* ditto  for "FileSystemXmlApplicationContext": block all ApplicationContexts*/ || "AbstractApplicationContext".equals(name)) { break main_check; } } } return; } while (false);
public void validateSubType(DeserializationContext ctxt, JavaType type) throws JsonMappingException { /* There are certain nasty classes that could cause problems, mostly*/ /* via default typing -- catch them here.*/ final Class<?> raw = type.getRawClass(); String full = raw.getName();  main_check: do { if (_cfgIllegalClassNames.contains(full)) { break; }  /* 18-Dec-2017, tatu: As per [databind#1855], need bit more sophisticated handling*/ /*    for some Spring framework types*/ /* 05-Jan-2017, tatu: ... also, only applies to classes, not interfaces*/ if (full.startsWith(PREFIX_STRING)) { for (Class<?> cls = raw; cls != Object.class; cls = cls.getSuperclass()) { String name = cls.getSimpleName(); /* looking for "AbstractBeanFactoryPointcutAdvisor" but no point to allow any is there?*/ <BUGS> if ("AbstractPointcutAdvisor".equals(name) <BUGE> /* ditto  for "FileSystemXmlApplicationContext": block all ApplicationContexts*/ || "AbstractApplicationContext".equals(name)) { break main_check; } } } return; } while (false);
public void validateSubType(DeserializationContext ctxt, JavaType type) throws JsonMappingException { /* There are certain nasty classes that could cause problems, mostly*/ /* via default typing -- catch them here.*/ final Class<?> raw = type.getRawClass(); String full = raw.getName();  main_check: do { if (_cfgIllegalClassNames.contains(full)) { break; }  /* 18-Dec-2017, tatu: As per [databind#1855], need bit more sophisticated handling*/ /*    for some Spring framework types*/ /* 05-Jan-2017, tatu: ... also, only applies to classes, not interfaces*/ if (full.startsWith(PREFIX_STRING)) { for (Class<?> cls = raw; cls != Object.class; cls = cls.getSuperclass()) { String name = cls.getSimpleName(); /* looking for "AbstractBeanFactoryPointcutAdvisor" but no point to allow any is there?*/ if ("AbstractPointcutAdvisor".equals(name) /* ditto  for "FileSystemXmlApplicationContext": block all ApplicationContexts*/ <BUGS> || "AbstractApplicationContext".equals(name)) { <BUGE> break main_check; } } } return; } while (false);
public void validateSubType(DeserializationContext ctxt, JavaType type) throws JsonMappingException { /* There are certain nasty classes that could cause problems, mostly*/ /* via default typing -- catch them here.*/ final Class<?> raw = type.getRawClass(); String full = raw.getName();  main_check: do { if (_cfgIllegalClassNames.contains(full)) { break; }  /* 18-Dec-2017, tatu: As per [databind#1855], need bit more sophisticated handling*/ /*    for some Spring framework types*/ /* 05-Jan-2017, tatu: ... also, only applies to classes, not interfaces*/ if (full.startsWith(PREFIX_STRING)) { for (Class<?> cls = raw; cls != Object.class; cls = cls.getSuperclass()) { String name = cls.getSimpleName(); /* looking for "AbstractBeanFactoryPointcutAdvisor" but no point to allow any is there?*/ if ("AbstractPointcutAdvisor".equals(name) /* ditto  for "FileSystemXmlApplicationContext": block all ApplicationContexts*/ || "AbstractApplicationContext".equals(name)) { break main_check; } } } <BUGS> return; <BUGE> } while (false);
*/ protected Object _createFromStringFallbacks(DeserializationContext ctxt, String value) throws IOException, JsonProcessingException { /* 28-Sep-2011, tatu: Ok this is not clean at all; but since there are legacy *   systems that expect conversions in some cases, let's just add a minimal *   patch (note: same could conceivably be used for numbers too). */ <BUGS> if (canCreateFromBoolean()) { <BUGE> String str = value.trim(); if ("true".equals(str)) { return createFromBoolean(ctxt, true); } if ("false".equals(str)) { return createFromBoolean(ctxt, false); } } /* also, empty Strings might be accepted as null Object...*/ if (value.length() == 0) { if (ctxt.isEnabled(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT)) { return null; } } throw ctxt.mappingException("Can not instantiate value of type %s from String value ('%s'); no single-String constructor/factory method", getValueTypeDesc(), value); }
*/ protected Object _createFromStringFallbacks(DeserializationContext ctxt, String value) throws IOException, JsonProcessingException { /* 28-Sep-2011, tatu: Ok this is not clean at all; but since there are legacy *   systems that expect conversions in some cases, let's just add a minimal *   patch (note: same could conceivably be used for numbers too). */ if (canCreateFromBoolean()) { String str = value.trim(); if ("true".equals(str)) { return createFromBoolean(ctxt, true); } if ("false".equals(str)) { return createFromBoolean(ctxt, false); } } /* also, empty Strings might be accepted as null Object...*/ <BUGS> if (value.length() == 0) { <BUGE> if (ctxt.isEnabled(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT)) { return null; } } throw ctxt.mappingException("Can not instantiate value of type %s from String value ('%s'); no single-String constructor/factory method", getValueTypeDesc(), value); }
*/ protected Object _createFromStringFallbacks(DeserializationContext ctxt, String value) throws IOException, JsonProcessingException { /* 28-Sep-2011, tatu: Ok this is not clean at all; but since there are legacy *   systems that expect conversions in some cases, let's just add a minimal *   patch (note: same could conceivably be used for numbers too). */ if (canCreateFromBoolean()) { String str = value.trim(); if ("true".equals(str)) { return createFromBoolean(ctxt, true); } if ("false".equals(str)) { return createFromBoolean(ctxt, false); } } /* also, empty Strings might be accepted as null Object...*/ if (value.length() == 0) { if (ctxt.isEnabled(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT)) { return null; } } <BUGS> throw ctxt.mappingException("Can not instantiate value of type %s from String value ('%s'); no single-String constructor/factory method", getValueTypeDesc(), value); <BUGE> }
@Override protected String buildCanonicalName() { <BUGS> StringBuilder sb = new StringBuilder(); sb.append(_class.getName()); if (_keyType != null) { sb.append('<'); sb.append(_keyType.toCanonical()); sb.append(','); sb.append(_valueType.toCanonical()); sb.append('>'); <BUGE> } return sb.toString(); }
@Override protected String buildCanonicalName() { StringBuilder sb = new StringBuilder(); sb.append(_class.getName()); if (_keyType != null) { sb.append('<'); sb.append(_keyType.toCanonical()); sb.append(','); sb.append(_valueType.toCanonical()); sb.append('>'); } <BUGS> return sb.toString(); <BUGE> }
*/ public ObjectWriter writerWithDefaultPrettyPrinter() { <BUGS> SerializationConfig config = getSerializationConfig(); return _newWriter(config, /*root type*/ null, config.getDefaultPrettyPrinter()); <BUGE> }
@Override protected String buildCanonicalName() { <BUGS> StringBuilder sb = new StringBuilder(); sb.append(_class.getName()); if (_keyType != null) { sb.append('<'); sb.append(_keyType.toCanonical()); sb.append(','); sb.append(_valueType.toCanonical()); sb.append('>'); <BUGE> } return sb.toString(); }
@Override protected String buildCanonicalName() { StringBuilder sb = new StringBuilder(); sb.append(_class.getName()); if (_keyType != null) { sb.append('<'); sb.append(_keyType.toCanonical()); sb.append(','); sb.append(_valueType.toCanonical()); sb.append('>'); } <BUGS> return sb.toString(); <BUGE> }
@SuppressWarnings("resource") public Object handleMissingInstantiator(Class<?> instClass, ValueInstantiator valueInst, JsonParser p, String msg, Object... msgArgs) throws IOException { <BUGS> if (p == null) { p = getParser(); <BUGE> } msg = _format(msg, msgArgs); LinkedNode<DeserializationProblemHandler> h = _config.getProblemHandlers(); while (h != null) { /* Can bail out if it's handled*/ Object instance = h.value().handleMissingInstantiator(this, instClass, valueInst, p, msg); if (instance != DeserializationProblemHandler.NOT_HANDLED) { /* Sanity check for broken handlers, otherwise nasty to debug:*/ if (_isCompatible(instClass, instance)) { return instance; } reportBadDefinition(constructType(instClass), String.format( "DeserializationProblemHandler.handleMissingInstantiator() for type %s returned value of type %s", instClass, ClassUtil.classNameOf(instance))); } h = h.next(); }  /* 16-Oct-2016, tatu: This is either a definition problem (if no applicable creator*/ /*   exists), or input mismatch problem (otherwise) since none of existing creators*/ /*   match with token.*/ if ((valueInst != null) && !valueInst.canInstantiate()) {
@SuppressWarnings("resource") public Object handleMissingInstantiator(Class<?> instClass, ValueInstantiator valueInst, JsonParser p, String msg, Object... msgArgs) throws IOException { if (p == null) { p = getParser(); } <BUGS> msg = _format(msg, msgArgs); LinkedNode<DeserializationProblemHandler> h = _config.getProblemHandlers(); while (h != null) { <BUGE> /* Can bail out if it's handled*/ Object instance = h.value().handleMissingInstantiator(this, instClass, valueInst, p, msg); if (instance != DeserializationProblemHandler.NOT_HANDLED) { /* Sanity check for broken handlers, otherwise nasty to debug:*/ if (_isCompatible(instClass, instance)) { return instance; } reportBadDefinition(constructType(instClass), String.format( "DeserializationProblemHandler.handleMissingInstantiator() for type %s returned value of type %s", instClass, ClassUtil.classNameOf(instance))); } h = h.next(); }  /* 16-Oct-2016, tatu: This is either a definition problem (if no applicable creator*/ /*   exists), or input mismatch problem (otherwise) since none of existing creators*/ /*   match with token.*/ if ((valueInst != null) && !valueInst.canInstantiate()) {
@SuppressWarnings("resource") public Object handleMissingInstantiator(Class<?> instClass, ValueInstantiator valueInst, JsonParser p, String msg, Object... msgArgs) throws IOException { if (p == null) { p = getParser(); } msg = _format(msg, msgArgs); LinkedNode<DeserializationProblemHandler> h = _config.getProblemHandlers(); while (h != null) { /* Can bail out if it's handled*/ Object instance = h.value().handleMissingInstantiator(this, instClass, valueInst, p, msg); if (instance != DeserializationProblemHandler.NOT_HANDLED) { /* Sanity check for broken handlers, otherwise nasty to debug:*/ if (_isCompatible(instClass, instance)) { return instance; } reportBadDefinition(constructType(instClass), String.format( "DeserializationProblemHandler.handleMissingInstantiator() for type %s returned value of type %s", instClass, ClassUtil.classNameOf(instance))); } h = h.next(); }  /* 16-Oct-2016, tatu: This is either a definition problem (if no applicable creator*/ /*   exists), or input mismatch problem (otherwise) since none of existing creators*/ /*   match with token.*/ <BUGS> if ((valueInst != null) && !valueInst.canInstantiate()) { <BUGE>
* has not been decoded, so that handler has a chance to handle decoding * using alternate mechanism, and handle underlying content (possibly by * just skipping it) to keep input state valid * * @param instClass Type that was to be instantiated * @param valueInst (optional) Value instantiator to be used, if any; null if type does not *    use one for instantiation (custom deserialiers don't; standard POJO deserializer does) * @param p Parser that points to the JSON value to decode * * @return Object that should be constructed, if any; has to be of type <code>instClass</code> * * @since 2.9 (2.8 had alternate that did not take <code>ValueInstantiator</code>) */ } <BUGS> msg = String.format("Cannot construct instance of %s (although at least one Creator exists): %s", ClassUtil.nameOf(instClass), msg); return reportInputMismatch(instClass, msg); <BUGE> }  /** * Method that deserializers should call if they fail to instantiate value * due to an exception that was thrown by constructor (or other mechanism used * to create instances). * Default implementation will try to call {@link DeserializationProblemHandler#handleInstantiationProblem} * on configured handlers, if any, to allow for recovery; if recovery does not * succeed, will throw exception constructed with {@link #instantiationException}. * * @param instClass Type that was to be instantiated * @param argument (optional) Argument that was passed to constructor or equivalent *    instantiator; often a {@link java.lang.String}.
*/ public JavaType handleUnknownTypeId(JavaType baseType, String id, TypeIdResolver idResolver, String extraDesc) throws IOException { <BUGS> LinkedNode<DeserializationProblemHandler> h = _config.getProblemHandlers(); while (h != null) { <BUGE> /* Can bail out if it's handled*/ JavaType type = h.value().handleUnknownTypeId(this, baseType, id, idResolver, extraDesc); if (type != null) { if (type.hasRawClass(Void.class)) { return null; } /* But ensure there's type compatibility*/ if (type.isTypeOrSubTypeOf(baseType.getRawClass())) { return type; } throw invalidTypeIdException(baseType, id, "problem handler tried to resolve into non-subtype: "+type); } h = h.next(); } /* 24-May-2016, tatu: Actually we may still not want to fail quite yet*/ if (!isEnabled(DeserializationFeature.FAIL_ON_INVALID_SUBTYPE)) { return null; } throw invalidTypeIdException(baseType, id, extraDesc); }
*/ public JavaType handleUnknownTypeId(JavaType baseType, String id, TypeIdResolver idResolver, String extraDesc) throws IOException { LinkedNode<DeserializationProblemHandler> h = _config.getProblemHandlers(); while (h != null) { /* Can bail out if it's handled*/ <BUGS> JavaType type = h.value().handleUnknownTypeId(this, baseType, id, idResolver, extraDesc); if (type != null) { if (type.hasRawClass(Void.class)) { return null; <BUGE> } /* But ensure there's type compatibility*/ if (type.isTypeOrSubTypeOf(baseType.getRawClass())) { return type; } throw invalidTypeIdException(baseType, id, "problem handler tried to resolve into non-subtype: "+type); } h = h.next(); } /* 24-May-2016, tatu: Actually we may still not want to fail quite yet*/ if (!isEnabled(DeserializationFeature.FAIL_ON_INVALID_SUBTYPE)) { return null; } throw invalidTypeIdException(baseType, id, extraDesc); }
@SuppressWarnings("resource") public Object handleMissingInstantiator(Class<?> instClass, ValueInstantiator valueInst, JsonParser p, String msg, Object... msgArgs) throws IOException { <BUGS> if (p == null) { p = getParser(); <BUGE> } msg = _format(msg, msgArgs); LinkedNode<DeserializationProblemHandler> h = _config.getProblemHandlers(); while (h != null) { /* Can bail out if it's handled*/ Object instance = h.value().handleMissingInstantiator(this, instClass, valueInst, p, msg); if (instance != DeserializationProblemHandler.NOT_HANDLED) { /* Sanity check for broken handlers, otherwise nasty to debug:*/ if (_isCompatible(instClass, instance)) { return instance; } reportBadDefinition(constructType(instClass), String.format( "DeserializationProblemHandler.handleMissingInstantiator() for type %s returned value of type %s", instClass, ClassUtil.classNameOf(instance))); } h = h.next(); }  /* 16-Oct-2016, tatu: This is either a definition problem (if no applicable creator*/ /*   exists), or input mismatch problem (otherwise) since none of existing creators*/ /*   match with token.*/ if ((valueInst != null) && !valueInst.canInstantiate()) {
@SuppressWarnings("resource") public Object handleMissingInstantiator(Class<?> instClass, ValueInstantiator valueInst, JsonParser p, String msg, Object... msgArgs) throws IOException { if (p == null) { p = getParser(); } <BUGS> msg = _format(msg, msgArgs); LinkedNode<DeserializationProblemHandler> h = _config.getProblemHandlers(); while (h != null) { <BUGE> /* Can bail out if it's handled*/ Object instance = h.value().handleMissingInstantiator(this, instClass, valueInst, p, msg); if (instance != DeserializationProblemHandler.NOT_HANDLED) { /* Sanity check for broken handlers, otherwise nasty to debug:*/ if (_isCompatible(instClass, instance)) { return instance; } reportBadDefinition(constructType(instClass), String.format( "DeserializationProblemHandler.handleMissingInstantiator() for type %s returned value of type %s", instClass, ClassUtil.classNameOf(instance))); } h = h.next(); }  /* 16-Oct-2016, tatu: This is either a definition problem (if no applicable creator*/ /*   exists), or input mismatch problem (otherwise) since none of existing creators*/ /*   match with token.*/ if ((valueInst != null) && !valueInst.canInstantiate()) {
* has not been decoded, so that handler has a chance to handle decoding * using alternate mechanism, and handle underlying content (possibly by * just skipping it) to keep input state valid * * @param instClass Type that was to be instantiated * @param valueInst (optional) Value instantiator to be used, if any; null if type does not *    use one for instantiation (custom deserialiers don't; standard POJO deserializer does) * @param p Parser that points to the JSON value to decode * * @return Object that should be constructed, if any; has to be of type <code>instClass</code> * * @since 2.9 (2.8 had alternate that did not take <code>ValueInstantiator</code>) */ /*   match with token.*/ <BUGS> if ((valueInst != null) && !valueInst.canInstantiate()) { msg = String.format("Cannot construct instance of %s (no Creators, like default construct, exist): %s", ClassUtil.nameOf(instClass), msg); return reportBadDefinition(constructType(instClass), msg); <BUGE> } msg = String.format("Cannot construct instance of %s (although at least one Creator exists): %s", ClassUtil.nameOf(instClass), msg); return reportInputMismatch(instClass, msg); }  /** * Method that deserializers should call if they fail to instantiate value * due to an exception that was thrown by constructor (or other mechanism used * to create instances). * Default implementation will try to call {@link DeserializationProblemHandler#handleInstantiationProblem} * on configured handlers, if any, to allow for recovery; if recovery does not
@Override public String idFromValueAndType(Object value, Class<?> type) { /* 18-Jan-2013, tatu: We may be called with null value occasionally *   it seems; nothing much we can figure out that way. */ <BUGS> if (value == null) { return idFromClass(type); <BUGE> } return idFromValue(value); }
@Override <BUGS> public BigDecimal decimalValue() { return _value; } <BUGE>
@Override public Boolean hasAnySetter(Annotated a) { <BUGS> Boolean b = _primary.hasAnySetter(a); if (b == null) { <BUGE> b = _secondary.hasAnySetter(a); } return b; }
@Override public Boolean hasAnySetter(Annotated a) { Boolean b = _primary.hasAnySetter(a); if (b == null) { b = _secondary.hasAnySetter(a); } <BUGS> return b; <BUGE> }
*/ public static JsonSerializer<Object> getStdKeySerializer(SerializationConfig config, Class<?> rawKeyType, boolean useDefault) { /* 24-Sep-2015, tatu: Important -- should ONLY consider types for which `@JsonValue`*/ /*    can not be used, since caller has not yet checked for that annotation*/ /*    This is why Enum types are not handled here quite yet*/  /* [databind#943: Use a dynamic key serializer if we are not given actual*/ /* type declaration*/ <BUGS> if ((rawKeyType == null) || (rawKeyType == Object.class)) { return new Dynamic(); <BUGE> } if (rawKeyType == String.class) { return DEFAULT_STRING_SERIALIZER; } if (rawKeyType.isPrimitive() || Number.class.isAssignableFrom(rawKeyType)) { /* 28-Jun-2016, tatu: Used to just return DEFAULT_KEY_SERIALIZER, but makes*/ /*   more sense to use simpler one directly*/ return new Default(Default.TYPE_TO_STRING, rawKeyType); } if (rawKeyType == Class.class) { return new Default(Default.TYPE_CLASS, rawKeyType); } if (Date.class.isAssignableFrom(rawKeyType)) { return new Default(Default.TYPE_DATE, rawKeyType); } if (Calendar.class.isAssignableFrom(rawKeyType)) { return new Default(Default.TYPE_CALENDAR, rawKeyType); }
public void validateSubType(DeserializationContext ctxt, JavaType type) throws JsonMappingException { /* There are certain nasty classes that could cause problems, mostly*/ /* via default typing -- catch them here.*/ <BUGS> final Class<?> raw = type.getRawClass(); String full = raw.getName(); <BUGE>  main_check: do { if (_cfgIllegalClassNames.contains(full)) { break; }  /* 18-Dec-2017, tatu: As per [databind#1855], need bit more sophisticated handling*/ /*    for some Spring framework types*/ /* 05-Jan-2017, tatu: ... also, only applies to classes, not interfaces*/ if (full.startsWith(PREFIX_STRING)) { for (Class<?> cls = raw; cls != Object.class; cls = cls.getSuperclass()) { String name = cls.getSimpleName(); /* looking for "AbstractBeanFactoryPointcutAdvisor" but no point to allow any is there?*/ if ("AbstractPointcutAdvisor".equals(name) /* ditto  for "FileSystemXmlApplicationContext": block all ApplicationContexts*/ || "AbstractApplicationContext".equals(name)) { break main_check; } } } return; } while (false);
public void validateSubType(DeserializationContext ctxt, JavaType type) throws JsonMappingException { /* There are certain nasty classes that could cause problems, mostly*/ /* via default typing -- catch them here.*/ final Class<?> raw = type.getRawClass(); String full = raw.getName();  main_check: do { <BUGS> if (_cfgIllegalClassNames.contains(full)) { <BUGE> break; }  /* 18-Dec-2017, tatu: As per [databind#1855], need bit more sophisticated handling*/ /*    for some Spring framework types*/ /* 05-Jan-2017, tatu: ... also, only applies to classes, not interfaces*/ if (full.startsWith(PREFIX_STRING)) { for (Class<?> cls = raw; cls != Object.class; cls = cls.getSuperclass()) { String name = cls.getSimpleName(); /* looking for "AbstractBeanFactoryPointcutAdvisor" but no point to allow any is there?*/ if ("AbstractPointcutAdvisor".equals(name) /* ditto  for "FileSystemXmlApplicationContext": block all ApplicationContexts*/ || "AbstractApplicationContext".equals(name)) { break main_check; } } } return; } while (false);
public void validateSubType(DeserializationContext ctxt, JavaType type) throws JsonMappingException { /* There are certain nasty classes that could cause problems, mostly*/ /* via default typing -- catch them here.*/ final Class<?> raw = type.getRawClass(); String full = raw.getName();  main_check: do { if (_cfgIllegalClassNames.contains(full)) { break; }  /* 18-Dec-2017, tatu: As per [databind#1855], need bit more sophisticated handling*/ /*    for some Spring framework types*/ /* 05-Jan-2017, tatu: ... also, only applies to classes, not interfaces*/ <BUGS> if (full.startsWith(PREFIX_STRING)) { for (Class<?> cls = raw; cls != Object.class; cls = cls.getSuperclass()) { String name = cls.getSimpleName(); <BUGE> /* looking for "AbstractBeanFactoryPointcutAdvisor" but no point to allow any is there?*/ if ("AbstractPointcutAdvisor".equals(name) /* ditto  for "FileSystemXmlApplicationContext": block all ApplicationContexts*/ || "AbstractApplicationContext".equals(name)) { break main_check; } } } return; } while (false);
public void validateSubType(DeserializationContext ctxt, JavaType type) throws JsonMappingException { /* There are certain nasty classes that could cause problems, mostly*/ /* via default typing -- catch them here.*/ final Class<?> raw = type.getRawClass(); String full = raw.getName();  main_check: do { if (_cfgIllegalClassNames.contains(full)) { break; }  /* 18-Dec-2017, tatu: As per [databind#1855], need bit more sophisticated handling*/ /*    for some Spring framework types*/ /* 05-Jan-2017, tatu: ... also, only applies to classes, not interfaces*/ if (full.startsWith(PREFIX_STRING)) { for (Class<?> cls = raw; cls != Object.class; cls = cls.getSuperclass()) { String name = cls.getSimpleName(); /* looking for "AbstractBeanFactoryPointcutAdvisor" but no point to allow any is there?*/ <BUGS> if ("AbstractPointcutAdvisor".equals(name) <BUGE> /* ditto  for "FileSystemXmlApplicationContext": block all ApplicationContexts*/ || "AbstractApplicationContext".equals(name)) { break main_check; } } } return; } while (false);
public void validateSubType(DeserializationContext ctxt, JavaType type) throws JsonMappingException { /* There are certain nasty classes that could cause problems, mostly*/ /* via default typing -- catch them here.*/ final Class<?> raw = type.getRawClass(); String full = raw.getName();  main_check: do { if (_cfgIllegalClassNames.contains(full)) { break; }  /* 18-Dec-2017, tatu: As per [databind#1855], need bit more sophisticated handling*/ /*    for some Spring framework types*/ /* 05-Jan-2017, tatu: ... also, only applies to classes, not interfaces*/ if (full.startsWith(PREFIX_STRING)) { for (Class<?> cls = raw; cls != Object.class; cls = cls.getSuperclass()) { String name = cls.getSimpleName(); /* looking for "AbstractBeanFactoryPointcutAdvisor" but no point to allow any is there?*/ if ("AbstractPointcutAdvisor".equals(name) /* ditto  for "FileSystemXmlApplicationContext": block all ApplicationContexts*/ <BUGS> || "AbstractApplicationContext".equals(name)) { <BUGE> break main_check; } } } return; } while (false);
public void validateSubType(DeserializationContext ctxt, JavaType type) throws JsonMappingException { /* There are certain nasty classes that could cause problems, mostly*/ /* via default typing -- catch them here.*/ final Class<?> raw = type.getRawClass(); String full = raw.getName();  main_check: do { if (_cfgIllegalClassNames.contains(full)) { break; }  /* 18-Dec-2017, tatu: As per [databind#1855], need bit more sophisticated handling*/ /*    for some Spring framework types*/ /* 05-Jan-2017, tatu: ... also, only applies to classes, not interfaces*/ if (full.startsWith(PREFIX_STRING)) { for (Class<?> cls = raw; cls != Object.class; cls = cls.getSuperclass()) { String name = cls.getSimpleName(); /* looking for "AbstractBeanFactoryPointcutAdvisor" but no point to allow any is there?*/ if ("AbstractPointcutAdvisor".equals(name) /* ditto  for "FileSystemXmlApplicationContext": block all ApplicationContexts*/ || "AbstractApplicationContext".equals(name)) { break main_check; } } } <BUGS> return; <BUGE> } while (false);
@Override public JsonToken nextToken() throws IOException { <BUGS> _binaryValue = null; if (_nextToken != null) { JsonToken t = _nextToken; _currToken = t; _nextToken = null; switch (t) { <BUGE> case START_OBJECT: _parsingContext = _parsingContext.createChildObjectContext(-1, -1); break; case START_ARRAY: _parsingContext = _parsingContext.createChildArrayContext(-1, -1); break; case END_OBJECT: case END_ARRAY: _parsingContext = _parsingContext.getParent(); _namesToWrap = _parsingContext.getNamesToWrap(); break; case FIELD_NAME: _parsingContext.setCurrentName(_xmlTokens.getLocalName()); break; default: /* VALUE_STRING, VALUE_NULL*/ /* should be fine as is?*/ } return t; } int token = _xmlTokens.next();
@Override public JsonToken nextToken() throws IOException { _binaryValue = null; if (_nextToken != null) { JsonToken t = _nextToken; _currToken = t; _nextToken = null; switch (t) { case START_OBJECT: <BUGS> _parsingContext = _parsingContext.createChildObjectContext(-1, -1); break; <BUGE> case START_ARRAY: _parsingContext = _parsingContext.createChildArrayContext(-1, -1); break; case END_OBJECT: case END_ARRAY: _parsingContext = _parsingContext.getParent(); _namesToWrap = _parsingContext.getNamesToWrap(); break; case FIELD_NAME: _parsingContext.setCurrentName(_xmlTokens.getLocalName()); break; default: /* VALUE_STRING, VALUE_NULL*/ /* should be fine as is?*/ } return t; } int token = _xmlTokens.next();
@Override public JsonToken nextToken() throws IOException { _binaryValue = null; if (_nextToken != null) { JsonToken t = _nextToken; _currToken = t; _nextToken = null; switch (t) { case START_OBJECT: _parsingContext = _parsingContext.createChildObjectContext(-1, -1); break; case START_ARRAY: _parsingContext = _parsingContext.createChildArrayContext(-1, -1); break; case END_OBJECT: case END_ARRAY: _parsingContext = _parsingContext.getParent(); _namesToWrap = _parsingContext.getNamesToWrap(); break; case FIELD_NAME: <BUGS> _parsingContext.setCurrentName(_xmlTokens.getLocalName()); break; <BUGE> default: /* VALUE_STRING, VALUE_NULL*/ /* should be fine as is?*/ } return t; } int token = _xmlTokens.next();
@Override public JsonToken nextToken() throws IOException { _binaryValue = null; if (_nextToken != null) { JsonToken t = _nextToken; _currToken = t; _nextToken = null; switch (t) { case START_OBJECT: _parsingContext = _parsingContext.createChildObjectContext(-1, -1); break; case START_ARRAY: _parsingContext = _parsingContext.createChildArrayContext(-1, -1); break; case END_OBJECT: case END_ARRAY: _parsingContext = _parsingContext.getParent(); _namesToWrap = _parsingContext.getNamesToWrap(); break; case FIELD_NAME: _parsingContext.setCurrentName(_xmlTokens.getLocalName()); break; default: /* VALUE_STRING, VALUE_NULL*/ /* should be fine as is?*/ } <BUGS> return t; <BUGE> } int token = _xmlTokens.next();
@Override public JsonToken nextToken() throws IOException { _binaryValue = null; if (_nextToken != null) { JsonToken t = _nextToken; _currToken = t; _nextToken = null; switch (t) { case START_OBJECT: _parsingContext = _parsingContext.createChildObjectContext(-1, -1); break; case START_ARRAY: _parsingContext = _parsingContext.createChildArrayContext(-1, -1); break; case END_OBJECT: case END_ARRAY: _parsingContext = _parsingContext.getParent(); _namesToWrap = _parsingContext.getNamesToWrap(); break; case FIELD_NAME: _parsingContext.setCurrentName(_xmlTokens.getLocalName()); break; default: /* VALUE_STRING, VALUE_NULL*/ /* should be fine as is?*/ } return t; } <BUGS> int token = _xmlTokens.next(); <BUGE>
case FIELD_NAME: System.out.println("JsonToken: FIELD_NAME '"+_parsingContext.getCurrentName()+"'"); break; case VALUE_STRING: System.out.println("JsonToken: VALUE_STRING '"+getText()+"'"); break; default: System.out.println("JsonToken: "+t); } } return t; } */  /* a start-element that indicates an array element.*/ <BUGS> while (token == XmlTokenStream.XML_START_ELEMENT) { <BUGE> /* If we thought we might get leaf, no such luck*/ if (_mayBeLeaf) { /* leave _mayBeLeaf set, as we start a new context*/ _nextToken = JsonToken.FIELD_NAME; _parsingContext = _parsingContext.createChildObjectContext(-1, -1); return (_currToken = JsonToken.START_OBJECT); } if (_parsingContext.inArray()) { /* Yup: in array, so this element could be verified; but it won't be*/ /* reported anyway, and we need to process following event.*/ token = _xmlTokens.next(); _mayBeLeaf = true; continue; }
case FIELD_NAME: System.out.println("JsonToken: FIELD_NAME '"+_parsingContext.getCurrentName()+"'"); break; case VALUE_STRING: System.out.println("JsonToken: VALUE_STRING '"+getText()+"'"); break; default: System.out.println("JsonToken: "+t); } } return t; } */  /* If we thought we might get leaf, no such luck*/ <BUGS> if (_mayBeLeaf) { <BUGE> /* leave _mayBeLeaf set, as we start a new context*/ _nextToken = JsonToken.FIELD_NAME; _parsingContext = _parsingContext.createChildObjectContext(-1, -1); return (_currToken = JsonToken.START_OBJECT); } if (_parsingContext.inArray()) { /* Yup: in array, so this element could be verified; but it won't be*/ /* reported anyway, and we need to process following event.*/ token = _xmlTokens.next(); _mayBeLeaf = true; continue; } String name = _xmlTokens.getLocalName(); _parsingContext.setCurrentName(name);
System.out.println("JsonToken: FIELD_NAME '"+_parsingContext.getCurrentName()+"'"); break; case VALUE_STRING: System.out.println("JsonToken: VALUE_STRING '"+getText()+"'"); break; default: System.out.println("JsonToken: "+t); } } return t; } */  /* leave _mayBeLeaf set, as we start a new context*/ <BUGS> _nextToken = JsonToken.FIELD_NAME; _parsingContext = _parsingContext.createChildObjectContext(-1, -1); return (_currToken = JsonToken.START_OBJECT); <BUGE> } if (_parsingContext.inArray()) { /* Yup: in array, so this element could be verified; but it won't be*/ /* reported anyway, and we need to process following event.*/ token = _xmlTokens.next(); _mayBeLeaf = true; continue; } String name = _xmlTokens.getLocalName(); _parsingContext.setCurrentName(name);  /* Ok: virtual wrapping can be done by simply repeating current START_ELEMENT.*/ /* Couple of ways to do it; but start by making _xmlTokens replay the thing...*/
case FIELD_NAME: System.out.println("JsonToken: FIELD_NAME '"+_parsingContext.getCurrentName()+"'"); break; case VALUE_STRING: System.out.println("JsonToken: VALUE_STRING '"+getText()+"'"); break; default: System.out.println("JsonToken: "+t); } } return t; } */  } <BUGS> if (_parsingContext.inArray()) { <BUGE> /* Yup: in array, so this element could be verified; but it won't be*/ /* reported anyway, and we need to process following event.*/ token = _xmlTokens.next(); _mayBeLeaf = true; continue; } String name = _xmlTokens.getLocalName(); _parsingContext.setCurrentName(name);  /* Ok: virtual wrapping can be done by simply repeating current START_ELEMENT.*/ /* Couple of ways to do it; but start by making _xmlTokens replay the thing...*/ if (_namesToWrap != null && _namesToWrap.contains(name)) { _xmlTokens.repeatStartElement(); }
System.out.println("JsonToken: FIELD_NAME '"+_parsingContext.getCurrentName()+"'"); break; case VALUE_STRING: System.out.println("JsonToken: VALUE_STRING '"+getText()+"'"); break; default: System.out.println("JsonToken: "+t); } } return t; } */  /* reported anyway, and we need to process following event.*/ <BUGS> token = _xmlTokens.next(); _mayBeLeaf = true; continue; <BUGE> } String name = _xmlTokens.getLocalName(); _parsingContext.setCurrentName(name);  /* Ok: virtual wrapping can be done by simply repeating current START_ELEMENT.*/ /* Couple of ways to do it; but start by making _xmlTokens replay the thing...*/ if (_namesToWrap != null && _namesToWrap.contains(name)) { _xmlTokens.repeatStartElement(); }  _mayBeLeaf = true; /* Ok: in array context we need to skip reporting field names.*/ /* But what's the best way to find next token?*/
case FIELD_NAME: System.out.println("JsonToken: FIELD_NAME '"+_parsingContext.getCurrentName()+"'"); break; case VALUE_STRING: System.out.println("JsonToken: VALUE_STRING '"+getText()+"'"); break; default: System.out.println("JsonToken: "+t); } } return t; } */  } <BUGS> String name = _xmlTokens.getLocalName(); _parsingContext.setCurrentName(name); <BUGE>  /* Ok: virtual wrapping can be done by simply repeating current START_ELEMENT.*/ /* Couple of ways to do it; but start by making _xmlTokens replay the thing...*/ if (_namesToWrap != null && _namesToWrap.contains(name)) { _xmlTokens.repeatStartElement(); }  _mayBeLeaf = true; /* Ok: in array context we need to skip reporting field names.*/ /* But what's the best way to find next token?*/ return (_currToken = JsonToken.FIELD_NAME); }
case FIELD_NAME: System.out.println("JsonToken: FIELD_NAME '"+_parsingContext.getCurrentName()+"'"); break; case VALUE_STRING: System.out.println("JsonToken: VALUE_STRING '"+getText()+"'"); break; default: System.out.println("JsonToken: "+t); } } return t; } */  /* Couple of ways to do it; but start by making _xmlTokens replay the thing...*/ <BUGS> if (_namesToWrap != null && _namesToWrap.contains(name)) { _xmlTokens.repeatStartElement(); <BUGE> }  _mayBeLeaf = true; /* Ok: in array context we need to skip reporting field names.*/ /* But what's the best way to find next token?*/ return (_currToken = JsonToken.FIELD_NAME); }  /* Ok; beyond start element, what do we get?*/ switch (token) { case XmlTokenStream.XML_END_ELEMENT: /* Simple, except that if this is a leaf, need to suppress end:*/ if (_mayBeLeaf) {
case FIELD_NAME: System.out.println("JsonToken: FIELD_NAME '"+_parsingContext.getCurrentName()+"'"); break; case VALUE_STRING: System.out.println("JsonToken: VALUE_STRING '"+getText()+"'"); break; default: System.out.println("JsonToken: "+t); } } return t; } */   <BUGS> _mayBeLeaf = true; <BUGE> /* Ok: in array context we need to skip reporting field names.*/ /* But what's the best way to find next token?*/ return (_currToken = JsonToken.FIELD_NAME); }  /* Ok; beyond start element, what do we get?*/ switch (token) { case XmlTokenStream.XML_END_ELEMENT: /* Simple, except that if this is a leaf, need to suppress end:*/ if (_mayBeLeaf) { _mayBeLeaf = false; /* 06-Jan-2015, tatu: as per [dataformat-xml#180], need to*/ /*    expose as empty Object, not null*/ return (_currToken = JsonToken.VALUE_NULL);
case FIELD_NAME: System.out.println("JsonToken: FIELD_NAME '"+_parsingContext.getCurrentName()+"'"); break; case VALUE_STRING: System.out.println("JsonToken: VALUE_STRING '"+getText()+"'"); break; default: System.out.println("JsonToken: "+t); } } return t; } */  /* But what's the best way to find next token?*/ <BUGS> return (_currToken = JsonToken.FIELD_NAME); <BUGE> }  /* Ok; beyond start element, what do we get?*/ switch (token) { case XmlTokenStream.XML_END_ELEMENT: /* Simple, except that if this is a leaf, need to suppress end:*/ if (_mayBeLeaf) { _mayBeLeaf = false; /* 06-Jan-2015, tatu: as per [dataformat-xml#180], need to*/ /*    expose as empty Object, not null*/ return (_currToken = JsonToken.VALUE_NULL); } _currToken = _parsingContext.inArray() ? JsonToken.END_ARRAY : JsonToken.END_OBJECT; _parsingContext = _parsingContext.getParent();
case FIELD_NAME: System.out.println("JsonToken: FIELD_NAME '"+_parsingContext.getCurrentName()+"'"); break; case VALUE_STRING: System.out.println("JsonToken: VALUE_STRING '"+getText()+"'"); break; default: System.out.println("JsonToken: "+t); } } return t; } */  /* Ok; beyond start element, what do we get?*/ <BUGS> switch (token) { <BUGE> case XmlTokenStream.XML_END_ELEMENT: /* Simple, except that if this is a leaf, need to suppress end:*/ if (_mayBeLeaf) { _mayBeLeaf = false; /* 06-Jan-2015, tatu: as per [dataformat-xml#180], need to*/ /*    expose as empty Object, not null*/ return (_currToken = JsonToken.VALUE_NULL); } _currToken = _parsingContext.inArray() ? JsonToken.END_ARRAY : JsonToken.END_OBJECT; _parsingContext = _parsingContext.getParent(); _namesToWrap = _parsingContext.getNamesToWrap(); return _currToken;  case XmlTokenStream.XML_ATTRIBUTE_NAME:
case FIELD_NAME: System.out.println("JsonToken: FIELD_NAME '"+_parsingContext.getCurrentName()+"'"); break; case VALUE_STRING: System.out.println("JsonToken: VALUE_STRING '"+getText()+"'"); break; default: System.out.println("JsonToken: "+t); } } return t; } */  /* Simple, except that if this is a leaf, need to suppress end:*/ <BUGS> if (_mayBeLeaf) { _mayBeLeaf = false; <BUGE> /* 06-Jan-2015, tatu: as per [dataformat-xml#180], need to*/ /*    expose as empty Object, not null*/ return (_currToken = JsonToken.VALUE_NULL); } _currToken = _parsingContext.inArray() ? JsonToken.END_ARRAY : JsonToken.END_OBJECT; _parsingContext = _parsingContext.getParent(); _namesToWrap = _parsingContext.getNamesToWrap(); return _currToken;  case XmlTokenStream.XML_ATTRIBUTE_NAME: /* If there was a chance of leaf node, no more...*/ if (_mayBeLeaf) { _mayBeLeaf = false;
case FIELD_NAME: System.out.println("JsonToken: FIELD_NAME '"+_parsingContext.getCurrentName()+"'"); break; case VALUE_STRING: System.out.println("JsonToken: VALUE_STRING '"+getText()+"'"); break; default: System.out.println("JsonToken: "+t); } } return t; } */  /*    expose as empty Object, not null*/ <BUGS> return (_currToken = JsonToken.VALUE_NULL); <BUGE> } _currToken = _parsingContext.inArray() ? JsonToken.END_ARRAY : JsonToken.END_OBJECT; _parsingContext = _parsingContext.getParent(); _namesToWrap = _parsingContext.getNamesToWrap(); return _currToken;  case XmlTokenStream.XML_ATTRIBUTE_NAME: /* If there was a chance of leaf node, no more...*/ if (_mayBeLeaf) { _mayBeLeaf = false; _nextToken = JsonToken.FIELD_NAME; _currText = _xmlTokens.getText(); _parsingContext = _parsingContext.createChildObjectContext(-1, -1); return (_currToken = JsonToken.START_OBJECT);
System.out.println("JsonToken: FIELD_NAME '"+_parsingContext.getCurrentName()+"'"); break; case VALUE_STRING: System.out.println("JsonToken: VALUE_STRING '"+getText()+"'"); break; default: System.out.println("JsonToken: "+t); } } return t; } */  } <BUGS> _currToken = _parsingContext.inArray() ? JsonToken.END_ARRAY : JsonToken.END_OBJECT; _parsingContext = _parsingContext.getParent(); _namesToWrap = _parsingContext.getNamesToWrap(); return _currToken; <BUGE>  case XmlTokenStream.XML_ATTRIBUTE_NAME: /* If there was a chance of leaf node, no more...*/ if (_mayBeLeaf) { _mayBeLeaf = false; _nextToken = JsonToken.FIELD_NAME; _currText = _xmlTokens.getText(); _parsingContext = _parsingContext.createChildObjectContext(-1, -1); return (_currToken = JsonToken.START_OBJECT); } _parsingContext.setCurrentName(_xmlTokens.getLocalName()); return (_currToken = JsonToken.FIELD_NAME);
break; case VALUE_STRING: System.out.println("JsonToken: VALUE_STRING '"+getText()+"'"); break; default: System.out.println("JsonToken: "+t); } } return t; } */  /* If there was a chance of leaf node, no more...*/ <BUGS> if (_mayBeLeaf) { _mayBeLeaf = false; _nextToken = JsonToken.FIELD_NAME; _currText = _xmlTokens.getText(); _parsingContext = _parsingContext.createChildObjectContext(-1, -1); return (_currToken = JsonToken.START_OBJECT); <BUGE> } _parsingContext.setCurrentName(_xmlTokens.getLocalName()); return (_currToken = JsonToken.FIELD_NAME); case XmlTokenStream.XML_ATTRIBUTE_VALUE: _currText = _xmlTokens.getText(); return (_currToken = JsonToken.VALUE_STRING); case XmlTokenStream.XML_TEXT: _currText = _xmlTokens.getText(); if (_mayBeLeaf) { _mayBeLeaf = false; /* One more refinement (pronunced like "hack") is that if
case FIELD_NAME: System.out.println("JsonToken: FIELD_NAME '"+_parsingContext.getCurrentName()+"'"); break; case VALUE_STRING: System.out.println("JsonToken: VALUE_STRING '"+getText()+"'"); break; default: System.out.println("JsonToken: "+t); } } return t; } */  case XmlTokenStream.XML_ATTRIBUTE_VALUE: <BUGS> _currText = _xmlTokens.getText(); return (_currToken = JsonToken.VALUE_STRING); <BUGE> case XmlTokenStream.XML_TEXT: _currText = _xmlTokens.getText(); if (_mayBeLeaf) { _mayBeLeaf = false; /* One more refinement (pronunced like "hack") is that if * we had an empty String (or all white space), and we are * deserializing an array, we better hide the empty text. */ /* Also: must skip following END_ELEMENT*/ _xmlTokens.skipEndElement(); if (_parsingContext.inArray()) { if (_isEmpty(_currText)) { /* 06-Jan-2015, tatu: as per [dataformat-xml#180], need to*/
System.out.println("JsonToken: FIELD_NAME '"+_parsingContext.getCurrentName()+"'"); break; case VALUE_STRING: System.out.println("JsonToken: VALUE_STRING '"+getText()+"'"); break; default: System.out.println("JsonToken: "+t); } } return t; } */  case XmlTokenStream.XML_TEXT: <BUGS> _currText = _xmlTokens.getText(); if (_mayBeLeaf) { _mayBeLeaf = false; <BUGE> /* One more refinement (pronunced like "hack") is that if * we had an empty String (or all white space), and we are * deserializing an array, we better hide the empty text. */ /* Also: must skip following END_ELEMENT*/ _xmlTokens.skipEndElement(); if (_parsingContext.inArray()) { if (_isEmpty(_currText)) { /* 06-Jan-2015, tatu: as per [dataformat-xml#180], need to*/ /*    expose as empty Object, not null (or, worse, as used to*/ /*    be done, by swallowing the token)*/ _currToken = JsonToken.END_ARRAY; _parsingContext = _parsingContext.getParent();
System.out.println("JsonToken: FIELD_NAME '"+_parsingContext.getCurrentName()+"'"); break; case VALUE_STRING: System.out.println("JsonToken: VALUE_STRING '"+getText()+"'"); break; default: System.out.println("JsonToken: "+t); } } return t; } */  /* Also: must skip following END_ELEMENT*/ <BUGS> _xmlTokens.skipEndElement(); if (_parsingContext.inArray()) { if (_isEmpty(_currText)) { <BUGE> /* 06-Jan-2015, tatu: as per [dataformat-xml#180], need to*/ /*    expose as empty Object, not null (or, worse, as used to*/ /*    be done, by swallowing the token)*/ _currToken = JsonToken.END_ARRAY; _parsingContext = _parsingContext.getParent(); _namesToWrap = _parsingContext.getNamesToWrap(); return _currToken; } } return (_currToken = JsonToken.VALUE_STRING); } else { /* [dataformat-xml#177]: empty text may also need to be skipped*/ if (_parsingContext.inObject()
System.out.println("JsonToken: FIELD_NAME '"+_parsingContext.getCurrentName()+"'"); break; case VALUE_STRING: System.out.println("JsonToken: VALUE_STRING '"+getText()+"'"); break; default: System.out.println("JsonToken: "+t); } } return t; } */  /*    be done, by swallowing the token)*/ <BUGS> _currToken = JsonToken.END_ARRAY; _parsingContext = _parsingContext.getParent(); _namesToWrap = _parsingContext.getNamesToWrap(); return _currToken; <BUGE> } } return (_currToken = JsonToken.VALUE_STRING); } else { /* [dataformat-xml#177]: empty text may also need to be skipped*/ if (_parsingContext.inObject() && (_currToken != JsonToken.FIELD_NAME) && _isEmpty(_currText)) { _currToken = JsonToken.END_OBJECT; _parsingContext = _parsingContext.getParent(); _namesToWrap = _parsingContext.getNamesToWrap(); return _currToken; }
case FIELD_NAME: System.out.println("JsonToken: FIELD_NAME '"+_parsingContext.getCurrentName()+"'"); break; case VALUE_STRING: System.out.println("JsonToken: VALUE_STRING '"+getText()+"'"); break; default: System.out.println("JsonToken: "+t); } } return t; } */  } <BUGS> return (_currToken = JsonToken.VALUE_STRING); <BUGE> } else { /* [dataformat-xml#177]: empty text may also need to be skipped*/ if (_parsingContext.inObject() && (_currToken != JsonToken.FIELD_NAME) && _isEmpty(_currText)) { _currToken = JsonToken.END_OBJECT; _parsingContext = _parsingContext.getParent(); _namesToWrap = _parsingContext.getNamesToWrap(); return _currToken; } } /* If not a leaf (or otherwise ignorable), need to transform into property...*/ _parsingContext.setCurrentName(_cfgNameForTextElement); _nextToken = JsonToken.VALUE_STRING; return (_currToken = JsonToken.FIELD_NAME);
@Override public Object deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { <BUGS> if (jp.getCurrentToken() == JsonToken.VALUE_STRING) { Object bean = _valueInstantiator.createUsingDefault(ctxt); _xmlTextProperty.deserializeAndSet(jp, ctxt, bean); return bean; <BUGE> } return _delegatee.deserialize(jp,  ctxt); }
@Override public String nextTextValue() throws IOException { <BUGS> _binaryValue = null; if (_nextToken != null) { <BUGE> JsonToken t = _nextToken; _currToken = t; _nextToken = null;  /* expected case; yes, got a String*/ if (t == JsonToken.VALUE_STRING) { return _currText; } _updateState(t); return null; }  int token = _xmlTokens.next();  /* mostly copied from 'nextToken()'*/ while (token == XmlTokenStream.XML_START_ELEMENT) { if (_mayBeLeaf) { _nextToken = JsonToken.FIELD_NAME; _parsingContext = _parsingContext.createChildObjectContext(-1, -1); _currToken = JsonToken.START_OBJECT; return null; } if (_parsingContext.inArray()) { token = _xmlTokens.next(); _mayBeLeaf = true;
@Override public String nextTextValue() throws IOException { _binaryValue = null; if (_nextToken != null) { JsonToken t = _nextToken; _currToken = t; _nextToken = null;  /* expected case; yes, got a String*/ if (t == JsonToken.VALUE_STRING) { return _currText; } _updateState(t); return null; }  <BUGS> int token = _xmlTokens.next(); <BUGE>  /* mostly copied from 'nextToken()'*/ while (token == XmlTokenStream.XML_START_ELEMENT) { if (_mayBeLeaf) { _nextToken = JsonToken.FIELD_NAME; _parsingContext = _parsingContext.createChildObjectContext(-1, -1); _currToken = JsonToken.START_OBJECT; return null; } if (_parsingContext.inArray()) { token = _xmlTokens.next(); _mayBeLeaf = true;
@Override public String nextTextValue() throws IOException { _binaryValue = null; if (_nextToken != null) { JsonToken t = _nextToken; _currToken = t; _nextToken = null;  /* expected case; yes, got a String*/ if (t == JsonToken.VALUE_STRING) { return _currText; } _updateState(t); return null; }  int token = _xmlTokens.next();  /* mostly copied from 'nextToken()'*/ <BUGS> while (token == XmlTokenStream.XML_START_ELEMENT) { <BUGE> if (_mayBeLeaf) { _nextToken = JsonToken.FIELD_NAME; _parsingContext = _parsingContext.createChildObjectContext(-1, -1); _currToken = JsonToken.START_OBJECT; return null; } if (_parsingContext.inArray()) { token = _xmlTokens.next(); _mayBeLeaf = true;
} } }  /* /********************************************************** /* Overrides of specialized nextXxx() methods /********************************************************** */  /** * Method overridden to support more reliable deserialization of * String collections. */ /* Ok; beyond start element, what do we get?*/ <BUGS> switch (token) { <BUGE> case XmlTokenStream.XML_END_ELEMENT: if (_mayBeLeaf) { /* NOTE: this is different from nextToken() -- produce "", NOT null*/ _mayBeLeaf = false; _currToken = JsonToken.VALUE_STRING; return (_currText = ""); } _currToken = _parsingContext.inArray() ? JsonToken.END_ARRAY : JsonToken.END_OBJECT; _parsingContext = _parsingContext.getParent(); _namesToWrap = _parsingContext.getNamesToWrap(); break; case XmlTokenStream.XML_ATTRIBUTE_NAME: /* If there was a chance of leaf node, no more...*/ if (_mayBeLeaf) {
} }  /* /********************************************************** /* Overrides of specialized nextXxx() methods /********************************************************** */  /** * Method overridden to support more reliable deserialization of * String collections. */ case XmlTokenStream.XML_ATTRIBUTE_VALUE: <BUGS> _currText = _xmlTokens.getText(); _currToken = JsonToken.VALUE_STRING; break; <BUGE> case XmlTokenStream.XML_TEXT: _currText = _xmlTokens.getText(); if (_mayBeLeaf) { _mayBeLeaf = false; /* Also: must skip following END_ELEMENT*/ _xmlTokens.skipEndElement();  /* NOTE: this is different from nextToken() -- NO work-around*/ /* for otherwise empty List/array*/ _currToken = JsonToken.VALUE_STRING; return _currText; } /* If not a leaf, need to transform into property...*/
} } }  /* /********************************************************** /* Overrides of specialized nextXxx() methods /********************************************************** */  /** * Method overridden to support more reliable deserialization of * String collections. */ } <BUGS> return null; <BUGE> }   private void _updateState(JsonToken t) { switch (t) { case START_OBJECT: _parsingContext = _parsingContext.createChildObjectContext(-1, -1); break; case START_ARRAY: _parsingContext = _parsingContext.createChildArrayContext(-1, -1); break; case END_OBJECT: case END_ARRAY:
@Override public void serializeValue(JsonGenerator gen, Object value) throws IOException { <BUGS> if (value == null) { _serializeXmlNull(gen); return; <BUGE> } final Class<?> cls = value.getClass(); final boolean asArray; final ToXmlGenerator xgen = _asXmlGenerator(gen); if (xgen == null) { /* called by convertValue()*/ asArray = false; } else { QName rootName = _rootNameFromConfig(); if (rootName == null) { rootName = _rootNameLookup.findRootName(cls, _config); } _initWithRootName(xgen, rootName); asArray = TypeUtil.isIndexedType(cls); if (asArray) { _startRootArray(xgen, rootName); } }  /* From super-class implementation*/ final JsonSerializer<Object> ser = findTypedValueSerializer(cls, true, null); try { ser.serialize(value, gen, this); } catch (IOException ioe) { /* As per [JACKSON-99], pass IOException and subtypes as-is*/ throw ioe;
@Override public void serializeValue(JsonGenerator gen, Object value) throws IOException { if (value == null) { _serializeXmlNull(gen); return; } <BUGS> final Class<?> cls = value.getClass(); <BUGE> final boolean asArray; final ToXmlGenerator xgen = _asXmlGenerator(gen); if (xgen == null) { /* called by convertValue()*/ asArray = false; } else { QName rootName = _rootNameFromConfig(); if (rootName == null) { rootName = _rootNameLookup.findRootName(cls, _config); } _initWithRootName(xgen, rootName); asArray = TypeUtil.isIndexedType(cls); if (asArray) { _startRootArray(xgen, rootName); } }  /* From super-class implementation*/ final JsonSerializer<Object> ser = findTypedValueSerializer(cls, true, null); try { ser.serialize(value, gen, this); } catch (IOException ioe) { /* As per [JACKSON-99], pass IOException and subtypes as-is*/ throw ioe;
@Override public void serializeValue(JsonGenerator gen, Object value) throws IOException { if (value == null) { _serializeXmlNull(gen); return; } final Class<?> cls = value.getClass(); final boolean asArray; <BUGS> final ToXmlGenerator xgen = _asXmlGenerator(gen); if (xgen == null) { /* called by convertValue() <BUGE>*/ asArray = false; } else { QName rootName = _rootNameFromConfig(); if (rootName == null) { rootName = _rootNameLookup.findRootName(cls, _config); } _initWithRootName(xgen, rootName); asArray = TypeUtil.isIndexedType(cls); if (asArray) { _startRootArray(xgen, rootName); } }  /* From super-class implementation*/ final JsonSerializer<Object> ser = findTypedValueSerializer(cls, true, null); try { ser.serialize(value, gen, this); } catch (IOException ioe) { /* As per [JACKSON-99], pass IOException and subtypes as-is*/ throw ioe;
@Override public void serializeValue(JsonGenerator gen, Object value) throws IOException { if (value == null) { _serializeXmlNull(gen); return; } final Class<?> cls = value.getClass(); final boolean asArray; final ToXmlGenerator xgen = _asXmlGenerator(gen); if (xgen == null) { /* called by convertValue()*/ asArray = false; } else { <BUGS> QName rootName = _rootNameFromConfig(); if (rootName == null) { <BUGE> rootName = _rootNameLookup.findRootName(cls, _config); } _initWithRootName(xgen, rootName); asArray = TypeUtil.isIndexedType(cls); if (asArray) { _startRootArray(xgen, rootName); } }  /* From super-class implementation*/ final JsonSerializer<Object> ser = findTypedValueSerializer(cls, true, null); try { ser.serialize(value, gen, this); } catch (IOException ioe) { /* As per [JACKSON-99], pass IOException and subtypes as-is*/ throw ioe;
@Override public void serializeValue(JsonGenerator gen, Object value) throws IOException { if (value == null) { _serializeXmlNull(gen); return; } final Class<?> cls = value.getClass(); final boolean asArray; final ToXmlGenerator xgen = _asXmlGenerator(gen); if (xgen == null) { /* called by convertValue()*/ asArray = false; } else { QName rootName = _rootNameFromConfig(); if (rootName == null) { rootName = _rootNameLookup.findRootName(cls, _config); } <BUGS> _initWithRootName(xgen, rootName); asArray = TypeUtil.isIndexedType(cls); if (asArray) { <BUGE> _startRootArray(xgen, rootName); } }  /* From super-class implementation*/ final JsonSerializer<Object> ser = findTypedValueSerializer(cls, true, null); try { ser.serialize(value, gen, this); } catch (IOException ioe) { /* As per [JACKSON-99], pass IOException and subtypes as-is*/ throw ioe;
@Override public void serializeValue(JsonGenerator gen, Object value) throws IOException { if (value == null) { _serializeXmlNull(gen); return; } final Class<?> cls = value.getClass(); final boolean asArray; final ToXmlGenerator xgen = _asXmlGenerator(gen); if (xgen == null) { /* called by convertValue()*/ asArray = false; } else { QName rootName = _rootNameFromConfig(); if (rootName == null) { rootName = _rootNameLookup.findRootName(cls, _config); } _initWithRootName(xgen, rootName); asArray = TypeUtil.isIndexedType(cls); if (asArray) { _startRootArray(xgen, rootName); } }  /* From super-class implementation*/ <BUGS> final JsonSerializer<Object> ser = findTypedValueSerializer(cls, true, null); <BUGE> try { ser.serialize(value, gen, this); } catch (IOException ioe) { /* As per [JACKSON-99], pass IOException and subtypes as-is*/ throw ioe;
@Override public void serializeValue(JsonGenerator gen, Object value) throws IOException { if (value == null) { _serializeXmlNull(gen); return; } final Class<?> cls = value.getClass(); final boolean asArray; final ToXmlGenerator xgen = _asXmlGenerator(gen); if (xgen == null) { /* called by convertValue()*/ asArray = false; } else { QName rootName = _rootNameFromConfig(); if (rootName == null) { rootName = _rootNameLookup.findRootName(cls, _config); } _initWithRootName(xgen, rootName); asArray = TypeUtil.isIndexedType(cls); if (asArray) { _startRootArray(xgen, rootName); } }  /* From super-class implementation*/ final JsonSerializer<Object> ser = findTypedValueSerializer(cls, true, null); try { <BUGS> ser.serialize(value, gen, this); <BUGE> } catch (IOException ioe) { /* As per [JACKSON-99], pass IOException and subtypes as-is*/ throw ioe;
/* /********************************************************************** /* Overridden methods /********************************************************************** */  @Override public DefaultSerializerProvider createInstance(SerializationConfig config, SerializerFactory jsf) { return new XmlSerializerProvider(this, config, jsf); }  @SuppressWarnings("resource") throw JsonMappingException.from(gen, msg, e); <BUGS> } <BUGE> /* end of super-class implementation*/  if (asArray) { gen.writeEndObject(); } }  @SuppressWarnings("resource") @Override public void serializeValue(JsonGenerator gen, Object value, JavaType rootType) throws IOException { if (value == null) { _serializeXmlNull(gen);
/* /********************************************************************** /* Overridden methods /********************************************************************** */  @Override public DefaultSerializerProvider createInstance(SerializationConfig config, SerializerFactory jsf) { return new XmlSerializerProvider(this, config, jsf); }  @SuppressWarnings("resource")  <BUGS> if (asArray) { <BUGE> gen.writeEndObject(); } }  @SuppressWarnings("resource") @Override public void serializeValue(JsonGenerator gen, Object value, JavaType rootType) throws IOException { if (value == null) { _serializeXmlNull(gen); return; } final boolean asArray;
/* /********************************************************************** /* Overridden methods /********************************************************************** */  @Override public DefaultSerializerProvider createInstance(SerializationConfig config, SerializerFactory jsf) { return new XmlSerializerProvider(this, config, jsf); }  @SuppressWarnings("resource") } <BUGS> } <BUGE>  @SuppressWarnings("resource") @Override public void serializeValue(JsonGenerator gen, Object value, JavaType rootType) throws IOException { if (value == null) { _serializeXmlNull(gen); return; } final boolean asArray; final ToXmlGenerator xgen = _asXmlGenerator(gen); if (xgen == null) { /* called by convertValue()*/ asArray = false;
*/ protected XmlMapper(XmlMapper src) { <BUGS> super(src); _xmlModule = src._xmlModule; } <BUGE>
@Override public void serializeValue(JsonGenerator gen, Object value) throws IOException { <BUGS> if (value == null) { <BUGE> _serializeXmlNull(gen); return; } final Class<?> cls = value.getClass(); final boolean asArray; final ToXmlGenerator xgen = _asXmlGenerator(gen); if (xgen == null) { /* called by convertValue()*/ asArray = false; } else { QName rootName = _rootNameFromConfig(); if (rootName == null) { rootName = _rootNameLookup.findRootName(cls, _config); } _initWithRootName(xgen, rootName); asArray = TypeUtil.isIndexedType(cls); if (asArray) { _startRootArray(xgen, rootName); } }  /* From super-class implementation*/ final JsonSerializer<Object> ser = findTypedValueSerializer(cls, true, null); try { ser.serialize(value, gen, this); } catch (Exception e) { /* but wrap RuntimeExceptions, to get path information*/ throw _wrapAsIOE(gen, e);
@Override public void serializeValue(JsonGenerator gen, Object value) throws IOException { if (value == null) { _serializeXmlNull(gen); return; } <BUGS> final Class<?> cls = value.getClass(); <BUGE> final boolean asArray; final ToXmlGenerator xgen = _asXmlGenerator(gen); if (xgen == null) { /* called by convertValue()*/ asArray = false; } else { QName rootName = _rootNameFromConfig(); if (rootName == null) { rootName = _rootNameLookup.findRootName(cls, _config); } _initWithRootName(xgen, rootName); asArray = TypeUtil.isIndexedType(cls); if (asArray) { _startRootArray(xgen, rootName); } }  /* From super-class implementation*/ final JsonSerializer<Object> ser = findTypedValueSerializer(cls, true, null); try { ser.serialize(value, gen, this); } catch (Exception e) { /* but wrap RuntimeExceptions, to get path information*/ throw _wrapAsIOE(gen, e);
@Override public void serializeValue(JsonGenerator gen, Object value) throws IOException { if (value == null) { _serializeXmlNull(gen); return; } final Class<?> cls = value.getClass(); final boolean asArray; <BUGS> final ToXmlGenerator xgen = _asXmlGenerator(gen); if (xgen == null) { /* called by convertValue() <BUGE>*/ asArray = false; } else { QName rootName = _rootNameFromConfig(); if (rootName == null) { rootName = _rootNameLookup.findRootName(cls, _config); } _initWithRootName(xgen, rootName); asArray = TypeUtil.isIndexedType(cls); if (asArray) { _startRootArray(xgen, rootName); } }  /* From super-class implementation*/ final JsonSerializer<Object> ser = findTypedValueSerializer(cls, true, null); try { ser.serialize(value, gen, this); } catch (Exception e) { /* but wrap RuntimeExceptions, to get path information*/ throw _wrapAsIOE(gen, e);
@Override public void serializeValue(JsonGenerator gen, Object value) throws IOException { if (value == null) { _serializeXmlNull(gen); return; } final Class<?> cls = value.getClass(); final boolean asArray; final ToXmlGenerator xgen = _asXmlGenerator(gen); if (xgen == null) { /* called by convertValue()*/ asArray = false; } else { <BUGS> QName rootName = _rootNameFromConfig(); if (rootName == null) { rootName = _rootNameLookup.findRootName(cls, _config); <BUGE> } _initWithRootName(xgen, rootName); asArray = TypeUtil.isIndexedType(cls); if (asArray) { _startRootArray(xgen, rootName); } }  /* From super-class implementation*/ final JsonSerializer<Object> ser = findTypedValueSerializer(cls, true, null); try { ser.serialize(value, gen, this); } catch (Exception e) { /* but wrap RuntimeExceptions, to get path information*/ throw _wrapAsIOE(gen, e);
@Override public void serializeValue(JsonGenerator gen, Object value) throws IOException { if (value == null) { _serializeXmlNull(gen); return; } final Class<?> cls = value.getClass(); final boolean asArray; final ToXmlGenerator xgen = _asXmlGenerator(gen); if (xgen == null) { /* called by convertValue()*/ asArray = false; } else { QName rootName = _rootNameFromConfig(); if (rootName == null) { rootName = _rootNameLookup.findRootName(cls, _config); } <BUGS> _initWithRootName(xgen, rootName); asArray = TypeUtil.isIndexedType(cls); if (asArray) { <BUGE> _startRootArray(xgen, rootName); } }  /* From super-class implementation*/ final JsonSerializer<Object> ser = findTypedValueSerializer(cls, true, null); try { ser.serialize(value, gen, this); } catch (Exception e) { /* but wrap RuntimeExceptions, to get path information*/ throw _wrapAsIOE(gen, e);
@Override public void serializeValue(JsonGenerator gen, Object value) throws IOException { if (value == null) { _serializeXmlNull(gen); return; } final Class<?> cls = value.getClass(); final boolean asArray; final ToXmlGenerator xgen = _asXmlGenerator(gen); if (xgen == null) { /* called by convertValue()*/ asArray = false; } else { QName rootName = _rootNameFromConfig(); if (rootName == null) { rootName = _rootNameLookup.findRootName(cls, _config); } _initWithRootName(xgen, rootName); asArray = TypeUtil.isIndexedType(cls); if (asArray) { _startRootArray(xgen, rootName); } }  /* From super-class implementation*/ <BUGS> final JsonSerializer<Object> ser = findTypedValueSerializer(cls, true, null); <BUGE> try { ser.serialize(value, gen, this); } catch (Exception e) { /* but wrap RuntimeExceptions, to get path information*/ throw _wrapAsIOE(gen, e);
@Override public void serializeValue(JsonGenerator gen, Object value) throws IOException { if (value == null) { _serializeXmlNull(gen); return; } final Class<?> cls = value.getClass(); final boolean asArray; final ToXmlGenerator xgen = _asXmlGenerator(gen); if (xgen == null) { /* called by convertValue()*/ asArray = false; } else { QName rootName = _rootNameFromConfig(); if (rootName == null) { rootName = _rootNameLookup.findRootName(cls, _config); } _initWithRootName(xgen, rootName); asArray = TypeUtil.isIndexedType(cls); if (asArray) { _startRootArray(xgen, rootName); } }  /* From super-class implementation*/ final JsonSerializer<Object> ser = findTypedValueSerializer(cls, true, null); try { <BUGS> ser.serialize(value, gen, this); } catch (Exception e) { /* but wrap RuntimeExceptions, to get path information*/ throw _wrapAsIOE(gen, e); <BUGE>
*/ public static Number createNumber(final String str) throws NumberFormatException { <BUGS> if (str == null) { <BUGE> return null; } if (StringUtils.isBlank(str)) { throw new NumberFormatException("A blank string is not a valid number"); } /* Need to deal with all possible hex prefixes here*/ final String[] hex_prefixes = {"0x", "0X", "-0x", "-0X", "#", "-#"}; int pfxLen = 0; for(final String pfx : hex_prefixes) { if (str.startsWith(pfx)) { pfxLen += pfx.length(); break; } } if (pfxLen > 0) { /* we have a hex number*/ final int hexDigits = str.length() - pfxLen; if (hexDigits > 16) { /* too many for Long*/ return createBigInteger(str); } if (hexDigits > 8) { /* too many for an int*/ return createLong(str); } return createInteger(str); } final char lastChar = str.charAt(str.length() - 1); String mant; String dec;
*/ public static Number createNumber(final String str) throws NumberFormatException { if (str == null) { return null; } <BUGS> if (StringUtils.isBlank(str)) { <BUGE> throw new NumberFormatException("A blank string is not a valid number"); } /* Need to deal with all possible hex prefixes here*/ final String[] hex_prefixes = {"0x", "0X", "-0x", "-0X", "#", "-#"}; int pfxLen = 0; for(final String pfx : hex_prefixes) { if (str.startsWith(pfx)) { pfxLen += pfx.length(); break; } } if (pfxLen > 0) { /* we have a hex number*/ final int hexDigits = str.length() - pfxLen; if (hexDigits > 16) { /* too many for Long*/ return createBigInteger(str); } if (hexDigits > 8) { /* too many for an int*/ return createLong(str); } return createInteger(str); } final char lastChar = str.charAt(str.length() - 1); String mant; String dec;
*/ public static Number createNumber(final String str) throws NumberFormatException { if (str == null) { return null; } if (StringUtils.isBlank(str)) { throw new NumberFormatException("A blank string is not a valid number"); } /* Need to deal with all possible hex prefixes here*/ <BUGS> final String[] hex_prefixes = {"0x", "0X", "-0x", "-0X", "#", "-#"}; int pfxLen = 0; for(final String pfx : hex_prefixes) { if (str.startsWith(pfx)) { pfxLen += pfx.length(); break; <BUGE> } } if (pfxLen > 0) { /* we have a hex number*/ final int hexDigits = str.length() - pfxLen; if (hexDigits > 16) { /* too many for Long*/ return createBigInteger(str); } if (hexDigits > 8) { /* too many for an int*/ return createLong(str); } return createInteger(str); } final char lastChar = str.charAt(str.length() - 1); String mant; String dec;
*/ public static Number createNumber(final String str) throws NumberFormatException { if (str == null) { return null; } if (StringUtils.isBlank(str)) { throw new NumberFormatException("A blank string is not a valid number"); } /* Need to deal with all possible hex prefixes here*/ final String[] hex_prefixes = {"0x", "0X", "-0x", "-0X", "#", "-#"}; int pfxLen = 0; for(final String pfx : hex_prefixes) { if (str.startsWith(pfx)) { pfxLen += pfx.length(); break; } } <BUGS> if (pfxLen > 0) { /* we have a hex number*/ final int hexDigits = str.length() - pfxLen; if (hexDigits > 16) { /* too many for Long <BUGE>*/ return createBigInteger(str); } if (hexDigits > 8) { /* too many for an int*/ return createLong(str); } return createInteger(str); } final char lastChar = str.charAt(str.length() - 1); String mant; String dec;
*/ public static Number createNumber(final String str) throws NumberFormatException { if (str == null) { return null; } if (StringUtils.isBlank(str)) { throw new NumberFormatException("A blank string is not a valid number"); } /* Need to deal with all possible hex prefixes here*/ final String[] hex_prefixes = {"0x", "0X", "-0x", "-0X", "#", "-#"}; int pfxLen = 0; for(final String pfx : hex_prefixes) { if (str.startsWith(pfx)) { pfxLen += pfx.length(); break; } } if (pfxLen > 0) { /* we have a hex number*/ final int hexDigits = str.length() - pfxLen; if (hexDigits > 16) { /* too many for Long*/ return createBigInteger(str); } <BUGS> if (hexDigits > 8) { /* too many for an int <BUGE>*/ return createLong(str); } return createInteger(str); } final char lastChar = str.charAt(str.length() - 1); String mant; String dec;
*/ public static Number createNumber(final String str) throws NumberFormatException { if (str == null) { return null; } if (StringUtils.isBlank(str)) { throw new NumberFormatException("A blank string is not a valid number"); } /* Need to deal with all possible hex prefixes here*/ final String[] hex_prefixes = {"0x", "0X", "-0x", "-0X", "#", "-#"}; int pfxLen = 0; for(final String pfx : hex_prefixes) { if (str.startsWith(pfx)) { pfxLen += pfx.length(); break; } } if (pfxLen > 0) { /* we have a hex number*/ final int hexDigits = str.length() - pfxLen; if (hexDigits > 16) { /* too many for Long*/ return createBigInteger(str); } if (hexDigits > 8) { /* too many for an int*/ return createLong(str); } <BUGS> return createInteger(str); <BUGE> } final char lastChar = str.charAt(str.length() - 1); String mant; String dec;
*/ public static Number createNumber(final String str) throws NumberFormatException { <BUGS> if (str == null) { <BUGE> return null; } if (StringUtils.isBlank(str)) { throw new NumberFormatException("A blank string is not a valid number"); } /* Need to deal with all possible hex prefixes here*/ final String[] hex_prefixes = {"0x", "0X", "-0x", "-0X", "#", "-#"}; int pfxLen = 0; for(final String pfx : hex_prefixes) { if (str.startsWith(pfx)) { pfxLen += pfx.length(); break; } } if (pfxLen > 0) { /* we have a hex number*/ final int hexDigits = str.length() - pfxLen; if (hexDigits > 16) { /* too many for Long*/ return createBigInteger(str); } if (hexDigits > 8) { /* too many for an int*/ return createLong(str); } return createInteger(str); } final char lastChar = str.charAt(str.length() - 1); String mant; String dec;
*/ public static Number createNumber(final String str) throws NumberFormatException { if (str == null) { return null; } <BUGS> if (StringUtils.isBlank(str)) { <BUGE> throw new NumberFormatException("A blank string is not a valid number"); } /* Need to deal with all possible hex prefixes here*/ final String[] hex_prefixes = {"0x", "0X", "-0x", "-0X", "#", "-#"}; int pfxLen = 0; for(final String pfx : hex_prefixes) { if (str.startsWith(pfx)) { pfxLen += pfx.length(); break; } } if (pfxLen > 0) { /* we have a hex number*/ final int hexDigits = str.length() - pfxLen; if (hexDigits > 16) { /* too many for Long*/ return createBigInteger(str); } if (hexDigits > 8) { /* too many for an int*/ return createLong(str); } return createInteger(str); } final char lastChar = str.charAt(str.length() - 1); String mant; String dec;
*/ public static Number createNumber(final String str) throws NumberFormatException { if (str == null) { return null; } if (StringUtils.isBlank(str)) { throw new NumberFormatException("A blank string is not a valid number"); } /* Need to deal with all possible hex prefixes here*/ <BUGS> final String[] hex_prefixes = {"0x", "0X", "-0x", "-0X", "#", "-#"}; int pfxLen = 0; for(final String pfx : hex_prefixes) { if (str.startsWith(pfx)) { <BUGE> pfxLen += pfx.length(); break; } } if (pfxLen > 0) { /* we have a hex number*/ final int hexDigits = str.length() - pfxLen; if (hexDigits > 16) { /* too many for Long*/ return createBigInteger(str); } if (hexDigits > 8) { /* too many for an int*/ return createLong(str); } return createInteger(str); } final char lastChar = str.charAt(str.length() - 1); String mant; String dec;
*/ public static Number createNumber(final String str) throws NumberFormatException { if (str == null) { return null; } if (StringUtils.isBlank(str)) { throw new NumberFormatException("A blank string is not a valid number"); } /* Need to deal with all possible hex prefixes here*/ final String[] hex_prefixes = {"0x", "0X", "-0x", "-0X", "#", "-#"}; int pfxLen = 0; for(final String pfx : hex_prefixes) { if (str.startsWith(pfx)) { pfxLen += pfx.length(); break; } } <BUGS> if (pfxLen > 0) { /* we have a hex number <BUGE>*/ final int hexDigits = str.length() - pfxLen; if (hexDigits > 16) { /* too many for Long*/ return createBigInteger(str); } if (hexDigits > 8) { /* too many for an int*/ return createLong(str); } return createInteger(str); } final char lastChar = str.charAt(str.length() - 1); String mant; String dec;
*/ public static Number createNumber(final String str) throws NumberFormatException { if (str == null) { return null; } if (StringUtils.isBlank(str)) { throw new NumberFormatException("A blank string is not a valid number"); } /* Need to deal with all possible hex prefixes here*/ final String[] hex_prefixes = {"0x", "0X", "-0x", "-0X", "#", "-#"}; int pfxLen = 0; for(final String pfx : hex_prefixes) { if (str.startsWith(pfx)) { pfxLen += pfx.length(); break; } } if (pfxLen > 0) { /* we have a hex number*/ final int hexDigits = str.length() - pfxLen; if (hexDigits > 16) { /* too many for Long*/ return createBigInteger(str); } if (hexDigits > 8) { /* too many for an int*/ return createLong(str); } return createInteger(str); } <BUGS> final char lastChar = str.charAt(str.length() - 1); <BUGE> String mant; String dec;
* * <p> * Integral values with a leading {@code 0} will be interpreted as octal; the returned number will * be Integer, Long or BigDecimal as appropriate. * </p> * * <p>Returns <code>null</code> if the string is <code>null</code>.</p> * * <p>This method does not trim the input string, i.e., strings with leading * or trailing spaces will generate NumberFormatExceptions.</p> * * @param str  String containing a number, may be null * @return Number created from the string (or null if the input is null) * @throws NumberFormatException if the value cannot be converted String exp; <BUGS> final int decPos = str.indexOf('.'); final int expPos = str.indexOf('e') + str.indexOf('E') + 1; /* assumes both not present <BUGE>*/ /* if both e and E are present, this is caught by the checks on expPos (which prevent IOOBE)*/ /* and the parsing which will detect if e or E appear in a number due to using the wrong offset*/  if (decPos > -1) { /* there is a decimal point*/  if (expPos > -1) { /* there is an exponent*/ if (expPos < decPos || expPos > str.length()) { /* prevents double exponent causing IOOBE*/ throw new NumberFormatException(str + " is not a valid number."); } dec = str.substring(decPos + 1, expPos); } else { dec = str.substring(decPos + 1); }
* * <p> * Integral values with a leading {@code 0} will be interpreted as octal; the returned number will * be Integer, Long or BigDecimal as appropriate. * </p> * * <p>Returns <code>null</code> if the string is <code>null</code>.</p> * * <p>This method does not trim the input string, i.e., strings with leading * or trailing spaces will generate NumberFormatExceptions.</p> * * @param str  String containing a number, may be null * @return Number created from the string (or null if the input is null) * @throws NumberFormatException if the value cannot be converted  <BUGS> if (decPos > -1) { /* there is a decimal point <BUGE>*/  if (expPos > -1) { /* there is an exponent*/ if (expPos < decPos || expPos > str.length()) { /* prevents double exponent causing IOOBE*/ throw new NumberFormatException(str + " is not a valid number."); } dec = str.substring(decPos + 1, expPos); } else { dec = str.substring(decPos + 1); } mant = str.substring(0, decPos); } else { if (expPos > -1) { if (expPos > str.length()) { /* prevents double exponent causing IOOBE*/ throw new NumberFormatException(str + " is not a valid number.");
* * <p> * Integral values with a leading {@code 0} will be interpreted as octal; the returned number will * be Integer, Long or BigDecimal as appropriate. * </p> * * <p>Returns <code>null</code> if the string is <code>null</code>.</p> * * <p>This method does not trim the input string, i.e., strings with leading * or trailing spaces will generate NumberFormatExceptions.</p> * * @param str  String containing a number, may be null * @return Number created from the string (or null if the input is null) * @throws NumberFormatException if the value cannot be converted  <BUGS> if (expPos > -1) { /* there is an exponent*/ if (expPos < decPos || expPos > str.length()) { /* prevents double exponent causing IOOBE <BUGE>*/ throw new NumberFormatException(str + " is not a valid number."); } dec = str.substring(decPos + 1, expPos); } else { dec = str.substring(decPos + 1); } mant = str.substring(0, decPos); } else { if (expPos > -1) { if (expPos > str.length()) { /* prevents double exponent causing IOOBE*/ throw new NumberFormatException(str + " is not a valid number."); } mant = str.substring(0, expPos);
* * <p> * Integral values with a leading {@code 0} will be interpreted as octal; the returned number will * be Integer, Long or BigDecimal as appropriate. * </p> * * <p>Returns <code>null</code> if the string is <code>null</code>.</p> * * <p>This method does not trim the input string, i.e., strings with leading * or trailing spaces will generate NumberFormatExceptions.</p> * * @param str  String containing a number, may be null * @return Number created from the string (or null if the input is null) * @throws NumberFormatException if the value cannot be converted } <BUGS> dec = str.substring(decPos + 1, expPos); <BUGE> } else { dec = str.substring(decPos + 1); } mant = str.substring(0, decPos); } else { if (expPos > -1) { if (expPos > str.length()) { /* prevents double exponent causing IOOBE*/ throw new NumberFormatException(str + " is not a valid number."); } mant = str.substring(0, expPos); } else { mant = str; } dec = null;
* * <p> * Integral values with a leading {@code 0} will be interpreted as octal; the returned number will * be Integer, Long or BigDecimal as appropriate. * </p> * * <p>Returns <code>null</code> if the string is <code>null</code>.</p> * * <p>This method does not trim the input string, i.e., strings with leading * or trailing spaces will generate NumberFormatExceptions.</p> * * @param str  String containing a number, may be null * @return Number created from the string (or null if the input is null) * @throws NumberFormatException if the value cannot be converted } else { <BUGS> dec = str.substring(decPos + 1); <BUGE> } mant = str.substring(0, decPos); } else { if (expPos > -1) { if (expPos > str.length()) { /* prevents double exponent causing IOOBE*/ throw new NumberFormatException(str + " is not a valid number."); } mant = str.substring(0, expPos); } else { mant = str; } dec = null; } if (!Character.isDigit(lastChar) && lastChar != '.') {
* * <p> * Integral values with a leading {@code 0} will be interpreted as octal; the returned number will * be Integer, Long or BigDecimal as appropriate. * </p> * * <p>Returns <code>null</code> if the string is <code>null</code>.</p> * * <p>This method does not trim the input string, i.e., strings with leading * or trailing spaces will generate NumberFormatExceptions.</p> * * @param str  String containing a number, may be null * @return Number created from the string (or null if the input is null) * @throws NumberFormatException if the value cannot be converted } <BUGS> mant = str.substring(0, decPos); <BUGE> } else { if (expPos > -1) { if (expPos > str.length()) { /* prevents double exponent causing IOOBE*/ throw new NumberFormatException(str + " is not a valid number."); } mant = str.substring(0, expPos); } else { mant = str; } dec = null; } if (!Character.isDigit(lastChar) && lastChar != '.') { if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length() - 1);
* * <p> * Integral values with a leading {@code 0} will be interpreted as octal; the returned number will * be Integer, Long or BigDecimal as appropriate. * </p> * * <p>Returns <code>null</code> if the string is <code>null</code>.</p> * * <p>This method does not trim the input string, i.e., strings with leading * or trailing spaces will generate NumberFormatExceptions.</p> * * @param str  String containing a number, may be null * @return Number created from the string (or null if the input is null) * @throws NumberFormatException if the value cannot be converted } <BUGS> if (!Character.isDigit(lastChar) && lastChar != '.') { <BUGE> if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length() - 1); } else { exp = null; } /*Requesting a specific type..*/ final String numeric = str.substring(0, str.length() - 1); final boolean allZeros = isAllZeros(mant) && isAllZeros(exp); switch (lastChar) { case 'l' : case 'L' : if (dec == null && exp == null && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {
* * <p> * Integral values with a leading {@code 0} will be interpreted as octal; the returned number will * be Integer, Long or BigDecimal as appropriate. * </p> * * <p>Returns <code>null</code> if the string is <code>null</code>.</p> * * <p>This method does not trim the input string, i.e., strings with leading * or trailing spaces will generate NumberFormatExceptions.</p> * * @param str  String containing a number, may be null * @return Number created from the string (or null if the input is null) * @throws NumberFormatException if the value cannot be converted /*small and go from there...*/ <BUGS> if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length()); <BUGE> } else { exp = null; } if (dec == null && exp == null) { /* no decimal point and no exponent*/ /*Must be an Integer, Long, Biginteger*/ try { return createInteger(str); } catch (final NumberFormatException nfe) { /* NOPMD*/ /* ignore the bad number*/ } try { return createLong(str); } catch (final NumberFormatException nfe) { /* NOPMD*/
* * <p> * Integral values with a leading {@code 0} will be interpreted as octal; the returned number will * be Integer, Long or BigDecimal as appropriate. * </p> * * <p>Returns <code>null</code> if the string is <code>null</code>.</p> * * <p>This method does not trim the input string, i.e., strings with leading * or trailing spaces will generate NumberFormatExceptions.</p> * * @param str  String containing a number, may be null * @return Number created from the string (or null if the input is null) * @throws NumberFormatException if the value cannot be converted } else { <BUGS> exp = null; <BUGE> } if (dec == null && exp == null) { /* no decimal point and no exponent*/ /*Must be an Integer, Long, Biginteger*/ try { return createInteger(str); } catch (final NumberFormatException nfe) { /* NOPMD*/ /* ignore the bad number*/ } try { return createLong(str); } catch (final NumberFormatException nfe) { /* NOPMD*/ /* ignore the bad number*/ } return createBigInteger(str);
* * <p> * Integral values with a leading {@code 0} will be interpreted as octal; the returned number will * be Integer, Long or BigDecimal as appropriate. * </p> * * <p>Returns <code>null</code> if the string is <code>null</code>.</p> * * <p>This method does not trim the input string, i.e., strings with leading * or trailing spaces will generate NumberFormatExceptions.</p> * * @param str  String containing a number, may be null * @return Number created from the string (or null if the input is null) * @throws NumberFormatException if the value cannot be converted } <BUGS> if (dec == null && exp == null) { /* no decimal point and no exponent <BUGE>*/ /*Must be an Integer, Long, Biginteger*/ try { return createInteger(str); } catch (final NumberFormatException nfe) { /* NOPMD*/ /* ignore the bad number*/ } try { return createLong(str); } catch (final NumberFormatException nfe) { /* NOPMD*/ /* ignore the bad number*/ } return createBigInteger(str); }
* * <p> * Integral values with a leading {@code 0} will be interpreted as octal; the returned number will * be Integer, Long or BigDecimal as appropriate. * </p> * * <p>Returns <code>null</code> if the string is <code>null</code>.</p> * * <p>This method does not trim the input string, i.e., strings with leading * or trailing spaces will generate NumberFormatExceptions.</p> * * @param str  String containing a number, may be null * @return Number created from the string (or null if the input is null) * @throws NumberFormatException if the value cannot be converted /*Must be a Float, Double, BigDecimal*/ <BUGS> final boolean allZeros = isAllZeros(mant) && isAllZeros(exp); <BUGE> try { final Float f = createFloat(str); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { return f; } } catch (final NumberFormatException nfe) { /* NOPMD*/ /* ignore the bad number*/ } try { final Double d = createDouble(str); if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) { return d; } } catch (final NumberFormatException nfe) { /* NOPMD*/
* <p> * Integral values with a leading {@code 0} will be interpreted as octal; the returned number will * be Integer, Long or BigDecimal as appropriate. * </p> * * <p>Returns <code>null</code> if the string is <code>null</code>.</p> * * <p>This method does not trim the input string, i.e., strings with leading * or trailing spaces will generate NumberFormatExceptions.</p> * * @param str  String containing a number, may be null * @return Number created from the string (or null if the input is null) * @throws NumberFormatException if the value cannot be converted try { <BUGS> final Float f = createFloat(str); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { return f; <BUGE> } } catch (final NumberFormatException nfe) { /* NOPMD*/ /* ignore the bad number*/ } try { final Double d = createDouble(str); if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) { return d; } } catch (final NumberFormatException nfe) { /* NOPMD*/ /* ignore the bad number*/ }
@Override public int translate(final CharSequence input, final int index, final Writer out) throws IOException { <BUGS> int max = longest; if (index + longest > input.length()) { <BUGE> max = input.length() - index; } /* descend so as to get a greedy algorithm*/ for (int i = max; i >= shortest; i--) { final CharSequence subSeq = input.subSequence(index, index + i); final CharSequence result = lookupMap.get(subSeq); if (result != null) { out.write(result.toString()); return i; } } return 0; }
@Override public int translate(final CharSequence input, final int index, final Writer out) throws IOException { int max = longest; if (index + longest > input.length()) { max = input.length() - index; } /* descend so as to get a greedy algorithm*/ <BUGS> for (int i = max; i >= shortest; i--) { final CharSequence subSeq = input.subSequence(index, index + i); final CharSequence result = lookupMap.get(subSeq); if (result != null) { <BUGE> out.write(result.toString()); return i; } } return 0; }
@Override public int translate(final CharSequence input, final int index, final Writer out) throws IOException { int max = longest; if (index + longest > input.length()) { max = input.length() - index; } /* descend so as to get a greedy algorithm*/ for (int i = max; i >= shortest; i--) { final CharSequence subSeq = input.subSequence(index, index + i); final CharSequence result = lookupMap.get(subSeq); if (result != null) { out.write(result.toString()); return i; } } <BUGS> return 0; <BUGE> }
*/ public static Locale toLocale(final String str) { <BUGS> if (str == null) { <BUGE> return null; } final int len = str.length(); if (len < 2) { throw new IllegalArgumentException("Invalid locale format: " + str); } final char ch0 = str.charAt(0); final char ch1 = str.charAt(1); if (!Character.isLowerCase(ch0) || !Character.isLowerCase(ch1)) { throw new IllegalArgumentException("Invalid locale format: " + str); } if (len == 2) { return new Locale(str); } if (len < 5) { throw new IllegalArgumentException("Invalid locale format: " + str); } if (str.charAt(2) != '_') { throw new IllegalArgumentException("Invalid locale format: " + str); } final char ch3 = str.charAt(3); if (ch3 == '_') { return new Locale(str.substring(0, 2), "", str.substring(4)); } final char ch4 = str.charAt(4); if (!Character.isUpperCase(ch3) || !Character.isUpperCase(ch4)) { throw new IllegalArgumentException("Invalid locale format: " + str);
*/ public static Locale toLocale(final String str) { if (str == null) { return null; } <BUGS> final int len = str.length(); if (len < 2) { <BUGE> throw new IllegalArgumentException("Invalid locale format: " + str); } final char ch0 = str.charAt(0); final char ch1 = str.charAt(1); if (!Character.isLowerCase(ch0) || !Character.isLowerCase(ch1)) { throw new IllegalArgumentException("Invalid locale format: " + str); } if (len == 2) { return new Locale(str); } if (len < 5) { throw new IllegalArgumentException("Invalid locale format: " + str); } if (str.charAt(2) != '_') { throw new IllegalArgumentException("Invalid locale format: " + str); } final char ch3 = str.charAt(3); if (ch3 == '_') { return new Locale(str.substring(0, 2), "", str.substring(4)); } final char ch4 = str.charAt(4); if (!Character.isUpperCase(ch3) || !Character.isUpperCase(ch4)) { throw new IllegalArgumentException("Invalid locale format: " + str);
*/ public static Locale toLocale(final String str) { if (str == null) { return null; } final int len = str.length(); if (len < 2) { throw new IllegalArgumentException("Invalid locale format: " + str); } <BUGS> final char ch0 = str.charAt(0); final char ch1 = str.charAt(1); if (!Character.isLowerCase(ch0) || !Character.isLowerCase(ch1)) { throw new IllegalArgumentException("Invalid locale format: " + str); <BUGE> } if (len == 2) { return new Locale(str); } if (len < 5) { throw new IllegalArgumentException("Invalid locale format: " + str); } if (str.charAt(2) != '_') { throw new IllegalArgumentException("Invalid locale format: " + str); } final char ch3 = str.charAt(3); if (ch3 == '_') { return new Locale(str.substring(0, 2), "", str.substring(4)); } final char ch4 = str.charAt(4); if (!Character.isUpperCase(ch3) || !Character.isUpperCase(ch4)) { throw new IllegalArgumentException("Invalid locale format: " + str);
*/ public static final String escapeCsv(String input) { <BUGS> return ESCAPE_CSV.translate(input); <BUGE> }
*/ public static Number createNumber(String str) throws NumberFormatException { <BUGS> if (str == null) { return null; <BUGE> } if (StringUtils.isBlank(str)) { throw new NumberFormatException("A blank string is not a valid number"); } if (str.startsWith("--")) { return null; } if (str.startsWith("0x") || str.startsWith("-0x") || str.startsWith("0X") || str.startsWith("-0X")) { int hexDigits = str.length() - 2; /* drop 0x*/ if (str.startsWith("-")) { /* drop -*/ hexDigits--; } if (hexDigits > 8) { /* too many for an int*/ return createLong(str); } return createInteger(str); } char lastChar = str.charAt(str.length() - 1); String mant; String dec; String exp; int decPos = str.indexOf('.'); int expPos = str.indexOf('e') + str.indexOf('E') + 1;  if (decPos > -1) {
*/ public static Number createNumber(String str) throws NumberFormatException { if (str == null) { return null; } <BUGS> if (StringUtils.isBlank(str)) { <BUGE> throw new NumberFormatException("A blank string is not a valid number"); } if (str.startsWith("--")) { return null; } if (str.startsWith("0x") || str.startsWith("-0x") || str.startsWith("0X") || str.startsWith("-0X")) { int hexDigits = str.length() - 2; /* drop 0x*/ if (str.startsWith("-")) { /* drop -*/ hexDigits--; } if (hexDigits > 8) { /* too many for an int*/ return createLong(str); } return createInteger(str); } char lastChar = str.charAt(str.length() - 1); String mant; String dec; String exp; int decPos = str.indexOf('.'); int expPos = str.indexOf('e') + str.indexOf('E') + 1;  if (decPos > -1) {
*/ public static Number createNumber(String str) throws NumberFormatException { if (str == null) { return null; } if (StringUtils.isBlank(str)) { throw new NumberFormatException("A blank string is not a valid number"); } <BUGS> if (str.startsWith("--")) { return null; <BUGE> } if (str.startsWith("0x") || str.startsWith("-0x") || str.startsWith("0X") || str.startsWith("-0X")) { int hexDigits = str.length() - 2; /* drop 0x*/ if (str.startsWith("-")) { /* drop -*/ hexDigits--; } if (hexDigits > 8) { /* too many for an int*/ return createLong(str); } return createInteger(str); } char lastChar = str.charAt(str.length() - 1); String mant; String dec; String exp; int decPos = str.indexOf('.'); int expPos = str.indexOf('e') + str.indexOf('E') + 1;  if (decPos > -1) {
*/ public static Number createNumber(String str) throws NumberFormatException { if (str == null) { return null; } if (StringUtils.isBlank(str)) { throw new NumberFormatException("A blank string is not a valid number"); } if (str.startsWith("--")) { return null; } <BUGS> if (str.startsWith("0x") || str.startsWith("-0x") || str.startsWith("0X") || str.startsWith("-0X")) { int hexDigits = str.length() - 2; /* drop 0x*/ if (str.startsWith("-")) { /* drop -*/ hexDigits--; <BUGE> } if (hexDigits > 8) { /* too many for an int*/ return createLong(str); } return createInteger(str); } char lastChar = str.charAt(str.length() - 1); String mant; String dec; String exp; int decPos = str.indexOf('.'); int expPos = str.indexOf('e') + str.indexOf('E') + 1;  if (decPos > -1) {
*/ public static Number createNumber(String str) throws NumberFormatException { if (str == null) { return null; } if (StringUtils.isBlank(str)) { throw new NumberFormatException("A blank string is not a valid number"); } if (str.startsWith("--")) { return null; } if (str.startsWith("0x") || str.startsWith("-0x") || str.startsWith("0X") || str.startsWith("-0X")) { int hexDigits = str.length() - 2; /* drop 0x*/ if (str.startsWith("-")) { /* drop -*/ hexDigits--; } <BUGS> if (hexDigits > 8) { /* too many for an int <BUGE>*/ return createLong(str); } return createInteger(str); } char lastChar = str.charAt(str.length() - 1); String mant; String dec; String exp; int decPos = str.indexOf('.'); int expPos = str.indexOf('e') + str.indexOf('E') + 1;  if (decPos > -1) {
*/ public static Number createNumber(String str) throws NumberFormatException { if (str == null) { return null; } if (StringUtils.isBlank(str)) { throw new NumberFormatException("A blank string is not a valid number"); } if (str.startsWith("--")) { return null; } if (str.startsWith("0x") || str.startsWith("-0x") || str.startsWith("0X") || str.startsWith("-0X")) { int hexDigits = str.length() - 2; /* drop 0x*/ if (str.startsWith("-")) { /* drop -*/ hexDigits--; } if (hexDigits > 8) { /* too many for an int*/ return createLong(str); } <BUGS> return createInteger(str); <BUGE> } char lastChar = str.charAt(str.length() - 1); String mant; String dec; String exp; int decPos = str.indexOf('.'); int expPos = str.indexOf('e') + str.indexOf('E') + 1;  if (decPos > -1) {
*/ public static Number createNumber(String str) throws NumberFormatException { if (str == null) { return null; } if (StringUtils.isBlank(str)) { throw new NumberFormatException("A blank string is not a valid number"); } if (str.startsWith("--")) { return null; } if (str.startsWith("0x") || str.startsWith("-0x") || str.startsWith("0X") || str.startsWith("-0X")) { int hexDigits = str.length() - 2; /* drop 0x*/ if (str.startsWith("-")) { /* drop -*/ hexDigits--; } if (hexDigits > 8) { /* too many for an int*/ return createLong(str); } return createInteger(str); } <BUGS> char lastChar = str.charAt(str.length() - 1); <BUGE> String mant; String dec; String exp; int decPos = str.indexOf('.'); int expPos = str.indexOf('e') + str.indexOf('E') + 1;  if (decPos > -1) {
*/ public static Number createNumber(String str) throws NumberFormatException { if (str == null) { return null; } if (StringUtils.isBlank(str)) { throw new NumberFormatException("A blank string is not a valid number"); } if (str.startsWith("--")) { return null; } if (str.startsWith("0x") || str.startsWith("-0x") || str.startsWith("0X") || str.startsWith("-0X")) { int hexDigits = str.length() - 2; /* drop 0x*/ if (str.startsWith("-")) { /* drop -*/ hexDigits--; } if (hexDigits > 8) { /* too many for an int*/ return createLong(str); } return createInteger(str); } char lastChar = str.charAt(str.length() - 1); String mant; String dec; String exp; <BUGS> int decPos = str.indexOf('.'); int expPos = str.indexOf('e') + str.indexOf('E') + 1; <BUGE>  if (decPos > -1) {
*/ public static Number createNumber(String str) throws NumberFormatException { if (str == null) { return null; } if (StringUtils.isBlank(str)) { throw new NumberFormatException("A blank string is not a valid number"); } if (str.startsWith("--")) { return null; } if (str.startsWith("0x") || str.startsWith("-0x") || str.startsWith("0X") || str.startsWith("-0X")) { int hexDigits = str.length() - 2; /* drop 0x*/ if (str.startsWith("-")) { /* drop -*/ hexDigits--; } if (hexDigits > 8) { /* too many for an int*/ return createLong(str); } return createInteger(str); } char lastChar = str.charAt(str.length() - 1); String mant; String dec; String exp; int decPos = str.indexOf('.'); int expPos = str.indexOf('e') + str.indexOf('E') + 1;  <BUGS> if (decPos > -1) { <BUGE>
* * <p>If a type specifier is not found, it will check for a decimal point * and then try successively larger types from <code>Integer</code> to * <code>BigInteger</code> and from <code>Float</code> to * <code>BigDecimal</code>.</p> * * <p>Returns <code>null</code> if the string is <code>null</code>.</p> * * <p>This method does not trim the input string, i.e., strings with leading * or trailing spaces will generate NumberFormatExceptions.</p> * * @param str  String containing a number, may be null * @return Number created from the string (or null if the input is null) * @throws NumberFormatException if the value cannot be converted  <BUGS> if (expPos > -1) { if (expPos < decPos || expPos > str.length()) { <BUGE> throw new NumberFormatException(str + " is not a valid number."); } dec = str.substring(decPos + 1, expPos); } else { dec = str.substring(decPos + 1); } mant = str.substring(0, decPos); } else { if (expPos > -1) { if (expPos > str.length()) { throw new NumberFormatException(str + " is not a valid number."); } mant = str.substring(0, expPos);
* * <p>If a type specifier is not found, it will check for a decimal point * and then try successively larger types from <code>Integer</code> to * <code>BigInteger</code> and from <code>Float</code> to * <code>BigDecimal</code>.</p> * * <p>Returns <code>null</code> if the string is <code>null</code>.</p> * * <p>This method does not trim the input string, i.e., strings with leading * or trailing spaces will generate NumberFormatExceptions.</p> * * @param str  String containing a number, may be null * @return Number created from the string (or null if the input is null) * @throws NumberFormatException if the value cannot be converted } <BUGS> dec = str.substring(decPos + 1, expPos); <BUGE> } else { dec = str.substring(decPos + 1); } mant = str.substring(0, decPos); } else { if (expPos > -1) { if (expPos > str.length()) { throw new NumberFormatException(str + " is not a valid number."); } mant = str.substring(0, expPos); } else { mant = str; } dec = null;
* * <p>If a type specifier is not found, it will check for a decimal point * and then try successively larger types from <code>Integer</code> to * <code>BigInteger</code> and from <code>Float</code> to * <code>BigDecimal</code>.</p> * * <p>Returns <code>null</code> if the string is <code>null</code>.</p> * * <p>This method does not trim the input string, i.e., strings with leading * or trailing spaces will generate NumberFormatExceptions.</p> * * @param str  String containing a number, may be null * @return Number created from the string (or null if the input is null) * @throws NumberFormatException if the value cannot be converted } else { <BUGS> dec = str.substring(decPos + 1); <BUGE> } mant = str.substring(0, decPos); } else { if (expPos > -1) { if (expPos > str.length()) { throw new NumberFormatException(str + " is not a valid number."); } mant = str.substring(0, expPos); } else { mant = str; } dec = null; } if (!Character.isDigit(lastChar) && lastChar != '.') {
* * <p>If a type specifier is not found, it will check for a decimal point * and then try successively larger types from <code>Integer</code> to * <code>BigInteger</code> and from <code>Float</code> to * <code>BigDecimal</code>.</p> * * <p>Returns <code>null</code> if the string is <code>null</code>.</p> * * <p>This method does not trim the input string, i.e., strings with leading * or trailing spaces will generate NumberFormatExceptions.</p> * * @param str  String containing a number, may be null * @return Number created from the string (or null if the input is null) * @throws NumberFormatException if the value cannot be converted } <BUGS> mant = str.substring(0, decPos); <BUGE> } else { if (expPos > -1) { if (expPos > str.length()) { throw new NumberFormatException(str + " is not a valid number."); } mant = str.substring(0, expPos); } else { mant = str; } dec = null; } if (!Character.isDigit(lastChar) && lastChar != '.') { if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length() - 1);
* <p>If a type specifier is not found, it will check for a decimal point * and then try successively larger types from <code>Integer</code> to * <code>BigInteger</code> and from <code>Float</code> to * <code>BigDecimal</code>.</p> * * <p>Returns <code>null</code> if the string is <code>null</code>.</p> * * <p>This method does not trim the input string, i.e., strings with leading * or trailing spaces will generate NumberFormatExceptions.</p> * * @param str  String containing a number, may be null * @return Number created from the string (or null if the input is null) * @throws NumberFormatException if the value cannot be converted } else { <BUGS> if (expPos > -1) { if (expPos > str.length()) { throw new NumberFormatException(str + " is not a valid number."); <BUGE> } mant = str.substring(0, expPos); } else { mant = str; } dec = null; } if (!Character.isDigit(lastChar) && lastChar != '.') { if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length() - 1); } else { exp = null; }
* * <p>If a type specifier is not found, it will check for a decimal point * and then try successively larger types from <code>Integer</code> to * <code>BigInteger</code> and from <code>Float</code> to * <code>BigDecimal</code>.</p> * * <p>Returns <code>null</code> if the string is <code>null</code>.</p> * * <p>This method does not trim the input string, i.e., strings with leading * or trailing spaces will generate NumberFormatExceptions.</p> * * @param str  String containing a number, may be null * @return Number created from the string (or null if the input is null) * @throws NumberFormatException if the value cannot be converted } else { <BUGS> mant = str; <BUGE> } dec = null; } if (!Character.isDigit(lastChar) && lastChar != '.') { if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length() - 1); } else { exp = null; } /*Requesting a specific type..*/ String numeric = str.substring(0, str.length() - 1); boolean allZeros = isAllZeros(mant) && isAllZeros(exp); switch (lastChar) { case 'l' :
* * <p>If a type specifier is not found, it will check for a decimal point * and then try successively larger types from <code>Integer</code> to * <code>BigInteger</code> and from <code>Float</code> to * <code>BigDecimal</code>.</p> * * <p>Returns <code>null</code> if the string is <code>null</code>.</p> * * <p>This method does not trim the input string, i.e., strings with leading * or trailing spaces will generate NumberFormatExceptions.</p> * * @param str  String containing a number, may be null * @return Number created from the string (or null if the input is null) * @throws NumberFormatException if the value cannot be converted } <BUGS> dec = null; <BUGE> } if (!Character.isDigit(lastChar) && lastChar != '.') { if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length() - 1); } else { exp = null; } /*Requesting a specific type..*/ String numeric = str.substring(0, str.length() - 1); boolean allZeros = isAllZeros(mant) && isAllZeros(exp); switch (lastChar) { case 'l' : case 'L' : if (dec == null
* <p>If a type specifier is not found, it will check for a decimal point * and then try successively larger types from <code>Integer</code> to * <code>BigInteger</code> and from <code>Float</code> to * <code>BigDecimal</code>.</p> * * <p>Returns <code>null</code> if the string is <code>null</code>.</p> * * <p>This method does not trim the input string, i.e., strings with leading * or trailing spaces will generate NumberFormatExceptions.</p> * * @param str  String containing a number, may be null * @return Number created from the string (or null if the input is null) * @throws NumberFormatException if the value cannot be converted } <BUGS> if (!Character.isDigit(lastChar) && lastChar != '.') { if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length() - 1); <BUGE> } else { exp = null; } /*Requesting a specific type..*/ String numeric = str.substring(0, str.length() - 1); boolean allZeros = isAllZeros(mant) && isAllZeros(exp); switch (lastChar) { case 'l' : case 'L' : if (dec == null && exp == null && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) { try {
* * <p>If a type specifier is not found, it will check for a decimal point * and then try successively larger types from <code>Integer</code> to * <code>BigInteger</code> and from <code>Float</code> to * <code>BigDecimal</code>.</p> * * <p>Returns <code>null</code> if the string is <code>null</code>.</p> * * <p>This method does not trim the input string, i.e., strings with leading * or trailing spaces will generate NumberFormatExceptions.</p> * * @param str  String containing a number, may be null * @return Number created from the string (or null if the input is null) * @throws NumberFormatException if the value cannot be converted } else { <BUGS> exp = null; <BUGE> } /*Requesting a specific type..*/ String numeric = str.substring(0, str.length() - 1); boolean allZeros = isAllZeros(mant) && isAllZeros(exp); switch (lastChar) { case 'l' : case 'L' : if (dec == null && exp == null && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) { try { return createLong(numeric); } catch (NumberFormatException nfe) { /* NOPMD*/ /* Too big for a long*/
* <p>If a type specifier is not found, it will check for a decimal point * and then try successively larger types from <code>Integer</code> to * <code>BigInteger</code> and from <code>Float</code> to * <code>BigDecimal</code>.</p> * * <p>Returns <code>null</code> if the string is <code>null</code>.</p> * * <p>This method does not trim the input string, i.e., strings with leading * or trailing spaces will generate NumberFormatExceptions.</p> * * @param str  String containing a number, may be null * @return Number created from the string (or null if the input is null) * @throws NumberFormatException if the value cannot be converted /*Requesting a specific type..*/ <BUGS> String numeric = str.substring(0, str.length() - 1); boolean allZeros = isAllZeros(mant) && isAllZeros(exp); switch (lastChar) { <BUGE> case 'l' : case 'L' : if (dec == null && exp == null && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) { try { return createLong(numeric); } catch (NumberFormatException nfe) { /* NOPMD*/ /* Too big for a long*/ } return createBigInteger(numeric);  }
* * <p>If a type specifier is not found, it will check for a decimal point * and then try successively larger types from <code>Integer</code> to * <code>BigInteger</code> and from <code>Float</code> to * <code>BigDecimal</code>.</p> * * <p>Returns <code>null</code> if the string is <code>null</code>.</p> * * <p>This method does not trim the input string, i.e., strings with leading * or trailing spaces will generate NumberFormatExceptions.</p> * * @param str  String containing a number, may be null * @return Number created from the string (or null if the input is null) * @throws NumberFormatException if the value cannot be converted case 'L' : <BUGS> if (dec == null <BUGE> && exp == null && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) { try { return createLong(numeric); } catch (NumberFormatException nfe) { /* NOPMD*/ /* Too big for a long*/ } return createBigInteger(numeric);  } throw new NumberFormatException(str + " is not a valid number."); case 'f' : case 'F' : try {
* * <p>If a type specifier is not found, it will check for a decimal point * and then try successively larger types from <code>Integer</code> to * <code>BigInteger</code> and from <code>Float</code> to * <code>BigDecimal</code>.</p> * * <p>Returns <code>null</code> if the string is <code>null</code>.</p> * * <p>This method does not trim the input string, i.e., strings with leading * or trailing spaces will generate NumberFormatExceptions.</p> * * @param str  String containing a number, may be null * @return Number created from the string (or null if the input is null) * @throws NumberFormatException if the value cannot be converted try { <BUGS> return createLong(numeric); } catch (NumberFormatException nfe) { /* NOPMD <BUGE>*/ /* Too big for a long*/ } return createBigInteger(numeric);  } throw new NumberFormatException(str + " is not a valid number."); case 'f' : case 'F' : try { Float f = NumberUtils.createFloat(numeric); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { /*If it's too big for a float or the float value = 0 and the string*/ /*has non-zeros in it, then float does not have the precision we want*/
* * <p>If a type specifier is not found, it will check for a decimal point * and then try successively larger types from <code>Integer</code> to * <code>BigInteger</code> and from <code>Float</code> to * <code>BigDecimal</code>.</p> * * <p>Returns <code>null</code> if the string is <code>null</code>.</p> * * <p>This method does not trim the input string, i.e., strings with leading * or trailing spaces will generate NumberFormatExceptions.</p> * * @param str  String containing a number, may be null * @return Number created from the string (or null if the input is null) * @throws NumberFormatException if the value cannot be converted } <BUGS> return createBigInteger(numeric); <BUGE>  } throw new NumberFormatException(str + " is not a valid number."); case 'f' : case 'F' : try { Float f = NumberUtils.createFloat(numeric); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { /*If it's too big for a float or the float value = 0 and the string*/ /*has non-zeros in it, then float does not have the precision we want*/ return f; }  } catch (NumberFormatException nfe) { /* NOPMD*/
* * <p>If a type specifier is not found, it will check for a decimal point * and then try successively larger types from <code>Integer</code> to * <code>BigInteger</code> and from <code>Float</code> to * <code>BigDecimal</code>.</p> * * <p>Returns <code>null</code> if the string is <code>null</code>.</p> * * <p>This method does not trim the input string, i.e., strings with leading * or trailing spaces will generate NumberFormatExceptions.</p> * * @param str  String containing a number, may be null * @return Number created from the string (or null if the input is null) * @throws NumberFormatException if the value cannot be converted try { <BUGS> Float f = NumberUtils.createFloat(numeric); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { <BUGE> /*If it's too big for a float or the float value = 0 and the string*/ /*has non-zeros in it, then float does not have the precision we want*/ return f; }  } catch (NumberFormatException nfe) { /* NOPMD*/ /* ignore the bad number*/ } /*$FALL-THROUGH$*/ case 'd' : case 'D' : try { Double d = NumberUtils.createDouble(numeric);
* * <p>If a type specifier is not found, it will check for a decimal point * and then try successively larger types from <code>Integer</code> to * <code>BigInteger</code> and from <code>Float</code> to * <code>BigDecimal</code>.</p> * * <p>Returns <code>null</code> if the string is <code>null</code>.</p> * * <p>This method does not trim the input string, i.e., strings with leading * or trailing spaces will generate NumberFormatExceptions.</p> * * @param str  String containing a number, may be null * @return Number created from the string (or null if the input is null) * @throws NumberFormatException if the value cannot be converted /*has non-zeros in it, then float does not have the precision we want*/ <BUGS> return f; <BUGE> }  } catch (NumberFormatException nfe) { /* NOPMD*/ /* ignore the bad number*/ } /*$FALL-THROUGH$*/ case 'd' : case 'D' : try { Double d = NumberUtils.createDouble(numeric); if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { /* NOPMD*/
* * <p>If a type specifier is not found, it will check for a decimal point * and then try successively larger types from <code>Integer</code> to * <code>BigInteger</code> and from <code>Float</code> to * <code>BigDecimal</code>.</p> * * <p>Returns <code>null</code> if the string is <code>null</code>.</p> * * <p>This method does not trim the input string, i.e., strings with leading * or trailing spaces will generate NumberFormatExceptions.</p> * * @param str  String containing a number, may be null * @return Number created from the string (or null if the input is null) * @throws NumberFormatException if the value cannot be converted /* ignore the bad number*/ <BUGS> } <BUGE> /*$FALL-THROUGH$*/ case 'd' : case 'D' : try { Double d = NumberUtils.createDouble(numeric); if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { /* NOPMD*/ /* ignore the bad number*/ } try { return createBigDecimal(numeric); } catch (NumberFormatException e) { /* NOPMD*/
* <p>If a type specifier is not found, it will check for a decimal point * and then try successively larger types from <code>Integer</code> to * <code>BigInteger</code> and from <code>Float</code> to * <code>BigDecimal</code>.</p> * * <p>Returns <code>null</code> if the string is <code>null</code>.</p> * * <p>This method does not trim the input string, i.e., strings with leading * or trailing spaces will generate NumberFormatExceptions.</p> * * @param str  String containing a number, may be null * @return Number created from the string (or null if the input is null) * @throws NumberFormatException if the value cannot be converted try { <BUGS> Double d = NumberUtils.createDouble(numeric); if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) { return d; <BUGE> } } catch (NumberFormatException nfe) { /* NOPMD*/ /* ignore the bad number*/ } try { return createBigDecimal(numeric); } catch (NumberFormatException e) { /* NOPMD*/ /* ignore the bad number*/ } /*$FALL-THROUGH$*/ default : throw new NumberFormatException(str + " is not a valid number.");
* * <p>If a type specifier is not found, it will check for a decimal point * and then try successively larger types from <code>Integer</code> to * <code>BigInteger</code> and from <code>Float</code> to * <code>BigDecimal</code>.</p> * * <p>Returns <code>null</code> if the string is <code>null</code>.</p> * * <p>This method does not trim the input string, i.e., strings with leading * or trailing spaces will generate NumberFormatExceptions.</p> * * @param str  String containing a number, may be null * @return Number created from the string (or null if the input is null) * @throws NumberFormatException if the value cannot be converted /* ignore the bad number*/ <BUGS> } <BUGE> try { return createBigDecimal(numeric); } catch (NumberFormatException e) { /* NOPMD*/ /* ignore the bad number*/ } /*$FALL-THROUGH$*/ default : throw new NumberFormatException(str + " is not a valid number.");  } } else { /*User doesn't have a preference on the return type, so let's start*/ /*small and go from there...*/ if (expPos > -1 && expPos < str.length() - 1) {
* * <p>If a type specifier is not found, it will check for a decimal point * and then try successively larger types from <code>Integer</code> to * <code>BigInteger</code> and from <code>Float</code> to * <code>BigDecimal</code>.</p> * * <p>Returns <code>null</code> if the string is <code>null</code>.</p> * * <p>This method does not trim the input string, i.e., strings with leading * or trailing spaces will generate NumberFormatExceptions.</p> * * @param str  String containing a number, may be null * @return Number created from the string (or null if the input is null) * @throws NumberFormatException if the value cannot be converted try { <BUGS> return createBigDecimal(numeric); <BUGE> } catch (NumberFormatException e) { /* NOPMD*/ /* ignore the bad number*/ } /*$FALL-THROUGH$*/ default : throw new NumberFormatException(str + " is not a valid number.");  } } else { /*User doesn't have a preference on the return type, so let's start*/ /*small and go from there...*/ if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length()); } else {
* * <p>If a type specifier is not found, it will check for a decimal point * and then try successively larger types from <code>Integer</code> to * <code>BigInteger</code> and from <code>Float</code> to * <code>BigDecimal</code>.</p> * * <p>Returns <code>null</code> if the string is <code>null</code>.</p> * * <p>This method does not trim the input string, i.e., strings with leading * or trailing spaces will generate NumberFormatExceptions.</p> * * @param str  String containing a number, may be null * @return Number created from the string (or null if the input is null) * @throws NumberFormatException if the value cannot be converted /*small and go from there...*/ <BUGS> if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length()); <BUGE> } else { exp = null; } if (dec == null && exp == null) { /*Must be an int,long,bigint*/ try { return createInteger(str); } catch (NumberFormatException nfe) { /* NOPMD*/ /* ignore the bad number*/ } try { return createLong(str); } catch (NumberFormatException nfe) { /* NOPMD*/
* * <p>If a type specifier is not found, it will check for a decimal point * and then try successively larger types from <code>Integer</code> to * <code>BigInteger</code> and from <code>Float</code> to * <code>BigDecimal</code>.</p> * * <p>Returns <code>null</code> if the string is <code>null</code>.</p> * * <p>This method does not trim the input string, i.e., strings with leading * or trailing spaces will generate NumberFormatExceptions.</p> * * @param str  String containing a number, may be null * @return Number created from the string (or null if the input is null) * @throws NumberFormatException if the value cannot be converted } else { <BUGS> exp = null; <BUGE> } if (dec == null && exp == null) { /*Must be an int,long,bigint*/ try { return createInteger(str); } catch (NumberFormatException nfe) { /* NOPMD*/ /* ignore the bad number*/ } try { return createLong(str); } catch (NumberFormatException nfe) { /* NOPMD*/ /* ignore the bad number*/ } return createBigInteger(str);
* * <p>If a type specifier is not found, it will check for a decimal point * and then try successively larger types from <code>Integer</code> to * <code>BigInteger</code> and from <code>Float</code> to * <code>BigDecimal</code>.</p> * * <p>Returns <code>null</code> if the string is <code>null</code>.</p> * * <p>This method does not trim the input string, i.e., strings with leading * or trailing spaces will generate NumberFormatExceptions.</p> * * @param str  String containing a number, may be null * @return Number created from the string (or null if the input is null) * @throws NumberFormatException if the value cannot be converted } <BUGS> if (dec == null && exp == null) { <BUGE> /*Must be an int,long,bigint*/ try { return createInteger(str); } catch (NumberFormatException nfe) { /* NOPMD*/ /* ignore the bad number*/ } try { return createLong(str); } catch (NumberFormatException nfe) { /* NOPMD*/ /* ignore the bad number*/ } return createBigInteger(str);  } else {
* * <p>If a type specifier is not found, it will check for a decimal point * and then try successively larger types from <code>Integer</code> to * <code>BigInteger</code> and from <code>Float</code> to * <code>BigDecimal</code>.</p> * * <p>Returns <code>null</code> if the string is <code>null</code>.</p> * * <p>This method does not trim the input string, i.e., strings with leading * or trailing spaces will generate NumberFormatExceptions.</p> * * @param str  String containing a number, may be null * @return Number created from the string (or null if the input is null) * @throws NumberFormatException if the value cannot be converted try { <BUGS> return createInteger(str); } catch (NumberFormatException nfe) { /* NOPMD <BUGE>*/ /* ignore the bad number*/ } try { return createLong(str); } catch (NumberFormatException nfe) { /* NOPMD*/ /* ignore the bad number*/ } return createBigInteger(str);  } else { /*Must be a float,double,BigDec*/ boolean allZeros = isAllZeros(mant) && isAllZeros(exp); try {
* * <p>If a type specifier is not found, it will check for a decimal point * and then try successively larger types from <code>Integer</code> to * <code>BigInteger</code> and from <code>Float</code> to * <code>BigDecimal</code>.</p> * * <p>Returns <code>null</code> if the string is <code>null</code>.</p> * * <p>This method does not trim the input string, i.e., strings with leading * or trailing spaces will generate NumberFormatExceptions.</p> * * @param str  String containing a number, may be null * @return Number created from the string (or null if the input is null) * @throws NumberFormatException if the value cannot be converted try { <BUGS> return createLong(str); } catch (NumberFormatException nfe) { /* NOPMD <BUGE>*/ /* ignore the bad number*/ } return createBigInteger(str);  } else { /*Must be a float,double,BigDec*/ boolean allZeros = isAllZeros(mant) && isAllZeros(exp); try { Float f = createFloat(str); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { return f; } } catch (NumberFormatException nfe) { /* NOPMD*/
* * <p>If a type specifier is not found, it will check for a decimal point * and then try successively larger types from <code>Integer</code> to * <code>BigInteger</code> and from <code>Float</code> to * <code>BigDecimal</code>.</p> * * <p>Returns <code>null</code> if the string is <code>null</code>.</p> * * <p>This method does not trim the input string, i.e., strings with leading * or trailing spaces will generate NumberFormatExceptions.</p> * * @param str  String containing a number, may be null * @return Number created from the string (or null if the input is null) * @throws NumberFormatException if the value cannot be converted } <BUGS> return createBigInteger(str); <BUGE>  } else { /*Must be a float,double,BigDec*/ boolean allZeros = isAllZeros(mant) && isAllZeros(exp); try { Float f = createFloat(str); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { return f; } } catch (NumberFormatException nfe) { /* NOPMD*/ /* ignore the bad number*/ } try { Double d = createDouble(str);
* * <p>If a type specifier is not found, it will check for a decimal point * and then try successively larger types from <code>Integer</code> to * <code>BigInteger</code> and from <code>Float</code> to * <code>BigDecimal</code>.</p> * * <p>Returns <code>null</code> if the string is <code>null</code>.</p> * * <p>This method does not trim the input string, i.e., strings with leading * or trailing spaces will generate NumberFormatExceptions.</p> * * @param str  String containing a number, may be null * @return Number created from the string (or null if the input is null) * @throws NumberFormatException if the value cannot be converted /*Must be a float,double,BigDec*/ <BUGS> boolean allZeros = isAllZeros(mant) && isAllZeros(exp); <BUGE> try { Float f = createFloat(str); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { return f; } } catch (NumberFormatException nfe) { /* NOPMD*/ /* ignore the bad number*/ } try { Double d = createDouble(str); if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { /* NOPMD*/
* <p>If a type specifier is not found, it will check for a decimal point * and then try successively larger types from <code>Integer</code> to * <code>BigInteger</code> and from <code>Float</code> to * <code>BigDecimal</code>.</p> * * <p>Returns <code>null</code> if the string is <code>null</code>.</p> * * <p>This method does not trim the input string, i.e., strings with leading * or trailing spaces will generate NumberFormatExceptions.</p> * * @param str  String containing a number, may be null * @return Number created from the string (or null if the input is null) * @throws NumberFormatException if the value cannot be converted try { <BUGS> Float f = createFloat(str); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { return f; <BUGE> } } catch (NumberFormatException nfe) { /* NOPMD*/ /* ignore the bad number*/ } try { Double d = createDouble(str); if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { /* NOPMD*/ /* ignore the bad number*/ }
* * <p>If a type specifier is not found, it will check for a decimal point * and then try successively larger types from <code>Integer</code> to * <code>BigInteger</code> and from <code>Float</code> to * <code>BigDecimal</code>.</p> * * <p>Returns <code>null</code> if the string is <code>null</code>.</p> * * <p>This method does not trim the input string, i.e., strings with leading * or trailing spaces will generate NumberFormatExceptions.</p> * * @param str  String containing a number, may be null * @return Number created from the string (or null if the input is null) * @throws NumberFormatException if the value cannot be converted /* ignore the bad number*/ <BUGS> } <BUGE> try { Double d = createDouble(str); if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { /* NOPMD*/ /* ignore the bad number*/ }  return createBigDecimal(str);  } } }
* <p>If a type specifier is not found, it will check for a decimal point * and then try successively larger types from <code>Integer</code> to * <code>BigInteger</code> and from <code>Float</code> to * <code>BigDecimal</code>.</p> * * <p>Returns <code>null</code> if the string is <code>null</code>.</p> * * <p>This method does not trim the input string, i.e., strings with leading * or trailing spaces will generate NumberFormatExceptions.</p> * * @param str  String containing a number, may be null * @return Number created from the string (or null if the input is null) * @throws NumberFormatException if the value cannot be converted try { <BUGS> Double d = createDouble(str); if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) { return d; <BUGE> } } catch (NumberFormatException nfe) { /* NOPMD*/ /* ignore the bad number*/ }  return createBigDecimal(str);  } } }  /** * <p>Utility method for {@link #createNumber(java.lang.String)}.</p>
@Override public void appendTo(StringBuffer buffer, Calendar calendar) { int value = calendar.get(Calendar.HOUR); if (value == 0) { value = calendar.getLeastMaximum(Calendar.HOUR) + 1; } mRule.appendTo(buffer, value); }
@Override public void appendTo(StringBuffer buffer, Calendar calendar) { int value = calendar.get(Calendar.HOUR); if (value == 0) { value = calendar.getLeastMaximum(Calendar.HOUR) + 1; } mRule.appendTo(buffer, value); }
@Override public void appendTo(StringBuffer buffer, Calendar calendar) { int value = calendar.get(Calendar.HOUR); if (value == 0) { value = calendar.getLeastMaximum(Calendar.HOUR) + 1; } mRule.appendTo(buffer, value); }
@Override public void appendTo(StringBuffer buffer, Calendar calendar) { <BUGS> int value = calendar.get(Calendar.HOUR); if (value == 0) { <BUGE> value = calendar.getLeastMaximum(Calendar.HOUR) + 1; } mRule.appendTo(buffer, value); }
@Override public void appendTo(StringBuffer buffer, Calendar calendar) { int value = calendar.get(Calendar.HOUR); if (value == 0) { value = calendar.getLeastMaximum(Calendar.HOUR) + 1; } <BUGS> mRule.appendTo(buffer, value); } <BUGE>
@Override public void appendTo(StringBuffer buffer, Calendar calendar) { int value = calendar.get(Calendar.HOUR); if (value == 0) { value = calendar.getLeastMaximum(Calendar.HOUR) + 1; } mRule.appendTo(buffer, value); }
@Override public void appendTo(StringBuffer buffer, Calendar calendar) { int value = calendar.get(Calendar.HOUR); if (value == 0) { value = calendar.getLeastMaximum(Calendar.HOUR) + 1; } mRule.appendTo(buffer, value); }
@Override public void appendTo(StringBuffer buffer, Calendar calendar) { int value = calendar.get(Calendar.HOUR); if (value == 0) { value = calendar.getLeastMaximum(Calendar.HOUR) + 1; } mRule.appendTo(buffer, value); }
*/ public static String random(int count, int start, int end, boolean letters, boolean numbers, char[] chars, Random random) { <BUGS> if (count == 0) { <BUGE> return ""; } else if (count < 0) { throw new IllegalArgumentException("Requested random string length " + count + " is less than 0."); } if (chars != null && chars.length == 0) { throw new IllegalArgumentException("The chars array must not be empty"); }  if (start == 0 && end == 0) { if (chars != null) { end = chars.length; } else { if (!letters && !numbers) { end = Integer.MAX_VALUE; } else { end = 'z' + 1; start = ' '; } } }  char[] buffer = new char[count]; int gap = end - start;  while (count-- != 0) { char ch;
*/ public static String random(int count, int start, int end, boolean letters, boolean numbers, char[] chars, Random random) { if (count == 0) { return ""; <BUGS> } else if (count < 0) { <BUGE> throw new IllegalArgumentException("Requested random string length " + count + " is less than 0."); } if (chars != null && chars.length == 0) { throw new IllegalArgumentException("The chars array must not be empty"); }  if (start == 0 && end == 0) { if (chars != null) { end = chars.length; } else { if (!letters && !numbers) { end = Integer.MAX_VALUE; } else { end = 'z' + 1; start = ' '; } } }  char[] buffer = new char[count]; int gap = end - start;  while (count-- != 0) { char ch;
*/ public static String random(int count, int start, int end, boolean letters, boolean numbers, char[] chars, Random random) { if (count == 0) { return ""; } else if (count < 0) { throw new IllegalArgumentException("Requested random string length " + count + " is less than 0."); } <BUGS> if (chars != null && chars.length == 0) { <BUGE> throw new IllegalArgumentException("The chars array must not be empty"); }  if (start == 0 && end == 0) { if (chars != null) { end = chars.length; } else { if (!letters && !numbers) { end = Integer.MAX_VALUE; } else { end = 'z' + 1; start = ' '; } } }  char[] buffer = new char[count]; int gap = end - start;  while (count-- != 0) { char ch;
*/ public static String random(int count, int start, int end, boolean letters, boolean numbers, char[] chars, Random random) { if (count == 0) { return ""; } else if (count < 0) { throw new IllegalArgumentException("Requested random string length " + count + " is less than 0."); } if (chars != null && chars.length == 0) { throw new IllegalArgumentException("The chars array must not be empty"); }  <BUGS> if (start == 0 && end == 0) { <BUGE> if (chars != null) { end = chars.length; } else { if (!letters && !numbers) { end = Integer.MAX_VALUE; } else { end = 'z' + 1; start = ' '; } } }  char[] buffer = new char[count]; int gap = end - start;  while (count-- != 0) { char ch;
*/ public static String random(int count, int start, int end, boolean letters, boolean numbers, char[] chars, Random random) { if (count == 0) { return ""; } else if (count < 0) { throw new IllegalArgumentException("Requested random string length " + count + " is less than 0."); } if (chars != null && chars.length == 0) { throw new IllegalArgumentException("The chars array must not be empty"); }  if (start == 0 && end == 0) { if (chars != null) { end = chars.length; } else { if (!letters && !numbers) { end = Integer.MAX_VALUE; } else { end = 'z' + 1; start = ' '; } } }  <BUGS> char[] buffer = new char[count]; int gap = end - start; <BUGE>  while (count-- != 0) { char ch;
*/ public static String random(int count, int start, int end, boolean letters, boolean numbers, char[] chars, Random random) { if (count == 0) { return ""; } else if (count < 0) { throw new IllegalArgumentException("Requested random string length " + count + " is less than 0."); } if (chars != null && chars.length == 0) { throw new IllegalArgumentException("The chars array must not be empty"); }  if (start == 0 && end == 0) { if (chars != null) { end = chars.length; } else { if (!letters && !numbers) { end = Integer.MAX_VALUE; } else { end = 'z' + 1; start = ' '; } } }  char[] buffer = new char[count]; int gap = end - start;  <BUGS> while (count-- != 0) { <BUGE> char ch;
* * @param count  the length of random string to create * @param start  the position in set of chars to start at * @param end  the position in set of chars to end before * @param letters  only allow letters? * @param numbers  only allow numbers? * @param chars  the set of chars to choose randoms from, must not be empty. *  If {@code null}, then it will use the set of all chars. * @param random  a source of randomness. * @return the random string * @throws ArrayIndexOutOfBoundsException if there are not *  {@code (end - start) + 1} characters in the set array. * @throws IllegalArgumentException if {@code count} &lt; 0 or the provided chars array is empty. * @since 2.0 char ch; <BUGS> if (chars == null) { ch = (char) (random.nextInt(gap) + start); <BUGE> } else { ch = chars[random.nextInt(gap) + start]; } if (letters && Character.isLetter(ch) || numbers && Character.isDigit(ch) || !letters && !numbers) { if(ch >= 56320 && ch <= 57343) { if(count == 0) { count++; } else { /* low surrogate, insert high surrogate after putting it in*/ buffer[count] = ch; count--;
*/ public static String random(int count, int start, int end, boolean letters, boolean numbers, char[] chars, Random random) { <BUGS> if (count == 0) { <BUGE> return ""; } else if (count < 0) { throw new IllegalArgumentException("Requested random string length " + count + " is less than 0."); }  if (start == 0 && end == 0) { if (!letters && !numbers) { end = Integer.MAX_VALUE; } else { end = 'z' + 1; start = ' '; } }  char[] buffer = new char[count]; int gap = end - start;  while (count-- != 0) { char ch; if (chars == null) { ch = (char) (random.nextInt(gap) + start); } else { ch = chars[random.nextInt(gap) + start]; } if (letters && Character.isLetter(ch) || numbers && Character.isDigit(ch)
*/ public static String random(int count, int start, int end, boolean letters, boolean numbers, char[] chars, Random random) { if (count == 0) { return ""; <BUGS> } else if (count < 0) { throw new IllegalArgumentException("Requested random string length " + count + " is less than 0."); <BUGE> }  if (start == 0 && end == 0) { if (!letters && !numbers) { end = Integer.MAX_VALUE; } else { end = 'z' + 1; start = ' '; } }  char[] buffer = new char[count]; int gap = end - start;  while (count-- != 0) { char ch; if (chars == null) { ch = (char) (random.nextInt(gap) + start); } else { ch = chars[random.nextInt(gap) + start]; } if (letters && Character.isLetter(ch) || numbers && Character.isDigit(ch)
*/ public static String random(int count, int start, int end, boolean letters, boolean numbers, char[] chars, Random random) { if (count == 0) { return ""; } else if (count < 0) { throw new IllegalArgumentException("Requested random string length " + count + " is less than 0."); }  <BUGS> if (start == 0 && end == 0) { if (!letters && !numbers) { end = Integer.MAX_VALUE; <BUGE> } else { end = 'z' + 1; start = ' '; } }  char[] buffer = new char[count]; int gap = end - start;  while (count-- != 0) { char ch; if (chars == null) { ch = (char) (random.nextInt(gap) + start); } else { ch = chars[random.nextInt(gap) + start]; } if (letters && Character.isLetter(ch) || numbers && Character.isDigit(ch)
*/ public static String random(int count, int start, int end, boolean letters, boolean numbers, char[] chars, Random random) { if (count == 0) { return ""; } else if (count < 0) { throw new IllegalArgumentException("Requested random string length " + count + " is less than 0."); }  if (start == 0 && end == 0) { if (!letters && !numbers) { end = Integer.MAX_VALUE; } else { end = 'z' + 1; start = ' '; } }  <BUGS> char[] buffer = new char[count]; int gap = end - start; <BUGE>  while (count-- != 0) { char ch; if (chars == null) { ch = (char) (random.nextInt(gap) + start); } else { ch = chars[random.nextInt(gap) + start]; } if (letters && Character.isLetter(ch) || numbers && Character.isDigit(ch)
*/ public static String random(int count, int start, int end, boolean letters, boolean numbers, char[] chars, Random random) { if (count == 0) { return ""; } else if (count < 0) { throw new IllegalArgumentException("Requested random string length " + count + " is less than 0."); }  if (start == 0 && end == 0) { if (!letters && !numbers) { end = Integer.MAX_VALUE; } else { end = 'z' + 1; start = ' '; } }  char[] buffer = new char[count]; int gap = end - start;  <BUGS> while (count-- != 0) { <BUGE> char ch; if (chars == null) { ch = (char) (random.nextInt(gap) + start); } else { ch = chars[random.nextInt(gap) + start]; } if (letters && Character.isLetter(ch) || numbers && Character.isDigit(ch)
*/ public static String random(int count, int start, int end, boolean letters, boolean numbers, char[] chars, Random random) { if (count == 0) { return ""; } else if (count < 0) { throw new IllegalArgumentException("Requested random string length " + count + " is less than 0."); }  if (start == 0 && end == 0) { if (!letters && !numbers) { end = Integer.MAX_VALUE; } else { end = 'z' + 1; start = ' '; } }  char[] buffer = new char[count]; int gap = end - start;  while (count-- != 0) { char ch; <BUGS> if (chars == null) { <BUGE> ch = (char) (random.nextInt(gap) + start); } else { ch = chars[random.nextInt(gap) + start]; } if (letters && Character.isLetter(ch) || numbers && Character.isDigit(ch)
*/ public static String random(int count, int start, int end, boolean letters, boolean numbers, char[] chars, Random random) { if (count == 0) { return ""; } else if (count < 0) { throw new IllegalArgumentException("Requested random string length " + count + " is less than 0."); }  if (start == 0 && end == 0) { if (!letters && !numbers) { end = Integer.MAX_VALUE; } else { end = 'z' + 1; start = ' '; } }  char[] buffer = new char[count]; int gap = end - start;  while (count-- != 0) { char ch; if (chars == null) { ch = (char) (random.nextInt(gap) + start); } else { <BUGS> ch = chars[random.nextInt(gap) + start]; <BUGE> } if (letters && Character.isLetter(ch) || numbers && Character.isDigit(ch)
*/ public static <T extends Serializable> T clone(T object) { <BUGS> if (object == null) { <BUGE> return null; } byte[] objectData = serialize(object); ByteArrayInputStream bais = new ByteArrayInputStream(objectData);  ClassLoaderAwareObjectInputStream in = null; try { /* stream closed in the finally*/ in = new ClassLoaderAwareObjectInputStream(bais, object.getClass().getClassLoader()); /* * when we serialize and deserialize an object, * it is reasonable to assume the deserialized object * is of the same type as the original serialized object */ @SuppressWarnings("unchecked") /* see above*/ T readObject = (T) in.readObject(); return readObject;  } catch (ClassNotFoundException ex) { throw new SerializationException("ClassNotFoundException while reading cloned object data", ex); } catch (IOException ex) { throw new SerializationException("IOException while reading cloned object data", ex); } finally { try { if (in != null) { in.close(); }
*/ public static <T extends Serializable> T clone(T object) { if (object == null) { return null; } <BUGS> byte[] objectData = serialize(object); ByteArrayInputStream bais = new ByteArrayInputStream(objectData); <BUGE>  ClassLoaderAwareObjectInputStream in = null; try { /* stream closed in the finally*/ in = new ClassLoaderAwareObjectInputStream(bais, object.getClass().getClassLoader()); /* * when we serialize and deserialize an object, * it is reasonable to assume the deserialized object * is of the same type as the original serialized object */ @SuppressWarnings("unchecked") /* see above*/ T readObject = (T) in.readObject(); return readObject;  } catch (ClassNotFoundException ex) { throw new SerializationException("ClassNotFoundException while reading cloned object data", ex); } catch (IOException ex) { throw new SerializationException("IOException while reading cloned object data", ex); } finally { try { if (in != null) { in.close(); }
*/ public static <T extends Serializable> T clone(T object) { if (object == null) { return null; } byte[] objectData = serialize(object); ByteArrayInputStream bais = new ByteArrayInputStream(objectData);  <BUGS> ClassLoaderAwareObjectInputStream in = null; <BUGE> try { /* stream closed in the finally*/ in = new ClassLoaderAwareObjectInputStream(bais, object.getClass().getClassLoader()); /* * when we serialize and deserialize an object, * it is reasonable to assume the deserialized object * is of the same type as the original serialized object */ @SuppressWarnings("unchecked") /* see above*/ T readObject = (T) in.readObject(); return readObject;  } catch (ClassNotFoundException ex) { throw new SerializationException("ClassNotFoundException while reading cloned object data", ex); } catch (IOException ex) { throw new SerializationException("IOException while reading cloned object data", ex); } finally { try { if (in != null) { in.close(); }
*/ public static <T extends Serializable> T clone(T object) { if (object == null) { return null; } byte[] objectData = serialize(object); ByteArrayInputStream bais = new ByteArrayInputStream(objectData);  ClassLoaderAwareObjectInputStream in = null; try { /* stream closed in the finally*/ <BUGS> in = new ClassLoaderAwareObjectInputStream(bais, object.getClass().getClassLoader()); <BUGE> /* * when we serialize and deserialize an object, * it is reasonable to assume the deserialized object * is of the same type as the original serialized object */ @SuppressWarnings("unchecked") /* see above*/ T readObject = (T) in.readObject(); return readObject;  } catch (ClassNotFoundException ex) { throw new SerializationException("ClassNotFoundException while reading cloned object data", ex); } catch (IOException ex) { throw new SerializationException("IOException while reading cloned object data", ex); } finally { try { if (in != null) { in.close(); }
*/ public static <T extends Serializable> T clone(T object) { if (object == null) { return null; } byte[] objectData = serialize(object); ByteArrayInputStream bais = new ByteArrayInputStream(objectData);  ClassLoaderAwareObjectInputStream in = null; try { /* stream closed in the finally*/ in = new ClassLoaderAwareObjectInputStream(bais, object.getClass().getClassLoader()); /* * when we serialize and deserialize an object, * it is reasonable to assume the deserialized object * is of the same type as the original serialized object */ @SuppressWarnings("unchecked") /* see above*/ <BUGS> T readObject = (T) in.readObject(); <BUGE> return readObject;  } catch (ClassNotFoundException ex) { throw new SerializationException("ClassNotFoundException while reading cloned object data", ex); } catch (IOException ex) { throw new SerializationException("IOException while reading cloned object data", ex); } finally { try { if (in != null) { in.close(); }
*/ public static <T extends Serializable> T clone(T object) { if (object == null) { return null; } byte[] objectData = serialize(object); ByteArrayInputStream bais = new ByteArrayInputStream(objectData);  ClassLoaderAwareObjectInputStream in = null; try { /* stream closed in the finally*/ in = new ClassLoaderAwareObjectInputStream(bais, object.getClass().getClassLoader()); /* * when we serialize and deserialize an object, * it is reasonable to assume the deserialized object * is of the same type as the original serialized object */ @SuppressWarnings("unchecked") /* see above*/ T readObject = (T) in.readObject(); return readObject;  <BUGS> } catch (ClassNotFoundException ex) { throw new SerializationException("ClassNotFoundException while reading cloned object data", ex); <BUGE> } catch (IOException ex) { throw new SerializationException("IOException while reading cloned object data", ex); } finally { try { if (in != null) { in.close(); }
*/ public static <T extends Serializable> T clone(T object) { if (object == null) { return null; } byte[] objectData = serialize(object); ByteArrayInputStream bais = new ByteArrayInputStream(objectData);  ClassLoaderAwareObjectInputStream in = null; try { /* stream closed in the finally*/ in = new ClassLoaderAwareObjectInputStream(bais, object.getClass().getClassLoader()); /* * when we serialize and deserialize an object, * it is reasonable to assume the deserialized object * is of the same type as the original serialized object */ @SuppressWarnings("unchecked") /* see above*/ T readObject = (T) in.readObject(); return readObject;  } catch (ClassNotFoundException ex) { throw new SerializationException("ClassNotFoundException while reading cloned object data", ex); } catch (IOException ex) { throw new SerializationException("IOException while reading cloned object data", ex); } finally { <BUGS> try { if (in != null) { in.close(); <BUGE> }
/*-----------------------------------------------------------------------*/ /** * <p>Deep clone an {@code Object} using serialization.</p> * * <p>This is many times slower than writing clone methods by hand * on all objects in your object graph. However, for complex object * graphs, or for those that don't support deep cloning this can * be a simple alternative implementation. Of course all the objects * must be {@code Serializable}.</p> * * @param <T> the type of the object involved * @param object  the {@code Serializable} object to clone * @return the cloned object * @throws SerializationException (runtime) if the serialization fails } catch (IOException ex) { <BUGS> throw new SerializationException("IOException on closing cloned object data InputStream.", ex); } <BUGE> } }  /* Serialize*/ /*-----------------------------------------------------------------------*/ /** * <p>Serializes an {@code Object} to the specified stream.</p> * * <p>The stream will be closed once the object is written. * This avoids the need for a finally clause, and maybe also exception * handling, in the application code.</p> * * <p>The stream passed in is not buffered internally within this method.
*/ public static boolean equals(CharSequence cs1, CharSequence cs2) { <BUGS> return cs1 == null ? cs2 == null : cs1.equals(cs2); <BUGE> }
*/ public static Number createNumber(String str) throws NumberFormatException { <BUGS> if (str == null) { <BUGE> return null; } if (StringUtils.isBlank(str)) { throw new NumberFormatException("A blank string is not a valid number"); } if (str.startsWith("--")) { /* this is protection for poorness in java.lang.BigDecimal.*/ /* it accepts this as a legal value, but it does not appear */ /* to be in specification of class. OS X Java parses it to */ /* a wrong value.*/ return null; } if (str.startsWith("0x") || str.startsWith("-0x")) { return createInteger(str); } char lastChar = str.charAt(str.length() - 1); String mant; String dec; String exp; int decPos = str.indexOf('.'); int expPos = str.indexOf('e') + str.indexOf('E') + 1;  if (decPos > -1) {  if (expPos > -1) { if (expPos < decPos || expPos > str.length()) { throw new NumberFormatException(str + " is not a valid number.");
*/ public static Number createNumber(String str) throws NumberFormatException { if (str == null) { return null; } <BUGS> if (StringUtils.isBlank(str)) { <BUGE> throw new NumberFormatException("A blank string is not a valid number"); } if (str.startsWith("--")) { /* this is protection for poorness in java.lang.BigDecimal.*/ /* it accepts this as a legal value, but it does not appear */ /* to be in specification of class. OS X Java parses it to */ /* a wrong value.*/ return null; } if (str.startsWith("0x") || str.startsWith("-0x")) { return createInteger(str); } char lastChar = str.charAt(str.length() - 1); String mant; String dec; String exp; int decPos = str.indexOf('.'); int expPos = str.indexOf('e') + str.indexOf('E') + 1;  if (decPos > -1) {  if (expPos > -1) { if (expPos < decPos || expPos > str.length()) { throw new NumberFormatException(str + " is not a valid number.");
*/ public static Number createNumber(String str) throws NumberFormatException { if (str == null) { return null; } if (StringUtils.isBlank(str)) { throw new NumberFormatException("A blank string is not a valid number"); } <BUGS> if (str.startsWith("--")) { <BUGE> /* this is protection for poorness in java.lang.BigDecimal.*/ /* it accepts this as a legal value, but it does not appear */ /* to be in specification of class. OS X Java parses it to */ /* a wrong value.*/ return null; } if (str.startsWith("0x") || str.startsWith("-0x")) { return createInteger(str); } char lastChar = str.charAt(str.length() - 1); String mant; String dec; String exp; int decPos = str.indexOf('.'); int expPos = str.indexOf('e') + str.indexOf('E') + 1;  if (decPos > -1) {  if (expPos > -1) { if (expPos < decPos || expPos > str.length()) { throw new NumberFormatException(str + " is not a valid number.");
*/ public static Number createNumber(String str) throws NumberFormatException { if (str == null) { return null; } if (StringUtils.isBlank(str)) { throw new NumberFormatException("A blank string is not a valid number"); } if (str.startsWith("--")) { /* this is protection for poorness in java.lang.BigDecimal.*/ /* it accepts this as a legal value, but it does not appear */ /* to be in specification of class. OS X Java parses it to */ /* a wrong value.*/ return null; } <BUGS> if (str.startsWith("0x") || str.startsWith("-0x")) { return createInteger(str); <BUGE> } char lastChar = str.charAt(str.length() - 1); String mant; String dec; String exp; int decPos = str.indexOf('.'); int expPos = str.indexOf('e') + str.indexOf('E') + 1;  if (decPos > -1) {  if (expPos > -1) { if (expPos < decPos || expPos > str.length()) { throw new NumberFormatException(str + " is not a valid number.");
*/ public static Number createNumber(String str) throws NumberFormatException { if (str == null) { return null; } if (StringUtils.isBlank(str)) { throw new NumberFormatException("A blank string is not a valid number"); } if (str.startsWith("--")) { /* this is protection for poorness in java.lang.BigDecimal.*/ /* it accepts this as a legal value, but it does not appear */ /* to be in specification of class. OS X Java parses it to */ /* a wrong value.*/ return null; } if (str.startsWith("0x") || str.startsWith("-0x")) { return createInteger(str); } <BUGS> char lastChar = str.charAt(str.length() - 1); <BUGE> String mant; String dec; String exp; int decPos = str.indexOf('.'); int expPos = str.indexOf('e') + str.indexOf('E') + 1;  if (decPos > -1) {  if (expPos > -1) { if (expPos < decPos || expPos > str.length()) { throw new NumberFormatException(str + " is not a valid number.");
*/ public static Number createNumber(String str) throws NumberFormatException { if (str == null) { return null; } if (StringUtils.isBlank(str)) { throw new NumberFormatException("A blank string is not a valid number"); } if (str.startsWith("--")) { /* this is protection for poorness in java.lang.BigDecimal.*/ /* it accepts this as a legal value, but it does not appear */ /* to be in specification of class. OS X Java parses it to */ /* a wrong value.*/ return null; } if (str.startsWith("0x") || str.startsWith("-0x")) { return createInteger(str); } char lastChar = str.charAt(str.length() - 1); String mant; String dec; String exp; <BUGS> int decPos = str.indexOf('.'); int expPos = str.indexOf('e') + str.indexOf('E') + 1; <BUGE>  if (decPos > -1) {  if (expPos > -1) { if (expPos < decPos || expPos > str.length()) { throw new NumberFormatException(str + " is not a valid number.");
*/ public static Number createNumber(String str) throws NumberFormatException { if (str == null) { return null; } if (StringUtils.isBlank(str)) { throw new NumberFormatException("A blank string is not a valid number"); } if (str.startsWith("--")) { /* this is protection for poorness in java.lang.BigDecimal.*/ /* it accepts this as a legal value, but it does not appear */ /* to be in specification of class. OS X Java parses it to */ /* a wrong value.*/ return null; } if (str.startsWith("0x") || str.startsWith("-0x")) { return createInteger(str); } char lastChar = str.charAt(str.length() - 1); String mant; String dec; String exp; int decPos = str.indexOf('.'); int expPos = str.indexOf('e') + str.indexOf('E') + 1;  <BUGS> if (decPos > -1) { <BUGE>  if (expPos > -1) { if (expPos < decPos || expPos > str.length()) { throw new NumberFormatException(str + " is not a valid number.");
*/ public static Number createNumber(String str) throws NumberFormatException { if (str == null) { return null; } if (StringUtils.isBlank(str)) { throw new NumberFormatException("A blank string is not a valid number"); } if (str.startsWith("--")) { /* this is protection for poorness in java.lang.BigDecimal.*/ /* it accepts this as a legal value, but it does not appear */ /* to be in specification of class. OS X Java parses it to */ /* a wrong value.*/ return null; } if (str.startsWith("0x") || str.startsWith("-0x")) { return createInteger(str); } char lastChar = str.charAt(str.length() - 1); String mant; String dec; String exp; int decPos = str.indexOf('.'); int expPos = str.indexOf('e') + str.indexOf('E') + 1;  if (decPos > -1) {  <BUGS> if (expPos > -1) { <BUGE> if (expPos < decPos || expPos > str.length()) { throw new NumberFormatException(str + " is not a valid number.");
* <code>BigDecimal</code>.</p> * * <p>If the string starts with <code>0x</code> or <code>-0x</code> (lower or upper case), it * will be interpreted as a hexadecimal integer.  Values with leading * <code>0</code>'s will not be interpreted as octal.</p> * * <p>Returns <code>null</code> if the string is <code>null</code>.</p> * * <p>This method does not trim the input string, i.e., strings with leading * or trailing spaces will generate NumberFormatExceptions.</p> * * @param str  String containing a number, may be null * @return Number created from the string (or null if the input is null) * @throws NumberFormatException if the value cannot be converted } else { <BUGS> dec = str.substring(decPos + 1); <BUGE> } mant = str.substring(0, decPos); } else { if (expPos > -1) { if (expPos > str.length()) { throw new NumberFormatException(str + " is not a valid number."); } mant = str.substring(0, expPos); } else { mant = str; } dec = null; } if (!Character.isDigit(lastChar) && lastChar != '.') {
* <code>BigDecimal</code>.</p> * * <p>If the string starts with <code>0x</code> or <code>-0x</code> (lower or upper case), it * will be interpreted as a hexadecimal integer.  Values with leading * <code>0</code>'s will not be interpreted as octal.</p> * * <p>Returns <code>null</code> if the string is <code>null</code>.</p> * * <p>This method does not trim the input string, i.e., strings with leading * or trailing spaces will generate NumberFormatExceptions.</p> * * @param str  String containing a number, may be null * @return Number created from the string (or null if the input is null) * @throws NumberFormatException if the value cannot be converted } <BUGS> mant = str.substring(0, decPos); <BUGE> } else { if (expPos > -1) { if (expPos > str.length()) { throw new NumberFormatException(str + " is not a valid number."); } mant = str.substring(0, expPos); } else { mant = str; } dec = null; } if (!Character.isDigit(lastChar) && lastChar != '.') { if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length() - 1);
* <code>BigDecimal</code>.</p> * * <p>If the string starts with <code>0x</code> or <code>-0x</code> (lower or upper case), it * will be interpreted as a hexadecimal integer.  Values with leading * <code>0</code>'s will not be interpreted as octal.</p> * * <p>Returns <code>null</code> if the string is <code>null</code>.</p> * * <p>This method does not trim the input string, i.e., strings with leading * or trailing spaces will generate NumberFormatExceptions.</p> * * @param str  String containing a number, may be null * @return Number created from the string (or null if the input is null) * @throws NumberFormatException if the value cannot be converted } else { <BUGS> if (expPos > -1) { if (expPos > str.length()) { <BUGE> throw new NumberFormatException(str + " is not a valid number."); } mant = str.substring(0, expPos); } else { mant = str; } dec = null; } if (!Character.isDigit(lastChar) && lastChar != '.') { if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length() - 1); } else { exp = null;
* <code>BigDecimal</code>.</p> * * <p>If the string starts with <code>0x</code> or <code>-0x</code> (lower or upper case), it * will be interpreted as a hexadecimal integer.  Values with leading * <code>0</code>'s will not be interpreted as octal.</p> * * <p>Returns <code>null</code> if the string is <code>null</code>.</p> * * <p>This method does not trim the input string, i.e., strings with leading * or trailing spaces will generate NumberFormatExceptions.</p> * * @param str  String containing a number, may be null * @return Number created from the string (or null if the input is null) * @throws NumberFormatException if the value cannot be converted } <BUGS> mant = str.substring(0, expPos); <BUGE> } else { mant = str; } dec = null; } if (!Character.isDigit(lastChar) && lastChar != '.') { if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length() - 1); } else { exp = null; } /*Requesting a specific type..*/ String numeric = str.substring(0, str.length() - 1); boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
* <code>BigDecimal</code>.</p> * * <p>If the string starts with <code>0x</code> or <code>-0x</code> (lower or upper case), it * will be interpreted as a hexadecimal integer.  Values with leading * <code>0</code>'s will not be interpreted as octal.</p> * * <p>Returns <code>null</code> if the string is <code>null</code>.</p> * * <p>This method does not trim the input string, i.e., strings with leading * or trailing spaces will generate NumberFormatExceptions.</p> * * @param str  String containing a number, may be null * @return Number created from the string (or null if the input is null) * @throws NumberFormatException if the value cannot be converted } else { <BUGS> mant = str; <BUGE> } dec = null; } if (!Character.isDigit(lastChar) && lastChar != '.') { if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length() - 1); } else { exp = null; } /*Requesting a specific type..*/ String numeric = str.substring(0, str.length() - 1); boolean allZeros = isAllZeros(mant) && isAllZeros(exp); switch (lastChar) { case 'l' :
* <code>BigDecimal</code>.</p> * * <p>If the string starts with <code>0x</code> or <code>-0x</code> (lower or upper case), it * will be interpreted as a hexadecimal integer.  Values with leading * <code>0</code>'s will not be interpreted as octal.</p> * * <p>Returns <code>null</code> if the string is <code>null</code>.</p> * * <p>This method does not trim the input string, i.e., strings with leading * or trailing spaces will generate NumberFormatExceptions.</p> * * @param str  String containing a number, may be null * @return Number created from the string (or null if the input is null) * @throws NumberFormatException if the value cannot be converted } <BUGS> dec = null; <BUGE> } if (!Character.isDigit(lastChar) && lastChar != '.') { if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length() - 1); } else { exp = null; } /*Requesting a specific type..*/ String numeric = str.substring(0, str.length() - 1); boolean allZeros = isAllZeros(mant) && isAllZeros(exp); switch (lastChar) { case 'l' : case 'L' : if (dec == null
* <code>BigDecimal</code>.</p> * * <p>If the string starts with <code>0x</code> or <code>-0x</code> (lower or upper case), it * will be interpreted as a hexadecimal integer.  Values with leading * <code>0</code>'s will not be interpreted as octal.</p> * * <p>Returns <code>null</code> if the string is <code>null</code>.</p> * * <p>This method does not trim the input string, i.e., strings with leading * or trailing spaces will generate NumberFormatExceptions.</p> * * @param str  String containing a number, may be null * @return Number created from the string (or null if the input is null) * @throws NumberFormatException if the value cannot be converted } <BUGS> if (!Character.isDigit(lastChar) && lastChar != '.') { if (expPos > -1 && expPos < str.length() - 1) { <BUGE> exp = str.substring(expPos + 1, str.length() - 1); } else { exp = null; } /*Requesting a specific type..*/ String numeric = str.substring(0, str.length() - 1); boolean allZeros = isAllZeros(mant) && isAllZeros(exp); switch (lastChar) { case 'l' : case 'L' : if (dec == null && exp == null && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {
* <code>BigDecimal</code>.</p> * * <p>If the string starts with <code>0x</code> or <code>-0x</code> (lower or upper case), it * will be interpreted as a hexadecimal integer.  Values with leading * <code>0</code>'s will not be interpreted as octal.</p> * * <p>Returns <code>null</code> if the string is <code>null</code>.</p> * * <p>This method does not trim the input string, i.e., strings with leading * or trailing spaces will generate NumberFormatExceptions.</p> * * @param str  String containing a number, may be null * @return Number created from the string (or null if the input is null) * @throws NumberFormatException if the value cannot be converted } else { <BUGS> exp = null; <BUGE> } /*Requesting a specific type..*/ String numeric = str.substring(0, str.length() - 1); boolean allZeros = isAllZeros(mant) && isAllZeros(exp); switch (lastChar) { case 'l' : case 'L' : if (dec == null && exp == null && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) { try { return createLong(numeric); } catch (NumberFormatException nfe) { /* NOPMD*/ /* Too big for a long*/
* * <p>If the string starts with <code>0x</code> or <code>-0x</code> (lower or upper case), it * will be interpreted as a hexadecimal integer.  Values with leading * <code>0</code>'s will not be interpreted as octal.</p> * * <p>Returns <code>null</code> if the string is <code>null</code>.</p> * * <p>This method does not trim the input string, i.e., strings with leading * or trailing spaces will generate NumberFormatExceptions.</p> * * @param str  String containing a number, may be null * @return Number created from the string (or null if the input is null) * @throws NumberFormatException if the value cannot be converted /*Requesting a specific type..*/ <BUGS> String numeric = str.substring(0, str.length() - 1); boolean allZeros = isAllZeros(mant) && isAllZeros(exp); switch (lastChar) { <BUGE> case 'l' : case 'L' : if (dec == null && exp == null && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) { try { return createLong(numeric); } catch (NumberFormatException nfe) { /* NOPMD*/ /* Too big for a long*/ } return createBigInteger(numeric);  }
* <code>BigDecimal</code>.</p> * * <p>If the string starts with <code>0x</code> or <code>-0x</code> (lower or upper case), it * will be interpreted as a hexadecimal integer.  Values with leading * <code>0</code>'s will not be interpreted as octal.</p> * * <p>Returns <code>null</code> if the string is <code>null</code>.</p> * * <p>This method does not trim the input string, i.e., strings with leading * or trailing spaces will generate NumberFormatExceptions.</p> * * @param str  String containing a number, may be null * @return Number created from the string (or null if the input is null) * @throws NumberFormatException if the value cannot be converted case 'L' : <BUGS> if (dec == null <BUGE> && exp == null && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) { try { return createLong(numeric); } catch (NumberFormatException nfe) { /* NOPMD*/ /* Too big for a long*/ } return createBigInteger(numeric);  } throw new NumberFormatException(str + " is not a valid number."); case 'f' : case 'F' : try {
* <code>BigDecimal</code>.</p> * * <p>If the string starts with <code>0x</code> or <code>-0x</code> (lower or upper case), it * will be interpreted as a hexadecimal integer.  Values with leading * <code>0</code>'s will not be interpreted as octal.</p> * * <p>Returns <code>null</code> if the string is <code>null</code>.</p> * * <p>This method does not trim the input string, i.e., strings with leading * or trailing spaces will generate NumberFormatExceptions.</p> * * @param str  String containing a number, may be null * @return Number created from the string (or null if the input is null) * @throws NumberFormatException if the value cannot be converted try { <BUGS> return createLong(numeric); <BUGE> } catch (NumberFormatException nfe) { /* NOPMD*/ /* Too big for a long*/ } return createBigInteger(numeric);  } throw new NumberFormatException(str + " is not a valid number."); case 'f' : case 'F' : try { Float f = NumberUtils.createFloat(numeric); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { /*If it's too big for a float or the float value = 0 and the string*/ /*has non-zeros in it, then float does not have the precision we want*/
* <code>BigDecimal</code>.</p> * * <p>If the string starts with <code>0x</code> or <code>-0x</code> (lower or upper case), it * will be interpreted as a hexadecimal integer.  Values with leading * <code>0</code>'s will not be interpreted as octal.</p> * * <p>Returns <code>null</code> if the string is <code>null</code>.</p> * * <p>This method does not trim the input string, i.e., strings with leading * or trailing spaces will generate NumberFormatExceptions.</p> * * @param str  String containing a number, may be null * @return Number created from the string (or null if the input is null) * @throws NumberFormatException if the value cannot be converted try { <BUGS> Float f = NumberUtils.createFloat(numeric); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { <BUGE> /*If it's too big for a float or the float value = 0 and the string*/ /*has non-zeros in it, then float does not have the precision we want*/ return f; }  } catch (NumberFormatException nfe) { /* NOPMD*/ /* ignore the bad number*/ } /*$FALL-THROUGH$*/ case 'd' : case 'D' : try { Double d = NumberUtils.createDouble(numeric);
* <code>BigDecimal</code>.</p> * * <p>If the string starts with <code>0x</code> or <code>-0x</code> (lower or upper case), it * will be interpreted as a hexadecimal integer.  Values with leading * <code>0</code>'s will not be interpreted as octal.</p> * * <p>Returns <code>null</code> if the string is <code>null</code>.</p> * * <p>This method does not trim the input string, i.e., strings with leading * or trailing spaces will generate NumberFormatExceptions.</p> * * @param str  String containing a number, may be null * @return Number created from the string (or null if the input is null) * @throws NumberFormatException if the value cannot be converted /*has non-zeros in it, then float does not have the precision we want*/ <BUGS> return f; <BUGE> }  } catch (NumberFormatException nfe) { /* NOPMD*/ /* ignore the bad number*/ } /*$FALL-THROUGH$*/ case 'd' : case 'D' : try { Double d = NumberUtils.createDouble(numeric); if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { /* NOPMD*/
* * <p>If the string starts with <code>0x</code> or <code>-0x</code> (lower or upper case), it * will be interpreted as a hexadecimal integer.  Values with leading * <code>0</code>'s will not be interpreted as octal.</p> * * <p>Returns <code>null</code> if the string is <code>null</code>.</p> * * <p>This method does not trim the input string, i.e., strings with leading * or trailing spaces will generate NumberFormatExceptions.</p> * * @param str  String containing a number, may be null * @return Number created from the string (or null if the input is null) * @throws NumberFormatException if the value cannot be converted try { <BUGS> Double d = NumberUtils.createDouble(numeric); if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) { return d; <BUGE> } } catch (NumberFormatException nfe) { /* NOPMD*/ /* ignore the bad number*/ } try { return createBigDecimal(numeric); } catch (NumberFormatException e) { /* NOPMD*/ /* ignore the bad number*/ } /*$FALL-THROUGH$*/ default : throw new NumberFormatException(str + " is not a valid number.");
* <code>BigDecimal</code>.</p> * * <p>If the string starts with <code>0x</code> or <code>-0x</code> (lower or upper case), it * will be interpreted as a hexadecimal integer.  Values with leading * <code>0</code>'s will not be interpreted as octal.</p> * * <p>Returns <code>null</code> if the string is <code>null</code>.</p> * * <p>This method does not trim the input string, i.e., strings with leading * or trailing spaces will generate NumberFormatExceptions.</p> * * @param str  String containing a number, may be null * @return Number created from the string (or null if the input is null) * @throws NumberFormatException if the value cannot be converted default : <BUGS> throw new NumberFormatException(str + " is not a valid number."); <BUGE>  } } else { /*User doesn't have a preference on the return type, so let's start*/ /*small and go from there...*/ if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length()); } else { exp = null; } if (dec == null && exp == null) { /*Must be an int,long,bigint*/ try { return createInteger(str);
* <code>BigDecimal</code>.</p> * * <p>If the string starts with <code>0x</code> or <code>-0x</code> (lower or upper case), it * will be interpreted as a hexadecimal integer.  Values with leading * <code>0</code>'s will not be interpreted as octal.</p> * * <p>Returns <code>null</code> if the string is <code>null</code>.</p> * * <p>This method does not trim the input string, i.e., strings with leading * or trailing spaces will generate NumberFormatExceptions.</p> * * @param str  String containing a number, may be null * @return Number created from the string (or null if the input is null) * @throws NumberFormatException if the value cannot be converted /*small and go from there...*/ <BUGS> if (expPos > -1 && expPos < str.length() - 1) { <BUGE> exp = str.substring(expPos + 1, str.length()); } else { exp = null; } if (dec == null && exp == null) { /*Must be an int,long,bigint*/ try { return createInteger(str); } catch (NumberFormatException nfe) { /* NOPMD*/ /* ignore the bad number*/ } try { return createLong(str); } catch (NumberFormatException nfe) { /* NOPMD*/
* <code>BigDecimal</code>.</p> * * <p>If the string starts with <code>0x</code> or <code>-0x</code> (lower or upper case), it * will be interpreted as a hexadecimal integer.  Values with leading * <code>0</code>'s will not be interpreted as octal.</p> * * <p>Returns <code>null</code> if the string is <code>null</code>.</p> * * <p>This method does not trim the input string, i.e., strings with leading * or trailing spaces will generate NumberFormatExceptions.</p> * * @param str  String containing a number, may be null * @return Number created from the string (or null if the input is null) * @throws NumberFormatException if the value cannot be converted } else { <BUGS> exp = null; <BUGE> } if (dec == null && exp == null) { /*Must be an int,long,bigint*/ try { return createInteger(str); } catch (NumberFormatException nfe) { /* NOPMD*/ /* ignore the bad number*/ } try { return createLong(str); } catch (NumberFormatException nfe) { /* NOPMD*/ /* ignore the bad number*/ } return createBigInteger(str);
* <code>BigDecimal</code>.</p> * * <p>If the string starts with <code>0x</code> or <code>-0x</code> (lower or upper case), it * will be interpreted as a hexadecimal integer.  Values with leading * <code>0</code>'s will not be interpreted as octal.</p> * * <p>Returns <code>null</code> if the string is <code>null</code>.</p> * * <p>This method does not trim the input string, i.e., strings with leading * or trailing spaces will generate NumberFormatExceptions.</p> * * @param str  String containing a number, may be null * @return Number created from the string (or null if the input is null) * @throws NumberFormatException if the value cannot be converted } <BUGS> if (dec == null && exp == null) { <BUGE> /*Must be an int,long,bigint*/ try { return createInteger(str); } catch (NumberFormatException nfe) { /* NOPMD*/ /* ignore the bad number*/ } try { return createLong(str); } catch (NumberFormatException nfe) { /* NOPMD*/ /* ignore the bad number*/ } return createBigInteger(str);  } else {
* <code>BigDecimal</code>.</p> * * <p>If the string starts with <code>0x</code> or <code>-0x</code> (lower or upper case), it * will be interpreted as a hexadecimal integer.  Values with leading * <code>0</code>'s will not be interpreted as octal.</p> * * <p>Returns <code>null</code> if the string is <code>null</code>.</p> * * <p>This method does not trim the input string, i.e., strings with leading * or trailing spaces will generate NumberFormatExceptions.</p> * * @param str  String containing a number, may be null * @return Number created from the string (or null if the input is null) * @throws NumberFormatException if the value cannot be converted try { <BUGS> return createInteger(str); } catch (NumberFormatException nfe) { /* NOPMD <BUGE>*/ /* ignore the bad number*/ } try { return createLong(str); } catch (NumberFormatException nfe) { /* NOPMD*/ /* ignore the bad number*/ } return createBigInteger(str);  } else { /*Must be a float,double,BigDec*/ boolean allZeros = isAllZeros(mant) && isAllZeros(exp); try {
* <code>BigDecimal</code>.</p> * * <p>If the string starts with <code>0x</code> or <code>-0x</code> (lower or upper case), it * will be interpreted as a hexadecimal integer.  Values with leading * <code>0</code>'s will not be interpreted as octal.</p> * * <p>Returns <code>null</code> if the string is <code>null</code>.</p> * * <p>This method does not trim the input string, i.e., strings with leading * or trailing spaces will generate NumberFormatExceptions.</p> * * @param str  String containing a number, may be null * @return Number created from the string (or null if the input is null) * @throws NumberFormatException if the value cannot be converted try { <BUGS> return createLong(str); <BUGE> } catch (NumberFormatException nfe) { /* NOPMD*/ /* ignore the bad number*/ } return createBigInteger(str);  } else { /*Must be a float,double,BigDec*/ boolean allZeros = isAllZeros(mant) && isAllZeros(exp); try { Float f = createFloat(str); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { return f; } } catch (NumberFormatException nfe) { /* NOPMD*/
* <code>BigDecimal</code>.</p> * * <p>If the string starts with <code>0x</code> or <code>-0x</code> (lower or upper case), it * will be interpreted as a hexadecimal integer.  Values with leading * <code>0</code>'s will not be interpreted as octal.</p> * * <p>Returns <code>null</code> if the string is <code>null</code>.</p> * * <p>This method does not trim the input string, i.e., strings with leading * or trailing spaces will generate NumberFormatExceptions.</p> * * @param str  String containing a number, may be null * @return Number created from the string (or null if the input is null) * @throws NumberFormatException if the value cannot be converted /*Must be a float,double,BigDec*/ <BUGS> boolean allZeros = isAllZeros(mant) && isAllZeros(exp); <BUGE> try { Float f = createFloat(str); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { return f; } } catch (NumberFormatException nfe) { /* NOPMD*/ /* ignore the bad number*/ } try { Double d = createDouble(str); if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { /* NOPMD*/
* * <p>If the string starts with <code>0x</code> or <code>-0x</code> (lower or upper case), it * will be interpreted as a hexadecimal integer.  Values with leading * <code>0</code>'s will not be interpreted as octal.</p> * * <p>Returns <code>null</code> if the string is <code>null</code>.</p> * * <p>This method does not trim the input string, i.e., strings with leading * or trailing spaces will generate NumberFormatExceptions.</p> * * @param str  String containing a number, may be null * @return Number created from the string (or null if the input is null) * @throws NumberFormatException if the value cannot be converted try { <BUGS> Float f = createFloat(str); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { return f; <BUGE> } } catch (NumberFormatException nfe) { /* NOPMD*/ /* ignore the bad number*/ } try { Double d = createDouble(str); if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { /* NOPMD*/ /* ignore the bad number*/ }
*/ public static final String escapeXml(String input) { <BUGS> return ESCAPE_XML.translate(input); <BUGE> }
*/ protected List<Rule> parsePattern() { <BUGS> DateFormatSymbols symbols = new DateFormatSymbols(mLocale); List<Rule> rules = new ArrayList<Rule>(); <BUGE>  String[] ERAs = symbols.getEras(); String[] months = symbols.getMonths(); String[] shortMonths = symbols.getShortMonths(); String[] weekdays = symbols.getWeekdays(); String[] shortWeekdays = symbols.getShortWeekdays(); String[] AmPmStrings = symbols.getAmPmStrings();  int length = mPattern.length(); int[] indexRef = new int[1];  for (int i = 0; i < length; i++) { indexRef[0] = i; String token = parseToken(mPattern, indexRef); i = indexRef[0];  int tokenLen = token.length(); if (tokenLen == 0) { break; }  Rule rule; char c = token.charAt(0);  switch (c) { case 'G': /* era designator (text)*/
*/ protected List<Rule> parsePattern() { DateFormatSymbols symbols = new DateFormatSymbols(mLocale); List<Rule> rules = new ArrayList<Rule>();  <BUGS> String[] ERAs = symbols.getEras(); String[] months = symbols.getMonths(); String[] shortMonths = symbols.getShortMonths(); String[] weekdays = symbols.getWeekdays(); String[] shortWeekdays = symbols.getShortWeekdays(); String[] AmPmStrings = symbols.getAmPmStrings(); <BUGE>  int length = mPattern.length(); int[] indexRef = new int[1];  for (int i = 0; i < length; i++) { indexRef[0] = i; String token = parseToken(mPattern, indexRef); i = indexRef[0];  int tokenLen = token.length(); if (tokenLen == 0) { break; }  Rule rule; char c = token.charAt(0);  switch (c) { case 'G': /* era designator (text)*/
*/ protected List<Rule> parsePattern() { DateFormatSymbols symbols = new DateFormatSymbols(mLocale); List<Rule> rules = new ArrayList<Rule>();  String[] ERAs = symbols.getEras(); String[] months = symbols.getMonths(); String[] shortMonths = symbols.getShortMonths(); String[] weekdays = symbols.getWeekdays(); String[] shortWeekdays = symbols.getShortWeekdays(); String[] AmPmStrings = symbols.getAmPmStrings();  <BUGS> int length = mPattern.length(); int[] indexRef = new int[1]; <BUGE>  for (int i = 0; i < length; i++) { indexRef[0] = i; String token = parseToken(mPattern, indexRef); i = indexRef[0];  int tokenLen = token.length(); if (tokenLen == 0) { break; }  Rule rule; char c = token.charAt(0);  switch (c) { case 'G': /* era designator (text)*/
*/ protected List<Rule> parsePattern() { DateFormatSymbols symbols = new DateFormatSymbols(mLocale); List<Rule> rules = new ArrayList<Rule>();  String[] ERAs = symbols.getEras(); String[] months = symbols.getMonths(); String[] shortMonths = symbols.getShortMonths(); String[] weekdays = symbols.getWeekdays(); String[] shortWeekdays = symbols.getShortWeekdays(); String[] AmPmStrings = symbols.getAmPmStrings();  int length = mPattern.length(); int[] indexRef = new int[1];  <BUGS> for (int i = 0; i < length; i++) { indexRef[0] = i; String token = parseToken(mPattern, indexRef); i = indexRef[0]; <BUGE>  int tokenLen = token.length(); if (tokenLen == 0) { break; }  Rule rule; char c = token.charAt(0);  switch (c) { case 'G': /* era designator (text)*/
*/ protected List<Rule> parsePattern() { DateFormatSymbols symbols = new DateFormatSymbols(mLocale); List<Rule> rules = new ArrayList<Rule>();  String[] ERAs = symbols.getEras(); String[] months = symbols.getMonths(); String[] shortMonths = symbols.getShortMonths(); String[] weekdays = symbols.getWeekdays(); String[] shortWeekdays = symbols.getShortWeekdays(); String[] AmPmStrings = symbols.getAmPmStrings();  int length = mPattern.length(); int[] indexRef = new int[1];  for (int i = 0; i < length; i++) { indexRef[0] = i; String token = parseToken(mPattern, indexRef); i = indexRef[0];  <BUGS> int tokenLen = token.length(); if (tokenLen == 0) { <BUGE> break; }  Rule rule; char c = token.charAt(0);  switch (c) { case 'G': /* era designator (text)*/
*/ protected List<Rule> parsePattern() { DateFormatSymbols symbols = new DateFormatSymbols(mLocale); List<Rule> rules = new ArrayList<Rule>();  String[] ERAs = symbols.getEras(); String[] months = symbols.getMonths(); String[] shortMonths = symbols.getShortMonths(); String[] weekdays = symbols.getWeekdays(); String[] shortWeekdays = symbols.getShortWeekdays(); String[] AmPmStrings = symbols.getAmPmStrings();  int length = mPattern.length(); int[] indexRef = new int[1];  for (int i = 0; i < length; i++) { indexRef[0] = i; String token = parseToken(mPattern, indexRef); i = indexRef[0];  int tokenLen = token.length(); if (tokenLen == 0) { break; }  Rule rule; <BUGS> char c = token.charAt(0); <BUGE>  switch (c) { case 'G': /* era designator (text)*/
*/ protected List<Rule> parsePattern() { DateFormatSymbols symbols = new DateFormatSymbols(mLocale); List<Rule> rules = new ArrayList<Rule>();  String[] ERAs = symbols.getEras(); String[] months = symbols.getMonths(); String[] shortMonths = symbols.getShortMonths(); String[] weekdays = symbols.getWeekdays(); String[] shortWeekdays = symbols.getShortWeekdays(); String[] AmPmStrings = symbols.getAmPmStrings();  int length = mPattern.length(); int[] indexRef = new int[1];  for (int i = 0; i < length; i++) { indexRef[0] = i; String token = parseToken(mPattern, indexRef); i = indexRef[0];  int tokenLen = token.length(); if (tokenLen == 0) { break; }  Rule rule; char c = token.charAt(0);  <BUGS> switch (c) { <BUGE> case 'G': /* era designator (text)*/
for (int i=mRules.length; --i >= 0; ) { len += mRules[i].estimateLength(); }  mMaxLengthEstimate = len; }  /* Parse the pattern*/ /*-----------------------------------------------------------------------*/ /** * <p>Returns a list of Rules given a pattern.</p> * * @return a {@code List} of Rule objects * @throws IllegalArgumentException if pattern is invalid case 'G': /* era designator (text)*/ <BUGS> rule = new TextField(Calendar.ERA, ERAs); break; <BUGE> case 'y': /* year (number)*/ if (tokenLen >= 4) { rule = selectNumberRule(Calendar.YEAR, tokenLen); } else { rule = TwoDigitYearField.INSTANCE; } break; case 'M': /* month in year (text and number)*/ if (tokenLen >= 4) { rule = new TextField(Calendar.MONTH, months); } else if (tokenLen == 3) { rule = new TextField(Calendar.MONTH, shortMonths); } else if (tokenLen == 2) {
for (int i=mRules.length; --i >= 0; ) { len += mRules[i].estimateLength(); }  mMaxLengthEstimate = len; }  /* Parse the pattern*/ /*-----------------------------------------------------------------------*/ /** * <p>Returns a list of Rules given a pattern.</p> * * @return a {@code List} of Rule objects * @throws IllegalArgumentException if pattern is invalid case 'y': /* year (number)*/ <BUGS> if (tokenLen >= 4) { rule = selectNumberRule(Calendar.YEAR, tokenLen); <BUGE> } else { rule = TwoDigitYearField.INSTANCE; } break; case 'M': /* month in year (text and number)*/ if (tokenLen >= 4) { rule = new TextField(Calendar.MONTH, months); } else if (tokenLen == 3) { rule = new TextField(Calendar.MONTH, shortMonths); } else if (tokenLen == 2) { rule = TwoDigitMonthField.INSTANCE; } else { rule = UnpaddedMonthField.INSTANCE;
for (int i=mRules.length; --i >= 0; ) { len += mRules[i].estimateLength(); }  mMaxLengthEstimate = len; }  /* Parse the pattern*/ /*-----------------------------------------------------------------------*/ /** * <p>Returns a list of Rules given a pattern.</p> * * @return a {@code List} of Rule objects * @throws IllegalArgumentException if pattern is invalid } else { <BUGS> rule = TwoDigitYearField.INSTANCE; <BUGE> } break; case 'M': /* month in year (text and number)*/ if (tokenLen >= 4) { rule = new TextField(Calendar.MONTH, months); } else if (tokenLen == 3) { rule = new TextField(Calendar.MONTH, shortMonths); } else if (tokenLen == 2) { rule = TwoDigitMonthField.INSTANCE; } else { rule = UnpaddedMonthField.INSTANCE; } break; case 'd': /* day in month (number)*/
for (int i=mRules.length; --i >= 0; ) { len += mRules[i].estimateLength(); }  mMaxLengthEstimate = len; }  /* Parse the pattern*/ /*-----------------------------------------------------------------------*/ /** * <p>Returns a list of Rules given a pattern.</p> * * @return a {@code List} of Rule objects * @throws IllegalArgumentException if pattern is invalid } <BUGS> break; <BUGE> case 'M': /* month in year (text and number)*/ if (tokenLen >= 4) { rule = new TextField(Calendar.MONTH, months); } else if (tokenLen == 3) { rule = new TextField(Calendar.MONTH, shortMonths); } else if (tokenLen == 2) { rule = TwoDigitMonthField.INSTANCE; } else { rule = UnpaddedMonthField.INSTANCE; } break; case 'd': /* day in month (number)*/ rule = selectNumberRule(Calendar.DAY_OF_MONTH, tokenLen); break;
}  mMaxLengthEstimate = len; }  /* Parse the pattern*/ /*-----------------------------------------------------------------------*/ /** * <p>Returns a list of Rules given a pattern.</p> * * @return a {@code List} of Rule objects * @throws IllegalArgumentException if pattern is invalid case 'M': /* month in year (text and number)*/ <BUGS> if (tokenLen >= 4) { rule = new TextField(Calendar.MONTH, months); } else if (tokenLen == 3) { rule = new TextField(Calendar.MONTH, shortMonths); } else if (tokenLen == 2) { rule = TwoDigitMonthField.INSTANCE; <BUGE> } else { rule = UnpaddedMonthField.INSTANCE; } break; case 'd': /* day in month (number)*/ rule = selectNumberRule(Calendar.DAY_OF_MONTH, tokenLen); break; case 'h': /* hour in am/pm (number, 1..12)*/ rule = new TwelveHourField(selectNumberRule(Calendar.HOUR, tokenLen)); break; case 'H': /* hour in day (number, 0..23)*/
for (int i=mRules.length; --i >= 0; ) { len += mRules[i].estimateLength(); }  mMaxLengthEstimate = len; }  /* Parse the pattern*/ /*-----------------------------------------------------------------------*/ /** * <p>Returns a list of Rules given a pattern.</p> * * @return a {@code List} of Rule objects * @throws IllegalArgumentException if pattern is invalid } else { <BUGS> rule = UnpaddedMonthField.INSTANCE; <BUGE> } break; case 'd': /* day in month (number)*/ rule = selectNumberRule(Calendar.DAY_OF_MONTH, tokenLen); break; case 'h': /* hour in am/pm (number, 1..12)*/ rule = new TwelveHourField(selectNumberRule(Calendar.HOUR, tokenLen)); break; case 'H': /* hour in day (number, 0..23)*/ rule = selectNumberRule(Calendar.HOUR_OF_DAY, tokenLen); break; case 'm': /* minute in hour (number)*/ rule = selectNumberRule(Calendar.MINUTE, tokenLen); break;
for (int i=mRules.length; --i >= 0; ) { len += mRules[i].estimateLength(); }  mMaxLengthEstimate = len; }  /* Parse the pattern*/ /*-----------------------------------------------------------------------*/ /** * <p>Returns a list of Rules given a pattern.</p> * * @return a {@code List} of Rule objects * @throws IllegalArgumentException if pattern is invalid } <BUGS> break; <BUGE> case 'd': /* day in month (number)*/ rule = selectNumberRule(Calendar.DAY_OF_MONTH, tokenLen); break; case 'h': /* hour in am/pm (number, 1..12)*/ rule = new TwelveHourField(selectNumberRule(Calendar.HOUR, tokenLen)); break; case 'H': /* hour in day (number, 0..23)*/ rule = selectNumberRule(Calendar.HOUR_OF_DAY, tokenLen); break; case 'm': /* minute in hour (number)*/ rule = selectNumberRule(Calendar.MINUTE, tokenLen); break; case 's': /* second in minute (number)*/ rule = selectNumberRule(Calendar.SECOND, tokenLen);
for (int i=mRules.length; --i >= 0; ) { len += mRules[i].estimateLength(); }  mMaxLengthEstimate = len; }  /* Parse the pattern*/ /*-----------------------------------------------------------------------*/ /** * <p>Returns a list of Rules given a pattern.</p> * * @return a {@code List} of Rule objects * @throws IllegalArgumentException if pattern is invalid case 'd': /* day in month (number)*/ <BUGS> rule = selectNumberRule(Calendar.DAY_OF_MONTH, tokenLen); break; <BUGE> case 'h': /* hour in am/pm (number, 1..12)*/ rule = new TwelveHourField(selectNumberRule(Calendar.HOUR, tokenLen)); break; case 'H': /* hour in day (number, 0..23)*/ rule = selectNumberRule(Calendar.HOUR_OF_DAY, tokenLen); break; case 'm': /* minute in hour (number)*/ rule = selectNumberRule(Calendar.MINUTE, tokenLen); break; case 's': /* second in minute (number)*/ rule = selectNumberRule(Calendar.SECOND, tokenLen); break; case 'S': /* millisecond (number)*/
for (int i=mRules.length; --i >= 0; ) { len += mRules[i].estimateLength(); }  mMaxLengthEstimate = len; }  /* Parse the pattern*/ /*-----------------------------------------------------------------------*/ /** * <p>Returns a list of Rules given a pattern.</p> * * @return a {@code List} of Rule objects * @throws IllegalArgumentException if pattern is invalid case 'H': /* hour in day (number, 0..23)*/ <BUGS> rule = selectNumberRule(Calendar.HOUR_OF_DAY, tokenLen); break; <BUGE> case 'm': /* minute in hour (number)*/ rule = selectNumberRule(Calendar.MINUTE, tokenLen); break; case 's': /* second in minute (number)*/ rule = selectNumberRule(Calendar.SECOND, tokenLen); break; case 'S': /* millisecond (number)*/ rule = selectNumberRule(Calendar.MILLISECOND, tokenLen); break; case 'E': /* day in week (text)*/ rule = new TextField(Calendar.DAY_OF_WEEK, tokenLen < 4 ? shortWeekdays : weekdays); break; case 'D': /* day in year (number)*/
for (int i=mRules.length; --i >= 0; ) { len += mRules[i].estimateLength(); }  mMaxLengthEstimate = len; }  /* Parse the pattern*/ /*-----------------------------------------------------------------------*/ /** * <p>Returns a list of Rules given a pattern.</p> * * @return a {@code List} of Rule objects * @throws IllegalArgumentException if pattern is invalid case 'm': /* minute in hour (number)*/ <BUGS> rule = selectNumberRule(Calendar.MINUTE, tokenLen); break; <BUGE> case 's': /* second in minute (number)*/ rule = selectNumberRule(Calendar.SECOND, tokenLen); break; case 'S': /* millisecond (number)*/ rule = selectNumberRule(Calendar.MILLISECOND, tokenLen); break; case 'E': /* day in week (text)*/ rule = new TextField(Calendar.DAY_OF_WEEK, tokenLen < 4 ? shortWeekdays : weekdays); break; case 'D': /* day in year (number)*/ rule = selectNumberRule(Calendar.DAY_OF_YEAR, tokenLen); break; case 'F': /* day of week in month (number)*/
for (int i=mRules.length; --i >= 0; ) { len += mRules[i].estimateLength(); }  mMaxLengthEstimate = len; }  /* Parse the pattern*/ /*-----------------------------------------------------------------------*/ /** * <p>Returns a list of Rules given a pattern.</p> * * @return a {@code List} of Rule objects * @throws IllegalArgumentException if pattern is invalid case 's': /* second in minute (number)*/ <BUGS> rule = selectNumberRule(Calendar.SECOND, tokenLen); break; <BUGE> case 'S': /* millisecond (number)*/ rule = selectNumberRule(Calendar.MILLISECOND, tokenLen); break; case 'E': /* day in week (text)*/ rule = new TextField(Calendar.DAY_OF_WEEK, tokenLen < 4 ? shortWeekdays : weekdays); break; case 'D': /* day in year (number)*/ rule = selectNumberRule(Calendar.DAY_OF_YEAR, tokenLen); break; case 'F': /* day of week in month (number)*/ rule = selectNumberRule(Calendar.DAY_OF_WEEK_IN_MONTH, tokenLen); break; case 'w': /* week in year (number)*/
for (int i=mRules.length; --i >= 0; ) { len += mRules[i].estimateLength(); }  mMaxLengthEstimate = len; }  /* Parse the pattern*/ /*-----------------------------------------------------------------------*/ /** * <p>Returns a list of Rules given a pattern.</p> * * @return a {@code List} of Rule objects * @throws IllegalArgumentException if pattern is invalid case 'E': /* day in week (text)*/ <BUGS> rule = new TextField(Calendar.DAY_OF_WEEK, tokenLen < 4 ? shortWeekdays : weekdays); break; <BUGE> case 'D': /* day in year (number)*/ rule = selectNumberRule(Calendar.DAY_OF_YEAR, tokenLen); break; case 'F': /* day of week in month (number)*/ rule = selectNumberRule(Calendar.DAY_OF_WEEK_IN_MONTH, tokenLen); break; case 'w': /* week in year (number)*/ rule = selectNumberRule(Calendar.WEEK_OF_YEAR, tokenLen); break; case 'W': /* week in month (number)*/ rule = selectNumberRule(Calendar.WEEK_OF_MONTH, tokenLen); break; case 'a': /* am/pm marker (text)*/
for (int i=mRules.length; --i >= 0; ) { len += mRules[i].estimateLength(); }  mMaxLengthEstimate = len; }  /* Parse the pattern*/ /*-----------------------------------------------------------------------*/ /** * <p>Returns a list of Rules given a pattern.</p> * * @return a {@code List} of Rule objects * @throws IllegalArgumentException if pattern is invalid case 'D': /* day in year (number)*/ <BUGS> rule = selectNumberRule(Calendar.DAY_OF_YEAR, tokenLen); break; <BUGE> case 'F': /* day of week in month (number)*/ rule = selectNumberRule(Calendar.DAY_OF_WEEK_IN_MONTH, tokenLen); break; case 'w': /* week in year (number)*/ rule = selectNumberRule(Calendar.WEEK_OF_YEAR, tokenLen); break; case 'W': /* week in month (number)*/ rule = selectNumberRule(Calendar.WEEK_OF_MONTH, tokenLen); break; case 'a': /* am/pm marker (text)*/ rule = new TextField(Calendar.AM_PM, AmPmStrings); break; case 'k': /* hour in day (1..24)*/
for (int i=mRules.length; --i >= 0; ) { len += mRules[i].estimateLength(); }  mMaxLengthEstimate = len; }  /* Parse the pattern*/ /*-----------------------------------------------------------------------*/ /** * <p>Returns a list of Rules given a pattern.</p> * * @return a {@code List} of Rule objects * @throws IllegalArgumentException if pattern is invalid case 'a': /* am/pm marker (text)*/ <BUGS> rule = new TextField(Calendar.AM_PM, AmPmStrings); break; <BUGE> case 'k': /* hour in day (1..24)*/ rule = new TwentyFourHourField(selectNumberRule(Calendar.HOUR_OF_DAY, tokenLen)); break; case 'K': /* hour in am/pm (0..11)*/ rule = selectNumberRule(Calendar.HOUR, tokenLen); break; case 'z': /* time zone (text)*/ if (tokenLen >= 4) { rule = new TimeZoneNameRule(mTimeZone, mLocale, TimeZone.LONG); } else { rule = new TimeZoneNameRule(mTimeZone, mLocale, TimeZone.SHORT); } break;
for (int i=mRules.length; --i >= 0; ) { len += mRules[i].estimateLength(); }  mMaxLengthEstimate = len; }  /* Parse the pattern*/ /*-----------------------------------------------------------------------*/ /** * <p>Returns a list of Rules given a pattern.</p> * * @return a {@code List} of Rule objects * @throws IllegalArgumentException if pattern is invalid case 'z': /* time zone (text)*/ <BUGS> if (tokenLen >= 4) { rule = new TimeZoneNameRule(mTimeZone, mLocale, TimeZone.LONG); <BUGE> } else { rule = new TimeZoneNameRule(mTimeZone, mLocale, TimeZone.SHORT); } break; case 'Z': /* time zone (value)*/ if (tokenLen == 1) { rule = TimeZoneNumberRule.INSTANCE_NO_COLON; } else { rule = TimeZoneNumberRule.INSTANCE_COLON; } break; case '\'': /* literal text*/ String sub = token.substring(1);
for (int i=mRules.length; --i >= 0; ) { len += mRules[i].estimateLength(); }  mMaxLengthEstimate = len; }  /* Parse the pattern*/ /*-----------------------------------------------------------------------*/ /** * <p>Returns a list of Rules given a pattern.</p> * * @return a {@code List} of Rule objects * @throws IllegalArgumentException if pattern is invalid } else { <BUGS> rule = new TimeZoneNameRule(mTimeZone, mLocale, TimeZone.SHORT); <BUGE> } break; case 'Z': /* time zone (value)*/ if (tokenLen == 1) { rule = TimeZoneNumberRule.INSTANCE_NO_COLON; } else { rule = TimeZoneNumberRule.INSTANCE_COLON; } break; case '\'': /* literal text*/ String sub = token.substring(1); if (sub.length() == 1) { rule = new CharacterLiteral(sub.charAt(0)); } else {
for (int i=mRules.length; --i >= 0; ) { len += mRules[i].estimateLength(); }  mMaxLengthEstimate = len; }  /* Parse the pattern*/ /*-----------------------------------------------------------------------*/ /** * <p>Returns a list of Rules given a pattern.</p> * * @return a {@code List} of Rule objects * @throws IllegalArgumentException if pattern is invalid } <BUGS> break; <BUGE> case 'Z': /* time zone (value)*/ if (tokenLen == 1) { rule = TimeZoneNumberRule.INSTANCE_NO_COLON; } else { rule = TimeZoneNumberRule.INSTANCE_COLON; } break; case '\'': /* literal text*/ String sub = token.substring(1); if (sub.length() == 1) { rule = new CharacterLiteral(sub.charAt(0)); } else { rule = new StringLiteral(sub); }
for (int i=mRules.length; --i >= 0; ) { len += mRules[i].estimateLength(); }  mMaxLengthEstimate = len; }  /* Parse the pattern*/ /*-----------------------------------------------------------------------*/ /** * <p>Returns a list of Rules given a pattern.</p> * * @return a {@code List} of Rule objects * @throws IllegalArgumentException if pattern is invalid case 'Z': /* time zone (value)*/ <BUGS> if (tokenLen == 1) { rule = TimeZoneNumberRule.INSTANCE_NO_COLON; <BUGE> } else { rule = TimeZoneNumberRule.INSTANCE_COLON; } break; case '\'': /* literal text*/ String sub = token.substring(1); if (sub.length() == 1) { rule = new CharacterLiteral(sub.charAt(0)); } else { rule = new StringLiteral(sub); } break; default:
for (int i=mRules.length; --i >= 0; ) { len += mRules[i].estimateLength(); }  mMaxLengthEstimate = len; }  /* Parse the pattern*/ /*-----------------------------------------------------------------------*/ /** * <p>Returns a list of Rules given a pattern.</p> * * @return a {@code List} of Rule objects * @throws IllegalArgumentException if pattern is invalid } else { <BUGS> rule = TimeZoneNumberRule.INSTANCE_COLON; <BUGE> } break; case '\'': /* literal text*/ String sub = token.substring(1); if (sub.length() == 1) { rule = new CharacterLiteral(sub.charAt(0)); } else { rule = new StringLiteral(sub); } break; default: throw new IllegalArgumentException("Illegal pattern component: " + token); }
for (int i=mRules.length; --i >= 0; ) { len += mRules[i].estimateLength(); }  mMaxLengthEstimate = len; }  /* Parse the pattern*/ /*-----------------------------------------------------------------------*/ /** * <p>Returns a list of Rules given a pattern.</p> * * @return a {@code List} of Rule objects * @throws IllegalArgumentException if pattern is invalid } <BUGS> break; <BUGE> case '\'': /* literal text*/ String sub = token.substring(1); if (sub.length() == 1) { rule = new CharacterLiteral(sub.charAt(0)); } else { rule = new StringLiteral(sub); } break; default: throw new IllegalArgumentException("Illegal pattern component: " + token); }  rules.add(rule); }
len += mRules[i].estimateLength(); }  mMaxLengthEstimate = len; }  /* Parse the pattern*/ /*-----------------------------------------------------------------------*/ /** * <p>Returns a list of Rules given a pattern.</p> * * @return a {@code List} of Rule objects * @throws IllegalArgumentException if pattern is invalid case '\'': /* literal text*/ <BUGS> String sub = token.substring(1); if (sub.length() == 1) { rule = new CharacterLiteral(sub.charAt(0)); <BUGE> } else { rule = new StringLiteral(sub); } break; default: throw new IllegalArgumentException("Illegal pattern component: " + token); }  rules.add(rule); }  return rules; }
for (int i=mRules.length; --i >= 0; ) { len += mRules[i].estimateLength(); }  mMaxLengthEstimate = len; }  /* Parse the pattern*/ /*-----------------------------------------------------------------------*/ /** * <p>Returns a list of Rules given a pattern.</p> * * @return a {@code List} of Rule objects * @throws IllegalArgumentException if pattern is invalid  <BUGS> rules.add(rule); <BUGE> }  return rules; }  /** * <p>Performs the parsing of tokens.</p> * * @param pattern  the pattern * @param indexRef  index references * @return parsed token */ protected String parseToken(String pattern, int[] indexRef) { StringBuilder buf = new StringBuilder();
for (int i=mRules.length; --i >= 0; ) { len += mRules[i].estimateLength(); }  mMaxLengthEstimate = len; }  /* Parse the pattern*/ /*-----------------------------------------------------------------------*/ /** * <p>Returns a list of Rules given a pattern.</p> * * @return a {@code List} of Rule objects * @throws IllegalArgumentException if pattern is invalid  <BUGS> return rules; <BUGE> }  /** * <p>Performs the parsing of tokens.</p> * * @param pattern  the pattern * @param indexRef  index references * @return parsed token */ protected String parseToken(String pattern, int[] indexRef) { StringBuilder buf = new StringBuilder();  int i = indexRef[0]; int length = pattern.length();
@Override public int translate(CharSequence input, int index, Writer out) throws IOException { <BUGS> int seqEnd = input.length(); <BUGE> /* Uses -2 to ensure there is something after the &#*/ if(input.charAt(index) == '&' && index < seqEnd - 1 && input.charAt(index + 1) == '#') { int start = index + 2; boolean isHex = false;  char firstChar = input.charAt(start); if(firstChar == 'x' || firstChar == 'X') { start++; isHex = true;  /* Check there's more than just an x after the &#*/ }  int end = start; /* Note that this supports character codes without a ; on the end*/ while(input.charAt(end) != ';') { end++; }  int entityValue; try { if(isHex) { entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 16); } else { entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 10); }
@Override public int translate(CharSequence input, int index, Writer out) throws IOException { int seqEnd = input.length(); /* Uses -2 to ensure there is something after the &#*/ <BUGS> if(input.charAt(index) == '&' && index < seqEnd - 1 && input.charAt(index + 1) == '#') { int start = index + 2; boolean isHex = false; <BUGE>  char firstChar = input.charAt(start); if(firstChar == 'x' || firstChar == 'X') { start++; isHex = true;  /* Check there's more than just an x after the &#*/ }  int end = start; /* Note that this supports character codes without a ; on the end*/ while(input.charAt(end) != ';') { end++; }  int entityValue; try { if(isHex) { entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 16); } else { entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 10); }
@Override public int translate(CharSequence input, int index, Writer out) throws IOException { int seqEnd = input.length(); /* Uses -2 to ensure there is something after the &#*/ if(input.charAt(index) == '&' && index < seqEnd - 1 && input.charAt(index + 1) == '#') { int start = index + 2; boolean isHex = false;  <BUGS> char firstChar = input.charAt(start); if(firstChar == 'x' || firstChar == 'X') { start++; isHex = true; <BUGE>  /* Check there's more than just an x after the &#*/ }  int end = start; /* Note that this supports character codes without a ; on the end*/ while(input.charAt(end) != ';') { end++; }  int entityValue; try { if(isHex) { entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 16); } else { entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 10); }
@Override public int translate(CharSequence input, int index, Writer out) throws IOException { int seqEnd = input.length(); /* Uses -2 to ensure there is something after the &#*/ if(input.charAt(index) == '&' && index < seqEnd - 1 && input.charAt(index + 1) == '#') { int start = index + 2; boolean isHex = false;  char firstChar = input.charAt(start); if(firstChar == 'x' || firstChar == 'X') { start++; isHex = true;  /* Check there's more than just an x after the &#*/ }  <BUGS> int end = start; <BUGE> /* Note that this supports character codes without a ; on the end*/ while(input.charAt(end) != ';') { end++; }  int entityValue; try { if(isHex) { entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 16); } else { entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 10); }
@Override public int translate(CharSequence input, int index, Writer out) throws IOException { int seqEnd = input.length(); /* Uses -2 to ensure there is something after the &#*/ if(input.charAt(index) == '&' && index < seqEnd - 1 && input.charAt(index + 1) == '#') { int start = index + 2; boolean isHex = false;  char firstChar = input.charAt(start); if(firstChar == 'x' || firstChar == 'X') { start++; isHex = true;  /* Check there's more than just an x after the &#*/ }  int end = start; /* Note that this supports character codes without a ; on the end*/ <BUGS> while(input.charAt(end) != ';') <BUGE> { end++; }  int entityValue; try { if(isHex) { entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 16); } else { entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 10); }
@Override public int translate(CharSequence input, int index, Writer out) throws IOException { int seqEnd = input.length(); /* Uses -2 to ensure there is something after the &#*/ if(input.charAt(index) == '&' && index < seqEnd - 1 && input.charAt(index + 1) == '#') { int start = index + 2; boolean isHex = false;  char firstChar = input.charAt(start); if(firstChar == 'x' || firstChar == 'X') { start++; isHex = true;  /* Check there's more than just an x after the &#*/ }  int end = start; /* Note that this supports character codes without a ; on the end*/ while(input.charAt(end) != ';') { <BUGS> end++; <BUGE> }  int entityValue; try { if(isHex) { entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 16); } else { entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 10); }
/** * Translate XML numeric entities of the form &#[xX]?\d+;? to * the specific codepoint. * * Note that the semi-colon is optional. * * @since 3.0 * @version $Id$ */ public class NumericEntityUnescaper extends CharSequenceTranslator {  /** * {@inheritDoc} */ } <BUGS> return 0; <BUGE> } }
*/ public static String join(Object[] array, char separator) { <BUGS> if (array == null) { return null; <BUGE> }  return join(array, separator, 0, array.length); }
*/ public static String join(Object[] array, char separator) { if (array == null) { return null; }  <BUGS> return join(array, separator, 0, array.length); <BUGE> }
*/ public static boolean isSameLocalTime(Calendar cal1, Calendar cal2) { <BUGS> if (cal1 == null || cal2 == null) { <BUGE> throw new IllegalArgumentException("The date must not be null"); } return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) && cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) && cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) && cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) && cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) && cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) && cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) && cal1.getClass() == cal2.getClass()); }
*/ public static boolean isSameLocalTime(Calendar cal1, Calendar cal2) { if (cal1 == null || cal2 == null) { throw new IllegalArgumentException("The date must not be null"); } <BUGS> return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) && <BUGE> cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) && cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) && cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) && cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) && cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) && cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) && cal1.getClass() == cal2.getClass()); }
*/ public static Fraction getReducedFraction(int numerator, int denominator) { <BUGS> if (denominator == 0) { throw new ArithmeticException("The denominator must not be zero"); <BUGE> } if (numerator==0) { return ZERO; /* normalize zero.*/ } /* allow 2^k/-2^31 as a valid fraction (where k>0)*/ if (denominator==Integer.MIN_VALUE && (numerator&1)==0) { numerator/=2; denominator/=2; } if (denominator < 0) { if (numerator==Integer.MIN_VALUE || denominator==Integer.MIN_VALUE) { throw new ArithmeticException("overflow: can't negate"); } numerator = -numerator; denominator = -denominator; } /* simplify fraction.*/ int gcd = greatestCommonDivisor(numerator, denominator); numerator /= gcd; denominator /= gcd; return new Fraction(numerator, denominator); }
*/ public static Fraction getReducedFraction(int numerator, int denominator) { if (denominator == 0) { throw new ArithmeticException("The denominator must not be zero"); } <BUGS> if (numerator==0) { return ZERO; /* normalize zero. <BUGE>*/ } /* allow 2^k/-2^31 as a valid fraction (where k>0)*/ if (denominator==Integer.MIN_VALUE && (numerator&1)==0) { numerator/=2; denominator/=2; } if (denominator < 0) { if (numerator==Integer.MIN_VALUE || denominator==Integer.MIN_VALUE) { throw new ArithmeticException("overflow: can't negate"); } numerator = -numerator; denominator = -denominator; } /* simplify fraction.*/ int gcd = greatestCommonDivisor(numerator, denominator); numerator /= gcd; denominator /= gcd; return new Fraction(numerator, denominator); }
*/ public static Fraction getReducedFraction(int numerator, int denominator) { if (denominator == 0) { throw new ArithmeticException("The denominator must not be zero"); } if (numerator==0) { return ZERO; /* normalize zero.*/ } /* allow 2^k/-2^31 as a valid fraction (where k>0)*/ <BUGS> if (denominator==Integer.MIN_VALUE && (numerator&1)==0) { numerator/=2; denominator/=2; <BUGE> } if (denominator < 0) { if (numerator==Integer.MIN_VALUE || denominator==Integer.MIN_VALUE) { throw new ArithmeticException("overflow: can't negate"); } numerator = -numerator; denominator = -denominator; } /* simplify fraction.*/ int gcd = greatestCommonDivisor(numerator, denominator); numerator /= gcd; denominator /= gcd; return new Fraction(numerator, denominator); }
*/ public static Fraction getReducedFraction(int numerator, int denominator) { if (denominator == 0) { throw new ArithmeticException("The denominator must not be zero"); } if (numerator==0) { return ZERO; /* normalize zero.*/ } /* allow 2^k/-2^31 as a valid fraction (where k>0)*/ if (denominator==Integer.MIN_VALUE && (numerator&1)==0) { numerator/=2; denominator/=2; } <BUGS> if (denominator < 0) { if (numerator==Integer.MIN_VALUE || <BUGE> denominator==Integer.MIN_VALUE) { throw new ArithmeticException("overflow: can't negate"); } numerator = -numerator; denominator = -denominator; } /* simplify fraction.*/ int gcd = greatestCommonDivisor(numerator, denominator); numerator /= gcd; denominator /= gcd; return new Fraction(numerator, denominator); }
*/ public static Fraction getReducedFraction(int numerator, int denominator) { if (denominator == 0) { throw new ArithmeticException("The denominator must not be zero"); } if (numerator==0) { return ZERO; /* normalize zero.*/ } /* allow 2^k/-2^31 as a valid fraction (where k>0)*/ if (denominator==Integer.MIN_VALUE && (numerator&1)==0) { numerator/=2; denominator/=2; } if (denominator < 0) { if (numerator==Integer.MIN_VALUE || denominator==Integer.MIN_VALUE) { <BUGS> throw new ArithmeticException("overflow: can't negate"); <BUGE> } numerator = -numerator; denominator = -denominator; } /* simplify fraction.*/ int gcd = greatestCommonDivisor(numerator, denominator); numerator /= gcd; denominator /= gcd; return new Fraction(numerator, denominator); }
*/ public static Fraction getReducedFraction(int numerator, int denominator) { if (denominator == 0) { throw new ArithmeticException("The denominator must not be zero"); } if (numerator==0) { return ZERO; /* normalize zero.*/ } /* allow 2^k/-2^31 as a valid fraction (where k>0)*/ if (denominator==Integer.MIN_VALUE && (numerator&1)==0) { numerator/=2; denominator/=2; } if (denominator < 0) { if (numerator==Integer.MIN_VALUE || denominator==Integer.MIN_VALUE) { throw new ArithmeticException("overflow: can't negate"); } <BUGS> numerator = -numerator; denominator = -denominator; <BUGE> } /* simplify fraction.*/ int gcd = greatestCommonDivisor(numerator, denominator); numerator /= gcd; denominator /= gcd; return new Fraction(numerator, denominator); }
*/ public static Fraction getReducedFraction(int numerator, int denominator) { if (denominator == 0) { throw new ArithmeticException("The denominator must not be zero"); } if (numerator==0) { return ZERO; /* normalize zero.*/ } /* allow 2^k/-2^31 as a valid fraction (where k>0)*/ if (denominator==Integer.MIN_VALUE && (numerator&1)==0) { numerator/=2; denominator/=2; } if (denominator < 0) { if (numerator==Integer.MIN_VALUE || denominator==Integer.MIN_VALUE) { throw new ArithmeticException("overflow: can't negate"); } numerator = -numerator; denominator = -denominator; } /* simplify fraction.*/ <BUGS> int gcd = greatestCommonDivisor(numerator, denominator); numerator /= gcd; denominator /= gcd; return new Fraction(numerator, denominator); <BUGE> }
@Override public final void applyPattern(String pattern) { <BUGS> if (registry == null) { super.applyPattern(pattern); toPattern = super.toPattern(); return; <BUGE> } ArrayList<Format> foundFormats = new ArrayList<Format>(); ArrayList<String> foundDescriptions = new ArrayList<String>(); StringBuilder stripCustom = new StringBuilder(pattern.length());  ParsePosition pos = new ParsePosition(0); char[] c = pattern.toCharArray(); int fmtCount = 0; while (pos.getIndex() < pattern.length()) { switch (c[pos.getIndex()]) { case QUOTE: appendQuotedString(pattern, pos, stripCustom, true); break; case START_FE: fmtCount++; seekNonWs(pattern, pos); int start = pos.getIndex(); int index = readArgumentIndex(pattern, next(pos)); stripCustom.append(START_FE).append(index); seekNonWs(pattern, pos); Format format = null; String formatDescription = null; if (c[pos.getIndex()] == START_FMT) { formatDescription = parseFormatDescription(pattern,
@Override public final void applyPattern(String pattern) { if (registry == null) { super.applyPattern(pattern); toPattern = super.toPattern(); return; } <BUGS> ArrayList<Format> foundFormats = new ArrayList<Format>(); ArrayList<String> foundDescriptions = new ArrayList<String>(); StringBuilder stripCustom = new StringBuilder(pattern.length()); <BUGE>  ParsePosition pos = new ParsePosition(0); char[] c = pattern.toCharArray(); int fmtCount = 0; while (pos.getIndex() < pattern.length()) { switch (c[pos.getIndex()]) { case QUOTE: appendQuotedString(pattern, pos, stripCustom, true); break; case START_FE: fmtCount++; seekNonWs(pattern, pos); int start = pos.getIndex(); int index = readArgumentIndex(pattern, next(pos)); stripCustom.append(START_FE).append(index); seekNonWs(pattern, pos); Format format = null; String formatDescription = null; if (c[pos.getIndex()] == START_FMT) { formatDescription = parseFormatDescription(pattern,
@Override public final void applyPattern(String pattern) { if (registry == null) { super.applyPattern(pattern); toPattern = super.toPattern(); return; } ArrayList<Format> foundFormats = new ArrayList<Format>(); ArrayList<String> foundDescriptions = new ArrayList<String>(); StringBuilder stripCustom = new StringBuilder(pattern.length());  <BUGS> ParsePosition pos = new ParsePosition(0); char[] c = pattern.toCharArray(); int fmtCount = 0; while (pos.getIndex() < pattern.length()) { switch (c[pos.getIndex()]) { <BUGE> case QUOTE: appendQuotedString(pattern, pos, stripCustom, true); break; case START_FE: fmtCount++; seekNonWs(pattern, pos); int start = pos.getIndex(); int index = readArgumentIndex(pattern, next(pos)); stripCustom.append(START_FE).append(index); seekNonWs(pattern, pos); Format format = null; String formatDescription = null; if (c[pos.getIndex()] == START_FMT) { formatDescription = parseFormatDescription(pattern,
@Override public final void applyPattern(String pattern) { if (registry == null) { super.applyPattern(pattern); toPattern = super.toPattern(); return; } ArrayList<Format> foundFormats = new ArrayList<Format>(); ArrayList<String> foundDescriptions = new ArrayList<String>(); StringBuilder stripCustom = new StringBuilder(pattern.length());  ParsePosition pos = new ParsePosition(0); char[] c = pattern.toCharArray(); int fmtCount = 0; while (pos.getIndex() < pattern.length()) { switch (c[pos.getIndex()]) { case QUOTE: appendQuotedString(pattern, pos, stripCustom, true); break; case START_FE: <BUGS> fmtCount++; seekNonWs(pattern, pos); int start = pos.getIndex(); int index = readArgumentIndex(pattern, next(pos)); stripCustom.append(START_FE).append(index); seekNonWs(pattern, pos); Format format = null; String formatDescription = null; if (c[pos.getIndex()] == START_FMT) { formatDescription = parseFormatDescription(pattern, <BUGE>
/** * {@inheritDoc} */ @Override public String toPattern() { return toPattern; }  /** * Apply the specified pattern. * * @param pattern String */ next(pos)); <BUGS> format = getFormat(formatDescription); if (format == null) { <BUGE> stripCustom.append(START_FMT).append(formatDescription); } } foundFormats.add(format); foundDescriptions.add(format == null ? null : formatDescription); Validate.isTrue(foundFormats.size() == fmtCount); Validate.isTrue(foundDescriptions.size() == fmtCount); if (c[pos.getIndex()] != END_FE) { throw new IllegalArgumentException( "Unreadable format element at position " + start); } /*$FALL-THROUGH$*/ default:
* {@inheritDoc} */ @Override public String toPattern() { return toPattern; }  /** * Apply the specified pattern. * * @param pattern String */ } <BUGS> foundFormats.add(format); foundDescriptions.add(format == null ? null : formatDescription); Validate.isTrue(foundFormats.size() == fmtCount); Validate.isTrue(foundDescriptions.size() == fmtCount); if (c[pos.getIndex()] != END_FE) { <BUGE> throw new IllegalArgumentException( "Unreadable format element at position " + start); } /*$FALL-THROUGH$*/ default: stripCustom.append(c[pos.getIndex()]); next(pos); } } super.applyPattern(stripCustom.toString()); toPattern = insertFormats(super.toPattern(), foundDescriptions); if (containsElements(foundFormats)) {
/** * {@inheritDoc} */ @Override public String toPattern() { return toPattern; }  /** * Apply the specified pattern. * * @param pattern String */ default: <BUGS> stripCustom.append(c[pos.getIndex()]); next(pos); <BUGE> } } super.applyPattern(stripCustom.toString()); toPattern = insertFormats(super.toPattern(), foundDescriptions); if (containsElements(foundFormats)) { Format[] origFormats = getFormats(); /* only loop over what we know we have, as MessageFormat on Java 1.3 */ /* seems to provide an extra format element:*/ int i = 0; for (Iterator<Format> it = foundFormats.iterator(); it.hasNext(); i++) { Format f = it.next(); if (f != null) { origFormats[i] = f;
/** * {@inheritDoc} */ @Override public String toPattern() { return toPattern; }  /** * Apply the specified pattern. * * @param pattern String */ } <BUGS> super.applyPattern(stripCustom.toString()); toPattern = insertFormats(super.toPattern(), foundDescriptions); if (containsElements(foundFormats)) { Format[] origFormats = getFormats(); <BUGE> /* only loop over what we know we have, as MessageFormat on Java 1.3 */ /* seems to provide an extra format element:*/ int i = 0; for (Iterator<Format> it = foundFormats.iterator(); it.hasNext(); i++) { Format f = it.next(); if (f != null) { origFormats[i] = f; } } super.setFormats(origFormats); } }
* {@inheritDoc} */ @Override public String toPattern() { return toPattern; }  /** * Apply the specified pattern. * * @param pattern String */ /* seems to provide an extra format element:*/ <BUGS> int i = 0; for (Iterator<Format> it = foundFormats.iterator(); it.hasNext(); i++) { Format f = it.next(); if (f != null) { origFormats[i] = f; <BUGE> } } super.setFormats(origFormats); } }  /** * Throws UnsupportedOperationException - see class Javadoc for details. * * @param formatElementIndex format element index * @param newFormat the new format * @throws UnsupportedOperationException
/** * {@inheritDoc} */ @Override public String toPattern() { return toPattern; }  /** * Apply the specified pattern. * * @param pattern String */ } <BUGS> super.setFormats(origFormats); <BUGE> } }  /** * Throws UnsupportedOperationException - see class Javadoc for details. * * @param formatElementIndex format element index * @param newFormat the new format * @throws UnsupportedOperationException */ @Override public void setFormat(int formatElementIndex, Format newFormat) { throw new UnsupportedOperationException(); }
/** * {@inheritDoc} */ @Override public String toPattern() { return toPattern; }  /** * Apply the specified pattern. * * @param pattern String */ } <BUGS> } <BUGE>  /** * Throws UnsupportedOperationException - see class Javadoc for details. * * @param formatElementIndex format element index * @param newFormat the new format * @throws UnsupportedOperationException */ @Override public void setFormat(int formatElementIndex, Format newFormat) { throw new UnsupportedOperationException(); }  /**
*/ public static Number createNumber(String str) throws NumberFormatException { <BUGS> if (str == null) { return null; <BUGE> } if (StringUtils.isBlank(str)) { throw new NumberFormatException("A blank string is not a valid number"); } if (str.startsWith("--")) { /* this is protection for poorness in java.lang.BigDecimal.*/ /* it accepts this as a legal value, but it does not appear */ /* to be in specification of class. OS X Java parses it to */ /* a wrong value.*/ return null; } if (str.startsWith("0x") || str.startsWith("-0x")) { return createInteger(str); } char lastChar = str.charAt(str.length() - 1); String mant; String dec; String exp; int decPos = str.indexOf('.'); int expPos = str.indexOf('e') + str.indexOf('E') + 1;  if (decPos > -1) {  if (expPos > -1) { if (expPos < decPos || expPos > str.length()) { throw new NumberFormatException(str + " is not a valid number.");
*/ public static Number createNumber(String str) throws NumberFormatException { if (str == null) { return null; } <BUGS> if (StringUtils.isBlank(str)) { throw new NumberFormatException("A blank string is not a valid number"); <BUGE> } if (str.startsWith("--")) { /* this is protection for poorness in java.lang.BigDecimal.*/ /* it accepts this as a legal value, but it does not appear */ /* to be in specification of class. OS X Java parses it to */ /* a wrong value.*/ return null; } if (str.startsWith("0x") || str.startsWith("-0x")) { return createInteger(str); } char lastChar = str.charAt(str.length() - 1); String mant; String dec; String exp; int decPos = str.indexOf('.'); int expPos = str.indexOf('e') + str.indexOf('E') + 1;  if (decPos > -1) {  if (expPos > -1) { if (expPos < decPos || expPos > str.length()) { throw new NumberFormatException(str + " is not a valid number.");
*/ public static Number createNumber(String str) throws NumberFormatException { if (str == null) { return null; } if (StringUtils.isBlank(str)) { throw new NumberFormatException("A blank string is not a valid number"); } <BUGS> if (str.startsWith("--")) { <BUGE> /* this is protection for poorness in java.lang.BigDecimal.*/ /* it accepts this as a legal value, but it does not appear */ /* to be in specification of class. OS X Java parses it to */ /* a wrong value.*/ return null; } if (str.startsWith("0x") || str.startsWith("-0x")) { return createInteger(str); } char lastChar = str.charAt(str.length() - 1); String mant; String dec; String exp; int decPos = str.indexOf('.'); int expPos = str.indexOf('e') + str.indexOf('E') + 1;  if (decPos > -1) {  if (expPos > -1) { if (expPos < decPos || expPos > str.length()) { throw new NumberFormatException(str + " is not a valid number.");
*/ public static Number createNumber(String str) throws NumberFormatException { if (str == null) { return null; } if (StringUtils.isBlank(str)) { throw new NumberFormatException("A blank string is not a valid number"); } if (str.startsWith("--")) { /* this is protection for poorness in java.lang.BigDecimal.*/ /* it accepts this as a legal value, but it does not appear */ /* to be in specification of class. OS X Java parses it to */ /* a wrong value.*/ <BUGS> return null; <BUGE> } if (str.startsWith("0x") || str.startsWith("-0x")) { return createInteger(str); } char lastChar = str.charAt(str.length() - 1); String mant; String dec; String exp; int decPos = str.indexOf('.'); int expPos = str.indexOf('e') + str.indexOf('E') + 1;  if (decPos > -1) {  if (expPos > -1) { if (expPos < decPos || expPos > str.length()) { throw new NumberFormatException(str + " is not a valid number.");
*/ public static Number createNumber(String str) throws NumberFormatException { if (str == null) { return null; } if (StringUtils.isBlank(str)) { throw new NumberFormatException("A blank string is not a valid number"); } if (str.startsWith("--")) { /* this is protection for poorness in java.lang.BigDecimal.*/ /* it accepts this as a legal value, but it does not appear */ /* to be in specification of class. OS X Java parses it to */ /* a wrong value.*/ return null; } <BUGS> if (str.startsWith("0x") || str.startsWith("-0x")) { return createInteger(str); <BUGE> } char lastChar = str.charAt(str.length() - 1); String mant; String dec; String exp; int decPos = str.indexOf('.'); int expPos = str.indexOf('e') + str.indexOf('E') + 1;  if (decPos > -1) {  if (expPos > -1) { if (expPos < decPos || expPos > str.length()) { throw new NumberFormatException(str + " is not a valid number.");
*/ public static Number createNumber(String str) throws NumberFormatException { if (str == null) { return null; } if (StringUtils.isBlank(str)) { throw new NumberFormatException("A blank string is not a valid number"); } if (str.startsWith("--")) { /* this is protection for poorness in java.lang.BigDecimal.*/ /* it accepts this as a legal value, but it does not appear */ /* to be in specification of class. OS X Java parses it to */ /* a wrong value.*/ return null; } if (str.startsWith("0x") || str.startsWith("-0x")) { return createInteger(str); } <BUGS> char lastChar = str.charAt(str.length() - 1); <BUGE> String mant; String dec; String exp; int decPos = str.indexOf('.'); int expPos = str.indexOf('e') + str.indexOf('E') + 1;  if (decPos > -1) {  if (expPos > -1) { if (expPos < decPos || expPos > str.length()) { throw new NumberFormatException(str + " is not a valid number.");
*/ public static Number createNumber(String str) throws NumberFormatException { if (str == null) { return null; } if (StringUtils.isBlank(str)) { throw new NumberFormatException("A blank string is not a valid number"); } if (str.startsWith("--")) { /* this is protection for poorness in java.lang.BigDecimal.*/ /* it accepts this as a legal value, but it does not appear */ /* to be in specification of class. OS X Java parses it to */ /* a wrong value.*/ return null; } if (str.startsWith("0x") || str.startsWith("-0x")) { return createInteger(str); } char lastChar = str.charAt(str.length() - 1); String mant; String dec; String exp; <BUGS> int decPos = str.indexOf('.'); int expPos = str.indexOf('e') + str.indexOf('E') + 1; <BUGE>  if (decPos > -1) {  if (expPos > -1) { if (expPos < decPos || expPos > str.length()) { throw new NumberFormatException(str + " is not a valid number.");
*/ public static Number createNumber(String str) throws NumberFormatException { if (str == null) { return null; } if (StringUtils.isBlank(str)) { throw new NumberFormatException("A blank string is not a valid number"); } if (str.startsWith("--")) { /* this is protection for poorness in java.lang.BigDecimal.*/ /* it accepts this as a legal value, but it does not appear */ /* to be in specification of class. OS X Java parses it to */ /* a wrong value.*/ return null; } if (str.startsWith("0x") || str.startsWith("-0x")) { return createInteger(str); } char lastChar = str.charAt(str.length() - 1); String mant; String dec; String exp; int decPos = str.indexOf('.'); int expPos = str.indexOf('e') + str.indexOf('E') + 1;  <BUGS> if (decPos > -1) { <BUGE>  if (expPos > -1) { if (expPos < decPos || expPos > str.length()) { throw new NumberFormatException(str + " is not a valid number.");
*/ public static Number createNumber(String str) throws NumberFormatException { if (str == null) { return null; } if (StringUtils.isBlank(str)) { throw new NumberFormatException("A blank string is not a valid number"); } if (str.startsWith("--")) { /* this is protection for poorness in java.lang.BigDecimal.*/ /* it accepts this as a legal value, but it does not appear */ /* to be in specification of class. OS X Java parses it to */ /* a wrong value.*/ return null; } if (str.startsWith("0x") || str.startsWith("-0x")) { return createInteger(str); } char lastChar = str.charAt(str.length() - 1); String mant; String dec; String exp; int decPos = str.indexOf('.'); int expPos = str.indexOf('e') + str.indexOf('E') + 1;  if (decPos > -1) {  <BUGS> if (expPos > -1) { if (expPos < decPos || expPos > str.length()) { throw new NumberFormatException(str + " is not a valid number."); <BUGE>
* <code>BigDecimal</code>.</p> * * <p>If the string starts with <code>0x</code> or <code>-0x</code>, it * will be interpreted as a hexadecimal integer.  Values with leading * <code>0</code>'s will not be interpreted as octal.</p> * * <p>Returns <code>null</code> if the string is <code>null</code>.</p> * * <p>This method does not trim the input string, i.e., strings with leading * or trailing spaces will generate NumberFormatExceptions.</p> * * @param str  String containing a number, may be null * @return Number created from the string * @throws NumberFormatException if the value cannot be converted } <BUGS> dec = str.substring(decPos + 1, expPos); <BUGE> } else { dec = str.substring(decPos + 1); } mant = str.substring(0, decPos); } else { if (expPos > -1) { if (expPos > str.length()) { throw new NumberFormatException(str + " is not a valid number."); } mant = str.substring(0, expPos); } else { mant = str; } dec = null;
* <code>BigDecimal</code>.</p> * * <p>If the string starts with <code>0x</code> or <code>-0x</code>, it * will be interpreted as a hexadecimal integer.  Values with leading * <code>0</code>'s will not be interpreted as octal.</p> * * <p>Returns <code>null</code> if the string is <code>null</code>.</p> * * <p>This method does not trim the input string, i.e., strings with leading * or trailing spaces will generate NumberFormatExceptions.</p> * * @param str  String containing a number, may be null * @return Number created from the string * @throws NumberFormatException if the value cannot be converted } else { <BUGS> dec = str.substring(decPos + 1); <BUGE> } mant = str.substring(0, decPos); } else { if (expPos > -1) { if (expPos > str.length()) { throw new NumberFormatException(str + " is not a valid number."); } mant = str.substring(0, expPos); } else { mant = str; } dec = null; } if (!Character.isDigit(lastChar) && lastChar != '.') {
* <code>BigDecimal</code>.</p> * * <p>If the string starts with <code>0x</code> or <code>-0x</code>, it * will be interpreted as a hexadecimal integer.  Values with leading * <code>0</code>'s will not be interpreted as octal.</p> * * <p>Returns <code>null</code> if the string is <code>null</code>.</p> * * <p>This method does not trim the input string, i.e., strings with leading * or trailing spaces will generate NumberFormatExceptions.</p> * * @param str  String containing a number, may be null * @return Number created from the string * @throws NumberFormatException if the value cannot be converted } <BUGS> mant = str.substring(0, decPos); <BUGE> } else { if (expPos > -1) { if (expPos > str.length()) { throw new NumberFormatException(str + " is not a valid number."); } mant = str.substring(0, expPos); } else { mant = str; } dec = null; } if (!Character.isDigit(lastChar) && lastChar != '.') { if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length() - 1);
* <code>BigDecimal</code>.</p> * * <p>If the string starts with <code>0x</code> or <code>-0x</code>, it * will be interpreted as a hexadecimal integer.  Values with leading * <code>0</code>'s will not be interpreted as octal.</p> * * <p>Returns <code>null</code> if the string is <code>null</code>.</p> * * <p>This method does not trim the input string, i.e., strings with leading * or trailing spaces will generate NumberFormatExceptions.</p> * * @param str  String containing a number, may be null * @return Number created from the string * @throws NumberFormatException if the value cannot be converted } else { <BUGS> if (expPos > -1) { if (expPos > str.length()) { <BUGE> throw new NumberFormatException(str + " is not a valid number."); } mant = str.substring(0, expPos); } else { mant = str; } dec = null; } if (!Character.isDigit(lastChar) && lastChar != '.') { if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length() - 1); } else { exp = null;
* <code>BigDecimal</code>.</p> * * <p>If the string starts with <code>0x</code> or <code>-0x</code>, it * will be interpreted as a hexadecimal integer.  Values with leading * <code>0</code>'s will not be interpreted as octal.</p> * * <p>Returns <code>null</code> if the string is <code>null</code>.</p> * * <p>This method does not trim the input string, i.e., strings with leading * or trailing spaces will generate NumberFormatExceptions.</p> * * @param str  String containing a number, may be null * @return Number created from the string * @throws NumberFormatException if the value cannot be converted } <BUGS> mant = str.substring(0, expPos); <BUGE> } else { mant = str; } dec = null; } if (!Character.isDigit(lastChar) && lastChar != '.') { if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length() - 1); } else { exp = null; } /*Requesting a specific type..*/ String numeric = str.substring(0, str.length() - 1); boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
* <code>BigDecimal</code>.</p> * * <p>If the string starts with <code>0x</code> or <code>-0x</code>, it * will be interpreted as a hexadecimal integer.  Values with leading * <code>0</code>'s will not be interpreted as octal.</p> * * <p>Returns <code>null</code> if the string is <code>null</code>.</p> * * <p>This method does not trim the input string, i.e., strings with leading * or trailing spaces will generate NumberFormatExceptions.</p> * * @param str  String containing a number, may be null * @return Number created from the string * @throws NumberFormatException if the value cannot be converted } else { <BUGS> mant = str; <BUGE> } dec = null; } if (!Character.isDigit(lastChar) && lastChar != '.') { if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length() - 1); } else { exp = null; } /*Requesting a specific type..*/ String numeric = str.substring(0, str.length() - 1); boolean allZeros = isAllZeros(mant) && isAllZeros(exp); switch (lastChar) { case 'l' :
* <code>BigDecimal</code>.</p> * * <p>If the string starts with <code>0x</code> or <code>-0x</code>, it * will be interpreted as a hexadecimal integer.  Values with leading * <code>0</code>'s will not be interpreted as octal.</p> * * <p>Returns <code>null</code> if the string is <code>null</code>.</p> * * <p>This method does not trim the input string, i.e., strings with leading * or trailing spaces will generate NumberFormatExceptions.</p> * * @param str  String containing a number, may be null * @return Number created from the string * @throws NumberFormatException if the value cannot be converted } <BUGS> dec = null; <BUGE> } if (!Character.isDigit(lastChar) && lastChar != '.') { if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length() - 1); } else { exp = null; } /*Requesting a specific type..*/ String numeric = str.substring(0, str.length() - 1); boolean allZeros = isAllZeros(mant) && isAllZeros(exp); switch (lastChar) { case 'l' : case 'L' : if (dec == null
* * <p>If the string starts with <code>0x</code> or <code>-0x</code>, it * will be interpreted as a hexadecimal integer.  Values with leading * <code>0</code>'s will not be interpreted as octal.</p> * * <p>Returns <code>null</code> if the string is <code>null</code>.</p> * * <p>This method does not trim the input string, i.e., strings with leading * or trailing spaces will generate NumberFormatExceptions.</p> * * @param str  String containing a number, may be null * @return Number created from the string * @throws NumberFormatException if the value cannot be converted } <BUGS> if (!Character.isDigit(lastChar) && lastChar != '.') { if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length() - 1); <BUGE> } else { exp = null; } /*Requesting a specific type..*/ String numeric = str.substring(0, str.length() - 1); boolean allZeros = isAllZeros(mant) && isAllZeros(exp); switch (lastChar) { case 'l' : case 'L' : if (dec == null && exp == null && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) { try {
* <code>BigDecimal</code>.</p> * * <p>If the string starts with <code>0x</code> or <code>-0x</code>, it * will be interpreted as a hexadecimal integer.  Values with leading * <code>0</code>'s will not be interpreted as octal.</p> * * <p>Returns <code>null</code> if the string is <code>null</code>.</p> * * <p>This method does not trim the input string, i.e., strings with leading * or trailing spaces will generate NumberFormatExceptions.</p> * * @param str  String containing a number, may be null * @return Number created from the string * @throws NumberFormatException if the value cannot be converted } else { <BUGS> exp = null; <BUGE> } /*Requesting a specific type..*/ String numeric = str.substring(0, str.length() - 1); boolean allZeros = isAllZeros(mant) && isAllZeros(exp); switch (lastChar) { case 'l' : case 'L' : if (dec == null && exp == null && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) { try { return createLong(numeric); } catch (NumberFormatException nfe) { /*Too big for a long*/
* * <p>If the string starts with <code>0x</code> or <code>-0x</code>, it * will be interpreted as a hexadecimal integer.  Values with leading * <code>0</code>'s will not be interpreted as octal.</p> * * <p>Returns <code>null</code> if the string is <code>null</code>.</p> * * <p>This method does not trim the input string, i.e., strings with leading * or trailing spaces will generate NumberFormatExceptions.</p> * * @param str  String containing a number, may be null * @return Number created from the string * @throws NumberFormatException if the value cannot be converted /*Requesting a specific type..*/ <BUGS> String numeric = str.substring(0, str.length() - 1); boolean allZeros = isAllZeros(mant) && isAllZeros(exp); switch (lastChar) { <BUGE> case 'l' : case 'L' : if (dec == null && exp == null && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) { try { return createLong(numeric); } catch (NumberFormatException nfe) { /*Too big for a long*/ } return createBigInteger(numeric);  }
* <code>BigDecimal</code>.</p> * * <p>If the string starts with <code>0x</code> or <code>-0x</code>, it * will be interpreted as a hexadecimal integer.  Values with leading * <code>0</code>'s will not be interpreted as octal.</p> * * <p>Returns <code>null</code> if the string is <code>null</code>.</p> * * <p>This method does not trim the input string, i.e., strings with leading * or trailing spaces will generate NumberFormatExceptions.</p> * * @param str  String containing a number, may be null * @return Number created from the string * @throws NumberFormatException if the value cannot be converted case 'L' : <BUGS> if (dec == null <BUGE> && exp == null && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) { try { return createLong(numeric); } catch (NumberFormatException nfe) { /*Too big for a long*/ } return createBigInteger(numeric);  } throw new NumberFormatException(str + " is not a valid number."); case 'f' : case 'F' : try {
* <code>BigDecimal</code>.</p> * * <p>If the string starts with <code>0x</code> or <code>-0x</code>, it * will be interpreted as a hexadecimal integer.  Values with leading * <code>0</code>'s will not be interpreted as octal.</p> * * <p>Returns <code>null</code> if the string is <code>null</code>.</p> * * <p>This method does not trim the input string, i.e., strings with leading * or trailing spaces will generate NumberFormatExceptions.</p> * * @param str  String containing a number, may be null * @return Number created from the string * @throws NumberFormatException if the value cannot be converted try { <BUGS> return createLong(numeric); <BUGE> } catch (NumberFormatException nfe) { /*Too big for a long*/ } return createBigInteger(numeric);  } throw new NumberFormatException(str + " is not a valid number."); case 'f' : case 'F' : try { Float f = NumberUtils.createFloat(numeric); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { /*If it's too big for a float or the float value = 0 and the string*/ /*has non-zeros in it, then float does not have the precision we want*/
* <code>BigDecimal</code>.</p> * * <p>If the string starts with <code>0x</code> or <code>-0x</code>, it * will be interpreted as a hexadecimal integer.  Values with leading * <code>0</code>'s will not be interpreted as octal.</p> * * <p>Returns <code>null</code> if the string is <code>null</code>.</p> * * <p>This method does not trim the input string, i.e., strings with leading * or trailing spaces will generate NumberFormatExceptions.</p> * * @param str  String containing a number, may be null * @return Number created from the string * @throws NumberFormatException if the value cannot be converted } <BUGS> throw new NumberFormatException(str + " is not a valid number."); <BUGE> case 'f' : case 'F' : try { Float f = NumberUtils.createFloat(numeric); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { /*If it's too big for a float or the float value = 0 and the string*/ /*has non-zeros in it, then float does not have the precision we want*/ return f; }  } catch (NumberFormatException nfe) { /* ignore the bad number*/ } /*$FALL-THROUGH$*/
* <code>BigDecimal</code>.</p> * * <p>If the string starts with <code>0x</code> or <code>-0x</code>, it * will be interpreted as a hexadecimal integer.  Values with leading * <code>0</code>'s will not be interpreted as octal.</p> * * <p>Returns <code>null</code> if the string is <code>null</code>.</p> * * <p>This method does not trim the input string, i.e., strings with leading * or trailing spaces will generate NumberFormatExceptions.</p> * * @param str  String containing a number, may be null * @return Number created from the string * @throws NumberFormatException if the value cannot be converted try { <BUGS> Float f = NumberUtils.createFloat(numeric); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { <BUGE> /*If it's too big for a float or the float value = 0 and the string*/ /*has non-zeros in it, then float does not have the precision we want*/ return f; }  } catch (NumberFormatException nfe) { /* ignore the bad number*/ } /*$FALL-THROUGH$*/ case 'd' : case 'D' : try { Double d = NumberUtils.createDouble(numeric);
* <code>BigDecimal</code>.</p> * * <p>If the string starts with <code>0x</code> or <code>-0x</code>, it * will be interpreted as a hexadecimal integer.  Values with leading * <code>0</code>'s will not be interpreted as octal.</p> * * <p>Returns <code>null</code> if the string is <code>null</code>.</p> * * <p>This method does not trim the input string, i.e., strings with leading * or trailing spaces will generate NumberFormatExceptions.</p> * * @param str  String containing a number, may be null * @return Number created from the string * @throws NumberFormatException if the value cannot be converted /*has non-zeros in it, then float does not have the precision we want*/ <BUGS> return f; <BUGE> }  } catch (NumberFormatException nfe) { /* ignore the bad number*/ } /*$FALL-THROUGH$*/ case 'd' : case 'D' : try { Double d = NumberUtils.createDouble(numeric); if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) {
* <code>BigDecimal</code>.</p> * * <p>If the string starts with <code>0x</code> or <code>-0x</code>, it * will be interpreted as a hexadecimal integer.  Values with leading * <code>0</code>'s will not be interpreted as octal.</p> * * <p>Returns <code>null</code> if the string is <code>null</code>.</p> * * <p>This method does not trim the input string, i.e., strings with leading * or trailing spaces will generate NumberFormatExceptions.</p> * * @param str  String containing a number, may be null * @return Number created from the string * @throws NumberFormatException if the value cannot be converted  <BUGS> } catch (NumberFormatException nfe) { <BUGE> /* ignore the bad number*/ } /*$FALL-THROUGH$*/ case 'd' : case 'D' : try { Double d = NumberUtils.createDouble(numeric); if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { /* ignore the bad number*/ } try {
* * <p>If the string starts with <code>0x</code> or <code>-0x</code>, it * will be interpreted as a hexadecimal integer.  Values with leading * <code>0</code>'s will not be interpreted as octal.</p> * * <p>Returns <code>null</code> if the string is <code>null</code>.</p> * * <p>This method does not trim the input string, i.e., strings with leading * or trailing spaces will generate NumberFormatExceptions.</p> * * @param str  String containing a number, may be null * @return Number created from the string * @throws NumberFormatException if the value cannot be converted try { <BUGS> Double d = NumberUtils.createDouble(numeric); if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) { return d; <BUGE> } } catch (NumberFormatException nfe) { /* ignore the bad number*/ } try { return createBigDecimal(numeric); } catch (NumberFormatException e) { /* ignore the bad number*/ } /*$FALL-THROUGH$*/ default : throw new NumberFormatException(str + " is not a valid number.");
* <code>BigDecimal</code>.</p> * * <p>If the string starts with <code>0x</code> or <code>-0x</code>, it * will be interpreted as a hexadecimal integer.  Values with leading * <code>0</code>'s will not be interpreted as octal.</p> * * <p>Returns <code>null</code> if the string is <code>null</code>.</p> * * <p>This method does not trim the input string, i.e., strings with leading * or trailing spaces will generate NumberFormatExceptions.</p> * * @param str  String containing a number, may be null * @return Number created from the string * @throws NumberFormatException if the value cannot be converted } <BUGS> } catch (NumberFormatException nfe) { <BUGE> /* ignore the bad number*/ } try { return createBigDecimal(numeric); } catch (NumberFormatException e) { /* ignore the bad number*/ } /*$FALL-THROUGH$*/ default : throw new NumberFormatException(str + " is not a valid number.");  } } else { /*User doesn't have a preference on the return type, so let's start*/
* <code>BigDecimal</code>.</p> * * <p>If the string starts with <code>0x</code> or <code>-0x</code>, it * will be interpreted as a hexadecimal integer.  Values with leading * <code>0</code>'s will not be interpreted as octal.</p> * * <p>Returns <code>null</code> if the string is <code>null</code>.</p> * * <p>This method does not trim the input string, i.e., strings with leading * or trailing spaces will generate NumberFormatExceptions.</p> * * @param str  String containing a number, may be null * @return Number created from the string * @throws NumberFormatException if the value cannot be converted try { <BUGS> return createBigDecimal(numeric); } catch (NumberFormatException e) { <BUGE> /* ignore the bad number*/ } /*$FALL-THROUGH$*/ default : throw new NumberFormatException(str + " is not a valid number.");  } } else { /*User doesn't have a preference on the return type, so let's start*/ /*small and go from there...*/ if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length()); } else {
* <code>BigDecimal</code>.</p> * * <p>If the string starts with <code>0x</code> or <code>-0x</code>, it * will be interpreted as a hexadecimal integer.  Values with leading * <code>0</code>'s will not be interpreted as octal.</p> * * <p>Returns <code>null</code> if the string is <code>null</code>.</p> * * <p>This method does not trim the input string, i.e., strings with leading * or trailing spaces will generate NumberFormatExceptions.</p> * * @param str  String containing a number, may be null * @return Number created from the string * @throws NumberFormatException if the value cannot be converted default : <BUGS> throw new NumberFormatException(str + " is not a valid number."); <BUGE>  } } else { /*User doesn't have a preference on the return type, so let's start*/ /*small and go from there...*/ if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length()); } else { exp = null; } if (dec == null && exp == null) { /*Must be an int,long,bigint*/ try { return createInteger(str);
* <code>BigDecimal</code>.</p> * * <p>If the string starts with <code>0x</code> or <code>-0x</code>, it * will be interpreted as a hexadecimal integer.  Values with leading * <code>0</code>'s will not be interpreted as octal.</p> * * <p>Returns <code>null</code> if the string is <code>null</code>.</p> * * <p>This method does not trim the input string, i.e., strings with leading * or trailing spaces will generate NumberFormatExceptions.</p> * * @param str  String containing a number, may be null * @return Number created from the string * @throws NumberFormatException if the value cannot be converted /*small and go from there...*/ <BUGS> if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length()); <BUGE> } else { exp = null; } if (dec == null && exp == null) { /*Must be an int,long,bigint*/ try { return createInteger(str); } catch (NumberFormatException nfe) { /* ignore the bad number*/ } try { return createLong(str); } catch (NumberFormatException nfe) {
* <code>BigDecimal</code>.</p> * * <p>If the string starts with <code>0x</code> or <code>-0x</code>, it * will be interpreted as a hexadecimal integer.  Values with leading * <code>0</code>'s will not be interpreted as octal.</p> * * <p>Returns <code>null</code> if the string is <code>null</code>.</p> * * <p>This method does not trim the input string, i.e., strings with leading * or trailing spaces will generate NumberFormatExceptions.</p> * * @param str  String containing a number, may be null * @return Number created from the string * @throws NumberFormatException if the value cannot be converted } else { <BUGS> exp = null; <BUGE> } if (dec == null && exp == null) { /*Must be an int,long,bigint*/ try { return createInteger(str); } catch (NumberFormatException nfe) { /* ignore the bad number*/ } try { return createLong(str); } catch (NumberFormatException nfe) { /* ignore the bad number*/ } return createBigInteger(str);
* <code>BigDecimal</code>.</p> * * <p>If the string starts with <code>0x</code> or <code>-0x</code>, it * will be interpreted as a hexadecimal integer.  Values with leading * <code>0</code>'s will not be interpreted as octal.</p> * * <p>Returns <code>null</code> if the string is <code>null</code>.</p> * * <p>This method does not trim the input string, i.e., strings with leading * or trailing spaces will generate NumberFormatExceptions.</p> * * @param str  String containing a number, may be null * @return Number created from the string * @throws NumberFormatException if the value cannot be converted } <BUGS> if (dec == null && exp == null) { <BUGE> /*Must be an int,long,bigint*/ try { return createInteger(str); } catch (NumberFormatException nfe) { /* ignore the bad number*/ } try { return createLong(str); } catch (NumberFormatException nfe) { /* ignore the bad number*/ } return createBigInteger(str);  } else {
* <code>BigDecimal</code>.</p> * * <p>If the string starts with <code>0x</code> or <code>-0x</code>, it * will be interpreted as a hexadecimal integer.  Values with leading * <code>0</code>'s will not be interpreted as octal.</p> * * <p>Returns <code>null</code> if the string is <code>null</code>.</p> * * <p>This method does not trim the input string, i.e., strings with leading * or trailing spaces will generate NumberFormatExceptions.</p> * * @param str  String containing a number, may be null * @return Number created from the string * @throws NumberFormatException if the value cannot be converted try { <BUGS> return createInteger(str); } catch (NumberFormatException nfe) { <BUGE> /* ignore the bad number*/ } try { return createLong(str); } catch (NumberFormatException nfe) { /* ignore the bad number*/ } return createBigInteger(str);  } else { /*Must be a float,double,BigDec*/ boolean allZeros = isAllZeros(mant) && isAllZeros(exp); try {
* <code>BigDecimal</code>.</p> * * <p>If the string starts with <code>0x</code> or <code>-0x</code>, it * will be interpreted as a hexadecimal integer.  Values with leading * <code>0</code>'s will not be interpreted as octal.</p> * * <p>Returns <code>null</code> if the string is <code>null</code>.</p> * * <p>This method does not trim the input string, i.e., strings with leading * or trailing spaces will generate NumberFormatExceptions.</p> * * @param str  String containing a number, may be null * @return Number created from the string * @throws NumberFormatException if the value cannot be converted try { <BUGS> return createLong(str); } catch (NumberFormatException nfe) { <BUGE> /* ignore the bad number*/ } return createBigInteger(str);  } else { /*Must be a float,double,BigDec*/ boolean allZeros = isAllZeros(mant) && isAllZeros(exp); try { Float f = createFloat(str); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { return f; } } catch (NumberFormatException nfe) {
* <code>BigDecimal</code>.</p> * * <p>If the string starts with <code>0x</code> or <code>-0x</code>, it * will be interpreted as a hexadecimal integer.  Values with leading * <code>0</code>'s will not be interpreted as octal.</p> * * <p>Returns <code>null</code> if the string is <code>null</code>.</p> * * <p>This method does not trim the input string, i.e., strings with leading * or trailing spaces will generate NumberFormatExceptions.</p> * * @param str  String containing a number, may be null * @return Number created from the string * @throws NumberFormatException if the value cannot be converted } <BUGS> return createBigInteger(str); <BUGE>  } else { /*Must be a float,double,BigDec*/ boolean allZeros = isAllZeros(mant) && isAllZeros(exp); try { Float f = createFloat(str); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { return f; } } catch (NumberFormatException nfe) { /* ignore the bad number*/ } try { Double d = createDouble(str);
* <code>BigDecimal</code>.</p> * * <p>If the string starts with <code>0x</code> or <code>-0x</code>, it * will be interpreted as a hexadecimal integer.  Values with leading * <code>0</code>'s will not be interpreted as octal.</p> * * <p>Returns <code>null</code> if the string is <code>null</code>.</p> * * <p>This method does not trim the input string, i.e., strings with leading * or trailing spaces will generate NumberFormatExceptions.</p> * * @param str  String containing a number, may be null * @return Number created from the string * @throws NumberFormatException if the value cannot be converted /*Must be a float,double,BigDec*/ <BUGS> boolean allZeros = isAllZeros(mant) && isAllZeros(exp); <BUGE> try { Float f = createFloat(str); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { return f; } } catch (NumberFormatException nfe) { /* ignore the bad number*/ } try { Double d = createDouble(str); if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) {
* * <p>If the string starts with <code>0x</code> or <code>-0x</code>, it * will be interpreted as a hexadecimal integer.  Values with leading * <code>0</code>'s will not be interpreted as octal.</p> * * <p>Returns <code>null</code> if the string is <code>null</code>.</p> * * <p>This method does not trim the input string, i.e., strings with leading * or trailing spaces will generate NumberFormatExceptions.</p> * * @param str  String containing a number, may be null * @return Number created from the string * @throws NumberFormatException if the value cannot be converted try { <BUGS> Float f = createFloat(str); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { return f; <BUGE> } } catch (NumberFormatException nfe) { /* ignore the bad number*/ } try { Double d = createDouble(str); if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { /* ignore the bad number*/ }
* <code>BigDecimal</code>.</p> * * <p>If the string starts with <code>0x</code> or <code>-0x</code>, it * will be interpreted as a hexadecimal integer.  Values with leading * <code>0</code>'s will not be interpreted as octal.</p> * * <p>Returns <code>null</code> if the string is <code>null</code>.</p> * * <p>This method does not trim the input string, i.e., strings with leading * or trailing spaces will generate NumberFormatExceptions.</p> * * @param str  String containing a number, may be null * @return Number created from the string * @throws NumberFormatException if the value cannot be converted } <BUGS> } catch (NumberFormatException nfe) { <BUGE> /* ignore the bad number*/ } try { Double d = createDouble(str); if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { /* ignore the bad number*/ }  return createBigDecimal(str);  }
* <code>BigDecimal</code>.</p> * * <p>If the string starts with <code>0x</code> or <code>-0x</code>, it * will be interpreted as a hexadecimal integer.  Values with leading * <code>0</code>'s will not be interpreted as octal.</p> * * <p>Returns <code>null</code> if the string is <code>null</code>.</p> * * <p>This method does not trim the input string, i.e., strings with leading * or trailing spaces will generate NumberFormatExceptions.</p> * * @param str  String containing a number, may be null * @return Number created from the string * @throws NumberFormatException if the value cannot be converted try { <BUGS> Double d = createDouble(str); <BUGE> if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { /* ignore the bad number*/ }  return createBigDecimal(str);  } } }  /**
* <code>BigDecimal</code>.</p> * * <p>If the string starts with <code>0x</code> or <code>-0x</code>, it * will be interpreted as a hexadecimal integer.  Values with leading * <code>0</code>'s will not be interpreted as octal.</p> * * <p>Returns <code>null</code> if the string is <code>null</code>.</p> * * <p>This method does not trim the input string, i.e., strings with leading * or trailing spaces will generate NumberFormatExceptions.</p> * * @param str  String containing a number, may be null * @return Number created from the string * @throws NumberFormatException if the value cannot be converted } <BUGS> } catch (NumberFormatException nfe) { <BUGE> /* ignore the bad number*/ }  return createBigDecimal(str);  } } }  /** * <p>Utility method for {@link #createNumber(java.lang.String)}.</p> * * <p>Returns <code>true</code> if s is <code>null</code>.</p> *
* <code>BigDecimal</code>.</p> * * <p>If the string starts with <code>0x</code> or <code>-0x</code>, it * will be interpreted as a hexadecimal integer.  Values with leading * <code>0</code>'s will not be interpreted as octal.</p> * * <p>Returns <code>null</code> if the string is <code>null</code>.</p> * * <p>This method does not trim the input string, i.e., strings with leading * or trailing spaces will generate NumberFormatExceptions.</p> * * @param str  String containing a number, may be null * @return Number created from the string * @throws NumberFormatException if the value cannot be converted  <BUGS> return createBigDecimal(str); <BUGE>  } } }  /** * <p>Utility method for {@link #createNumber(java.lang.String)}.</p> * * <p>Returns <code>true</code> if s is <code>null</code>.</p> * * @param str  the String to check * @return if it is all zeros or <code>null</code> */ private static boolean isAllZeros(String str) {
*/ protected List<Rule> parsePattern() { <BUGS> DateFormatSymbols symbols = new DateFormatSymbols(mLocale); List<Rule> rules = new ArrayList<Rule>(); <BUGE>  String[] ERAs = symbols.getEras(); String[] months = symbols.getMonths(); String[] shortMonths = symbols.getShortMonths(); String[] weekdays = symbols.getWeekdays(); String[] shortWeekdays = symbols.getShortWeekdays(); String[] AmPmStrings = symbols.getAmPmStrings();  int length = mPattern.length(); int[] indexRef = new int[1];  for (int i = 0; i < length; i++) { indexRef[0] = i; String token = parseToken(mPattern, indexRef); i = indexRef[0];  int tokenLen = token.length(); if (tokenLen == 0) { break; }  Rule rule; char c = token.charAt(0);  switch (c) { case 'G': /* era designator (text)*/
*/ protected List<Rule> parsePattern() { DateFormatSymbols symbols = new DateFormatSymbols(mLocale); List<Rule> rules = new ArrayList<Rule>();  <BUGS> String[] ERAs = symbols.getEras(); String[] months = symbols.getMonths(); String[] shortMonths = symbols.getShortMonths(); String[] weekdays = symbols.getWeekdays(); String[] shortWeekdays = symbols.getShortWeekdays(); String[] AmPmStrings = symbols.getAmPmStrings(); <BUGE>  int length = mPattern.length(); int[] indexRef = new int[1];  for (int i = 0; i < length; i++) { indexRef[0] = i; String token = parseToken(mPattern, indexRef); i = indexRef[0];  int tokenLen = token.length(); if (tokenLen == 0) { break; }  Rule rule; char c = token.charAt(0);  switch (c) { case 'G': /* era designator (text)*/
*/ protected List<Rule> parsePattern() { DateFormatSymbols symbols = new DateFormatSymbols(mLocale); List<Rule> rules = new ArrayList<Rule>();  String[] ERAs = symbols.getEras(); String[] months = symbols.getMonths(); String[] shortMonths = symbols.getShortMonths(); String[] weekdays = symbols.getWeekdays(); String[] shortWeekdays = symbols.getShortWeekdays(); String[] AmPmStrings = symbols.getAmPmStrings();  <BUGS> int length = mPattern.length(); int[] indexRef = new int[1]; <BUGE>  for (int i = 0; i < length; i++) { indexRef[0] = i; String token = parseToken(mPattern, indexRef); i = indexRef[0];  int tokenLen = token.length(); if (tokenLen == 0) { break; }  Rule rule; char c = token.charAt(0);  switch (c) { case 'G': /* era designator (text)*/
*/ protected List<Rule> parsePattern() { DateFormatSymbols symbols = new DateFormatSymbols(mLocale); List<Rule> rules = new ArrayList<Rule>();  String[] ERAs = symbols.getEras(); String[] months = symbols.getMonths(); String[] shortMonths = symbols.getShortMonths(); String[] weekdays = symbols.getWeekdays(); String[] shortWeekdays = symbols.getShortWeekdays(); String[] AmPmStrings = symbols.getAmPmStrings();  int length = mPattern.length(); int[] indexRef = new int[1];  <BUGS> for (int i = 0; i < length; i++) { indexRef[0] = i; String token = parseToken(mPattern, indexRef); i = indexRef[0]; <BUGE>  int tokenLen = token.length(); if (tokenLen == 0) { break; }  Rule rule; char c = token.charAt(0);  switch (c) { case 'G': /* era designator (text)*/
*/ protected List<Rule> parsePattern() { DateFormatSymbols symbols = new DateFormatSymbols(mLocale); List<Rule> rules = new ArrayList<Rule>();  String[] ERAs = symbols.getEras(); String[] months = symbols.getMonths(); String[] shortMonths = symbols.getShortMonths(); String[] weekdays = symbols.getWeekdays(); String[] shortWeekdays = symbols.getShortWeekdays(); String[] AmPmStrings = symbols.getAmPmStrings();  int length = mPattern.length(); int[] indexRef = new int[1];  for (int i = 0; i < length; i++) { indexRef[0] = i; String token = parseToken(mPattern, indexRef); i = indexRef[0];  <BUGS> int tokenLen = token.length(); if (tokenLen == 0) { <BUGE> break; }  Rule rule; char c = token.charAt(0);  switch (c) { case 'G': /* era designator (text)*/
*/ protected List<Rule> parsePattern() { DateFormatSymbols symbols = new DateFormatSymbols(mLocale); List<Rule> rules = new ArrayList<Rule>();  String[] ERAs = symbols.getEras(); String[] months = symbols.getMonths(); String[] shortMonths = symbols.getShortMonths(); String[] weekdays = symbols.getWeekdays(); String[] shortWeekdays = symbols.getShortWeekdays(); String[] AmPmStrings = symbols.getAmPmStrings();  int length = mPattern.length(); int[] indexRef = new int[1];  for (int i = 0; i < length; i++) { indexRef[0] = i; String token = parseToken(mPattern, indexRef); i = indexRef[0];  int tokenLen = token.length(); if (tokenLen == 0) { break; }  Rule rule; <BUGS> char c = token.charAt(0); <BUGE>  switch (c) { case 'G': /* era designator (text)*/
*/ protected List<Rule> parsePattern() { DateFormatSymbols symbols = new DateFormatSymbols(mLocale); List<Rule> rules = new ArrayList<Rule>();  String[] ERAs = symbols.getEras(); String[] months = symbols.getMonths(); String[] shortMonths = symbols.getShortMonths(); String[] weekdays = symbols.getWeekdays(); String[] shortWeekdays = symbols.getShortWeekdays(); String[] AmPmStrings = symbols.getAmPmStrings();  int length = mPattern.length(); int[] indexRef = new int[1];  for (int i = 0; i < length; i++) { indexRef[0] = i; String token = parseToken(mPattern, indexRef); i = indexRef[0];  int tokenLen = token.length(); if (tokenLen == 0) { break; }  Rule rule; char c = token.charAt(0);  <BUGS> switch (c) { <BUGE> case 'G': /* era designator (text)*/
for (int i=mRules.length; --i >= 0; ) { len += mRules[i].estimateLength(); }  mMaxLengthEstimate = len; }  /* Parse the pattern*/ /*-----------------------------------------------------------------------*/ /** * <p>Returns a list of Rules given a pattern.</p> * * @return a <code>List</code> of Rule objects * @throws IllegalArgumentException if pattern is invalid case 'E': /* day in week (text)*/ <BUGS> rule = new TextField(Calendar.DAY_OF_WEEK, tokenLen < 4 ? shortWeekdays : weekdays); break; <BUGE> case 'D': /* day in year (number)*/ rule = selectNumberRule(Calendar.DAY_OF_YEAR, tokenLen); break; case 'F': /* day of week in month (number)*/ rule = selectNumberRule(Calendar.DAY_OF_WEEK_IN_MONTH, tokenLen); break; case 'w': /* week in year (number)*/ rule = selectNumberRule(Calendar.WEEK_OF_YEAR, tokenLen); break; case 'W': /* week in month (number)*/ rule = selectNumberRule(Calendar.WEEK_OF_MONTH, tokenLen); break; case 'a': /* am/pm marker (text)*/
for (int i=mRules.length; --i >= 0; ) { len += mRules[i].estimateLength(); }  mMaxLengthEstimate = len; }  /* Parse the pattern*/ /*-----------------------------------------------------------------------*/ /** * <p>Returns a list of Rules given a pattern.</p> * * @return a <code>List</code> of Rule objects * @throws IllegalArgumentException if pattern is invalid case 'w': /* week in year (number)*/ <BUGS> rule = selectNumberRule(Calendar.WEEK_OF_YEAR, tokenLen); break; <BUGE> case 'W': /* week in month (number)*/ rule = selectNumberRule(Calendar.WEEK_OF_MONTH, tokenLen); break; case 'a': /* am/pm marker (text)*/ rule = new TextField(Calendar.AM_PM, AmPmStrings); break; case 'k': /* hour in day (1..24)*/ rule = new TwentyFourHourField(selectNumberRule(Calendar.HOUR_OF_DAY, tokenLen)); break; case 'K': /* hour in am/pm (0..11)*/ rule = selectNumberRule(Calendar.HOUR, tokenLen); break; case 'z': /* time zone (text)*/
for (int i=mRules.length; --i >= 0; ) { len += mRules[i].estimateLength(); }  mMaxLengthEstimate = len; }  /* Parse the pattern*/ /*-----------------------------------------------------------------------*/ /** * <p>Returns a list of Rules given a pattern.</p> * * @return a <code>List</code> of Rule objects * @throws IllegalArgumentException if pattern is invalid case '\'': /* literal text*/ <BUGS> String sub = token.substring(1); if (sub.length() == 1) { <BUGE> rule = new CharacterLiteral(sub.charAt(0)); } else { rule = new StringLiteral(sub); } break; default: throw new IllegalArgumentException("Illegal pattern component: " + token); }  rules.add(rule); }  return rules;
for (int i=mRules.length; --i >= 0; ) { len += mRules[i].estimateLength(); }  mMaxLengthEstimate = len; }  /* Parse the pattern*/ /*-----------------------------------------------------------------------*/ /** * <p>Returns a list of Rules given a pattern.</p> * * @return a <code>List</code> of Rule objects * @throws IllegalArgumentException if pattern is invalid } else { <BUGS> rule = new StringLiteral(sub); <BUGE> } break; default: throw new IllegalArgumentException("Illegal pattern component: " + token); }  rules.add(rule); }  return rules; }  /** * <p>Performs the parsing of tokens.</p>
for (int i=mRules.length; --i >= 0; ) { len += mRules[i].estimateLength(); }  mMaxLengthEstimate = len; }  /* Parse the pattern*/ /*-----------------------------------------------------------------------*/ /** * <p>Returns a list of Rules given a pattern.</p> * * @return a <code>List</code> of Rule objects * @throws IllegalArgumentException if pattern is invalid } <BUGS> break; <BUGE> default: throw new IllegalArgumentException("Illegal pattern component: " + token); }  rules.add(rule); }  return rules; }  /** * <p>Performs the parsing of tokens.</p> * * @param pattern  the pattern
for (int i=mRules.length; --i >= 0; ) { len += mRules[i].estimateLength(); }  mMaxLengthEstimate = len; }  /* Parse the pattern*/ /*-----------------------------------------------------------------------*/ /** * <p>Returns a list of Rules given a pattern.</p> * * @return a <code>List</code> of Rule objects * @throws IllegalArgumentException if pattern is invalid  <BUGS> rules.add(rule); <BUGE> }  return rules; }  /** * <p>Performs the parsing of tokens.</p> * * @param pattern  the pattern * @param indexRef  index references * @return parsed token */ protected String parseToken(String pattern, int[] indexRef) { StringBuilder buf = new StringBuilder();
for (int i=mRules.length; --i >= 0; ) { len += mRules[i].estimateLength(); }  mMaxLengthEstimate = len; }  /* Parse the pattern*/ /*-----------------------------------------------------------------------*/ /** * <p>Returns a list of Rules given a pattern.</p> * * @return a <code>List</code> of Rule objects * @throws IllegalArgumentException if pattern is invalid  <BUGS> return rules; <BUGE> }  /** * <p>Performs the parsing of tokens.</p> * * @param pattern  the pattern * @param indexRef  index references * @return parsed token */ protected String parseToken(String pattern, int[] indexRef) { StringBuilder buf = new StringBuilder();  int i = indexRef[0]; int length = pattern.length();
*/ public static Number createNumber(String str) throws NumberFormatException { <BUGS> if (str == null) { return null; <BUGE> } if (StringUtils.isBlank(str)) { throw new NumberFormatException("A blank string is not a valid number"); } if (str.startsWith("--")) { /* this is protection for poorness in java.lang.BigDecimal.*/ /* it accepts this as a legal value, but it does not appear */ /* to be in specification of class. OS X Java parses it to */ /* a wrong value.*/ return null; } if (str.startsWith("0x") || str.startsWith("-0x")) { return createInteger(str); } char lastChar = str.charAt(str.length() - 1); String mant; String dec; String exp; int decPos = str.indexOf('.'); int expPos = str.indexOf('e') + str.indexOf('E') + 1;  if (decPos > -1) {  if (expPos > -1) { if (expPos < decPos) { throw new NumberFormatException(str + " is not a valid number.");
*/ public static Number createNumber(String str) throws NumberFormatException { if (str == null) { return null; } <BUGS> if (StringUtils.isBlank(str)) { <BUGE> throw new NumberFormatException("A blank string is not a valid number"); } if (str.startsWith("--")) { /* this is protection for poorness in java.lang.BigDecimal.*/ /* it accepts this as a legal value, but it does not appear */ /* to be in specification of class. OS X Java parses it to */ /* a wrong value.*/ return null; } if (str.startsWith("0x") || str.startsWith("-0x")) { return createInteger(str); } char lastChar = str.charAt(str.length() - 1); String mant; String dec; String exp; int decPos = str.indexOf('.'); int expPos = str.indexOf('e') + str.indexOf('E') + 1;  if (decPos > -1) {  if (expPos > -1) { if (expPos < decPos) { throw new NumberFormatException(str + " is not a valid number.");
*/ public static Number createNumber(String str) throws NumberFormatException { if (str == null) { return null; } if (StringUtils.isBlank(str)) { throw new NumberFormatException("A blank string is not a valid number"); } <BUGS> if (str.startsWith("--")) { <BUGE> /* this is protection for poorness in java.lang.BigDecimal.*/ /* it accepts this as a legal value, but it does not appear */ /* to be in specification of class. OS X Java parses it to */ /* a wrong value.*/ return null; } if (str.startsWith("0x") || str.startsWith("-0x")) { return createInteger(str); } char lastChar = str.charAt(str.length() - 1); String mant; String dec; String exp; int decPos = str.indexOf('.'); int expPos = str.indexOf('e') + str.indexOf('E') + 1;  if (decPos > -1) {  if (expPos > -1) { if (expPos < decPos) { throw new NumberFormatException(str + " is not a valid number.");
*/ public static Number createNumber(String str) throws NumberFormatException { if (str == null) { return null; } if (StringUtils.isBlank(str)) { throw new NumberFormatException("A blank string is not a valid number"); } if (str.startsWith("--")) { /* this is protection for poorness in java.lang.BigDecimal.*/ /* it accepts this as a legal value, but it does not appear */ /* to be in specification of class. OS X Java parses it to */ /* a wrong value.*/ return null; } <BUGS> if (str.startsWith("0x") || str.startsWith("-0x")) { return createInteger(str); <BUGE> } char lastChar = str.charAt(str.length() - 1); String mant; String dec; String exp; int decPos = str.indexOf('.'); int expPos = str.indexOf('e') + str.indexOf('E') + 1;  if (decPos > -1) {  if (expPos > -1) { if (expPos < decPos) { throw new NumberFormatException(str + " is not a valid number.");
*/ public static Number createNumber(String str) throws NumberFormatException { if (str == null) { return null; } if (StringUtils.isBlank(str)) { throw new NumberFormatException("A blank string is not a valid number"); } if (str.startsWith("--")) { /* this is protection for poorness in java.lang.BigDecimal.*/ /* it accepts this as a legal value, but it does not appear */ /* to be in specification of class. OS X Java parses it to */ /* a wrong value.*/ return null; } if (str.startsWith("0x") || str.startsWith("-0x")) { return createInteger(str); } <BUGS> char lastChar = str.charAt(str.length() - 1); <BUGE> String mant; String dec; String exp; int decPos = str.indexOf('.'); int expPos = str.indexOf('e') + str.indexOf('E') + 1;  if (decPos > -1) {  if (expPos > -1) { if (expPos < decPos) { throw new NumberFormatException(str + " is not a valid number.");
*/ public static Number createNumber(String str) throws NumberFormatException { if (str == null) { return null; } if (StringUtils.isBlank(str)) { throw new NumberFormatException("A blank string is not a valid number"); } if (str.startsWith("--")) { /* this is protection for poorness in java.lang.BigDecimal.*/ /* it accepts this as a legal value, but it does not appear */ /* to be in specification of class. OS X Java parses it to */ /* a wrong value.*/ return null; } if (str.startsWith("0x") || str.startsWith("-0x")) { return createInteger(str); } char lastChar = str.charAt(str.length() - 1); String mant; String dec; String exp; <BUGS> int decPos = str.indexOf('.'); int expPos = str.indexOf('e') + str.indexOf('E') + 1; <BUGE>  if (decPos > -1) {  if (expPos > -1) { if (expPos < decPos) { throw new NumberFormatException(str + " is not a valid number.");
*/ public static Number createNumber(String str) throws NumberFormatException { if (str == null) { return null; } if (StringUtils.isBlank(str)) { throw new NumberFormatException("A blank string is not a valid number"); } if (str.startsWith("--")) { /* this is protection for poorness in java.lang.BigDecimal.*/ /* it accepts this as a legal value, but it does not appear */ /* to be in specification of class. OS X Java parses it to */ /* a wrong value.*/ return null; } if (str.startsWith("0x") || str.startsWith("-0x")) { return createInteger(str); } char lastChar = str.charAt(str.length() - 1); String mant; String dec; String exp; int decPos = str.indexOf('.'); int expPos = str.indexOf('e') + str.indexOf('E') + 1;  <BUGS> if (decPos > -1) { <BUGE>  if (expPos > -1) { if (expPos < decPos) { throw new NumberFormatException(str + " is not a valid number.");
*/ public static Number createNumber(String str) throws NumberFormatException { if (str == null) { return null; } if (StringUtils.isBlank(str)) { throw new NumberFormatException("A blank string is not a valid number"); } if (str.startsWith("--")) { /* this is protection for poorness in java.lang.BigDecimal.*/ /* it accepts this as a legal value, but it does not appear */ /* to be in specification of class. OS X Java parses it to */ /* a wrong value.*/ return null; } if (str.startsWith("0x") || str.startsWith("-0x")) { return createInteger(str); } char lastChar = str.charAt(str.length() - 1); String mant; String dec; String exp; int decPos = str.indexOf('.'); int expPos = str.indexOf('e') + str.indexOf('E') + 1;  if (decPos > -1) {  <BUGS> if (expPos > -1) { if (expPos < decPos) { <BUGE> throw new NumberFormatException(str + " is not a valid number.");
* <code>BigDecimal</code>.</p> * * <p>If the string starts with <code>0x</code> or <code>-0x</code>, it * will be interpreted as a hexadecimal integer.  Values with leading * <code>0</code>'s will not be interpreted as octal.</p> * * <p>Returns <code>null</code> if the string is <code>null</code>.</p> * * <p>This method does not trim the input string, i.e., strings with leading * or trailing spaces will generate NumberFormatExceptions.</p> * * @param str  String containing a number, may be null * @return Number created from the string * @throws NumberFormatException if the value cannot be converted } <BUGS> dec = str.substring(decPos + 1, expPos); <BUGE> } else { dec = str.substring(decPos + 1); } mant = str.substring(0, decPos); } else { if (expPos > -1) { mant = str.substring(0, expPos); } else { mant = str; } dec = null; } if (!Character.isDigit(lastChar) && lastChar != '.') { if (expPos > -1 && expPos < str.length() - 1) {
* <code>BigDecimal</code>.</p> * * <p>If the string starts with <code>0x</code> or <code>-0x</code>, it * will be interpreted as a hexadecimal integer.  Values with leading * <code>0</code>'s will not be interpreted as octal.</p> * * <p>Returns <code>null</code> if the string is <code>null</code>.</p> * * <p>This method does not trim the input string, i.e., strings with leading * or trailing spaces will generate NumberFormatExceptions.</p> * * @param str  String containing a number, may be null * @return Number created from the string * @throws NumberFormatException if the value cannot be converted } else { <BUGS> dec = str.substring(decPos + 1); <BUGE> } mant = str.substring(0, decPos); } else { if (expPos > -1) { mant = str.substring(0, expPos); } else { mant = str; } dec = null; } if (!Character.isDigit(lastChar) && lastChar != '.') { if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length() - 1); } else {
* <code>BigDecimal</code>.</p> * * <p>If the string starts with <code>0x</code> or <code>-0x</code>, it * will be interpreted as a hexadecimal integer.  Values with leading * <code>0</code>'s will not be interpreted as octal.</p> * * <p>Returns <code>null</code> if the string is <code>null</code>.</p> * * <p>This method does not trim the input string, i.e., strings with leading * or trailing spaces will generate NumberFormatExceptions.</p> * * @param str  String containing a number, may be null * @return Number created from the string * @throws NumberFormatException if the value cannot be converted } <BUGS> mant = str.substring(0, decPos); <BUGE> } else { if (expPos > -1) { mant = str.substring(0, expPos); } else { mant = str; } dec = null; } if (!Character.isDigit(lastChar) && lastChar != '.') { if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length() - 1); } else { exp = null; }
* <code>BigDecimal</code>.</p> * * <p>If the string starts with <code>0x</code> or <code>-0x</code>, it * will be interpreted as a hexadecimal integer.  Values with leading * <code>0</code>'s will not be interpreted as octal.</p> * * <p>Returns <code>null</code> if the string is <code>null</code>.</p> * * <p>This method does not trim the input string, i.e., strings with leading * or trailing spaces will generate NumberFormatExceptions.</p> * * @param str  String containing a number, may be null * @return Number created from the string * @throws NumberFormatException if the value cannot be converted } else { <BUGS> if (expPos > -1) { mant = str.substring(0, expPos); <BUGE> } else { mant = str; } dec = null; } if (!Character.isDigit(lastChar) && lastChar != '.') { if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length() - 1); } else { exp = null; } /*Requesting a specific type..*/ String numeric = str.substring(0, str.length() - 1);
* <code>BigDecimal</code>.</p> * * <p>If the string starts with <code>0x</code> or <code>-0x</code>, it * will be interpreted as a hexadecimal integer.  Values with leading * <code>0</code>'s will not be interpreted as octal.</p> * * <p>Returns <code>null</code> if the string is <code>null</code>.</p> * * <p>This method does not trim the input string, i.e., strings with leading * or trailing spaces will generate NumberFormatExceptions.</p> * * @param str  String containing a number, may be null * @return Number created from the string * @throws NumberFormatException if the value cannot be converted } else { <BUGS> mant = str; <BUGE> } dec = null; } if (!Character.isDigit(lastChar) && lastChar != '.') { if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length() - 1); } else { exp = null; } /*Requesting a specific type..*/ String numeric = str.substring(0, str.length() - 1); boolean allZeros = isAllZeros(mant) && isAllZeros(exp); switch (lastChar) { case 'l' :
* <code>BigDecimal</code>.</p> * * <p>If the string starts with <code>0x</code> or <code>-0x</code>, it * will be interpreted as a hexadecimal integer.  Values with leading * <code>0</code>'s will not be interpreted as octal.</p> * * <p>Returns <code>null</code> if the string is <code>null</code>.</p> * * <p>This method does not trim the input string, i.e., strings with leading * or trailing spaces will generate NumberFormatExceptions.</p> * * @param str  String containing a number, may be null * @return Number created from the string * @throws NumberFormatException if the value cannot be converted } <BUGS> dec = null; <BUGE> } if (!Character.isDigit(lastChar) && lastChar != '.') { if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length() - 1); } else { exp = null; } /*Requesting a specific type..*/ String numeric = str.substring(0, str.length() - 1); boolean allZeros = isAllZeros(mant) && isAllZeros(exp); switch (lastChar) { case 'l' : case 'L' : if (dec == null
* * <p>If the string starts with <code>0x</code> or <code>-0x</code>, it * will be interpreted as a hexadecimal integer.  Values with leading * <code>0</code>'s will not be interpreted as octal.</p> * * <p>Returns <code>null</code> if the string is <code>null</code>.</p> * * <p>This method does not trim the input string, i.e., strings with leading * or trailing spaces will generate NumberFormatExceptions.</p> * * @param str  String containing a number, may be null * @return Number created from the string * @throws NumberFormatException if the value cannot be converted } <BUGS> if (!Character.isDigit(lastChar) && lastChar != '.') { if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length() - 1); <BUGE> } else { exp = null; } /*Requesting a specific type..*/ String numeric = str.substring(0, str.length() - 1); boolean allZeros = isAllZeros(mant) && isAllZeros(exp); switch (lastChar) { case 'l' : case 'L' : if (dec == null && exp == null && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) { try {
* <code>BigDecimal</code>.</p> * * <p>If the string starts with <code>0x</code> or <code>-0x</code>, it * will be interpreted as a hexadecimal integer.  Values with leading * <code>0</code>'s will not be interpreted as octal.</p> * * <p>Returns <code>null</code> if the string is <code>null</code>.</p> * * <p>This method does not trim the input string, i.e., strings with leading * or trailing spaces will generate NumberFormatExceptions.</p> * * @param str  String containing a number, may be null * @return Number created from the string * @throws NumberFormatException if the value cannot be converted } else { <BUGS> exp = null; <BUGE> } /*Requesting a specific type..*/ String numeric = str.substring(0, str.length() - 1); boolean allZeros = isAllZeros(mant) && isAllZeros(exp); switch (lastChar) { case 'l' : case 'L' : if (dec == null && exp == null && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) { try { return createLong(numeric); } catch (NumberFormatException nfe) { /*Too big for a long*/
* * <p>If the string starts with <code>0x</code> or <code>-0x</code>, it * will be interpreted as a hexadecimal integer.  Values with leading * <code>0</code>'s will not be interpreted as octal.</p> * * <p>Returns <code>null</code> if the string is <code>null</code>.</p> * * <p>This method does not trim the input string, i.e., strings with leading * or trailing spaces will generate NumberFormatExceptions.</p> * * @param str  String containing a number, may be null * @return Number created from the string * @throws NumberFormatException if the value cannot be converted /*Requesting a specific type..*/ <BUGS> String numeric = str.substring(0, str.length() - 1); boolean allZeros = isAllZeros(mant) && isAllZeros(exp); switch (lastChar) { <BUGE> case 'l' : case 'L' : if (dec == null && exp == null && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) { try { return createLong(numeric); } catch (NumberFormatException nfe) { /*Too big for a long*/ } return createBigInteger(numeric);  }
* <code>BigDecimal</code>.</p> * * <p>If the string starts with <code>0x</code> or <code>-0x</code>, it * will be interpreted as a hexadecimal integer.  Values with leading * <code>0</code>'s will not be interpreted as octal.</p> * * <p>Returns <code>null</code> if the string is <code>null</code>.</p> * * <p>This method does not trim the input string, i.e., strings with leading * or trailing spaces will generate NumberFormatExceptions.</p> * * @param str  String containing a number, may be null * @return Number created from the string * @throws NumberFormatException if the value cannot be converted case 'L' : <BUGS> if (dec == null <BUGE> && exp == null && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) { try { return createLong(numeric); } catch (NumberFormatException nfe) { /*Too big for a long*/ } return createBigInteger(numeric);  } throw new NumberFormatException(str + " is not a valid number."); case 'f' : case 'F' : try {
* <code>BigDecimal</code>.</p> * * <p>If the string starts with <code>0x</code> or <code>-0x</code>, it * will be interpreted as a hexadecimal integer.  Values with leading * <code>0</code>'s will not be interpreted as octal.</p> * * <p>Returns <code>null</code> if the string is <code>null</code>.</p> * * <p>This method does not trim the input string, i.e., strings with leading * or trailing spaces will generate NumberFormatExceptions.</p> * * @param str  String containing a number, may be null * @return Number created from the string * @throws NumberFormatException if the value cannot be converted try { <BUGS> return createLong(numeric); } catch (NumberFormatException nfe) { <BUGE> /*Too big for a long*/ } return createBigInteger(numeric);  } throw new NumberFormatException(str + " is not a valid number."); case 'f' : case 'F' : try { Float f = NumberUtils.createFloat(numeric); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { /*If it's too big for a float or the float value = 0 and the string*/ /*has non-zeros in it, then float does not have the precision we want*/
* <code>BigDecimal</code>.</p> * * <p>If the string starts with <code>0x</code> or <code>-0x</code>, it * will be interpreted as a hexadecimal integer.  Values with leading * <code>0</code>'s will not be interpreted as octal.</p> * * <p>Returns <code>null</code> if the string is <code>null</code>.</p> * * <p>This method does not trim the input string, i.e., strings with leading * or trailing spaces will generate NumberFormatExceptions.</p> * * @param str  String containing a number, may be null * @return Number created from the string * @throws NumberFormatException if the value cannot be converted } <BUGS> return createBigInteger(numeric); <BUGE>  } throw new NumberFormatException(str + " is not a valid number."); case 'f' : case 'F' : try { Float f = NumberUtils.createFloat(numeric); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { /*If it's too big for a float or the float value = 0 and the string*/ /*has non-zeros in it, then float does not have the precision we want*/ return f; }  } catch (NumberFormatException nfe) {
* <code>BigDecimal</code>.</p> * * <p>If the string starts with <code>0x</code> or <code>-0x</code>, it * will be interpreted as a hexadecimal integer.  Values with leading * <code>0</code>'s will not be interpreted as octal.</p> * * <p>Returns <code>null</code> if the string is <code>null</code>.</p> * * <p>This method does not trim the input string, i.e., strings with leading * or trailing spaces will generate NumberFormatExceptions.</p> * * @param str  String containing a number, may be null * @return Number created from the string * @throws NumberFormatException if the value cannot be converted try { <BUGS> Float f = NumberUtils.createFloat(numeric); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { <BUGE> /*If it's too big for a float or the float value = 0 and the string*/ /*has non-zeros in it, then float does not have the precision we want*/ return f; }  } catch (NumberFormatException nfe) { /* ignore the bad number*/ } /*$FALL-THROUGH$*/ case 'd' : case 'D' : try { Double d = NumberUtils.createDouble(numeric);
* <code>BigDecimal</code>.</p> * * <p>If the string starts with <code>0x</code> or <code>-0x</code>, it * will be interpreted as a hexadecimal integer.  Values with leading * <code>0</code>'s will not be interpreted as octal.</p> * * <p>Returns <code>null</code> if the string is <code>null</code>.</p> * * <p>This method does not trim the input string, i.e., strings with leading * or trailing spaces will generate NumberFormatExceptions.</p> * * @param str  String containing a number, may be null * @return Number created from the string * @throws NumberFormatException if the value cannot be converted /*has non-zeros in it, then float does not have the precision we want*/ <BUGS> return f; <BUGE> }  } catch (NumberFormatException nfe) { /* ignore the bad number*/ } /*$FALL-THROUGH$*/ case 'd' : case 'D' : try { Double d = NumberUtils.createDouble(numeric); if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) {
* <code>BigDecimal</code>.</p> * * <p>If the string starts with <code>0x</code> or <code>-0x</code>, it * will be interpreted as a hexadecimal integer.  Values with leading * <code>0</code>'s will not be interpreted as octal.</p> * * <p>Returns <code>null</code> if the string is <code>null</code>.</p> * * <p>This method does not trim the input string, i.e., strings with leading * or trailing spaces will generate NumberFormatExceptions.</p> * * @param str  String containing a number, may be null * @return Number created from the string * @throws NumberFormatException if the value cannot be converted /* ignore the bad number*/ <BUGS> } <BUGE> /*$FALL-THROUGH$*/ case 'd' : case 'D' : try { Double d = NumberUtils.createDouble(numeric); if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { /* ignore the bad number*/ } try { return createBigDecimal(numeric); } catch (NumberFormatException e) {
* * <p>If the string starts with <code>0x</code> or <code>-0x</code>, it * will be interpreted as a hexadecimal integer.  Values with leading * <code>0</code>'s will not be interpreted as octal.</p> * * <p>Returns <code>null</code> if the string is <code>null</code>.</p> * * <p>This method does not trim the input string, i.e., strings with leading * or trailing spaces will generate NumberFormatExceptions.</p> * * @param str  String containing a number, may be null * @return Number created from the string * @throws NumberFormatException if the value cannot be converted try { <BUGS> Double d = NumberUtils.createDouble(numeric); if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) { return d; <BUGE> } } catch (NumberFormatException nfe) { /* ignore the bad number*/ } try { return createBigDecimal(numeric); } catch (NumberFormatException e) { /* ignore the bad number*/ } /*$FALL-THROUGH$*/ default : throw new NumberFormatException(str + " is not a valid number.");
* <code>BigDecimal</code>.</p> * * <p>If the string starts with <code>0x</code> or <code>-0x</code>, it * will be interpreted as a hexadecimal integer.  Values with leading * <code>0</code>'s will not be interpreted as octal.</p> * * <p>Returns <code>null</code> if the string is <code>null</code>.</p> * * <p>This method does not trim the input string, i.e., strings with leading * or trailing spaces will generate NumberFormatExceptions.</p> * * @param str  String containing a number, may be null * @return Number created from the string * @throws NumberFormatException if the value cannot be converted /* ignore the bad number*/ <BUGS> } <BUGE> try { return createBigDecimal(numeric); } catch (NumberFormatException e) { /* ignore the bad number*/ } /*$FALL-THROUGH$*/ default : throw new NumberFormatException(str + " is not a valid number.");  } } else { /*User doesn't have a preference on the return type, so let's start*/ /*small and go from there...*/ if (expPos > -1 && expPos < str.length() - 1) {
* <code>BigDecimal</code>.</p> * * <p>If the string starts with <code>0x</code> or <code>-0x</code>, it * will be interpreted as a hexadecimal integer.  Values with leading * <code>0</code>'s will not be interpreted as octal.</p> * * <p>Returns <code>null</code> if the string is <code>null</code>.</p> * * <p>This method does not trim the input string, i.e., strings with leading * or trailing spaces will generate NumberFormatExceptions.</p> * * @param str  String containing a number, may be null * @return Number created from the string * @throws NumberFormatException if the value cannot be converted try { <BUGS> return createBigDecimal(numeric); <BUGE> } catch (NumberFormatException e) { /* ignore the bad number*/ } /*$FALL-THROUGH$*/ default : throw new NumberFormatException(str + " is not a valid number.");  } } else { /*User doesn't have a preference on the return type, so let's start*/ /*small and go from there...*/ if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length()); } else {
* <code>BigDecimal</code>.</p> * * <p>If the string starts with <code>0x</code> or <code>-0x</code>, it * will be interpreted as a hexadecimal integer.  Values with leading * <code>0</code>'s will not be interpreted as octal.</p> * * <p>Returns <code>null</code> if the string is <code>null</code>.</p> * * <p>This method does not trim the input string, i.e., strings with leading * or trailing spaces will generate NumberFormatExceptions.</p> * * @param str  String containing a number, may be null * @return Number created from the string * @throws NumberFormatException if the value cannot be converted /*small and go from there...*/ <BUGS> if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length()); <BUGE> } else { exp = null; } if (dec == null && exp == null) { /*Must be an int,long,bigint*/ try { return createInteger(str); } catch (NumberFormatException nfe) { /* ignore the bad number*/ } try { return createLong(str); } catch (NumberFormatException nfe) {
* <code>BigDecimal</code>.</p> * * <p>If the string starts with <code>0x</code> or <code>-0x</code>, it * will be interpreted as a hexadecimal integer.  Values with leading * <code>0</code>'s will not be interpreted as octal.</p> * * <p>Returns <code>null</code> if the string is <code>null</code>.</p> * * <p>This method does not trim the input string, i.e., strings with leading * or trailing spaces will generate NumberFormatExceptions.</p> * * @param str  String containing a number, may be null * @return Number created from the string * @throws NumberFormatException if the value cannot be converted } else { <BUGS> exp = null; <BUGE> } if (dec == null && exp == null) { /*Must be an int,long,bigint*/ try { return createInteger(str); } catch (NumberFormatException nfe) { /* ignore the bad number*/ } try { return createLong(str); } catch (NumberFormatException nfe) { /* ignore the bad number*/ } return createBigInteger(str);
* <code>BigDecimal</code>.</p> * * <p>If the string starts with <code>0x</code> or <code>-0x</code>, it * will be interpreted as a hexadecimal integer.  Values with leading * <code>0</code>'s will not be interpreted as octal.</p> * * <p>Returns <code>null</code> if the string is <code>null</code>.</p> * * <p>This method does not trim the input string, i.e., strings with leading * or trailing spaces will generate NumberFormatExceptions.</p> * * @param str  String containing a number, may be null * @return Number created from the string * @throws NumberFormatException if the value cannot be converted } <BUGS> if (dec == null && exp == null) { <BUGE> /*Must be an int,long,bigint*/ try { return createInteger(str); } catch (NumberFormatException nfe) { /* ignore the bad number*/ } try { return createLong(str); } catch (NumberFormatException nfe) { /* ignore the bad number*/ } return createBigInteger(str);  } else {
* <code>BigDecimal</code>.</p> * * <p>If the string starts with <code>0x</code> or <code>-0x</code>, it * will be interpreted as a hexadecimal integer.  Values with leading * <code>0</code>'s will not be interpreted as octal.</p> * * <p>Returns <code>null</code> if the string is <code>null</code>.</p> * * <p>This method does not trim the input string, i.e., strings with leading * or trailing spaces will generate NumberFormatExceptions.</p> * * @param str  String containing a number, may be null * @return Number created from the string * @throws NumberFormatException if the value cannot be converted try { <BUGS> return createInteger(str); } catch (NumberFormatException nfe) { <BUGE> /* ignore the bad number*/ } try { return createLong(str); } catch (NumberFormatException nfe) { /* ignore the bad number*/ } return createBigInteger(str);  } else { /*Must be a float,double,BigDec*/ boolean allZeros = isAllZeros(mant) && isAllZeros(exp); try {
* <code>BigDecimal</code>.</p> * * <p>If the string starts with <code>0x</code> or <code>-0x</code>, it * will be interpreted as a hexadecimal integer.  Values with leading * <code>0</code>'s will not be interpreted as octal.</p> * * <p>Returns <code>null</code> if the string is <code>null</code>.</p> * * <p>This method does not trim the input string, i.e., strings with leading * or trailing spaces will generate NumberFormatExceptions.</p> * * @param str  String containing a number, may be null * @return Number created from the string * @throws NumberFormatException if the value cannot be converted try { <BUGS> return createLong(str); } catch (NumberFormatException nfe) { <BUGE> /* ignore the bad number*/ } return createBigInteger(str);  } else { /*Must be a float,double,BigDec*/ boolean allZeros = isAllZeros(mant) && isAllZeros(exp); try { Float f = createFloat(str); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { return f; } } catch (NumberFormatException nfe) {
* <code>BigDecimal</code>.</p> * * <p>If the string starts with <code>0x</code> or <code>-0x</code>, it * will be interpreted as a hexadecimal integer.  Values with leading * <code>0</code>'s will not be interpreted as octal.</p> * * <p>Returns <code>null</code> if the string is <code>null</code>.</p> * * <p>This method does not trim the input string, i.e., strings with leading * or trailing spaces will generate NumberFormatExceptions.</p> * * @param str  String containing a number, may be null * @return Number created from the string * @throws NumberFormatException if the value cannot be converted } <BUGS> return createBigInteger(str); <BUGE>  } else { /*Must be a float,double,BigDec*/ boolean allZeros = isAllZeros(mant) && isAllZeros(exp); try { Float f = createFloat(str); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { return f; } } catch (NumberFormatException nfe) { /* ignore the bad number*/ } try { Double d = createDouble(str);
* <code>BigDecimal</code>.</p> * * <p>If the string starts with <code>0x</code> or <code>-0x</code>, it * will be interpreted as a hexadecimal integer.  Values with leading * <code>0</code>'s will not be interpreted as octal.</p> * * <p>Returns <code>null</code> if the string is <code>null</code>.</p> * * <p>This method does not trim the input string, i.e., strings with leading * or trailing spaces will generate NumberFormatExceptions.</p> * * @param str  String containing a number, may be null * @return Number created from the string * @throws NumberFormatException if the value cannot be converted /*Must be a float,double,BigDec*/ <BUGS> boolean allZeros = isAllZeros(mant) && isAllZeros(exp); <BUGE> try { Float f = createFloat(str); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { return f; } } catch (NumberFormatException nfe) { /* ignore the bad number*/ } try { Double d = createDouble(str); if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) {
* * <p>If the string starts with <code>0x</code> or <code>-0x</code>, it * will be interpreted as a hexadecimal integer.  Values with leading * <code>0</code>'s will not be interpreted as octal.</p> * * <p>Returns <code>null</code> if the string is <code>null</code>.</p> * * <p>This method does not trim the input string, i.e., strings with leading * or trailing spaces will generate NumberFormatExceptions.</p> * * @param str  String containing a number, may be null * @return Number created from the string * @throws NumberFormatException if the value cannot be converted try { <BUGS> Float f = createFloat(str); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { return f; <BUGE> } } catch (NumberFormatException nfe) { /* ignore the bad number*/ } try { Double d = createDouble(str); if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { /* ignore the bad number*/ }
* <code>BigDecimal</code>.</p> * * <p>If the string starts with <code>0x</code> or <code>-0x</code>, it * will be interpreted as a hexadecimal integer.  Values with leading * <code>0</code>'s will not be interpreted as octal.</p> * * <p>Returns <code>null</code> if the string is <code>null</code>.</p> * * <p>This method does not trim the input string, i.e., strings with leading * or trailing spaces will generate NumberFormatExceptions.</p> * * @param str  String containing a number, may be null * @return Number created from the string * @throws NumberFormatException if the value cannot be converted /* ignore the bad number*/ <BUGS> } <BUGE> try { Double d = createDouble(str); if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { /* ignore the bad number*/ }  return createBigDecimal(str);  } } }
* * <p>If the string starts with <code>0x</code> or <code>-0x</code>, it * will be interpreted as a hexadecimal integer.  Values with leading * <code>0</code>'s will not be interpreted as octal.</p> * * <p>Returns <code>null</code> if the string is <code>null</code>.</p> * * <p>This method does not trim the input string, i.e., strings with leading * or trailing spaces will generate NumberFormatExceptions.</p> * * @param str  String containing a number, may be null * @return Number created from the string * @throws NumberFormatException if the value cannot be converted try { <BUGS> Double d = createDouble(str); if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) { return d; <BUGE> } } catch (NumberFormatException nfe) { /* ignore the bad number*/ }  return createBigDecimal(str);  } } }  /** * <p>Utility method for {@link #createNumber(java.lang.String)}.</p>
@Override public int translate(CharSequence input, int index, Writer out) throws IOException { /* TODO: Protect from ArrayIndexOutOfBounds*/ <BUGS> if(input.charAt(index) == '&' && input.charAt(index + 1) == '#') { int start = index + 2; boolean isHex = false; <BUGE>  char firstChar = input.charAt(start); if(firstChar == 'x' || firstChar == 'X') { start++; isHex = true; }  int end = start; while(input.charAt(end) != ';') { end++; }  int entityValue; try { if(isHex) { entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 16); } else { entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 10); } } catch(NumberFormatException nfe) { return 0; }  out.write(entityValue);
@Override public int translate(CharSequence input, int index, Writer out) throws IOException { /* TODO: Protect from ArrayIndexOutOfBounds*/ if(input.charAt(index) == '&' && input.charAt(index + 1) == '#') { int start = index + 2; boolean isHex = false;  <BUGS> char firstChar = input.charAt(start); if(firstChar == 'x' || firstChar == 'X') { <BUGE> start++; isHex = true; }  int end = start; while(input.charAt(end) != ';') { end++; }  int entityValue; try { if(isHex) { entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 16); } else { entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 10); } } catch(NumberFormatException nfe) { return 0; }  out.write(entityValue);
@Override public int translate(CharSequence input, int index, Writer out) throws IOException { /* TODO: Protect from ArrayIndexOutOfBounds*/ if(input.charAt(index) == '&' && input.charAt(index + 1) == '#') { int start = index + 2; boolean isHex = false;  char firstChar = input.charAt(start); if(firstChar == 'x' || firstChar == 'X') { start++; isHex = true; }  <BUGS> int end = start; while(input.charAt(end) != ';') { end++; <BUGE> }  int entityValue; try { if(isHex) { entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 16); } else { entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 10); } } catch(NumberFormatException nfe) { return 0; }  out.write(entityValue);
@Override public int translate(CharSequence input, int index, Writer out) throws IOException { /* TODO: Protect from ArrayIndexOutOfBounds*/ if(input.charAt(index) == '&' && input.charAt(index + 1) == '#') { int start = index + 2; boolean isHex = false;  char firstChar = input.charAt(start); if(firstChar == 'x' || firstChar == 'X') { start++; isHex = true; }  int end = start; while(input.charAt(end) != ';') { end++; }  int entityValue; try { <BUGS> if(isHex) { <BUGE> entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 16); } else { entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 10); } } catch(NumberFormatException nfe) { return 0; }  out.write(entityValue);
@Override public int translate(CharSequence input, int index, Writer out) throws IOException { /* TODO: Protect from ArrayIndexOutOfBounds*/ if(input.charAt(index) == '&' && input.charAt(index + 1) == '#') { int start = index + 2; boolean isHex = false;  char firstChar = input.charAt(start); if(firstChar == 'x' || firstChar == 'X') { start++; isHex = true; }  int end = start; while(input.charAt(end) != ';') { end++; }  int entityValue; try { if(isHex) { entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 16); } else { <BUGS> entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 10); <BUGE> } } catch(NumberFormatException nfe) { return 0; }  out.write(entityValue);
@Override public int translate(CharSequence input, int index, Writer out) throws IOException { /* TODO: Protect from ArrayIndexOutOfBounds*/ if(input.charAt(index) == '&' && input.charAt(index + 1) == '#') { int start = index + 2; boolean isHex = false;  char firstChar = input.charAt(start); if(firstChar == 'x' || firstChar == 'X') { start++; isHex = true; }  int end = start; while(input.charAt(end) != ';') { end++; }  int entityValue; try { if(isHex) { entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 16); } else { entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 10); } } catch(NumberFormatException nfe) { return 0; <BUGS> } <BUGE>  out.write(entityValue);
@Override public int translate(CharSequence input, int index, Writer out) throws IOException { /* TODO: Protect from ArrayIndexOutOfBounds*/ if(input.charAt(index) == '&' && input.charAt(index + 1) == '#') { int start = index + 2; boolean isHex = false;  char firstChar = input.charAt(start); if(firstChar == 'x' || firstChar == 'X') { start++; isHex = true; }  int end = start; while(input.charAt(end) != ';') { end++; }  int entityValue; try { if(isHex) { entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 16); } else { entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 10); } } catch(NumberFormatException nfe) { return 0; }  <BUGS> out.write(entityValue);
*/ static float toJavaVersionInt(String version) { <BUGS> return toVersionInt(toJavaVersionIntArray(version, JAVA_VERSION_TRIM_SIZE)); <BUGE> }
*/ public static boolean containsNone(CharSequence cs, char[] searchChars) { <BUGS> if (cs == null || searchChars == null) { <BUGE> return true; } int csLen = cs.length(); int searchLen = searchChars.length; for (int i = 0; i < csLen; i++) { char ch = cs.charAt(i); for (int j = 0; j < searchLen; j++) { if (searchChars[j] == ch) { /* missing low surrogate, fine, like String.indexOf(String)*/ /* ch is in the Basic Multilingual Plane*/ return false; } } } return true; }
*/ public static boolean containsNone(CharSequence cs, char[] searchChars) { if (cs == null || searchChars == null) { return true; } <BUGS> int csLen = cs.length(); int searchLen = searchChars.length; for (int i = 0; i < csLen; i++) { char ch = cs.charAt(i); for (int j = 0; j < searchLen; j++) { if (searchChars[j] == ch) { <BUGE> /* missing low surrogate, fine, like String.indexOf(String)*/ /* ch is in the Basic Multilingual Plane*/ return false; } } } return true; }
*/ public static boolean containsNone(CharSequence cs, char[] searchChars) { if (cs == null || searchChars == null) { return true; } int csLen = cs.length(); int searchLen = searchChars.length; for (int i = 0; i < csLen; i++) { char ch = cs.charAt(i); for (int j = 0; j < searchLen; j++) { if (searchChars[j] == ch) { /* missing low surrogate, fine, like String.indexOf(String)*/ /* ch is in the Basic Multilingual Plane*/ <BUGS> return false; <BUGE> } } } return true; }
*/ public static boolean containsNone(CharSequence cs, char[] searchChars) { if (cs == null || searchChars == null) { return true; } int csLen = cs.length(); int searchLen = searchChars.length; for (int i = 0; i < csLen; i++) { char ch = cs.charAt(i); for (int j = 0; j < searchLen; j++) { if (searchChars[j] == ch) { /* missing low surrogate, fine, like String.indexOf(String)*/ /* ch is in the Basic Multilingual Plane*/ return false; } } } <BUGS> return true; <BUGE> }
*/ public static boolean containsAny(CharSequence cs, char[] searchChars) { <BUGS> if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) { <BUGE> return false; } int csLength = cs.length(); int searchLength = searchChars.length; for (int i = 0; i < csLength; i++) { char ch = cs.charAt(i); for (int j = 0; j < searchLength; j++) { if (searchChars[j] == ch) { /* ch is a supplementary character*/ /* ch is in the Basic Multilingual Plane*/ return true; } } } return false; }
*/ public static boolean containsAny(CharSequence cs, char[] searchChars) { if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) { return false; } <BUGS> int csLength = cs.length(); int searchLength = searchChars.length; for (int i = 0; i < csLength; i++) { char ch = cs.charAt(i); for (int j = 0; j < searchLength; j++) { if (searchChars[j] == ch) { <BUGE> /* ch is a supplementary character*/ /* ch is in the Basic Multilingual Plane*/ return true; } } } return false; }
*/ public static boolean containsAny(CharSequence cs, char[] searchChars) { if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) { return false; } int csLength = cs.length(); int searchLength = searchChars.length; for (int i = 0; i < csLength; i++) { char ch = cs.charAt(i); for (int j = 0; j < searchLength; j++) { if (searchChars[j] == ch) { /* ch is a supplementary character*/ /* ch is in the Basic Multilingual Plane*/ <BUGS> return true; <BUGE> } } } return false; }
*/ private static void reflectionAppend(Object object, Class<?> clazz, HashCodeBuilder builder, boolean useTransients, String[] excludeFields) { <BUGS> if (isRegistered(object)) { return; <BUGE> } try { register(object); Field[] fields = clazz.getDeclaredFields(); AccessibleObject.setAccessible(fields, true); for (Field field : fields) { if (!ArrayUtils.contains(excludeFields, field.getName()) && (field.getName().indexOf('$') == -1) && (useTransients || !Modifier.isTransient(field.getModifiers())) && (!Modifier.isStatic(field.getModifiers()))) { try { Object fieldValue = field.get(object); builder.append(fieldValue); } catch (IllegalAccessException e) { /* this can't happen. Would get a Security exception instead*/ /* throw a runtime exception in case the impossible happens.*/ throw new InternalError("Unexpected IllegalAccessException"); } } } } finally { unregister(object); } }
*/ private static void reflectionAppend(Object object, Class<?> clazz, HashCodeBuilder builder, boolean useTransients, String[] excludeFields) { if (isRegistered(object)) { return; } try { <BUGS> register(object); Field[] fields = clazz.getDeclaredFields(); AccessibleObject.setAccessible(fields, true); for (Field field : fields) { if (!ArrayUtils.contains(excludeFields, field.getName()) <BUGE> && (field.getName().indexOf('$') == -1) && (useTransients || !Modifier.isTransient(field.getModifiers())) && (!Modifier.isStatic(field.getModifiers()))) { try { Object fieldValue = field.get(object); builder.append(fieldValue); } catch (IllegalAccessException e) { /* this can't happen. Would get a Security exception instead*/ /* throw a runtime exception in case the impossible happens.*/ throw new InternalError("Unexpected IllegalAccessException"); } } } } finally { unregister(object); } }
*/ private static void reflectionAppend(Object object, Class<?> clazz, HashCodeBuilder builder, boolean useTransients, String[] excludeFields) { if (isRegistered(object)) { return; } try { register(object); Field[] fields = clazz.getDeclaredFields(); AccessibleObject.setAccessible(fields, true); for (Field field : fields) { if (!ArrayUtils.contains(excludeFields, field.getName()) && (field.getName().indexOf('$') == -1) && (useTransients || !Modifier.isTransient(field.getModifiers())) && (!Modifier.isStatic(field.getModifiers()))) { try { <BUGS> Object fieldValue = field.get(object); builder.append(fieldValue); <BUGE> } catch (IllegalAccessException e) { /* this can't happen. Would get a Security exception instead*/ /* throw a runtime exception in case the impossible happens.*/ throw new InternalError("Unexpected IllegalAccessException"); } } } } finally { unregister(object); } }
*/ private static void reflectionAppend(Object object, Class<?> clazz, HashCodeBuilder builder, boolean useTransients, String[] excludeFields) { if (isRegistered(object)) { return; } try { register(object); Field[] fields = clazz.getDeclaredFields(); AccessibleObject.setAccessible(fields, true); for (Field field : fields) { if (!ArrayUtils.contains(excludeFields, field.getName()) && (field.getName().indexOf('$') == -1) && (useTransients || !Modifier.isTransient(field.getModifiers())) && (!Modifier.isStatic(field.getModifiers()))) { try { Object fieldValue = field.get(object); builder.append(fieldValue); } catch (IllegalAccessException e) { /* this can't happen. Would get a Security exception instead*/ /* throw a runtime exception in case the impossible happens.*/ throw new InternalError("Unexpected IllegalAccessException"); <BUGS> } <BUGE> } } } finally { unregister(object); } }
*/ private static void reflectionAppend(Object object, Class<?> clazz, HashCodeBuilder builder, boolean useTransients, String[] excludeFields) { if (isRegistered(object)) { return; } try { register(object); Field[] fields = clazz.getDeclaredFields(); AccessibleObject.setAccessible(fields, true); for (Field field : fields) { if (!ArrayUtils.contains(excludeFields, field.getName()) && (field.getName().indexOf('$') == -1) && (useTransients || !Modifier.isTransient(field.getModifiers())) && (!Modifier.isStatic(field.getModifiers()))) { try { Object fieldValue = field.get(object); builder.append(fieldValue); } catch (IllegalAccessException e) { /* this can't happen. Would get a Security exception instead*/ /* throw a runtime exception in case the impossible happens.*/ throw new InternalError("Unexpected IllegalAccessException"); } } } } finally { <BUGS> unregister(object); } } <BUGE>
* toClass is non-primitive.</p> * * <p>Specifically, this method tests whether the type represented by the * specified <code>Class</code> parameter can be converted to the type * represented by this <code>Class</code> object via an identity conversion * widening primitive or widening reference conversion. See * <em><a href="http:/*java.sun.com/docs/books/jls/">The Java Language Specification</a></em>,*/ * sections 5.1.1, 5.1.2 and 5.1.4 for details.</p> * * @param cls  the Class to check, may be null * @param toClass  the Class to try to assign into, returns false if null * @param autoboxing  whether to use implicit autoboxing/unboxing between primitives and wrappers * @return <code>true</code> if assignment possible public static Class<?>[] toClass(Object[] array) { <BUGS> if (array == null) { return null; } else if (array.length == 0) { return ArrayUtils.EMPTY_CLASS_ARRAY; <BUGE> } Class<?>[] classes = new Class[array.length]; for (int i = 0; i < array.length; i++) { classes[i] = array[i].getClass(); } return classes; }  /* Short canonical name*/ /* ----------------------------------------------------------------------*/ /** * <p>Gets the canonical name minus the package name for an <code>Object</code>.</p>
* toClass is non-primitive.</p> * * <p>Specifically, this method tests whether the type represented by the * specified <code>Class</code> parameter can be converted to the type * represented by this <code>Class</code> object via an identity conversion * widening primitive or widening reference conversion. See * <em><a href="http:/*java.sun.com/docs/books/jls/">The Java Language Specification</a></em>,*/ * sections 5.1.1, 5.1.2 and 5.1.4 for details.</p> * * @param cls  the Class to check, may be null * @param toClass  the Class to try to assign into, returns false if null * @param autoboxing  whether to use implicit autoboxing/unboxing between primitives and wrappers * @return <code>true</code> if assignment possible } <BUGS> Class<?>[] classes = new Class[array.length]; for (int i = 0; i < array.length; i++) { classes[i] = array[i].getClass(); <BUGE> } return classes; }  /* Short canonical name*/ /* ----------------------------------------------------------------------*/ /** * <p>Gets the canonical name minus the package name for an <code>Object</code>.</p> * * @param object  the class to get the short name for, may be null * @param valueIfNull  the value to return if null * @return the canonical name of the object without the package name, or the null value * @since 2.4
* will return <code>true</code> if <code>null</code> is passed in and the * toClass is non-primitive.</p> * * <p>Specifically, this method tests whether the type represented by the * specified <code>Class</code> parameter can be converted to the type * represented by this <code>Class</code> object via an identity conversion * widening primitive or widening reference conversion. See * <em><a href="http:/*java.sun.com/docs/books/jls/">The Java Language Specification</a></em>,*/ * sections 5.1.1, 5.1.2 and 5.1.4 for details.</p> * * @param cls  the Class to check, may be null * @param toClass  the Class to try to assign into, returns false if null * @param autoboxing  whether to use implicit autoboxing/unboxing between primitives and wrappers * @return <code>true</code> if assignment possible } <BUGS> return classes; <BUGE> }  /* Short canonical name*/ /* ----------------------------------------------------------------------*/ /** * <p>Gets the canonical name minus the package name for an <code>Object</code>.</p> * * @param object  the class to get the short name for, may be null * @param valueIfNull  the value to return if null * @return the canonical name of the object without the package name, or the null value * @since 2.4 */ public static String getShortCanonicalName(Object object, String valueIfNull) { if (object == null) {
*/ public static <T> T[] add(T[] array, T element) { Class<?> type; <BUGS> if (array != null){ <BUGE> type = array.getClass(); } else if (element != null) { type = element.getClass(); } else { type = Object.class; } @SuppressWarnings("unchecked") /* type must be T*/ T[] newArray = (T[]) copyArrayGrow1(array, type); newArray[newArray.length - 1] = element; return newArray; }
*/ public static <T> T[] add(T[] array, T element) { Class<?> type; if (array != null){ type = array.getClass(); <BUGS> } else if (element != null) { <BUGE> type = element.getClass(); } else { type = Object.class; } @SuppressWarnings("unchecked") /* type must be T*/ T[] newArray = (T[]) copyArrayGrow1(array, type); newArray[newArray.length - 1] = element; return newArray; }
*/ public static <T> T[] add(T[] array, T element) { Class<?> type; if (array != null){ type = array.getClass(); } else if (element != null) { type = element.getClass(); } else { <BUGS> type = Object.class; <BUGE> } @SuppressWarnings("unchecked") /* type must be T*/ T[] newArray = (T[]) copyArrayGrow1(array, type); newArray[newArray.length - 1] = element; return newArray; }
*/ public static <T> T[] add(T[] array, T element) { Class<?> type; if (array != null){ type = array.getClass(); } else if (element != null) { type = element.getClass(); } else { type = Object.class; } @SuppressWarnings("unchecked") /* type must be T*/ <BUGS> T[] newArray = (T[]) copyArrayGrow1(array, type); newArray[newArray.length - 1] = element; return newArray; <BUGE> }
*/ public double[] rank(double[] data) {  /* Array recording initial positions of data to be ranked*/ <BUGS> IntDoublePair[] ranks = new IntDoublePair[data.length]; for (int i = 0; i < data.length; i++) { ranks[i] = new IntDoublePair(data[i], i); <BUGE> }  /* Recode, remove or record positions of NaNs*/ List<Integer> nanPositions = null; switch (nanStrategy) { case MAXIMAL: /* Replace NaNs with +INFs*/ recodeNaNs(ranks, Double.POSITIVE_INFINITY); break; case MINIMAL: /* Replace NaNs with -INFs*/ recodeNaNs(ranks, Double.NEGATIVE_INFINITY); break; case REMOVED: /* Drop NaNs from data*/ ranks = removeNaNs(ranks); break; case FIXED:   /* Record positions of NaNs*/ nanPositions = getNanPositions(ranks); break; case FAILED: nanPositions = getNanPositions(ranks); if (nanPositions.size() > 0) { throw new NotANumberException(); } break;
*/ public double[] rank(double[] data) {  /* Array recording initial positions of data to be ranked*/ IntDoublePair[] ranks = new IntDoublePair[data.length]; for (int i = 0; i < data.length; i++) { ranks[i] = new IntDoublePair(data[i], i); }  /* Recode, remove or record positions of NaNs*/ <BUGS> List<Integer> nanPositions = null; switch (nanStrategy) { <BUGE> case MAXIMAL: /* Replace NaNs with +INFs*/ recodeNaNs(ranks, Double.POSITIVE_INFINITY); break; case MINIMAL: /* Replace NaNs with -INFs*/ recodeNaNs(ranks, Double.NEGATIVE_INFINITY); break; case REMOVED: /* Drop NaNs from data*/ ranks = removeNaNs(ranks); break; case FIXED:   /* Record positions of NaNs*/ nanPositions = getNanPositions(ranks); break; case FAILED: nanPositions = getNanPositions(ranks); if (nanPositions.size() > 0) { throw new NotANumberException(); } break;
*/ public double[] rank(double[] data) {  /* Array recording initial positions of data to be ranked*/ IntDoublePair[] ranks = new IntDoublePair[data.length]; for (int i = 0; i < data.length; i++) { ranks[i] = new IntDoublePair(data[i], i); }  /* Recode, remove or record positions of NaNs*/ List<Integer> nanPositions = null; switch (nanStrategy) { case MAXIMAL: /* Replace NaNs with +INFs*/ recodeNaNs(ranks, Double.POSITIVE_INFINITY); break; case MINIMAL: /* Replace NaNs with -INFs*/ recodeNaNs(ranks, Double.NEGATIVE_INFINITY); break; case REMOVED: /* Drop NaNs from data*/ ranks = removeNaNs(ranks); break; case FIXED:   /* Record positions of NaNs*/ <BUGS> nanPositions = getNanPositions(ranks); break; <BUGE> case FAILED: nanPositions = getNanPositions(ranks); if (nanPositions.size() > 0) { throw new NotANumberException(); } break;
*/ public TiesStrategy getTiesStrategy() { return tiesStrategy; }  /** * Rank <code>data</code> using the natural ordering on Doubles, with * NaN values handled according to <code>nanStrategy</code> and ties * resolved using <code>tiesStrategy.</code> * * @param data array to be ranked * @return array of ranks * @throws NotANumberException if the selected {@link NaNStrategy} is {@code FAILED} * and a {@link Double#NaN} is encountered in the input data /* Sort the IntDoublePairs*/ <BUGS> Arrays.sort(ranks); <BUGE>  /* Walk the sorted array, filling output array using sorted positions,*/ /* resolving ties as we go*/ double[] out = new double[ranks.length]; int pos = 1;  /* position in sorted array*/ out[ranks[0].getPosition()] = pos; List<Integer> tiesTrace = new ArrayList<Integer>(); tiesTrace.add(ranks[0].getPosition()); for (int i = 1; i < ranks.length; i++) { if (Double.compare(ranks[i].getValue(), ranks[i - 1].getValue()) > 0) { /* tie sequence has ended (or had length 1)*/ pos = i + 1; if (tiesTrace.size() > 1) {  /* if seq is nontrivial, resolve*/ resolveTie(out, tiesTrace);
}  /** * Rank <code>data</code> using the natural ordering on Doubles, with * NaN values handled according to <code>nanStrategy</code> and ties * resolved using <code>tiesStrategy.</code> * * @param data array to be ranked * @return array of ranks * @throws NotANumberException if the selected {@link NaNStrategy} is {@code FAILED} * and a {@link Double#NaN} is encountered in the input data /* resolving ties as we go*/ <BUGS> double[] out = new double[ranks.length]; int pos = 1;  /* position in sorted array*/ out[ranks[0].getPosition()] = pos; List<Integer> tiesTrace = new ArrayList<Integer>(); tiesTrace.add(ranks[0].getPosition()); for (int i = 1; i < ranks.length; i++) { if (Double.compare(ranks[i].getValue(), ranks[i - 1].getValue()) > 0) { <BUGE> /* tie sequence has ended (or had length 1)*/ pos = i + 1; if (tiesTrace.size() > 1) {  /* if seq is nontrivial, resolve*/ resolveTie(out, tiesTrace); } tiesTrace = new ArrayList<Integer>(); tiesTrace.add(ranks[i].getPosition()); } else { /* tie sequence continues*/ tiesTrace.add(ranks[i].getPosition()); }
public TiesStrategy getTiesStrategy() { return tiesStrategy; }  /** * Rank <code>data</code> using the natural ordering on Doubles, with * NaN values handled according to <code>nanStrategy</code> and ties * resolved using <code>tiesStrategy.</code> * * @param data array to be ranked * @return array of ranks * @throws NotANumberException if the selected {@link NaNStrategy} is {@code FAILED} * and a {@link Double#NaN} is encountered in the input data /* tie sequence has ended (or had length 1)*/ <BUGS> pos = i + 1; if (tiesTrace.size() > 1) {  /* if seq is nontrivial, resolve*/ resolveTie(out, tiesTrace); <BUGE> } tiesTrace = new ArrayList<Integer>(); tiesTrace.add(ranks[i].getPosition()); } else { /* tie sequence continues*/ tiesTrace.add(ranks[i].getPosition()); } out[ranks[i].getPosition()] = pos; } if (tiesTrace.size() > 1) {  /* handle tie sequence at end*/ resolveTie(out, tiesTrace); } if (nanStrategy == NaNStrategy.FIXED) {
*/ public TiesStrategy getTiesStrategy() { return tiesStrategy; }  /** * Rank <code>data</code> using the natural ordering on Doubles, with * NaN values handled according to <code>nanStrategy</code> and ties * resolved using <code>tiesStrategy.</code> * * @param data array to be ranked * @return array of ranks * @throws NotANumberException if the selected {@link NaNStrategy} is {@code FAILED} * and a {@link Double#NaN} is encountered in the input data } <BUGS> tiesTrace = new ArrayList<Integer>(); tiesTrace.add(ranks[i].getPosition()); <BUGE> } else { /* tie sequence continues*/ tiesTrace.add(ranks[i].getPosition()); } out[ranks[i].getPosition()] = pos; } if (tiesTrace.size() > 1) {  /* handle tie sequence at end*/ resolveTie(out, tiesTrace); } if (nanStrategy == NaNStrategy.FIXED) { restoreNaNs(out, nanPositions); } return out;
*/ public TiesStrategy getTiesStrategy() { return tiesStrategy; }  /** * Rank <code>data</code> using the natural ordering on Doubles, with * NaN values handled according to <code>nanStrategy</code> and ties * resolved using <code>tiesStrategy.</code> * * @param data array to be ranked * @return array of ranks * @throws NotANumberException if the selected {@link NaNStrategy} is {@code FAILED} * and a {@link Double#NaN} is encountered in the input data /* tie sequence continues*/ <BUGS> tiesTrace.add(ranks[i].getPosition()); <BUGE> } out[ranks[i].getPosition()] = pos; } if (tiesTrace.size() > 1) {  /* handle tie sequence at end*/ resolveTie(out, tiesTrace); } if (nanStrategy == NaNStrategy.FIXED) { restoreNaNs(out, nanPositions); } return out; }  /** * Returns an array that is a copy of the input array with IntDoublePairs
*/ public TiesStrategy getTiesStrategy() { return tiesStrategy; }  /** * Rank <code>data</code> using the natural ordering on Doubles, with * NaN values handled according to <code>nanStrategy</code> and ties * resolved using <code>tiesStrategy.</code> * * @param data array to be ranked * @return array of ranks * @throws NotANumberException if the selected {@link NaNStrategy} is {@code FAILED} * and a {@link Double#NaN} is encountered in the input data } <BUGS> out[ranks[i].getPosition()] = pos; <BUGE> } if (tiesTrace.size() > 1) {  /* handle tie sequence at end*/ resolveTie(out, tiesTrace); } if (nanStrategy == NaNStrategy.FIXED) { restoreNaNs(out, nanPositions); } return out; }  /** * Returns an array that is a copy of the input array with IntDoublePairs * having NaN values removed. *
*/ public TiesStrategy getTiesStrategy() { return tiesStrategy; }  /** * Rank <code>data</code> using the natural ordering on Doubles, with * NaN values handled according to <code>nanStrategy</code> and ties * resolved using <code>tiesStrategy.</code> * * @param data array to be ranked * @return array of ranks * @throws NotANumberException if the selected {@link NaNStrategy} is {@code FAILED} * and a {@link Double#NaN} is encountered in the input data } <BUGS> if (tiesTrace.size() > 1) {  /* handle tie sequence at end*/ resolveTie(out, tiesTrace); <BUGE> } if (nanStrategy == NaNStrategy.FIXED) { restoreNaNs(out, nanPositions); } return out; }  /** * Returns an array that is a copy of the input array with IntDoublePairs * having NaN values removed. * * @param ranks input array * @return array with NaN-valued entries removed
*/ public TiesStrategy getTiesStrategy() { return tiesStrategy; }  /** * Rank <code>data</code> using the natural ordering on Doubles, with * NaN values handled according to <code>nanStrategy</code> and ties * resolved using <code>tiesStrategy.</code> * * @param data array to be ranked * @return array of ranks * @throws NotANumberException if the selected {@link NaNStrategy} is {@code FAILED} * and a {@link Double#NaN} is encountered in the input data } <BUGS> if (nanStrategy == NaNStrategy.FIXED) { restoreNaNs(out, nanPositions); <BUGE> } return out; }  /** * Returns an array that is a copy of the input array with IntDoublePairs * having NaN values removed. * * @param ranks input array * @return array with NaN-valued entries removed */ private IntDoublePair[] removeNaNs(IntDoublePair[] ranks) { if (!containsNaNs(ranks)) {
*/ public TiesStrategy getTiesStrategy() { return tiesStrategy; }  /** * Rank <code>data</code> using the natural ordering on Doubles, with * NaN values handled according to <code>nanStrategy</code> and ties * resolved using <code>tiesStrategy.</code> * * @param data array to be ranked * @return array of ranks * @throws NotANumberException if the selected {@link NaNStrategy} is {@code FAILED} * and a {@link Double#NaN} is encountered in the input data } <BUGS> return out; <BUGE> }  /** * Returns an array that is a copy of the input array with IntDoublePairs * having NaN values removed. * * @param ranks input array * @return array with NaN-valued entries removed */ private IntDoublePair[] removeNaNs(IntDoublePair[] ranks) { if (!containsNaNs(ranks)) { return ranks; } IntDoublePair[] outRanks = new IntDoublePair[ranks.length];
*/ private static double log(final double x, final double[] hiPrec) { <BUGS> if (x==0) { /* Handle special case of +0/-0*/ return Double.NEGATIVE_INFINITY; <BUGE> } long bits = Double.doubleToRawLongBits(x);  /* Handle special cases of negative input, and NaN */ if (((bits & 0x8000000000000000L) != 0 || x != x) && x != 0.0) { if (hiPrec != null) { hiPrec[0] = Double.NaN; }  return Double.NaN; }  /* Handle special cases of Positive infinity. */ if (x == Double.POSITIVE_INFINITY) { if (hiPrec != null) { hiPrec[0] = Double.POSITIVE_INFINITY; }  return Double.POSITIVE_INFINITY; }  /* Extract the exponent */ int exp = (int)(bits >> 52)-1023;  if ((bits & 0x7ff0000000000000L) == 0) { /* Subnormal!*/
*/ private static double log(final double x, final double[] hiPrec) { if (x==0) { /* Handle special case of +0/-0*/ return Double.NEGATIVE_INFINITY; } <BUGS> long bits = Double.doubleToRawLongBits(x); <BUGE>  /* Handle special cases of negative input, and NaN */ if (((bits & 0x8000000000000000L) != 0 || x != x) && x != 0.0) { if (hiPrec != null) { hiPrec[0] = Double.NaN; }  return Double.NaN; }  /* Handle special cases of Positive infinity. */ if (x == Double.POSITIVE_INFINITY) { if (hiPrec != null) { hiPrec[0] = Double.POSITIVE_INFINITY; }  return Double.POSITIVE_INFINITY; }  /* Extract the exponent */ int exp = (int)(bits >> 52)-1023;  if ((bits & 0x7ff0000000000000L) == 0) { /* Subnormal!*/
*/ private static double log(final double x, final double[] hiPrec) { if (x==0) { /* Handle special case of +0/-0*/ return Double.NEGATIVE_INFINITY; } long bits = Double.doubleToRawLongBits(x);  /* Handle special cases of negative input, and NaN */ <BUGS> if (((bits & 0x8000000000000000L) != 0 || x != x) && x != 0.0) { if (hiPrec != null) { <BUGE> hiPrec[0] = Double.NaN; }  return Double.NaN; }  /* Handle special cases of Positive infinity. */ if (x == Double.POSITIVE_INFINITY) { if (hiPrec != null) { hiPrec[0] = Double.POSITIVE_INFINITY; }  return Double.POSITIVE_INFINITY; }  /* Extract the exponent */ int exp = (int)(bits >> 52)-1023;  if ((bits & 0x7ff0000000000000L) == 0) { /* Subnormal!*/
*/ private static double log(final double x, final double[] hiPrec) { if (x==0) { /* Handle special case of +0/-0*/ return Double.NEGATIVE_INFINITY; } long bits = Double.doubleToRawLongBits(x);  /* Handle special cases of negative input, and NaN */ if (((bits & 0x8000000000000000L) != 0 || x != x) && x != 0.0) { if (hiPrec != null) { hiPrec[0] = Double.NaN; }  <BUGS> return Double.NaN; <BUGE> }  /* Handle special cases of Positive infinity. */ if (x == Double.POSITIVE_INFINITY) { if (hiPrec != null) { hiPrec[0] = Double.POSITIVE_INFINITY; }  return Double.POSITIVE_INFINITY; }  /* Extract the exponent */ int exp = (int)(bits >> 52)-1023;  if ((bits & 0x7ff0000000000000L) == 0) { /* Subnormal!*/
*/ private static double log(final double x, final double[] hiPrec) { if (x==0) { /* Handle special case of +0/-0*/ return Double.NEGATIVE_INFINITY; } long bits = Double.doubleToRawLongBits(x);  /* Handle special cases of negative input, and NaN */ if (((bits & 0x8000000000000000L) != 0 || x != x) && x != 0.0) { if (hiPrec != null) { hiPrec[0] = Double.NaN; }  return Double.NaN; }  /* Handle special cases of Positive infinity. */ <BUGS> if (x == Double.POSITIVE_INFINITY) { <BUGE> if (hiPrec != null) { hiPrec[0] = Double.POSITIVE_INFINITY; }  return Double.POSITIVE_INFINITY; }  /* Extract the exponent */ int exp = (int)(bits >> 52)-1023;  if ((bits & 0x7ff0000000000000L) == 0) { /* Subnormal!*/
*/ private static double log(final double x, final double[] hiPrec) { if (x==0) { /* Handle special case of +0/-0*/ return Double.NEGATIVE_INFINITY; } long bits = Double.doubleToRawLongBits(x);  /* Handle special cases of negative input, and NaN */ if (((bits & 0x8000000000000000L) != 0 || x != x) && x != 0.0) { if (hiPrec != null) { hiPrec[0] = Double.NaN; }  return Double.NaN; }  /* Handle special cases of Positive infinity. */ if (x == Double.POSITIVE_INFINITY) { if (hiPrec != null) { hiPrec[0] = Double.POSITIVE_INFINITY; }  return Double.POSITIVE_INFINITY; }  /* Extract the exponent */ <BUGS> int exp = (int)(bits >> 52)-1023; <BUGE>  if ((bits & 0x7ff0000000000000L) == 0) { /* Subnormal!*/
*/ private static double log(final double x, final double[] hiPrec) { if (x==0) { /* Handle special case of +0/-0*/ return Double.NEGATIVE_INFINITY; } long bits = Double.doubleToRawLongBits(x);  /* Handle special cases of negative input, and NaN */ if (((bits & 0x8000000000000000L) != 0 || x != x) && x != 0.0) { if (hiPrec != null) { hiPrec[0] = Double.NaN; }  return Double.NaN; }  /* Handle special cases of Positive infinity. */ if (x == Double.POSITIVE_INFINITY) { if (hiPrec != null) { hiPrec[0] = Double.POSITIVE_INFINITY; }  return Double.POSITIVE_INFINITY; }  /* Extract the exponent */ int exp = (int)(bits >> 52)-1023;  <BUGS> if ((bits & 0x7ff0000000000000L) == 0) { <BUGE> /* Subnormal!*/
* Natural logarithm. * * @param x   a double * @return log(x) */ public static double log(final double x) { return log(x, null); }  /** * Internal helper method for natural logarithm function. * @param x original argument of the natural logarithm function * @param hiPrec extra bits of precision on output (To Be Confirmed) * @return log(x)  <BUGS> if ((exp == -1 || exp == 0) && x < 1.01 && x > 0.99 && hiPrec == null) { <BUGE> /* The normal method doesn't work well in the range [0.99, 1.01], so call do a straight polynomial expansion in higer precision. */  /* Compute x - 1.0 and split it */ double xa = x - 1.0; double xb = xa - x + 1.0; double tmp = xa * HEX_40000000; double aa = xa + tmp - tmp; double ab = xa - aa; xa = aa; xb = ab;  final double[] lnCoef_last = LN_QUICK_COEF[LN_QUICK_COEF.length - 1]; double ya = lnCoef_last[0];
* Natural logarithm. * * @param x   a double * @return log(x) */ public static double log(final double x) { return log(x, null); }  /** * Internal helper method for natural logarithm function. * @param x original argument of the natural logarithm function * @param hiPrec extra bits of precision on output (To Be Confirmed) * @return log(x) /* lnm is a log of a number in the range of 1.0 - 2.0, so 0 <= lnm < ln(2)*/ <BUGS> final double[] lnm = lnMant.LN_MANT[(int)((bits & 0x000ffc0000000000L) >> 42)]; <BUGE>  /* double epsilon = x / Double.longBitsToDouble(bits & 0xfffffc0000000000L);  epsilon -= 1.0; */  /* y is the most significant 10 bits of the mantissa*/ /*double y = Double.longBitsToDouble(bits & 0xfffffc0000000000L);*/ /*double epsilon = (x - y) / y;*/ final double epsilon = (bits & 0x3ffffffffffL) / (TWO_POWER_52 + (bits & 0x000ffc0000000000L));  double lnza = 0.0; double lnzb = 0.0;
* Natural logarithm. * * @param x   a double * @return log(x) */ public static double log(final double x) { return log(x, null); }  /** * Internal helper method for natural logarithm function. * @param x original argument of the natural logarithm function * @param hiPrec extra bits of precision on output (To Be Confirmed) * @return log(x) /*double epsilon = (x - y) / y;*/ <BUGS> final double epsilon = (bits & 0x3ffffffffffL) / (TWO_POWER_52 + (bits & 0x000ffc0000000000L)); <BUGE>  double lnza = 0.0; double lnzb = 0.0;  if (hiPrec != null) { /* split epsilon -> x */ double tmp = epsilon * HEX_40000000; double aa = epsilon + tmp - tmp; double ab = epsilon - aa; double xa = aa; double xb = ab;  /* Need a more accurate epsilon, so adjust the division. */ final double numer = bits & 0x3ffffffffffL;
* Natural logarithm. * * @param x   a double * @return log(x) */ public static double log(final double x) { return log(x, null); }  /** * Internal helper method for natural logarithm function. * @param x original argument of the natural logarithm function * @param hiPrec extra bits of precision on output (To Be Confirmed) * @return log(x)  <BUGS> double lnza = 0.0; double lnzb = 0.0; <BUGE>  if (hiPrec != null) { /* split epsilon -> x */ double tmp = epsilon * HEX_40000000; double aa = epsilon + tmp - tmp; double ab = epsilon - aa; double xa = aa; double xb = ab;  /* Need a more accurate epsilon, so adjust the division. */ final double numer = bits & 0x3ffffffffffL; final double denom = TWO_POWER_52 + (bits & 0x000ffc0000000000L); aa = numer - xa*denom - xb * denom;
* Natural logarithm. * * @param x   a double * @return log(x) */ public static double log(final double x) { return log(x, null); }  /** * Internal helper method for natural logarithm function. * @param x original argument of the natural logarithm function * @param hiPrec extra bits of precision on output (To Be Confirmed) * @return log(x)  <BUGS> if (hiPrec != null) { <BUGE> /* split epsilon -> x */ double tmp = epsilon * HEX_40000000; double aa = epsilon + tmp - tmp; double ab = epsilon - aa; double xa = aa; double xb = ab;  /* Need a more accurate epsilon, so adjust the division. */ final double numer = bits & 0x3ffffffffffL; final double denom = TWO_POWER_52 + (bits & 0x000ffc0000000000L); aa = numer - xa*denom - xb * denom; xb += aa / denom;  /* Remez polynomial evaluation */
* @return log(x) */ public static double log(final double x) { return log(x, null); }  /** * Internal helper method for natural logarithm function. * @param x original argument of the natural logarithm function * @param hiPrec extra bits of precision on output (To Be Confirmed) * @return log(x) using standard double precision */ <BUGS> lnza = -0.16624882440418567; lnza = lnza * epsilon + 0.19999954120254515; lnza = lnza * epsilon + -0.2499999997677497; lnza = lnza * epsilon + 0.3333333333332802; lnza = lnza * epsilon + -0.5; lnza = lnza * epsilon + 1.0; lnza = lnza * epsilon; <BUGE> }  /* Relative sizes: * lnzb     [0, 2.33E-10] * lnm[1]   [0, 1.17E-7] * ln2B*exp [0, 1.12E-4] * lnza      [0, 9.7E-4] * lnm[0]   [0, 0.692] * ln2A*exp [0, 709] */
* @param x   a double * @return log(x) */ public static double log(final double x) { return log(x, null); }  /** * Internal helper method for natural logarithm function. * @param x original argument of the natural logarithm function * @param hiPrec extra bits of precision on output (To Be Confirmed) * @return log(x) /*return lnzb + lnm[1] + ln2B*exp + lnza + lnm[0] + ln2A*exp;*/ <BUGS> double a = LN_2_A*exp; double b = 0.0; double c = a+lnm[0]; double d = -(c-a-lnm[0]); a = c; b = b + d; <BUGE>  c = a + lnza; d = -(c - a - lnza); a = c; b = b + d;  c = a + LN_2_B*exp; d = -(c - a - LN_2_B*exp); a = c; b = b + d;
* * @param x   a double * @return log(x) */ public static double log(final double x) { return log(x, null); }  /** * Internal helper method for natural logarithm function. * @param x original argument of the natural logarithm function * @param hiPrec extra bits of precision on output (To Be Confirmed) * @return log(x)  <BUGS> c = a + lnza; d = -(c - a - lnza); a = c; b = b + d; <BUGE>  c = a + LN_2_B*exp; d = -(c - a - LN_2_B*exp); a = c; b = b + d;  c = a + lnm[1]; d = -(c - a - lnm[1]); a = c; b = b + d;  c = a + lnzb;
* * @param x   a double * @return log(x) */ public static double log(final double x) { return log(x, null); }  /** * Internal helper method for natural logarithm function. * @param x original argument of the natural logarithm function * @param hiPrec extra bits of precision on output (To Be Confirmed) * @return log(x)  <BUGS> c = a + LN_2_B*exp; d = -(c - a - LN_2_B*exp); a = c; b = b + d; <BUGE>  c = a + lnm[1]; d = -(c - a - lnm[1]); a = c; b = b + d;  c = a + lnzb; d = -(c - a - lnzb); a = c; b = b + d;  if (hiPrec != null) {
* * @param x   a double * @return log(x) */ public static double log(final double x) { return log(x, null); }  /** * Internal helper method for natural logarithm function. * @param x original argument of the natural logarithm function * @param hiPrec extra bits of precision on output (To Be Confirmed) * @return log(x)  <BUGS> c = a + lnm[1]; d = -(c - a - lnm[1]); a = c; b = b + d; <BUGE>  c = a + lnzb; d = -(c - a - lnzb); a = c; b = b + d;  if (hiPrec != null) { hiPrec[0] = a; hiPrec[1] = b; }  return a + b;
* * @param x   a double * @return log(x) */ public static double log(final double x) { return log(x, null); }  /** * Internal helper method for natural logarithm function. * @param x original argument of the natural logarithm function * @param hiPrec extra bits of precision on output (To Be Confirmed) * @return log(x)  <BUGS> c = a + lnzb; d = -(c - a - lnzb); a = c; b = b + d; <BUGE>  if (hiPrec != null) { hiPrec[0] = a; hiPrec[1] = b; }  return a + b; }  /** * Computes log(1 + x). *
* Natural logarithm. * * @param x   a double * @return log(x) */ public static double log(final double x) { return log(x, null); }  /** * Internal helper method for natural logarithm function. * @param x original argument of the natural logarithm function * @param hiPrec extra bits of precision on output (To Be Confirmed) * @return log(x)  <BUGS> if (hiPrec != null) { <BUGE> hiPrec[0] = a; hiPrec[1] = b; }  return a + b; }  /** * Computes log(1 + x). * * @param x Number. * @return {@code log(1 + x)}. */ public static double log1p(final double x) {
* Natural logarithm. * * @param x   a double * @return log(x) */ public static double log(final double x) { return log(x, null); }  /** * Internal helper method for natural logarithm function. * @param x original argument of the natural logarithm function * @param hiPrec extra bits of precision on output (To Be Confirmed) * @return log(x)  <BUGS> return a + b; <BUGE> }  /** * Computes log(1 + x). * * @param x Number. * @return {@code log(1 + x)}. */ public static double log1p(final double x) { if (x == -1) { return Double.NEGATIVE_INFINITY; }  if (x == Double.POSITIVE_INFINITY) {
*/ public boolean insertCut(final Hyperplane<S> hyperplane) {  if (cut != null) { plus.parent  = null; minus.parent = null; } <BUGS> <BUGE> final SubHyperplane<S> chopped = fitToCell(hyperplane.wholeHyperplane()); if (chopped == null || chopped.isEmpty()) { cut          = null; plus         = null; minus        = null; return false; }  cut          = chopped; plus         = new BSPTree<S>(); plus.parent  = this; minus        = new BSPTree<S>(); minus.parent = this; return true;  }
*/ public boolean insertCut(final Hyperplane<S> hyperplane) {  if (cut != null) { plus.parent  = null; minus.parent = null; }  final SubHyperplane<S> chopped = fitToCell(hyperplane.wholeHyperplane()); if (chopped == null || chopped.isEmpty()) { cut          = null; plus         = null; <BUGS> minus        = null; return false; }  cut          = chopped; plus         = new BSPTree<S>(); <BUGE> plus.parent  = this; minus        = new BSPTree<S>(); minus.parent = this; return true;  }
*/ public boolean insertCut(final Hyperplane<S> hyperplane) {  if (cut != null) { plus.parent  = null; minus.parent = null; }  final SubHyperplane<S> chopped = fitToCell(hyperplane.wholeHyperplane()); if (chopped == null || chopped.isEmpty()) { cut          = null; plus         = null; minus        = null; return false; }  cut          = chopped; plus         = new BSPTree<S>(); plus.parent  = this; minus        = new BSPTree<S>(); <BUGS> minus.parent = this; return true;  }
*/ public void reset(final Vector2D p, final double alpha) { this.angle   = MathUtils.normalizeAngle(alpha, FastMath.PI); cos          = FastMath.cos(this.angle); sin          = FastMath.sin(this.angle); originOffset = cos * p.getY() - sin * p.getX(); }
*/ public void reset(final Vector2D p, final double alpha) { this.angle   = MathUtils.normalizeAngle(alpha, FastMath.PI); cos          = FastMath.cos(this.angle); sin          = FastMath.sin(this.angle); originOffset = cos * p.getY() - sin * p.getX(); }
*/ public void reset(final Vector2D p, final double alpha) { this.angle   = MathUtils.normalizeAngle(alpha, FastMath.PI); cos          = FastMath.cos(this.angle); sin          = FastMath.sin(this.angle); originOffset = cos * p.getY() - sin * p.getX(); }
*/ public static double round(double x, int scale) { <BUGS> return round(x, scale, BigDecimal.ROUND_HALF_UP); <BUGE> }
*/ public static float round(float x, int scale) { <BUGS> return round(x, scale, BigDecimal.ROUND_HALF_UP); <BUGE> }
*/ public static double pow(double x, double y) { <BUGS> final double lns[] = new double[2]; <BUGE>  if (y == 0.0) { return 1.0; }  if (x != x) { /* X is NaN*/ return x; }   if (x == 0) { long bits = Double.doubleToRawLongBits(x); if ((bits & 0x8000000000000000L) != 0) { /* -zero*/ long yi = (long) y;  if (y < 0 && y == yi && (yi & 1) == 1) { return Double.NEGATIVE_INFINITY; }  if (y > 0 && y == yi && (yi & 1) == 1) { return -0.0; } }  if (y < 0) { return Double.POSITIVE_INFINITY;
*/ public static double pow(double x, double y) { final double lns[] = new double[2];  <BUGS> if (y == 0.0) { <BUGE> return 1.0; }  if (x != x) { /* X is NaN*/ return x; }   if (x == 0) { long bits = Double.doubleToRawLongBits(x); if ((bits & 0x8000000000000000L) != 0) { /* -zero*/ long yi = (long) y;  if (y < 0 && y == yi && (yi & 1) == 1) { return Double.NEGATIVE_INFINITY; }  if (y > 0 && y == yi && (yi & 1) == 1) { return -0.0; } }  if (y < 0) { return Double.POSITIVE_INFINITY;
*/ public static double pow(double x, double y) { final double lns[] = new double[2];  if (y == 0.0) { return 1.0; }  <BUGS> if (x != x) { /* X is NaN <BUGE>*/ return x; }   if (x == 0) { long bits = Double.doubleToRawLongBits(x); if ((bits & 0x8000000000000000L) != 0) { /* -zero*/ long yi = (long) y;  if (y < 0 && y == yi && (yi & 1) == 1) { return Double.NEGATIVE_INFINITY; }  if (y > 0 && y == yi && (yi & 1) == 1) { return -0.0; } }  if (y < 0) { return Double.POSITIVE_INFINITY;
*/ public static double pow(double x, double y) { final double lns[] = new double[2];  if (y == 0.0) { return 1.0; }  if (x != x) { /* X is NaN*/ return x; }   <BUGS> if (x == 0) { long bits = Double.doubleToRawLongBits(x); if ((bits & 0x8000000000000000L) != 0) { <BUGE> /* -zero*/ long yi = (long) y;  if (y < 0 && y == yi && (yi & 1) == 1) { return Double.NEGATIVE_INFINITY; }  if (y > 0 && y == yi && (yi & 1) == 1) { return -0.0; } }  if (y < 0) { return Double.POSITIVE_INFINITY;
*/ public static double pow(double x, double y) { final double lns[] = new double[2];  if (y == 0.0) { return 1.0; }  if (x != x) { /* X is NaN*/ return x; }   if (x == 0) { long bits = Double.doubleToRawLongBits(x); if ((bits & 0x8000000000000000L) != 0) { /* -zero*/ <BUGS> long yi = (long) y; <BUGE>  if (y < 0 && y == yi && (yi & 1) == 1) { return Double.NEGATIVE_INFINITY; }  if (y > 0 && y == yi && (yi & 1) == 1) { return -0.0; } }  if (y < 0) { return Double.POSITIVE_INFINITY;
*/ public static double pow(double x, double y) { final double lns[] = new double[2];  if (y == 0.0) { return 1.0; }  if (x != x) { /* X is NaN*/ return x; }   if (x == 0) { long bits = Double.doubleToRawLongBits(x); if ((bits & 0x8000000000000000L) != 0) { /* -zero*/ long yi = (long) y;  <BUGS> if (y < 0 && y == yi && (yi & 1) == 1) { <BUGE> return Double.NEGATIVE_INFINITY; }  if (y > 0 && y == yi && (yi & 1) == 1) { return -0.0; } }  if (y < 0) { return Double.POSITIVE_INFINITY;
*/ public static double pow(double x, double y) { final double lns[] = new double[2];  if (y == 0.0) { return 1.0; }  if (x != x) { /* X is NaN*/ return x; }   if (x == 0) { long bits = Double.doubleToRawLongBits(x); if ((bits & 0x8000000000000000L) != 0) { /* -zero*/ long yi = (long) y;  if (y < 0 && y == yi && (yi & 1) == 1) { return Double.NEGATIVE_INFINITY; }  <BUGS> if (y > 0 && y == yi && (yi & 1) == 1) { <BUGE> return -0.0; } }  if (y < 0) { return Double.POSITIVE_INFINITY;
*/ public static double pow(double x, double y) { final double lns[] = new double[2];  if (y == 0.0) { return 1.0; }  if (x != x) { /* X is NaN*/ return x; }   if (x == 0) { long bits = Double.doubleToRawLongBits(x); if ((bits & 0x8000000000000000L) != 0) { /* -zero*/ long yi = (long) y;  if (y < 0 && y == yi && (yi & 1) == 1) { return Double.NEGATIVE_INFINITY; }  if (y > 0 && y == yi && (yi & 1) == 1) { return -0.0; } }  <BUGS> if (y < 0) { <BUGE> return Double.POSITIVE_INFINITY;
* @return the value of the logarithm, i.e. the number {@code y} such that * <code>base<sup>y</sup> = x</code>. * @since 1.2 (previously in {@code MathUtils}, moved as of version 3.0) */ public static double log(double base, double x) { return log(x) / log(base); }  /** * Power function.  Compute x^y. * * @param x   a double * @param y   a double * @return double } <BUGS> if (y > 0) { return 0.0; <BUGE> }  return Double.NaN; }  if (x == Double.POSITIVE_INFINITY) { if (y != y) { /* y is NaN*/ return y; } if (y < 0.0) { return 0.0; } else { return Double.POSITIVE_INFINITY;
*/ public static double floor(double x) { long y;  <BUGS> if (x != x) { /* NaN <BUGE>*/ return x; }  if (x >= TWO_POWER_52 || x <= -TWO_POWER_52) { return x; }  y = (long) x; if (x < 0 && y != x) { y--; }  if (y == 0) { return x*y; }  return y; }
*/ public static double floor(double x) { long y;  if (x != x) { /* NaN*/ return x; }  <BUGS> if (x >= TWO_POWER_52 || x <= -TWO_POWER_52) { return x; <BUGE> }  y = (long) x; if (x < 0 && y != x) { y--; }  if (y == 0) { return x*y; }  return y; }
*/ public static double floor(double x) { long y;  if (x != x) { /* NaN*/ return x; }  if (x >= TWO_POWER_52 || x <= -TWO_POWER_52) { return x; }  <BUGS> y = (long) x; if (x < 0 && y != x) { <BUGE> y--; }  if (y == 0) { return x*y; }  return y; }
*/ public static double floor(double x) { long y;  if (x != x) { /* NaN*/ return x; }  if (x >= TWO_POWER_52 || x <= -TWO_POWER_52) { return x; }  y = (long) x; if (x < 0 && y != x) { y--; }  <BUGS> if (y == 0) { <BUGE> return x*y; }  return y; }
*/ public static double floor(double x) { long y;  if (x != x) { /* NaN*/ return x; }  if (x >= TWO_POWER_52 || x <= -TWO_POWER_52) { return x; }  y = (long) x; if (x < 0 && y != x) { y--; }  if (y == 0) { return x*y; }  <BUGS> return y; <BUGE> }
*/ public double[] toArray() { <BUGS> return new double[] { x, y, z }; <BUGE> }
<BUGS> <BUGE> /** Multiply this by x. * @param x multiplicand * @return product of this and x */ public Dfp multiply(final Dfp x) {  /* make sure we don't mix number with different precision*/ if (field.getRadixDigits() != x.field.getRadixDigits()) { field.setIEEEFlagsBits(DfpField.FLAG_INVALID); final Dfp result = newInstance(getZero()); result.nans = QNAN; return dotrap(DfpField.FLAG_INVALID, MULTIPLY_TRAP, x, result); }  Dfp result = newInstance(getZero());  /* handle special cases */ if (nans != FINITE || x.nans != FINITE) { if (isNaN()) { return this; }  if (x.isNaN()) { return x; }  if (nans == INFINITE && x.nans == FINITE && x.mant[mant.length-1] != 0) { result = newInstance(this); result.sign = (byte) (sign * x.sign); return result; }  if (x.nans == INFINITE && nans == FINITE && mant[mant.length-1] != 0) {
*/ public Dfp multiply(final Dfp x) {  <BUGS> /* make sure we don't mix number with different precision <BUGE>*/ if (field.getRadixDigits() != x.field.getRadixDigits()) { field.setIEEEFlagsBits(DfpField.FLAG_INVALID); final Dfp result = newInstance(getZero()); result.nans = QNAN; return dotrap(DfpField.FLAG_INVALID, MULTIPLY_TRAP, x, result); }  Dfp result = newInstance(getZero());  /* handle special cases */ if (nans != FINITE || x.nans != FINITE) { if (isNaN()) { return this; }  if (x.isNaN()) { return x; }  if (nans == INFINITE && x.nans == FINITE && x.mant[mant.length-1] != 0) { result = newInstance(this); result.sign = (byte) (sign * x.sign); return result; }  if (x.nans == INFINITE && nans == FINITE && mant[mant.length-1] != 0) {
*/ public Dfp multiply(final Dfp x) {  /* make sure we don't mix number with different precision*/ if (field.getRadixDigits() != x.field.getRadixDigits()) { field.setIEEEFlagsBits(DfpField.FLAG_INVALID); <BUGS> final Dfp result = newInstance(getZero()); result.nans = QNAN; return dotrap(DfpField.FLAG_INVALID, MULTIPLY_TRAP, x, result); <BUGE> }  Dfp result = newInstance(getZero());  /* handle special cases */ if (nans != FINITE || x.nans != FINITE) { if (isNaN()) { return this; }  if (x.isNaN()) { return x; }  if (nans == INFINITE && x.nans == FINITE && x.mant[mant.length-1] != 0) { result = newInstance(this); result.sign = (byte) (sign * x.sign); return result; }  if (x.nans == INFINITE && nans == FINITE && mant[mant.length-1] != 0) {
*/ public Dfp multiply(final Dfp x) {  /* make sure we don't mix number with different precision*/ if (field.getRadixDigits() != x.field.getRadixDigits()) { field.setIEEEFlagsBits(DfpField.FLAG_INVALID); final Dfp result = newInstance(getZero()); result.nans = QNAN; return dotrap(DfpField.FLAG_INVALID, MULTIPLY_TRAP, x, result); }  <BUGS> Dfp result = newInstance(getZero()); <BUGE> /* handle special cases */ if (nans != FINITE || x.nans != FINITE) { if (isNaN()) { return this; }  if (x.isNaN()) { return x; }  if (nans == INFINITE && x.nans == FINITE && x.mant[mant.length-1] != 0) { result = newInstance(this); result.sign = (byte) (sign * x.sign); return result; }  if (x.nans == INFINITE && nans == FINITE && mant[mant.length-1] != 0) {
*/ public Dfp multiply(final Dfp x) {  /* make sure we don't mix number with different precision*/ if (field.getRadixDigits() != x.field.getRadixDigits()) { field.setIEEEFlagsBits(DfpField.FLAG_INVALID); final Dfp result = newInstance(getZero()); result.nans = QNAN; return dotrap(DfpField.FLAG_INVALID, MULTIPLY_TRAP, x, result); }  Dfp result = newInstance(getZero());  /* handle special cases */ if (nans != FINITE || x.nans != FINITE) { <BUGS> if (isNaN()) { return this; } <BUGE> if (x.isNaN()) { return x; }  if (nans == INFINITE && x.nans == FINITE && x.mant[mant.length-1] != 0) { result = newInstance(this); result.sign = (byte) (sign * x.sign); return result; }  if (x.nans == INFINITE && nans == FINITE && mant[mant.length-1] != 0) {
*/ public Dfp multiply(final Dfp x) {  /* make sure we don't mix number with different precision*/ if (field.getRadixDigits() != x.field.getRadixDigits()) { field.setIEEEFlagsBits(DfpField.FLAG_INVALID); final Dfp result = newInstance(getZero()); result.nans = QNAN; return dotrap(DfpField.FLAG_INVALID, MULTIPLY_TRAP, x, result); }  Dfp result = newInstance(getZero());  /* handle special cases */ if (nans != FINITE || x.nans != FINITE) { if (isNaN()) { return this; }  if (x.isNaN()) { return x; <BUGS> }  if (nans == INFINITE && x.nans == FINITE && x.mant[mant.length-1] != 0) { result = newInstance(this); <BUGE> result.sign = (byte) (sign * x.sign); return result; }  if (x.nans == INFINITE && nans == FINITE && mant[mant.length-1] != 0) {
*/ public Dfp multiply(final Dfp x) {  /* make sure we don't mix number with different precision*/ if (field.getRadixDigits() != x.field.getRadixDigits()) { field.setIEEEFlagsBits(DfpField.FLAG_INVALID); final Dfp result = newInstance(getZero()); result.nans = QNAN; return dotrap(DfpField.FLAG_INVALID, MULTIPLY_TRAP, x, result); }  Dfp result = newInstance(getZero());  /* handle special cases */ if (nans != FINITE || x.nans != FINITE) { if (isNaN()) { return this; }  if (x.isNaN()) { return x; }  if (nans == INFINITE && x.nans == FINITE && x.mant[mant.length-1] != 0) { result = newInstance(this); result.sign = (byte) (sign * x.sign); return result; <BUGS> }  if (x.nans == INFINITE && nans == FINITE && mant[mant.length-1] != 0) {
if (n != 0) { /* Inexact*/ field.setIEEEFlagsBits(DfpField.FLAG_INEXACT); return DfpField.FLAG_INEXACT; }  return 0;  }  /** Multiply this by x. * @param x multiplicand * @return product of this and x return result; <BUGS> } <BUGE>  if (x.nans == INFINITE && nans == INFINITE) { result = newInstance(this); result.sign = (byte) (sign * x.sign); return result; }  if ( (x.nans == INFINITE && nans == FINITE && mant[mant.length-1] == 0) || (nans == INFINITE && x.nans == FINITE && x.mant[mant.length-1] == 0) ) { field.setIEEEFlagsBits(DfpField.FLAG_INVALID); result = newInstance(getZero()); result.nans = QNAN; result = dotrap(DfpField.FLAG_INVALID, MULTIPLY_TRAP, x, result); return result;
/* Inexact*/ field.setIEEEFlagsBits(DfpField.FLAG_INEXACT); return DfpField.FLAG_INEXACT; }  return 0;  }  /** Multiply this by x. * @param x multiplicand * @return product of this and x  <BUGS> if (x.nans == INFINITE && nans == INFINITE) { result = newInstance(this); result.sign = (byte) (sign * x.sign); return result; } <BUGE>  if ( (x.nans == INFINITE && nans == FINITE && mant[mant.length-1] == 0) || (nans == INFINITE && x.nans == FINITE && x.mant[mant.length-1] == 0) ) { field.setIEEEFlagsBits(DfpField.FLAG_INVALID); result = newInstance(getZero()); result.nans = QNAN; result = dotrap(DfpField.FLAG_INVALID, MULTIPLY_TRAP, x, result); return result; } }  int[] product = new int[mant.length*2];  /* Big enough to hold even the largest result*/
if (n != 0) { /* Inexact*/ field.setIEEEFlagsBits(DfpField.FLAG_INEXACT); return DfpField.FLAG_INEXACT; }  return 0;  }  /** Multiply this by x. * @param x multiplicand * @return product of this and x (nans == INFINITE && x.nans == FINITE && x.mant[mant.length-1] == 0) ) { <BUGS> field.setIEEEFlagsBits(DfpField.FLAG_INVALID); <BUGE> result = newInstance(getZero()); result.nans = QNAN; result = dotrap(DfpField.FLAG_INVALID, MULTIPLY_TRAP, x, result); return result; } }  int[] product = new int[mant.length*2];  /* Big enough to hold even the largest result*/  for (int i = 0; i < mant.length; i++) { int rh = 0;  /* acts as a carry*/ for (int j=0; j<mant.length; j++) { int r = mant[i] * x.mant[j];    /* multiply the 2 digits*/ r = r + product[i+j] + rh;  /* add to the product digit with carry in*/
/* Inexact*/ field.setIEEEFlagsBits(DfpField.FLAG_INEXACT); return DfpField.FLAG_INEXACT; }  return 0;  }  /** Multiply this by x. * @param x multiplicand * @return product of this and x result = newInstance(getZero()); <BUGS> result.nans = QNAN; result = dotrap(DfpField.FLAG_INVALID, MULTIPLY_TRAP, x, result); return result; } } <BUGE>  int[] product = new int[mant.length*2];  /* Big enough to hold even the largest result*/  for (int i = 0; i < mant.length; i++) { int rh = 0;  /* acts as a carry*/ for (int j=0; j<mant.length; j++) { int r = mant[i] * x.mant[j];    /* multiply the 2 digits*/ r = r + product[i+j] + rh;  /* add to the product digit with carry in*/  rh = r / RADIX; product[i+j] = r - rh * RADIX; }
if (n != 0) { /* Inexact*/ field.setIEEEFlagsBits(DfpField.FLAG_INEXACT); return DfpField.FLAG_INEXACT; }  return 0;  }  /** Multiply this by x. * @param x multiplicand * @return product of this and x  <BUGS> int[] product = new int[mant.length*2];  /* Big enough to hold even the largest result*/ <BUGE> for (int i = 0; i < mant.length; i++) { int rh = 0;  /* acts as a carry*/ for (int j=0; j<mant.length; j++) { int r = mant[i] * x.mant[j];    /* multiply the 2 digits*/ r = r + product[i+j] + rh;  /* add to the product digit with carry in*/  rh = r / RADIX; product[i+j] = r - rh * RADIX; } product[i+mant.length] = rh; }  /* Find the most sig digit*/
if (n != 0) { /* Inexact*/ field.setIEEEFlagsBits(DfpField.FLAG_INEXACT); return DfpField.FLAG_INEXACT; }  return 0;  }  /** Multiply this by x. * @param x multiplicand * @return product of this and x for (int i = 0; i < mant.length; i++) { <BUGS> int rh = 0;  /* acts as a carry <BUGE>*/ for (int j=0; j<mant.length; j++) { int r = mant[i] * x.mant[j];    /* multiply the 2 digits*/ r = r + product[i+j] + rh;  /* add to the product digit with carry in*/  rh = r / RADIX; product[i+j] = r - rh * RADIX; } product[i+mant.length] = rh; }  /* Find the most sig digit*/ int md = mant.length * 2 - 1;  /* default, in case result is zero*/ for (int i = mant.length * 2 - 1; i >= 0; i--) { if (product[i] != 0) {
/* Inexact*/ field.setIEEEFlagsBits(DfpField.FLAG_INEXACT); return DfpField.FLAG_INEXACT; }  return 0;  }  /** Multiply this by x. * @param x multiplicand * @return product of this and x r = r + product[i+j] + rh;  /* add to the product digit with carry in*/ <BUGS> rh = r / RADIX; product[i+j] = r - rh * RADIX; } product[i+mant.length] = rh; <BUGE> }  /* Find the most sig digit*/ int md = mant.length * 2 - 1;  /* default, in case result is zero*/ for (int i = mant.length * 2 - 1; i >= 0; i--) { if (product[i] != 0) { md = i; break; } }  /* Copy the digits into the result*/
if (n != 0) { /* Inexact*/ field.setIEEEFlagsBits(DfpField.FLAG_INEXACT); return DfpField.FLAG_INEXACT; }  return 0;  }  /** Multiply this by x. * @param x multiplicand * @return product of this and x int md = mant.length * 2 - 1;  /* default, in case result is zero*/ <BUGS> for (int i = mant.length * 2 - 1; i >= 0; i--) { if (product[i] != 0) { <BUGE> md = i; break; } }  /* Copy the digits into the result*/ for (int i = 0; i < mant.length; i++) { result.mant[mant.length - i - 1] = product[md - i]; }  /* Fixup the exponent.*/ result.exp = exp + x.exp + md - 2 * mant.length + 1; result.sign = (byte)((sign == x.sign)?1:-1);
if (n != 0) { /* Inexact*/ field.setIEEEFlagsBits(DfpField.FLAG_INEXACT); return DfpField.FLAG_INEXACT; }  return 0;  }  /** Multiply this by x. * @param x multiplicand * @return product of this and x } <BUGS> } <BUGE> /* Copy the digits into the result*/ for (int i = 0; i < mant.length; i++) { result.mant[mant.length - i - 1] = product[md - i]; }  /* Fixup the exponent.*/ result.exp = exp + x.exp + md - 2 * mant.length + 1; result.sign = (byte)((sign == x.sign)?1:-1);  if (result.mant[mant.length-1] == 0) { /* if result is zero, set exp to zero*/ result.exp = 0; }
if (n != 0) { /* Inexact*/ field.setIEEEFlagsBits(DfpField.FLAG_INEXACT); return DfpField.FLAG_INEXACT; }  return 0;  }  /** Multiply this by x. * @param x multiplicand * @return product of this and x /* Copy the digits into the result*/ <BUGS> for (int i = 0; i < mant.length; i++) { <BUGE> result.mant[mant.length - i - 1] = product[md - i]; }  /* Fixup the exponent.*/ result.exp = exp + x.exp + md - 2 * mant.length + 1; result.sign = (byte)((sign == x.sign)?1:-1);  if (result.mant[mant.length-1] == 0) { /* if result is zero, set exp to zero*/ result.exp = 0; }  final int excp; if (md > (mant.length-1)) {
if (n != 0) { /* Inexact*/ field.setIEEEFlagsBits(DfpField.FLAG_INEXACT); return DfpField.FLAG_INEXACT; }  return 0;  }  /** Multiply this by x. * @param x multiplicand * @return product of this and x result.mant[mant.length - i - 1] = product[md - i]; <BUGS> } <BUGE>  /* Fixup the exponent.*/ result.exp = exp + x.exp + md - 2 * mant.length + 1; result.sign = (byte)((sign == x.sign)?1:-1);  if (result.mant[mant.length-1] == 0) { /* if result is zero, set exp to zero*/ result.exp = 0; }  final int excp; if (md > (mant.length-1)) { excp = result.round(product[md-mant.length]); } else {
if (n != 0) { /* Inexact*/ field.setIEEEFlagsBits(DfpField.FLAG_INEXACT); return DfpField.FLAG_INEXACT; }  return 0;  }  /** Multiply this by x. * @param x multiplicand * @return product of this and x result.exp = exp + x.exp + md - 2 * mant.length + 1; <BUGS> result.sign = (byte)((sign == x.sign)?1:-1); <BUGE> if (result.mant[mant.length-1] == 0) { /* if result is zero, set exp to zero*/ result.exp = 0; }  final int excp; if (md > (mant.length-1)) { excp = result.round(product[md-mant.length]); } else { excp = result.round(0); /* has no effect except to check status*/ }  if (excp != 0) {
if (n != 0) { /* Inexact*/ field.setIEEEFlagsBits(DfpField.FLAG_INEXACT); return DfpField.FLAG_INEXACT; }  return 0;  }  /** Multiply this by x. * @param x multiplicand * @return product of this and x } <BUGS> final int excp; <BUGE> if (md > (mant.length-1)) { excp = result.round(product[md-mant.length]); } else { excp = result.round(0); /* has no effect except to check status*/ }  if (excp != 0) { result = dotrap(excp, MULTIPLY_TRAP, x, result); }  return result;  }
if (n != 0) { /* Inexact*/ field.setIEEEFlagsBits(DfpField.FLAG_INEXACT); return DfpField.FLAG_INEXACT; }  return 0;  }  /** Multiply this by x. * @param x multiplicand * @return product of this and x excp = result.round(product[md-mant.length]); <BUGS> } else { <BUGE> excp = result.round(0); /* has no effect except to check status*/ }  if (excp != 0) { result = dotrap(excp, MULTIPLY_TRAP, x, result); }  return result;  }  /** Multiply this by a single digit x. * @param x multiplicand * @return product of this and x
*/ public SubLine(final Vector2D start, final Vector2D end) { <BUGS> super(new Line(start, end), buildIntervalSet(start, end)); } <BUGE>
*/ public Partial(DateTimeFieldType[] types, int[] values, Chronology chronology) { <BUGS> super(); chronology = DateTimeUtils.getChronology(chronology).withUTC(); iChronology = chronology; if (types == null) { <BUGE> throw new IllegalArgumentException("Types array must not be null"); } if (values == null) { throw new IllegalArgumentException("Values array must not be null"); } if (values.length != types.length) { throw new IllegalArgumentException("Values array must be the same length as the types array"); } if (types.length == 0) { iTypes = types; iValues = values; return; } for (int i = 0; i < types.length; i++) { if (types[i] == null) { throw new IllegalArgumentException("Types array must not contain null: index " + i); } } DurationField lastUnitField = null; for (int i = 0; i < types.length; i++) { DateTimeFieldType loopType = types[i]; DurationField loopUnitField = loopType.getDurationType().getField(iChronology); if (i > 0) { int compare = lastUnitField.compareTo(loopUnitField);
*/ public Partial(DateTimeFieldType[] types, int[] values, Chronology chronology) { super(); chronology = DateTimeUtils.getChronology(chronology).withUTC(); iChronology = chronology; if (types == null) { throw new IllegalArgumentException("Types array must not be null"); } <BUGS> if (values == null) { <BUGE> throw new IllegalArgumentException("Values array must not be null"); } if (values.length != types.length) { throw new IllegalArgumentException("Values array must be the same length as the types array"); } if (types.length == 0) { iTypes = types; iValues = values; return; } for (int i = 0; i < types.length; i++) { if (types[i] == null) { throw new IllegalArgumentException("Types array must not contain null: index " + i); } } DurationField lastUnitField = null; for (int i = 0; i < types.length; i++) { DateTimeFieldType loopType = types[i]; DurationField loopUnitField = loopType.getDurationType().getField(iChronology); if (i > 0) { int compare = lastUnitField.compareTo(loopUnitField);
*/ public Partial(DateTimeFieldType[] types, int[] values, Chronology chronology) { super(); chronology = DateTimeUtils.getChronology(chronology).withUTC(); iChronology = chronology; if (types == null) { throw new IllegalArgumentException("Types array must not be null"); } if (values == null) { throw new IllegalArgumentException("Values array must not be null"); } <BUGS> if (values.length != types.length) { <BUGE> throw new IllegalArgumentException("Values array must be the same length as the types array"); } if (types.length == 0) { iTypes = types; iValues = values; return; } for (int i = 0; i < types.length; i++) { if (types[i] == null) { throw new IllegalArgumentException("Types array must not contain null: index " + i); } } DurationField lastUnitField = null; for (int i = 0; i < types.length; i++) { DateTimeFieldType loopType = types[i]; DurationField loopUnitField = loopType.getDurationType().getField(iChronology); if (i > 0) { int compare = lastUnitField.compareTo(loopUnitField);
*/ public Partial(DateTimeFieldType[] types, int[] values, Chronology chronology) { super(); chronology = DateTimeUtils.getChronology(chronology).withUTC(); iChronology = chronology; if (types == null) { throw new IllegalArgumentException("Types array must not be null"); } if (values == null) { throw new IllegalArgumentException("Values array must not be null"); } if (values.length != types.length) { throw new IllegalArgumentException("Values array must be the same length as the types array"); } <BUGS> if (types.length == 0) { <BUGE> iTypes = types; iValues = values; return; } for (int i = 0; i < types.length; i++) { if (types[i] == null) { throw new IllegalArgumentException("Types array must not contain null: index " + i); } } DurationField lastUnitField = null; for (int i = 0; i < types.length; i++) { DateTimeFieldType loopType = types[i]; DurationField loopUnitField = loopType.getDurationType().getField(iChronology); if (i > 0) { int compare = lastUnitField.compareTo(loopUnitField);
*/ public Partial(DateTimeFieldType[] types, int[] values, Chronology chronology) { super(); chronology = DateTimeUtils.getChronology(chronology).withUTC(); iChronology = chronology; if (types == null) { throw new IllegalArgumentException("Types array must not be null"); } if (values == null) { throw new IllegalArgumentException("Values array must not be null"); } if (values.length != types.length) { throw new IllegalArgumentException("Values array must be the same length as the types array"); } if (types.length == 0) { iTypes = types; iValues = values; return; } <BUGS> for (int i = 0; i < types.length; i++) { if (types[i] == null) { <BUGE> throw new IllegalArgumentException("Types array must not contain null: index " + i); } } DurationField lastUnitField = null; for (int i = 0; i < types.length; i++) { DateTimeFieldType loopType = types[i]; DurationField loopUnitField = loopType.getDurationType().getField(iChronology); if (i > 0) { int compare = lastUnitField.compareTo(loopUnitField);
/** * Constructs a Partial with the specified fields and values. * The fields must be specified in the order largest to smallest. * <p> * The constructor uses the specified chronology. * * @param types  the types to create the partial from, not null * @param values  the values to store, not null * @param chronology  the chronology, null means ISO * @throws IllegalArgumentException if the types or values are invalid } <BUGS> DurationField lastUnitField = null; for (int i = 0; i < types.length; i++) { DateTimeFieldType loopType = types[i]; DurationField loopUnitField = loopType.getDurationType().getField(iChronology); if (i > 0) { int compare = lastUnitField.compareTo(loopUnitField); if (compare < 0) { throw new IllegalArgumentException("Types array must be in order largest-smallest: " + <BUGE> types[i - 1].getName() + " < " + loopType.getName()); } else if (compare == 0) { if (types[i - 1].getRangeDurationType() == null) { if (loopType.getRangeDurationType() == null) { throw new IllegalArgumentException("Types array must not contain duplicate: " + types[i - 1].getName() + " and " + loopType.getName()); } } else { if (loopType.getRangeDurationType() == null) { throw new IllegalArgumentException("Types array must be in order largest-smallest: " +
public Partial(DateTimeFieldType[] types, int[] values) { this(types, values, null); }  /** * Constructs a Partial with the specified fields and values. * The fields must be specified in the order largest to smallest. * <p> * The constructor uses the specified chronology. * * @param types  the types to create the partial from, not null * @param values  the values to store, not null * @param chronology  the chronology, null means ISO * @throws IllegalArgumentException if the types or values are invalid types[i - 1].getName() + " < " + loopType.getName()); <BUGS> } else if (compare == 0) { <BUGE> if (types[i - 1].getRangeDurationType() == null) { if (loopType.getRangeDurationType() == null) { throw new IllegalArgumentException("Types array must not contain duplicate: " + types[i - 1].getName() + " and " + loopType.getName()); } } else { if (loopType.getRangeDurationType() == null) { throw new IllegalArgumentException("Types array must be in order largest-smallest: " + types[i - 1].getName() + " < " + loopType.getName()); } DurationField lastRangeField = types[i - 1].getRangeDurationType().getField(iChronology); DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology); if (lastRangeField.compareTo(loopRangeField) < 0) { throw new IllegalArgumentException("Types array must be in order largest-smallest: " +
public Partial(DateTimeFieldType[] types, int[] values) { this(types, values, null); }  /** * Constructs a Partial with the specified fields and values. * The fields must be specified in the order largest to smallest. * <p> * The constructor uses the specified chronology. * * @param types  the types to create the partial from, not null * @param values  the values to store, not null * @param chronology  the chronology, null means ISO * @throws IllegalArgumentException if the types or values are invalid } <BUGS> lastUnitField = loopUnitField; <BUGE> }  iTypes = (DateTimeFieldType[]) types.clone(); chronology.validate(this, values); iValues = (int[]) values.clone(); }  /** * Constructs a Partial by copying all the fields and types from * another partial. * <p> * This is most useful when copying from a YearMonthDay or TimeOfDay. */ public Partial(ReadablePartial partial) {
this(types, values, null); }  /** * Constructs a Partial with the specified fields and values. * The fields must be specified in the order largest to smallest. * <p> * The constructor uses the specified chronology. * * @param types  the types to create the partial from, not null * @param values  the values to store, not null * @param chronology  the chronology, null means ISO * @throws IllegalArgumentException if the types or values are invalid  <BUGS> iTypes = (DateTimeFieldType[]) types.clone(); chronology.validate(this, values); iValues = (int[]) values.clone(); } <BUGE>  /** * Constructs a Partial by copying all the fields and types from * another partial. * <p> * This is most useful when copying from a YearMonthDay or TimeOfDay. */ public Partial(ReadablePartial partial) { super(); if (partial == null) { throw new IllegalArgumentException("The partial must not be null"); }
*/ public Partial(DateTimeFieldType[] types, int[] values, Chronology chronology) { <BUGS> super(); chronology = DateTimeUtils.getChronology(chronology).withUTC(); iChronology = chronology; if (types == null) { <BUGE> throw new IllegalArgumentException("Types array must not be null"); } if (values == null) { throw new IllegalArgumentException("Values array must not be null"); } if (values.length != types.length) { throw new IllegalArgumentException("Values array must be the same length as the types array"); } if (types.length == 0) { iTypes = types; iValues = values; return; } for (int i = 0; i < types.length; i++) { if (types[i] == null) { throw new IllegalArgumentException("Types array must not contain null: index " + i); } } DurationField lastUnitField = null; for (int i = 0; i < types.length; i++) { DateTimeFieldType loopType = types[i]; DurationField loopUnitField = loopType.getDurationType().getField(iChronology); if (i > 0) { int compare = lastUnitField.compareTo(loopUnitField);
*/ public Partial(DateTimeFieldType[] types, int[] values, Chronology chronology) { super(); chronology = DateTimeUtils.getChronology(chronology).withUTC(); iChronology = chronology; if (types == null) { throw new IllegalArgumentException("Types array must not be null"); } <BUGS> if (values == null) { <BUGE> throw new IllegalArgumentException("Values array must not be null"); } if (values.length != types.length) { throw new IllegalArgumentException("Values array must be the same length as the types array"); } if (types.length == 0) { iTypes = types; iValues = values; return; } for (int i = 0; i < types.length; i++) { if (types[i] == null) { throw new IllegalArgumentException("Types array must not contain null: index " + i); } } DurationField lastUnitField = null; for (int i = 0; i < types.length; i++) { DateTimeFieldType loopType = types[i]; DurationField loopUnitField = loopType.getDurationType().getField(iChronology); if (i > 0) { int compare = lastUnitField.compareTo(loopUnitField);
*/ public Partial(DateTimeFieldType[] types, int[] values, Chronology chronology) { super(); chronology = DateTimeUtils.getChronology(chronology).withUTC(); iChronology = chronology; if (types == null) { throw new IllegalArgumentException("Types array must not be null"); } if (values == null) { throw new IllegalArgumentException("Values array must not be null"); } <BUGS> if (values.length != types.length) { <BUGE> throw new IllegalArgumentException("Values array must be the same length as the types array"); } if (types.length == 0) { iTypes = types; iValues = values; return; } for (int i = 0; i < types.length; i++) { if (types[i] == null) { throw new IllegalArgumentException("Types array must not contain null: index " + i); } } DurationField lastUnitField = null; for (int i = 0; i < types.length; i++) { DateTimeFieldType loopType = types[i]; DurationField loopUnitField = loopType.getDurationType().getField(iChronology); if (i > 0) { int compare = lastUnitField.compareTo(loopUnitField);
*/ public Partial(DateTimeFieldType[] types, int[] values, Chronology chronology) { super(); chronology = DateTimeUtils.getChronology(chronology).withUTC(); iChronology = chronology; if (types == null) { throw new IllegalArgumentException("Types array must not be null"); } if (values == null) { throw new IllegalArgumentException("Values array must not be null"); } if (values.length != types.length) { throw new IllegalArgumentException("Values array must be the same length as the types array"); } <BUGS> if (types.length == 0) { <BUGE> iTypes = types; iValues = values; return; } for (int i = 0; i < types.length; i++) { if (types[i] == null) { throw new IllegalArgumentException("Types array must not contain null: index " + i); } } DurationField lastUnitField = null; for (int i = 0; i < types.length; i++) { DateTimeFieldType loopType = types[i]; DurationField loopUnitField = loopType.getDurationType().getField(iChronology); if (i > 0) { int compare = lastUnitField.compareTo(loopUnitField);
*/ public Partial(DateTimeFieldType[] types, int[] values, Chronology chronology) { super(); chronology = DateTimeUtils.getChronology(chronology).withUTC(); iChronology = chronology; if (types == null) { throw new IllegalArgumentException("Types array must not be null"); } if (values == null) { throw new IllegalArgumentException("Values array must not be null"); } if (values.length != types.length) { throw new IllegalArgumentException("Values array must be the same length as the types array"); } if (types.length == 0) { iTypes = types; iValues = values; return; } <BUGS> for (int i = 0; i < types.length; i++) { if (types[i] == null) { <BUGE> throw new IllegalArgumentException("Types array must not contain null: index " + i); } } DurationField lastUnitField = null; for (int i = 0; i < types.length; i++) { DateTimeFieldType loopType = types[i]; DurationField loopUnitField = loopType.getDurationType().getField(iChronology); if (i > 0) { int compare = lastUnitField.compareTo(loopUnitField);
*/ public Partial(DateTimeFieldType[] types, int[] values, Chronology chronology) { super(); chronology = DateTimeUtils.getChronology(chronology).withUTC(); iChronology = chronology; if (types == null) { throw new IllegalArgumentException("Types array must not be null"); } if (values == null) { throw new IllegalArgumentException("Values array must not be null"); } if (values.length != types.length) { throw new IllegalArgumentException("Values array must be the same length as the types array"); } if (types.length == 0) { iTypes = types; iValues = values; return; } for (int i = 0; i < types.length; i++) { if (types[i] == null) { throw new IllegalArgumentException("Types array must not contain null: index " + i); } } <BUGS> DurationField lastUnitField = null; for (int i = 0; i < types.length; i++) { DateTimeFieldType loopType = types[i]; DurationField loopUnitField = loopType.getDurationType().getField(iChronology); if (i > 0) { int compare = lastUnitField.compareTo(loopUnitField);
this(types, values, null); }  /** * Constructs a Partial with the specified fields and values. * The fields must be specified in the order largest to smallest. * <p> * The constructor uses the specified chronology. * * @param types  the types to create the partial from, not null * @param values  the values to store, not null * @param chronology  the chronology, null means ISO * @throws IllegalArgumentException if the types or values are invalid types[i - 1].getName() + " < " + loopType.getName()); <BUGS> } else if (compare == 0) { if (types[i - 1].getRangeDurationType() == null) { if (loopType.getRangeDurationType() == null) { throw new IllegalArgumentException("Types array must not contain duplicate: " + <BUGE> types[i - 1].getName() + " and " + loopType.getName()); } } else { if (loopType.getRangeDurationType() == null) { throw new IllegalArgumentException("Types array must be in order largest-smallest: " + types[i - 1].getName() + " < " + loopType.getName()); } DurationField lastRangeField = types[i - 1].getRangeDurationType().getField(iChronology); DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology); if (lastRangeField.compareTo(loopRangeField) < 0) { throw new IllegalArgumentException("Types array must be in order largest-smallest: " + types[i - 1].getName() + " < " + loopType.getName());
public Partial(DateTimeFieldType[] types, int[] values) { this(types, values, null); }  /** * Constructs a Partial with the specified fields and values. * The fields must be specified in the order largest to smallest. * <p> * The constructor uses the specified chronology. * * @param types  the types to create the partial from, not null * @param values  the values to store, not null * @param chronology  the chronology, null means ISO * @throws IllegalArgumentException if the types or values are invalid } <BUGS> lastUnitField = loopUnitField; <BUGE> }  iTypes = (DateTimeFieldType[]) types.clone(); chronology.validate(this, values); iValues = (int[]) values.clone(); }  /** * Constructs a Partial by copying all the fields and types from * another partial. * <p> * This is most useful when copying from a YearMonthDay or TimeOfDay. */ public Partial(ReadablePartial partial) {
*/ public void addHours(final int hours) { <BUGS> setMillis(getChronology().hours().add(getMillis(), hours)); } <BUGE>
*/ public int getMinimumValue() { <BUGS> return 1; <BUGE> }
*/ public static final PeriodType getPeriodType(PeriodType type) { <BUGS> if (type == null) { return PeriodType.standard(); <BUGE> } return type; }
*/ public static final PeriodType getPeriodType(PeriodType type) { if (type == null) { return PeriodType.standard(); } <BUGS> return type; <BUGE> }
public long add(long instant, int value) { <BUGS> if (instant >= iCutover) { instant = iGregorianField.add(instant, value); if (instant < iCutover) { <BUGE> /* Only adjust if gap fully crossed.*/ if (instant + iGapDuration < iCutover) { instant = gregorianToJulian(instant); } } } else { instant = iJulianField.add(instant, value); if (instant >= iCutover) { /* Only adjust if gap fully crossed.*/ if (instant - iGapDuration >= iCutover) { /* no special handling for year zero as cutover always after year zero*/ instant = julianToGregorian(instant); } } } return instant; }
public long add(long instant, int value) { if (instant >= iCutover) { instant = iGregorianField.add(instant, value); if (instant < iCutover) { /* Only adjust if gap fully crossed.*/ <BUGS> if (instant + iGapDuration < iCutover) { instant = gregorianToJulian(instant); <BUGE> } } } else { instant = iJulianField.add(instant, value); if (instant >= iCutover) { /* Only adjust if gap fully crossed.*/ if (instant - iGapDuration >= iCutover) { /* no special handling for year zero as cutover always after year zero*/ instant = julianToGregorian(instant); } } } return instant; }
public long add(long instant, int value) { if (instant >= iCutover) { instant = iGregorianField.add(instant, value); if (instant < iCutover) { /* Only adjust if gap fully crossed.*/ if (instant + iGapDuration < iCutover) { instant = gregorianToJulian(instant); } } } else { instant = iJulianField.add(instant, value); if (instant >= iCutover) { /* Only adjust if gap fully crossed.*/ if (instant - iGapDuration >= iCutover) { /* no special handling for year zero as cutover always after year zero*/ instant = julianToGregorian(instant); } } } <BUGS> return instant; <BUGE> }
public long add(long instant, int value) { if (instant >= iCutover) { instant = iGregorianField.add(instant, value); if (instant < iCutover) { /* Only adjust if gap fully crossed.*/ if (instant + iGapDuration < iCutover) { instant = gregorianToJulian(instant); } } } else { instant = iJulianField.add(instant, value); if (instant >= iCutover) { /* Only adjust if gap fully crossed.*/ if (instant - iGapDuration >= iCutover) { /* no special handling for year zero as cutover always after year zero*/ instant = julianToGregorian(instant); } } } return instant; }
*/ public void prependMessage(String message) { <BUGS> if (iMessage == null) { <BUGE> iMessage = message; } else if (message != null) { iMessage = message + ": " + iMessage; } }
*/ public void prependMessage(String message) { if (iMessage == null) { iMessage = message; <BUGS> } else if (message != null) { iMessage = message + ": " + iMessage; <BUGE> } }
*/ public void prependMessage(String message) { if (iMessage == null) { iMessage = message; } else if (message != null) { iMessage = message + ": " + iMessage; } <BUGS> } <BUGE>
*/ public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException { <BUGS> if (hoursOffset == 0 && minutesOffset == 0) { return DateTimeZone.UTC; <BUGE> } if (hoursOffset < -23 || hoursOffset > 23) { throw new IllegalArgumentException("Hours out of range: " + hoursOffset); } if (minutesOffset < 0 || minutesOffset > 59) { throw new IllegalArgumentException("Minutes out of range: " + minutesOffset); } int offset = 0; try { int hoursInMinutes = hoursOffset * 60; if (hoursInMinutes < 0) { minutesOffset = hoursInMinutes - minutesOffset; } else { minutesOffset = hoursInMinutes + minutesOffset; } offset = FieldUtils.safeMultiply(minutesOffset, DateTimeConstants.MILLIS_PER_MINUTE); } catch (ArithmeticException ex) { throw new IllegalArgumentException("Offset is too large"); } return forOffsetMillis(offset); }
*/ public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException { if (hoursOffset == 0 && minutesOffset == 0) { return DateTimeZone.UTC; } <BUGS> if (hoursOffset < -23 || hoursOffset > 23) { <BUGE> throw new IllegalArgumentException("Hours out of range: " + hoursOffset); } if (minutesOffset < 0 || minutesOffset > 59) { throw new IllegalArgumentException("Minutes out of range: " + minutesOffset); } int offset = 0; try { int hoursInMinutes = hoursOffset * 60; if (hoursInMinutes < 0) { minutesOffset = hoursInMinutes - minutesOffset; } else { minutesOffset = hoursInMinutes + minutesOffset; } offset = FieldUtils.safeMultiply(minutesOffset, DateTimeConstants.MILLIS_PER_MINUTE); } catch (ArithmeticException ex) { throw new IllegalArgumentException("Offset is too large"); } return forOffsetMillis(offset); }
*/ public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException { if (hoursOffset == 0 && minutesOffset == 0) { return DateTimeZone.UTC; } if (hoursOffset < -23 || hoursOffset > 23) { throw new IllegalArgumentException("Hours out of range: " + hoursOffset); } <BUGS> if (minutesOffset < 0 || minutesOffset > 59) { throw new IllegalArgumentException("Minutes out of range: " + minutesOffset); <BUGE> } int offset = 0; try { int hoursInMinutes = hoursOffset * 60; if (hoursInMinutes < 0) { minutesOffset = hoursInMinutes - minutesOffset; } else { minutesOffset = hoursInMinutes + minutesOffset; } offset = FieldUtils.safeMultiply(minutesOffset, DateTimeConstants.MILLIS_PER_MINUTE); } catch (ArithmeticException ex) { throw new IllegalArgumentException("Offset is too large"); } return forOffsetMillis(offset); }
*/ public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException { if (hoursOffset == 0 && minutesOffset == 0) { return DateTimeZone.UTC; } if (hoursOffset < -23 || hoursOffset > 23) { throw new IllegalArgumentException("Hours out of range: " + hoursOffset); } if (minutesOffset < 0 || minutesOffset > 59) { throw new IllegalArgumentException("Minutes out of range: " + minutesOffset); } <BUGS> int offset = 0; <BUGE> try { int hoursInMinutes = hoursOffset * 60; if (hoursInMinutes < 0) { minutesOffset = hoursInMinutes - minutesOffset; } else { minutesOffset = hoursInMinutes + minutesOffset; } offset = FieldUtils.safeMultiply(minutesOffset, DateTimeConstants.MILLIS_PER_MINUTE); } catch (ArithmeticException ex) { throw new IllegalArgumentException("Offset is too large"); } return forOffsetMillis(offset); }
*/ public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException { if (hoursOffset == 0 && minutesOffset == 0) { return DateTimeZone.UTC; } if (hoursOffset < -23 || hoursOffset > 23) { throw new IllegalArgumentException("Hours out of range: " + hoursOffset); } if (minutesOffset < 0 || minutesOffset > 59) { throw new IllegalArgumentException("Minutes out of range: " + minutesOffset); } int offset = 0; try { <BUGS> int hoursInMinutes = hoursOffset * 60; if (hoursInMinutes < 0) { <BUGE> minutesOffset = hoursInMinutes - minutesOffset; } else { minutesOffset = hoursInMinutes + minutesOffset; } offset = FieldUtils.safeMultiply(minutesOffset, DateTimeConstants.MILLIS_PER_MINUTE); } catch (ArithmeticException ex) { throw new IllegalArgumentException("Offset is too large"); } return forOffsetMillis(offset); }
*/ public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException { if (hoursOffset == 0 && minutesOffset == 0) { return DateTimeZone.UTC; } if (hoursOffset < -23 || hoursOffset > 23) { throw new IllegalArgumentException("Hours out of range: " + hoursOffset); } if (minutesOffset < 0 || minutesOffset > 59) { throw new IllegalArgumentException("Minutes out of range: " + minutesOffset); } int offset = 0; try { int hoursInMinutes = hoursOffset * 60; if (hoursInMinutes < 0) { minutesOffset = hoursInMinutes - minutesOffset; } else { <BUGS> minutesOffset = hoursInMinutes + minutesOffset; <BUGE> } offset = FieldUtils.safeMultiply(minutesOffset, DateTimeConstants.MILLIS_PER_MINUTE); } catch (ArithmeticException ex) { throw new IllegalArgumentException("Offset is too large"); } return forOffsetMillis(offset); }
*/ public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException { if (hoursOffset == 0 && minutesOffset == 0) { return DateTimeZone.UTC; } if (hoursOffset < -23 || hoursOffset > 23) { throw new IllegalArgumentException("Hours out of range: " + hoursOffset); } if (minutesOffset < 0 || minutesOffset > 59) { throw new IllegalArgumentException("Minutes out of range: " + minutesOffset); } int offset = 0; try { int hoursInMinutes = hoursOffset * 60; if (hoursInMinutes < 0) { minutesOffset = hoursInMinutes - minutesOffset; } else { minutesOffset = hoursInMinutes + minutesOffset; } <BUGS> offset = FieldUtils.safeMultiply(minutesOffset, DateTimeConstants.MILLIS_PER_MINUTE); <BUGE> } catch (ArithmeticException ex) { throw new IllegalArgumentException("Offset is too large"); } return forOffsetMillis(offset); }
*/ public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException { if (hoursOffset == 0 && minutesOffset == 0) { return DateTimeZone.UTC; } if (hoursOffset < -23 || hoursOffset > 23) { throw new IllegalArgumentException("Hours out of range: " + hoursOffset); } if (minutesOffset < 0 || minutesOffset > 59) { throw new IllegalArgumentException("Minutes out of range: " + minutesOffset); } int offset = 0; try { int hoursInMinutes = hoursOffset * 60; if (hoursInMinutes < 0) { minutesOffset = hoursInMinutes - minutesOffset; } else { minutesOffset = hoursInMinutes + minutesOffset; } offset = FieldUtils.safeMultiply(minutesOffset, DateTimeConstants.MILLIS_PER_MINUTE); } catch (ArithmeticException ex) { throw new IllegalArgumentException("Offset is too large"); <BUGS> } return forOffsetMillis(offset); <BUGE> }
*/ public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException { <BUGS> if (hoursOffset == 0 && minutesOffset == 0) { return DateTimeZone.UTC; <BUGE> } if (minutesOffset < 0 || minutesOffset > 59) { throw new IllegalArgumentException("Minutes out of range: " + minutesOffset); } int offset = 0; try { int hoursInMinutes = FieldUtils.safeMultiply(hoursOffset, 60); if (hoursInMinutes < 0) { minutesOffset = FieldUtils.safeAdd(hoursInMinutes, -minutesOffset); } else { minutesOffset = FieldUtils.safeAdd(hoursInMinutes, minutesOffset); } offset = FieldUtils.safeMultiply(minutesOffset, DateTimeConstants.MILLIS_PER_MINUTE); } catch (ArithmeticException ex) { throw new IllegalArgumentException("Offset is too large"); } return forOffsetMillis(offset); }
*/ public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException { if (hoursOffset == 0 && minutesOffset == 0) { return DateTimeZone.UTC; } <BUGS> if (minutesOffset < 0 || minutesOffset > 59) { throw new IllegalArgumentException("Minutes out of range: " + minutesOffset); <BUGE> } int offset = 0; try { int hoursInMinutes = FieldUtils.safeMultiply(hoursOffset, 60); if (hoursInMinutes < 0) { minutesOffset = FieldUtils.safeAdd(hoursInMinutes, -minutesOffset); } else { minutesOffset = FieldUtils.safeAdd(hoursInMinutes, minutesOffset); } offset = FieldUtils.safeMultiply(minutesOffset, DateTimeConstants.MILLIS_PER_MINUTE); } catch (ArithmeticException ex) { throw new IllegalArgumentException("Offset is too large"); } return forOffsetMillis(offset); }
*/ public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException { if (hoursOffset == 0 && minutesOffset == 0) { return DateTimeZone.UTC; } if (minutesOffset < 0 || minutesOffset > 59) { throw new IllegalArgumentException("Minutes out of range: " + minutesOffset); } <BUGS> int offset = 0; <BUGE> try { int hoursInMinutes = FieldUtils.safeMultiply(hoursOffset, 60); if (hoursInMinutes < 0) { minutesOffset = FieldUtils.safeAdd(hoursInMinutes, -minutesOffset); } else { minutesOffset = FieldUtils.safeAdd(hoursInMinutes, minutesOffset); } offset = FieldUtils.safeMultiply(minutesOffset, DateTimeConstants.MILLIS_PER_MINUTE); } catch (ArithmeticException ex) { throw new IllegalArgumentException("Offset is too large"); } return forOffsetMillis(offset); }
*/ public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException { if (hoursOffset == 0 && minutesOffset == 0) { return DateTimeZone.UTC; } if (minutesOffset < 0 || minutesOffset > 59) { throw new IllegalArgumentException("Minutes out of range: " + minutesOffset); } int offset = 0; try { <BUGS> int hoursInMinutes = FieldUtils.safeMultiply(hoursOffset, 60); if (hoursInMinutes < 0) { minutesOffset = FieldUtils.safeAdd(hoursInMinutes, -minutesOffset); <BUGE> } else { minutesOffset = FieldUtils.safeAdd(hoursInMinutes, minutesOffset); } offset = FieldUtils.safeMultiply(minutesOffset, DateTimeConstants.MILLIS_PER_MINUTE); } catch (ArithmeticException ex) { throw new IllegalArgumentException("Offset is too large"); } return forOffsetMillis(offset); }
*/ public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException { if (hoursOffset == 0 && minutesOffset == 0) { return DateTimeZone.UTC; } if (minutesOffset < 0 || minutesOffset > 59) { throw new IllegalArgumentException("Minutes out of range: " + minutesOffset); } int offset = 0; try { int hoursInMinutes = FieldUtils.safeMultiply(hoursOffset, 60); if (hoursInMinutes < 0) { minutesOffset = FieldUtils.safeAdd(hoursInMinutes, -minutesOffset); } else { <BUGS> minutesOffset = FieldUtils.safeAdd(hoursInMinutes, minutesOffset); <BUGE> } offset = FieldUtils.safeMultiply(minutesOffset, DateTimeConstants.MILLIS_PER_MINUTE); } catch (ArithmeticException ex) { throw new IllegalArgumentException("Offset is too large"); } return forOffsetMillis(offset); }
*/ public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException { if (hoursOffset == 0 && minutesOffset == 0) { return DateTimeZone.UTC; } if (minutesOffset < 0 || minutesOffset > 59) { throw new IllegalArgumentException("Minutes out of range: " + minutesOffset); } int offset = 0; try { int hoursInMinutes = FieldUtils.safeMultiply(hoursOffset, 60); if (hoursInMinutes < 0) { minutesOffset = FieldUtils.safeAdd(hoursInMinutes, -minutesOffset); } else { minutesOffset = FieldUtils.safeAdd(hoursInMinutes, minutesOffset); } <BUGS> offset = FieldUtils.safeMultiply(minutesOffset, DateTimeConstants.MILLIS_PER_MINUTE); <BUGE> } catch (ArithmeticException ex) { throw new IllegalArgumentException("Offset is too large"); } return forOffsetMillis(offset); }
*/ public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException { if (hoursOffset == 0 && minutesOffset == 0) { return DateTimeZone.UTC; } if (minutesOffset < 0 || minutesOffset > 59) { throw new IllegalArgumentException("Minutes out of range: " + minutesOffset); } int offset = 0; try { int hoursInMinutes = FieldUtils.safeMultiply(hoursOffset, 60); if (hoursInMinutes < 0) { minutesOffset = FieldUtils.safeAdd(hoursInMinutes, -minutesOffset); } else { minutesOffset = FieldUtils.safeAdd(hoursInMinutes, minutesOffset); } offset = FieldUtils.safeMultiply(minutesOffset, DateTimeConstants.MILLIS_PER_MINUTE); } catch (ArithmeticException ex) { throw new IllegalArgumentException("Offset is too large"); <BUGS> } return forOffsetMillis(offset); <BUGE> }
*/ public String getName() { <BUGS> return iName; <BUGE> }
*/ static PrecalculatedZone create(String id, boolean outputID, ArrayList<Transition> transitions, DSTZone tailZone) { <BUGS> int size = transitions.size(); if (size == 0) { <BUGE> throw new IllegalArgumentException(); }  long[] trans = new long[size]; int[] wallOffsets = new int[size]; int[] standardOffsets = new int[size]; String[] nameKeys = new String[size];  Transition last = null; for (int i=0; i<size; i++) { Transition tr = transitions.get(i);  if (!tr.isTransitionFrom(last)) { throw new IllegalArgumentException(id); }  trans[i] = tr.getMillis(); wallOffsets[i] = tr.getWallOffset(); standardOffsets[i] = tr.getStandardOffset(); nameKeys[i] = tr.getNameKey();  last = tr; }  /* Some timezones (Australia) have the same name key for*/
*/ static PrecalculatedZone create(String id, boolean outputID, ArrayList<Transition> transitions, DSTZone tailZone) { int size = transitions.size(); if (size == 0) { throw new IllegalArgumentException(); }  <BUGS> long[] trans = new long[size]; int[] wallOffsets = new int[size]; int[] standardOffsets = new int[size]; String[] nameKeys = new String[size]; <BUGE>  Transition last = null; for (int i=0; i<size; i++) { Transition tr = transitions.get(i);  if (!tr.isTransitionFrom(last)) { throw new IllegalArgumentException(id); }  trans[i] = tr.getMillis(); wallOffsets[i] = tr.getWallOffset(); standardOffsets[i] = tr.getStandardOffset(); nameKeys[i] = tr.getNameKey();  last = tr; }  /* Some timezones (Australia) have the same name key for*/
*/ static PrecalculatedZone create(String id, boolean outputID, ArrayList<Transition> transitions, DSTZone tailZone) { int size = transitions.size(); if (size == 0) { throw new IllegalArgumentException(); }  long[] trans = new long[size]; int[] wallOffsets = new int[size]; int[] standardOffsets = new int[size]; String[] nameKeys = new String[size];  <BUGS> Transition last = null; for (int i=0; i<size; i++) { Transition tr = transitions.get(i); <BUGE>  if (!tr.isTransitionFrom(last)) { throw new IllegalArgumentException(id); }  trans[i] = tr.getMillis(); wallOffsets[i] = tr.getWallOffset(); standardOffsets[i] = tr.getStandardOffset(); nameKeys[i] = tr.getNameKey();  last = tr; }  /* Some timezones (Australia) have the same name key for*/
*/ static PrecalculatedZone create(String id, boolean outputID, ArrayList<Transition> transitions, DSTZone tailZone) { int size = transitions.size(); if (size == 0) { throw new IllegalArgumentException(); }  long[] trans = new long[size]; int[] wallOffsets = new int[size]; int[] standardOffsets = new int[size]; String[] nameKeys = new String[size];  Transition last = null; for (int i=0; i<size; i++) { Transition tr = transitions.get(i);  <BUGS> if (!tr.isTransitionFrom(last)) { <BUGE> throw new IllegalArgumentException(id); }  trans[i] = tr.getMillis(); wallOffsets[i] = tr.getWallOffset(); standardOffsets[i] = tr.getStandardOffset(); nameKeys[i] = tr.getNameKey();  last = tr; }  /* Some timezones (Australia) have the same name key for*/
*/ static PrecalculatedZone create(String id, boolean outputID, ArrayList<Transition> transitions, DSTZone tailZone) { int size = transitions.size(); if (size == 0) { throw new IllegalArgumentException(); }  long[] trans = new long[size]; int[] wallOffsets = new int[size]; int[] standardOffsets = new int[size]; String[] nameKeys = new String[size];  Transition last = null; for (int i=0; i<size; i++) { Transition tr = transitions.get(i);  if (!tr.isTransitionFrom(last)) { throw new IllegalArgumentException(id); }  <BUGS> trans[i] = tr.getMillis(); wallOffsets[i] = tr.getWallOffset(); standardOffsets[i] = tr.getStandardOffset(); nameKeys[i] = tr.getNameKey(); <BUGE>  last = tr; }  /* Some timezones (Australia) have the same name key for*/
*/ static PrecalculatedZone create(String id, boolean outputID, ArrayList<Transition> transitions, DSTZone tailZone) { int size = transitions.size(); if (size == 0) { throw new IllegalArgumentException(); }  long[] trans = new long[size]; int[] wallOffsets = new int[size]; int[] standardOffsets = new int[size]; String[] nameKeys = new String[size];  Transition last = null; for (int i=0; i<size; i++) { Transition tr = transitions.get(i);  if (!tr.isTransitionFrom(last)) { throw new IllegalArgumentException(id); }  trans[i] = tr.getMillis(); wallOffsets[i] = tr.getWallOffset(); standardOffsets[i] = tr.getStandardOffset(); nameKeys[i] = tr.getNameKey();  <BUGS> last = tr; <BUGE> }  /* Some timezones (Australia) have the same name key for*/
return new PrecalculatedZone (id, transitions, wallOffsets, standardOffsets, nameKeys, tailZone); }  /** * Factory to create instance from builder. * * @param id  the zone id * @param outputID  true if the zone id should be output * @param transitions  the list of Transition objects * @param tailZone  optional zone for getting info beyond precalculated tables /* summer and winter which messes everything up. Fix it here.*/ <BUGS> String[] zoneNameData = new String[5]; String[][] zoneStrings = new DateFormatSymbols(Locale.ENGLISH).getZoneStrings(); for (int j = 0; j < zoneStrings.length; j++) { String[] set = zoneStrings[j]; if (set != null && set.length == 5 && id.equals(set[0])) { <BUGE> zoneNameData = set; } }  Chronology chrono = ISOChronology.getInstanceUTC();  for (int i = 0; i < nameKeys.length - 1; i++) { String curNameKey = nameKeys[i]; String nextNameKey = nameKeys[i + 1]; long curOffset = wallOffsets[i]; long nextOffset = wallOffsets[i + 1]; long curStdOffset = standardOffsets[i];
tailZone = DSTZone.readFrom(in, id); }  return new PrecalculatedZone (id, transitions, wallOffsets, standardOffsets, nameKeys, tailZone); }  /** * Factory to create instance from builder. * * @param id  the zone id * @param outputID  true if the zone id should be output * @param transitions  the list of Transition objects * @param tailZone  optional zone for getting info beyond precalculated tables  <BUGS> Chronology chrono = ISOChronology.getInstanceUTC(); <BUGE>  for (int i = 0; i < nameKeys.length - 1; i++) { String curNameKey = nameKeys[i]; String nextNameKey = nameKeys[i + 1]; long curOffset = wallOffsets[i]; long nextOffset = wallOffsets[i + 1]; long curStdOffset = standardOffsets[i]; long nextStdOffset = standardOffsets[i + 1]; Period p = new Period(trans[i], trans[i + 1], PeriodType.yearMonthDay(), chrono); if (curOffset != nextOffset && curStdOffset == nextStdOffset && curNameKey.equals(nextNameKey) && p.getYears() == 0 && p.getMonths() > 4 && p.getMonths() < 8 && curNameKey.equals(zoneNameData[2]) &&
(id, transitions, wallOffsets, standardOffsets, nameKeys, tailZone); }  /** * Factory to create instance from builder. * * @param id  the zone id * @param outputID  true if the zone id should be output * @param transitions  the list of Transition objects * @param tailZone  optional zone for getting info beyond precalculated tables  <BUGS> for (int i = 0; i < nameKeys.length - 1; i++) { String curNameKey = nameKeys[i]; String nextNameKey = nameKeys[i + 1]; long curOffset = wallOffsets[i]; long nextOffset = wallOffsets[i + 1]; long curStdOffset = standardOffsets[i]; long nextStdOffset = standardOffsets[i + 1]; Period p = new Period(trans[i], trans[i + 1], PeriodType.yearMonthDay(), chrono); if (curOffset != nextOffset && <BUGE> curStdOffset == nextStdOffset && curNameKey.equals(nextNameKey) && p.getYears() == 0 && p.getMonths() > 4 && p.getMonths() < 8 && curNameKey.equals(zoneNameData[2]) && curNameKey.equals(zoneNameData[4])) {  if (ZoneInfoCompiler.verbose()) { System.out.println("Fixing duplicate name key - " + nextNameKey); System.out.println("     - " + new DateTime(trans[i], chrono) + " - " + new DateTime(trans[i + 1], chrono));
}  return new PrecalculatedZone (id, transitions, wallOffsets, standardOffsets, nameKeys, tailZone); }  /** * Factory to create instance from builder. * * @param id  the zone id * @param outputID  true if the zone id should be output * @param transitions  the list of Transition objects * @param tailZone  optional zone for getting info beyond precalculated tables curStdOffset == nextStdOffset && <BUGS> curNameKey.equals(nextNameKey) && p.getYears() == 0 && p.getMonths() > 4 && p.getMonths() < 8 && curNameKey.equals(zoneNameData[2]) && <BUGE> curNameKey.equals(zoneNameData[4])) {  if (ZoneInfoCompiler.verbose()) { System.out.println("Fixing duplicate name key - " + nextNameKey); System.out.println("     - " + new DateTime(trans[i], chrono) + " - " + new DateTime(trans[i + 1], chrono)); } if (curOffset > nextOffset) { nameKeys[i] = (curNameKey + "-Summer").intern(); } else if (curOffset < nextOffset) { nameKeys[i + 1] = (nextNameKey + "-Summer").intern(); i++; }
}  return new PrecalculatedZone (id, transitions, wallOffsets, standardOffsets, nameKeys, tailZone); }  /** * Factory to create instance from builder. * * @param id  the zone id * @param outputID  true if the zone id should be output * @param transitions  the list of Transition objects * @param tailZone  optional zone for getting info beyond precalculated tables  <BUGS> if (tailZone != null) { if (tailZone.iStartRecurrence.getNameKey() .equals(tailZone.iEndRecurrence.getNameKey())) { if (ZoneInfoCompiler.verbose()) { <BUGE> System.out.println("Fixing duplicate recurrent name key - " + tailZone.iStartRecurrence.getNameKey()); } if (tailZone.iStartRecurrence.getSaveMillis() > 0) { tailZone = new DSTZone( tailZone.getID(), tailZone.iStandardOffset, tailZone.iStartRecurrence.renameAppend("-Summer"), tailZone.iEndRecurrence); } else { tailZone = new DSTZone( tailZone.getID(),
}  return new PrecalculatedZone (id, transitions, wallOffsets, standardOffsets, nameKeys, tailZone); }  /** * Factory to create instance from builder. * * @param id  the zone id * @param outputID  true if the zone id should be output * @param transitions  the list of Transition objects * @param tailZone  optional zone for getting info beyond precalculated tables } <BUGS> if (tailZone.iStartRecurrence.getSaveMillis() > 0) { tailZone = new DSTZone( tailZone.getID(), <BUGE> tailZone.iStandardOffset, tailZone.iStartRecurrence.renameAppend("-Summer"), tailZone.iEndRecurrence); } else { tailZone = new DSTZone( tailZone.getID(), tailZone.iStandardOffset, tailZone.iStartRecurrence, tailZone.iEndRecurrence.renameAppend("-Summer")); } } }
tailZone = DSTZone.readFrom(in, id); }  return new PrecalculatedZone (id, transitions, wallOffsets, standardOffsets, nameKeys, tailZone); }  /** * Factory to create instance from builder. * * @param id  the zone id * @param outputID  true if the zone id should be output * @param transitions  the list of Transition objects * @param tailZone  optional zone for getting info beyond precalculated tables tailZone.iStandardOffset, <BUGS> tailZone.iStartRecurrence.renameAppend("-Summer"), <BUGE> tailZone.iEndRecurrence); } else { tailZone = new DSTZone( tailZone.getID(), tailZone.iStandardOffset, tailZone.iStartRecurrence, tailZone.iEndRecurrence.renameAppend("-Summer")); } } }  return new PrecalculatedZone ((outputID ? id : ""), trans, wallOffsets, standardOffsets, nameKeys, tailZone); }
tailZone = DSTZone.readFrom(in, id); }  return new PrecalculatedZone (id, transitions, wallOffsets, standardOffsets, nameKeys, tailZone); }  /** * Factory to create instance from builder. * * @param id  the zone id * @param outputID  true if the zone id should be output * @param transitions  the list of Transition objects * @param tailZone  optional zone for getting info beyond precalculated tables  <BUGS> return new PrecalculatedZone <BUGE> ((outputID ? id : ""), trans, wallOffsets, standardOffsets, nameKeys, tailZone); }  /* All array fields have the same length.*/  private final long[] iTransitions;  private final int[] iWallOffsets; private final int[] iStandardOffsets; private final String[] iNameKeys;  private final DSTZone iTailZone;  /**
*/ public Period withMillis(int millis) { <BUGS> int[] values = getValues();  /* cloned*/ getPeriodType().setIndexedField(this, PeriodType.MILLI_INDEX, values, millis); return new Period(values, getPeriodType()); <BUGE> }
public String getMessage() { <BUGS> return iMessage; <BUGE> }
*/ public static long safeMultiply(long val1, int val2) { <BUGS> switch (val2) { <BUGE> case -1: return -val1; case 0: return 0L; case 1: return val1; } long total = val1 * val2; if (total / val2 != val1) { throw new ArithmeticException("Multiplication overflows a long: " + val1 + " * " + val2); } return total; }
*/ public static long safeMultiply(long val1, int val2) { switch (val2) { case -1: <BUGS> return -val1; <BUGE> case 0: return 0L; case 1: return val1; } long total = val1 * val2; if (total / val2 != val1) { throw new ArithmeticException("Multiplication overflows a long: " + val1 + " * " + val2); } return total; }
*/ public static long safeMultiply(long val1, int val2) { switch (val2) { case -1: return -val1; case 0: <BUGS> return 0L; <BUGE> case 1: return val1; } long total = val1 * val2; if (total / val2 != val1) { throw new ArithmeticException("Multiplication overflows a long: " + val1 + " * " + val2); } return total; }
*/ public static long safeMultiply(long val1, int val2) { switch (val2) { case -1: return -val1; case 0: return 0L; case 1: <BUGS> return val1; <BUGE> } long total = val1 * val2; if (total / val2 != val1) { throw new ArithmeticException("Multiplication overflows a long: " + val1 + " * " + val2); } return total; }
*/ public static long safeMultiply(long val1, int val2) { switch (val2) { case -1: return -val1; case 0: return 0L; case 1: return val1; } <BUGS> long total = val1 * val2; if (total / val2 != val1) { <BUGE> throw new ArithmeticException("Multiplication overflows a long: " + val1 + " * " + val2); } return total; }
*/ public static long safeMultiply(long val1, int val2) { switch (val2) { case -1: return -val1; case 0: return 0L; case 1: return val1; } long total = val1 * val2; if (total / val2 != val1) { throw new ArithmeticException("Multiplication overflows a long: " + val1 + " * " + val2); } <BUGS> return total; <BUGE> }
*/ public int parseInto(ReadWritableInstant instant, String text, int position) { <BUGS> DateTimeParser parser = requireParser(); if (instant == null) { <BUGE> throw new IllegalArgumentException("Instant must not be null"); }  long instantMillis = instant.getMillis(); Chronology chrono = instant.getChronology(); long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis); chrono = selectChronology(chrono);  DateTimeParserBucket bucket = new DateTimeParserBucket( instantLocal, chrono, iLocale, iPivotYear, iDefaultYear); int newPos = parser.parseInto(bucket, text, position); instant.setMillis(bucket.computeMillis(false, text)); if (iOffsetParsed && bucket.getOffsetInteger() != null) { int parsedOffset = bucket.getOffsetInteger(); DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset); chrono = chrono.withZone(parsedZone); } else if (bucket.getZone() != null) { chrono = chrono.withZone(bucket.getZone()); } instant.setChronology(chrono); if (iZone != null) { instant.setZone(iZone); } return newPos; }
*/ public int parseInto(ReadWritableInstant instant, String text, int position) { DateTimeParser parser = requireParser(); if (instant == null) { throw new IllegalArgumentException("Instant must not be null"); }  <BUGS> long instantMillis = instant.getMillis(); Chronology chrono = instant.getChronology(); long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis); chrono = selectChronology(chrono); <BUGE>  DateTimeParserBucket bucket = new DateTimeParserBucket( instantLocal, chrono, iLocale, iPivotYear, iDefaultYear); int newPos = parser.parseInto(bucket, text, position); instant.setMillis(bucket.computeMillis(false, text)); if (iOffsetParsed && bucket.getOffsetInteger() != null) { int parsedOffset = bucket.getOffsetInteger(); DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset); chrono = chrono.withZone(parsedZone); } else if (bucket.getZone() != null) { chrono = chrono.withZone(bucket.getZone()); } instant.setChronology(chrono); if (iZone != null) { instant.setZone(iZone); } return newPos; }
*/ public int parseInto(ReadWritableInstant instant, String text, int position) { DateTimeParser parser = requireParser(); if (instant == null) { throw new IllegalArgumentException("Instant must not be null"); }  long instantMillis = instant.getMillis(); Chronology chrono = instant.getChronology(); long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis); chrono = selectChronology(chrono);  <BUGS> DateTimeParserBucket bucket = new DateTimeParserBucket( <BUGE> instantLocal, chrono, iLocale, iPivotYear, iDefaultYear); int newPos = parser.parseInto(bucket, text, position); instant.setMillis(bucket.computeMillis(false, text)); if (iOffsetParsed && bucket.getOffsetInteger() != null) { int parsedOffset = bucket.getOffsetInteger(); DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset); chrono = chrono.withZone(parsedZone); } else if (bucket.getZone() != null) { chrono = chrono.withZone(bucket.getZone()); } instant.setChronology(chrono); if (iZone != null) { instant.setZone(iZone); } return newPos; }
*/ public int parseInto(ReadWritableInstant instant, String text, int position) { DateTimeParser parser = requireParser(); if (instant == null) { throw new IllegalArgumentException("Instant must not be null"); }  long instantMillis = instant.getMillis(); Chronology chrono = instant.getChronology(); long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis); chrono = selectChronology(chrono);  DateTimeParserBucket bucket = new DateTimeParserBucket( instantLocal, chrono, iLocale, iPivotYear, iDefaultYear); <BUGS> int newPos = parser.parseInto(bucket, text, position); instant.setMillis(bucket.computeMillis(false, text)); if (iOffsetParsed && bucket.getOffsetInteger() != null) { <BUGE> int parsedOffset = bucket.getOffsetInteger(); DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset); chrono = chrono.withZone(parsedZone); } else if (bucket.getZone() != null) { chrono = chrono.withZone(bucket.getZone()); } instant.setChronology(chrono); if (iZone != null) { instant.setZone(iZone); } return newPos; }
*/ public int parseInto(ReadWritableInstant instant, String text, int position) { DateTimeParser parser = requireParser(); if (instant == null) { throw new IllegalArgumentException("Instant must not be null"); }  long instantMillis = instant.getMillis(); Chronology chrono = instant.getChronology(); long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis); chrono = selectChronology(chrono);  DateTimeParserBucket bucket = new DateTimeParserBucket( instantLocal, chrono, iLocale, iPivotYear, iDefaultYear); int newPos = parser.parseInto(bucket, text, position); instant.setMillis(bucket.computeMillis(false, text)); if (iOffsetParsed && bucket.getOffsetInteger() != null) { int parsedOffset = bucket.getOffsetInteger(); DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset); chrono = chrono.withZone(parsedZone); <BUGS> } else if (bucket.getZone() != null) { chrono = chrono.withZone(bucket.getZone()); <BUGE> } instant.setChronology(chrono); if (iZone != null) { instant.setZone(iZone); } return newPos; }
*/ public int parseInto(ReadWritableInstant instant, String text, int position) { DateTimeParser parser = requireParser(); if (instant == null) { throw new IllegalArgumentException("Instant must not be null"); }  long instantMillis = instant.getMillis(); Chronology chrono = instant.getChronology(); long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis); chrono = selectChronology(chrono);  DateTimeParserBucket bucket = new DateTimeParserBucket( instantLocal, chrono, iLocale, iPivotYear, iDefaultYear); int newPos = parser.parseInto(bucket, text, position); instant.setMillis(bucket.computeMillis(false, text)); if (iOffsetParsed && bucket.getOffsetInteger() != null) { int parsedOffset = bucket.getOffsetInteger(); DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset); chrono = chrono.withZone(parsedZone); } else if (bucket.getZone() != null) { chrono = chrono.withZone(bucket.getZone()); } <BUGS> instant.setChronology(chrono); if (iZone != null) { <BUGE> instant.setZone(iZone); } return newPos; }
*/ public int parseInto(ReadWritableInstant instant, String text, int position) { DateTimeParser parser = requireParser(); if (instant == null) { throw new IllegalArgumentException("Instant must not be null"); }  long instantMillis = instant.getMillis(); Chronology chrono = instant.getChronology(); long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis); chrono = selectChronology(chrono);  DateTimeParserBucket bucket = new DateTimeParserBucket( instantLocal, chrono, iLocale, iPivotYear, iDefaultYear); int newPos = parser.parseInto(bucket, text, position); instant.setMillis(bucket.computeMillis(false, text)); if (iOffsetParsed && bucket.getOffsetInteger() != null) { int parsedOffset = bucket.getOffsetInteger(); DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset); chrono = chrono.withZone(parsedZone); } else if (bucket.getZone() != null) { chrono = chrono.withZone(bucket.getZone()); } instant.setChronology(chrono); if (iZone != null) { instant.setZone(iZone); } <BUGS> return newPos; <BUGE> }
*/ public long adjustOffset(long instant, boolean earlierOrLater) { /* a bit messy, but will work in all non-pathological cases*/  /* evaluate 3 hours before and after to work out if anything is happening*/ <BUGS> long instantBefore = convertUTCToLocal(instant - 3 * DateTimeConstants.MILLIS_PER_HOUR); long instantAfter = convertUTCToLocal(instant + 3 * DateTimeConstants.MILLIS_PER_HOUR); if (instantBefore == instantAfter) { <BUGE> return instant;  /* not an overlap (less than is a gap, equal is normal case)*/ }  /* work out range of instants that have duplicate local times*/ long local = convertUTCToLocal(instant); return convertLocalToUTC(local, false, earlierOrLater ? instantAfter : instantBefore);  /* calculate result*/ /* currently in later offset*/ /* currently in earlier offset*/ }
*/ public long adjustOffset(long instant, boolean earlierOrLater) { /* a bit messy, but will work in all non-pathological cases*/  /* evaluate 3 hours before and after to work out if anything is happening*/ long instantBefore = convertUTCToLocal(instant - 3 * DateTimeConstants.MILLIS_PER_HOUR); long instantAfter = convertUTCToLocal(instant + 3 * DateTimeConstants.MILLIS_PER_HOUR); if (instantBefore == instantAfter) { return instant;  /* not an overlap (less than is a gap, equal is normal case)*/ }  /* work out range of instants that have duplicate local times*/ <BUGS> long local = convertUTCToLocal(instant); return convertLocalToUTC(local, false, earlierOrLater ? instantAfter : instantBefore); <BUGE>  /* calculate result*/ /* currently in later offset*/ /* currently in earlier offset*/ }
public String getMessage() { <BUGS> return iMessage; <BUGE> }
*/ public DateTime( int year, int monthOfYear, int dayOfMonth, int hourOfDay, int minuteOfHour, DateTimeZone zone) { <BUGS> super(year, monthOfYear, dayOfMonth, <BUGE> hourOfDay, minuteOfHour, 0, 0, zone); }
*/ public DateTime( int year, int monthOfYear, int dayOfMonth, int hourOfDay, int minuteOfHour, DateTimeZone zone) { super(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, 0, 0, zone); <BUGS> } <BUGE>
public void printTo( StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) { buf.append(displayZone != null ? displayZone.getID() : ""); }
public void printTo( StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) { buf.append(displayZone != null ? displayZone.getID() : ""); }
public void printTo( StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) { buf.append(displayZone != null ? displayZone.getID() : ""); }
public void printTo( StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) { <BUGS> buf.append(displayZone != null ? displayZone.getID() : ""); } <BUGE>
public void printTo( StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) { buf.append(displayZone != null ? displayZone.getID() : ""); }
public void printTo( StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) { buf.append(displayZone != null ? displayZone.getID() : ""); }
public void printTo( StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) { buf.append(displayZone != null ? displayZone.getID() : ""); }
public void printTo( StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) { buf.append(displayZone != null ? displayZone.getID() : ""); }
public void printTo( StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) { buf.append(displayZone != null ? displayZone.getID() : ""); }
public boolean isFixed() { <BUGS> return true; <BUGE> }
*/ public static DateTimeZone forTimeZone(TimeZone zone) { <BUGS> if (zone == null) { <BUGE> return getDefault(); } final String id = zone.getID(); if (id.equals("UTC")) { return DateTimeZone.UTC; }  /* Convert from old alias before consulting provider since they may differ.*/ DateTimeZone dtz = null; String convId = getConvertedId(id); if (convId != null) { dtz = cProvider.getZone(convId); } if (dtz == null) { dtz = cProvider.getZone(id); } if (dtz != null) { return dtz; }  /* Support GMT+/-hh:mm formats*/ if (convId == null) { convId = zone.getDisplayName(); if (convId.startsWith("GMT+") || convId.startsWith("GMT-")) { convId = convId.substring(3); int offset = parseOffset(convId); if (offset == 0L) {
*/ public static DateTimeZone forTimeZone(TimeZone zone) { if (zone == null) { return getDefault(); } <BUGS> final String id = zone.getID(); if (id.equals("UTC")) { <BUGE> return DateTimeZone.UTC; }  /* Convert from old alias before consulting provider since they may differ.*/ DateTimeZone dtz = null; String convId = getConvertedId(id); if (convId != null) { dtz = cProvider.getZone(convId); } if (dtz == null) { dtz = cProvider.getZone(id); } if (dtz != null) { return dtz; }  /* Support GMT+/-hh:mm formats*/ if (convId == null) { convId = zone.getDisplayName(); if (convId.startsWith("GMT+") || convId.startsWith("GMT-")) { convId = convId.substring(3); int offset = parseOffset(convId); if (offset == 0L) {
*/ public static DateTimeZone forTimeZone(TimeZone zone) { if (zone == null) { return getDefault(); } final String id = zone.getID(); if (id.equals("UTC")) { return DateTimeZone.UTC; }  /* Convert from old alias before consulting provider since they may differ.*/ <BUGS> DateTimeZone dtz = null; String convId = getConvertedId(id); if (convId != null) { dtz = cProvider.getZone(convId); <BUGE> } if (dtz == null) { dtz = cProvider.getZone(id); } if (dtz != null) { return dtz; }  /* Support GMT+/-hh:mm formats*/ if (convId == null) { convId = zone.getDisplayName(); if (convId.startsWith("GMT+") || convId.startsWith("GMT-")) { convId = convId.substring(3); int offset = parseOffset(convId); if (offset == 0L) {
*/ public static DateTimeZone forTimeZone(TimeZone zone) { if (zone == null) { return getDefault(); } final String id = zone.getID(); if (id.equals("UTC")) { return DateTimeZone.UTC; }  /* Convert from old alias before consulting provider since they may differ.*/ DateTimeZone dtz = null; String convId = getConvertedId(id); if (convId != null) { dtz = cProvider.getZone(convId); } <BUGS> if (dtz == null) { dtz = cProvider.getZone(id); <BUGE> } if (dtz != null) { return dtz; }  /* Support GMT+/-hh:mm formats*/ if (convId == null) { convId = zone.getDisplayName(); if (convId.startsWith("GMT+") || convId.startsWith("GMT-")) { convId = convId.substring(3); int offset = parseOffset(convId); if (offset == 0L) {
*/ public static DateTimeZone forTimeZone(TimeZone zone) { if (zone == null) { return getDefault(); } final String id = zone.getID(); if (id.equals("UTC")) { return DateTimeZone.UTC; }  /* Convert from old alias before consulting provider since they may differ.*/ DateTimeZone dtz = null; String convId = getConvertedId(id); if (convId != null) { dtz = cProvider.getZone(convId); } if (dtz == null) { dtz = cProvider.getZone(id); } <BUGS> if (dtz != null) { return dtz; <BUGE> }  /* Support GMT+/-hh:mm formats*/ if (convId == null) { convId = zone.getDisplayName(); if (convId.startsWith("GMT+") || convId.startsWith("GMT-")) { convId = convId.substring(3); int offset = parseOffset(convId); if (offset == 0L) {
@ToString public String toString() { <BUGS> return ISODateTimeFormat.date().print(this); <BUGE> }
*/ public long next(long instant, int standardOffset, int saveMillis) { int offset; <BUGS> if (iMode == 'w') { <BUGE> offset = standardOffset + saveMillis; } else if (iMode == 's') { offset = standardOffset; } else { offset = 0; }  /* Convert from UTC to local time.*/ instant += offset;  Chronology chrono = ISOChronology.getInstanceUTC(); long next = chrono.monthOfYear().set(instant, iMonthOfYear); /* Be lenient with millisOfDay.*/ next = chrono.millisOfDay().set(next, 0); next = chrono.millisOfDay().add(next, iMillisOfDay); next = setDayOfMonthNext(chrono, next);  if (iDayOfWeek == 0) { if (next <= instant) { next = chrono.year().add(next, 1); next = setDayOfMonthNext(chrono, next); } } else { next = setDayOfWeek(chrono, next); if (next <= instant) { next = chrono.year().add(next, 1);
*/ public long next(long instant, int standardOffset, int saveMillis) { int offset; if (iMode == 'w') { offset = standardOffset + saveMillis; <BUGS> } else if (iMode == 's') { offset = standardOffset; <BUGE> } else { offset = 0; }  /* Convert from UTC to local time.*/ instant += offset;  Chronology chrono = ISOChronology.getInstanceUTC(); long next = chrono.monthOfYear().set(instant, iMonthOfYear); /* Be lenient with millisOfDay.*/ next = chrono.millisOfDay().set(next, 0); next = chrono.millisOfDay().add(next, iMillisOfDay); next = setDayOfMonthNext(chrono, next);  if (iDayOfWeek == 0) { if (next <= instant) { next = chrono.year().add(next, 1); next = setDayOfMonthNext(chrono, next); } } else { next = setDayOfWeek(chrono, next); if (next <= instant) { next = chrono.year().add(next, 1);
*/ public long next(long instant, int standardOffset, int saveMillis) { int offset; if (iMode == 'w') { offset = standardOffset + saveMillis; } else if (iMode == 's') { offset = standardOffset; } else { offset = 0; }  /* Convert from UTC to local time.*/ <BUGS> instant += offset; <BUGE>  Chronology chrono = ISOChronology.getInstanceUTC(); long next = chrono.monthOfYear().set(instant, iMonthOfYear); /* Be lenient with millisOfDay.*/ next = chrono.millisOfDay().set(next, 0); next = chrono.millisOfDay().add(next, iMillisOfDay); next = setDayOfMonthNext(chrono, next);  if (iDayOfWeek == 0) { if (next <= instant) { next = chrono.year().add(next, 1); next = setDayOfMonthNext(chrono, next); } } else { next = setDayOfWeek(chrono, next); if (next <= instant) { next = chrono.year().add(next, 1);
*/ public long next(long instant, int standardOffset, int saveMillis) { int offset; if (iMode == 'w') { offset = standardOffset + saveMillis; } else if (iMode == 's') { offset = standardOffset; } else { offset = 0; }  /* Convert from UTC to local time.*/ instant += offset;  <BUGS> Chronology chrono = ISOChronology.getInstanceUTC(); long next = chrono.monthOfYear().set(instant, iMonthOfYear); <BUGE> /* Be lenient with millisOfDay.*/ next = chrono.millisOfDay().set(next, 0); next = chrono.millisOfDay().add(next, iMillisOfDay); next = setDayOfMonthNext(chrono, next);  if (iDayOfWeek == 0) { if (next <= instant) { next = chrono.year().add(next, 1); next = setDayOfMonthNext(chrono, next); } } else { next = setDayOfWeek(chrono, next); if (next <= instant) { next = chrono.year().add(next, 1);
*/ public long next(long instant, int standardOffset, int saveMillis) { int offset; if (iMode == 'w') { offset = standardOffset + saveMillis; } else if (iMode == 's') { offset = standardOffset; } else { offset = 0; }  /* Convert from UTC to local time.*/ instant += offset;  Chronology chrono = ISOChronology.getInstanceUTC(); long next = chrono.monthOfYear().set(instant, iMonthOfYear); /* Be lenient with millisOfDay.*/ <BUGS> next = chrono.millisOfDay().set(next, 0); next = chrono.millisOfDay().add(next, iMillisOfDay); next = setDayOfMonthNext(chrono, next); <BUGE>  if (iDayOfWeek == 0) { if (next <= instant) { next = chrono.year().add(next, 1); next = setDayOfMonthNext(chrono, next); } } else { next = setDayOfWeek(chrono, next); if (next <= instant) { next = chrono.year().add(next, 1);
*/ public long next(long instant, int standardOffset, int saveMillis) { int offset; if (iMode == 'w') { offset = standardOffset + saveMillis; } else if (iMode == 's') { offset = standardOffset; } else { offset = 0; }  /* Convert from UTC to local time.*/ instant += offset;  Chronology chrono = ISOChronology.getInstanceUTC(); long next = chrono.monthOfYear().set(instant, iMonthOfYear); /* Be lenient with millisOfDay.*/ next = chrono.millisOfDay().set(next, 0); next = chrono.millisOfDay().add(next, iMillisOfDay); next = setDayOfMonthNext(chrono, next);  <BUGS> if (iDayOfWeek == 0) { <BUGE> if (next <= instant) { next = chrono.year().add(next, 1); next = setDayOfMonthNext(chrono, next); } } else { next = setDayOfWeek(chrono, next); if (next <= instant) { next = chrono.year().add(next, 1);
millis = setDayOfMonth(chrono, millis);  if (iDayOfWeek != 0) { millis = setDayOfWeek(chrono, millis); }  /* Convert from local time to UTC.*/ return millis - offset; }  /** * @param standardOffset standard offset just before next recurrence } else { <BUGS> next = setDayOfWeek(chrono, next); if (next <= instant) { next = chrono.year().add(next, 1); next = chrono.monthOfYear().set(next, iMonthOfYear); next = setDayOfMonthNext(chrono, next); next = setDayOfWeek(chrono, next); <BUGE> } }  /* Convert from local time to UTC.*/ return next - offset; }  /** * @param standardOffset standard offset just before previous recurrence */ public long previous(long instant, int standardOffset, int saveMillis) {
millis = chrono.monthOfYear().set(millis, iMonthOfYear); millis = chrono.millisOfDay().set(millis, iMillisOfDay); millis = setDayOfMonth(chrono, millis);  if (iDayOfWeek != 0) { millis = setDayOfWeek(chrono, millis); }  /* Convert from local time to UTC.*/ return millis - offset; }  /** * @param standardOffset standard offset just before next recurrence /* Convert from local time to UTC.*/ <BUGS> return next - offset; <BUGE> }  /** * @param standardOffset standard offset just before previous recurrence */ public long previous(long instant, int standardOffset, int saveMillis) { int offset; if (iMode == 'w') { offset = standardOffset + saveMillis; } else if (iMode == 's') { offset = standardOffset; } else { offset = 0; }
millis = chrono.monthOfYear().set(millis, iMonthOfYear); millis = chrono.millisOfDay().set(millis, iMillisOfDay); millis = setDayOfMonth(chrono, millis);  if (iDayOfWeek != 0) { millis = setDayOfWeek(chrono, millis); }  /* Convert from local time to UTC.*/ return millis - offset; }  /** * @param standardOffset standard offset just before next recurrence public long next(long instant, int standardOffset, int saveMillis) { <BUGS> return iOfYear.next(instant, standardOffset, saveMillis); <BUGE> }  /** * @param standardOffset standard offset just before previous recurrence */ public long previous(long instant, int standardOffset, int saveMillis) { return iOfYear.previous(instant, standardOffset, saveMillis); }  public String getNameKey() { return iNameKey; }  public int getSaveMillis() {
*/ public DateTimeZone getZone(String id) { <BUGS> if (id == null) { <BUGE> return null; }  Object obj = iZoneInfoMap.get(id); if (obj == null) { return null; }  if (id.equals(obj)) { /* Load zone data for the first time.*/ return loadZoneData(id); }  if (obj instanceof SoftReference<?>) { @SuppressWarnings("unchecked") SoftReference<DateTimeZone> ref = (SoftReference<DateTimeZone>) obj; DateTimeZone tz = ref.get(); if (tz != null) { return tz; } /* Reference cleared; load data again.*/ return loadZoneData(id); }  /* If this point is reached, mapping must link to another.*/ return getZone((String)obj); }
*/ public DateTimeZone getZone(String id) { if (id == null) { return null; }  <BUGS> Object obj = iZoneInfoMap.get(id); if (obj == null) { return null; <BUGE> }  if (id.equals(obj)) { /* Load zone data for the first time.*/ return loadZoneData(id); }  if (obj instanceof SoftReference<?>) { @SuppressWarnings("unchecked") SoftReference<DateTimeZone> ref = (SoftReference<DateTimeZone>) obj; DateTimeZone tz = ref.get(); if (tz != null) { return tz; } /* Reference cleared; load data again.*/ return loadZoneData(id); }  /* If this point is reached, mapping must link to another.*/ return getZone((String)obj); }
*/ public DateTimeZone getZone(String id) { if (id == null) { return null; }  Object obj = iZoneInfoMap.get(id); if (obj == null) { return null; }  <BUGS> if (id.equals(obj)) { <BUGE> /* Load zone data for the first time.*/ return loadZoneData(id); }  if (obj instanceof SoftReference<?>) { @SuppressWarnings("unchecked") SoftReference<DateTimeZone> ref = (SoftReference<DateTimeZone>) obj; DateTimeZone tz = ref.get(); if (tz != null) { return tz; } /* Reference cleared; load data again.*/ return loadZoneData(id); }  /* If this point is reached, mapping must link to another.*/ return getZone((String)obj); }
*/ public DateTimeZone getZone(String id) { if (id == null) { return null; }  Object obj = iZoneInfoMap.get(id); if (obj == null) { return null; }  if (id.equals(obj)) { /* Load zone data for the first time.*/ <BUGS> return loadZoneData(id); <BUGE> }  if (obj instanceof SoftReference<?>) { @SuppressWarnings("unchecked") SoftReference<DateTimeZone> ref = (SoftReference<DateTimeZone>) obj; DateTimeZone tz = ref.get(); if (tz != null) { return tz; } /* Reference cleared; load data again.*/ return loadZoneData(id); }  /* If this point is reached, mapping must link to another.*/ return getZone((String)obj); }
*/ public DateTimeZone getZone(String id) { if (id == null) { return null; }  Object obj = iZoneInfoMap.get(id); if (obj == null) { return null; }  if (id.equals(obj)) { /* Load zone data for the first time.*/ return loadZoneData(id); }  <BUGS> if (obj instanceof SoftReference<?>) { <BUGE> @SuppressWarnings("unchecked") SoftReference<DateTimeZone> ref = (SoftReference<DateTimeZone>) obj; DateTimeZone tz = ref.get(); if (tz != null) { return tz; } /* Reference cleared; load data again.*/ return loadZoneData(id); }  /* If this point is reached, mapping must link to another.*/ return getZone((String)obj); }
*/ public DateTimeZone getZone(String id) { if (id == null) { return null; }  Object obj = iZoneInfoMap.get(id); if (obj == null) { return null; }  if (id.equals(obj)) { /* Load zone data for the first time.*/ return loadZoneData(id); }  if (obj instanceof SoftReference<?>) { @SuppressWarnings("unchecked") <BUGS> SoftReference<DateTimeZone> ref = (SoftReference<DateTimeZone>) obj; DateTimeZone tz = ref.get(); if (tz != null) { return tz; <BUGE> } /* Reference cleared; load data again.*/ return loadZoneData(id); }  /* If this point is reached, mapping must link to another.*/ return getZone((String)obj); }
*/ public DateTimeZone getZone(String id) { if (id == null) { return null; }  Object obj = iZoneInfoMap.get(id); if (obj == null) { return null; }  if (id.equals(obj)) { /* Load zone data for the first time.*/ return loadZoneData(id); }  if (obj instanceof SoftReference<?>) { @SuppressWarnings("unchecked") SoftReference<DateTimeZone> ref = (SoftReference<DateTimeZone>) obj; DateTimeZone tz = ref.get(); if (tz != null) { return tz; } /* Reference cleared; load data again.*/ return loadZoneData(id); }  /* If this point is reached, mapping must link to another.*/ <BUGS> return getZone((String)obj); <BUGE> }
*/ private int parseInt(String text, int position, int length) { <BUGS> if (length >= 10) { <BUGE> /* Since value may exceed max, use stock parser which checks for this.*/ return Integer.parseInt(text.substring(position, position + length)); } if (length <= 0) { return 0; } int value = text.charAt(position++); length--; boolean negative; if (value == '-') { if (--length < 0) { return 0; } negative = true; value = text.charAt(position++); } else { negative = false; } value -= '0'; while (length-- > 0) { value = ((value << 3) + (value << 1)) + text.charAt(position++) - '0'; } return negative ? -value : value; }
*/ private int parseInt(String text, int position, int length) { if (length >= 10) { /* Since value may exceed max, use stock parser which checks for this.*/ <BUGS> return Integer.parseInt(text.substring(position, position + length)); <BUGE> } if (length <= 0) { return 0; } int value = text.charAt(position++); length--; boolean negative; if (value == '-') { if (--length < 0) { return 0; } negative = true; value = text.charAt(position++); } else { negative = false; } value -= '0'; while (length-- > 0) { value = ((value << 3) + (value << 1)) + text.charAt(position++) - '0'; } return negative ? -value : value; }
@Override public void run(T configuration, Environment environment) throws Exception { /* Register Dropwizard Configuration as a Bean Spring.*/ <BUGS> if (registerConfiguration) registerConfiguration(configuration, context); <BUGE>  /* Register a placeholder to resolve Dropwizard Configuration as properties.*/ if (placeholderConfigurer != null) registerPlaceholder(configuration, context);  /* Register the Dropwizard environment*/  /* Refresh context if is not active*/ if (!context.isActive()) context.refresh();  /* Initialize Dropwizard environment*/ registerManaged(environment, context); registerLifecycle(environment, context); registerTasks(environment, context); registerHealthChecks(environment, context); registerInjectableProviders(environment, context); registerProviders(environment, context); registerResources(environment, context); }
@Override public void run(T configuration, Environment environment) throws Exception { /* Register Dropwizard Configuration as a Bean Spring.*/ if (registerConfiguration) registerConfiguration(configuration, context);  /* Register a placeholder to resolve Dropwizard Configuration as properties.*/ <BUGS> if (placeholderConfigurer != null) registerPlaceholder(configuration, context); <BUGE>  /* Register the Dropwizard environment*/  /* Refresh context if is not active*/ if (!context.isActive()) context.refresh();  /* Initialize Dropwizard environment*/ registerManaged(environment, context); registerLifecycle(environment, context); registerTasks(environment, context); registerHealthChecks(environment, context); registerInjectableProviders(environment, context); registerProviders(environment, context); registerResources(environment, context); }
@Override public void run(T configuration, Environment environment) throws Exception { /* Register Dropwizard Configuration as a Bean Spring.*/ if (registerConfiguration) registerConfiguration(configuration, context);  /* Register a placeholder to resolve Dropwizard Configuration as properties.*/ if (placeholderConfigurer != null) registerPlaceholder(configuration, context);  /* Register the Dropwizard environment*/  /* Refresh context if is not active*/ <BUGS> if (!context.isActive()) context.refresh(); <BUGE>  /* Initialize Dropwizard environment*/ registerManaged(environment, context); registerLifecycle(environment, context); registerTasks(environment, context); registerHealthChecks(environment, context); registerInjectableProviders(environment, context); registerProviders(environment, context); registerResources(environment, context); }
@Override public void run(T configuration, Environment environment) throws Exception { /* Register Dropwizard Configuration as a Bean Spring.*/ if (registerConfiguration) registerConfiguration(configuration, context);  /* Register a placeholder to resolve Dropwizard Configuration as properties.*/ if (placeholderConfigurer != null) registerPlaceholder(configuration, context);  /* Register the Dropwizard environment*/  /* Refresh context if is not active*/ if (!context.isActive()) context.refresh();  /* Initialize Dropwizard environment*/ <BUGS> registerManaged(environment, context); registerLifecycle(environment, context); registerTasks(environment, context); registerHealthChecks(environment, context); registerInjectableProviders(environment, context); registerProviders(environment, context); registerResources(environment, context); } <BUGE>
*/ public long[] point(long index) { <BUGS> return HilbertCurve.transposedIndexToPoint(bits, transposeLong(index)); <BUGE> }
@VisibleForTesting static void visitPerimeter(long[] mins, long[] maxes, long[] x, int specialIndex, Consumer<? super long[]> visitor) { <BUGS> long[] y = Arrays.copyOf(x, x.length); for (int i = specialIndex + 1; i < y.length; i++) { if (mins[i] >= maxes[i] - 1) { <BUGE> return; } y[i] = mins[i] + 1; } visitor.accept(y); while (true) { /* try to increment once*/ for (int i = y.length - 1; i >= 0; i--) { if (i > specialIndex) { /* to the right of specialIndex we only allow values between min + 1 and max -1*/ /* inclusive*/ if (y[i] == maxes[i] - 1) { y[i] = mins[i] + 1; /* continue looping to increment at the next index to the left*/ } else { /* increment happened without carryover so we break and report y*/ y[i] += 1; break; } } else if (i < specialIndex) { /* to the left of specialIndex we allow all values*/ if (y[i] == maxes[i]) { if (i == 0) { return;
@VisibleForTesting static void visitPerimeter(long[] mins, long[] maxes, long[] x, int specialIndex, Consumer<? super long[]> visitor) { long[] y = Arrays.copyOf(x, x.length); for (int i = specialIndex + 1; i < y.length; i++) { if (mins[i] >= maxes[i] - 1) { return; } <BUGS> y[i] = mins[i] + 1; <BUGE> } visitor.accept(y); while (true) { /* try to increment once*/ for (int i = y.length - 1; i >= 0; i--) { if (i > specialIndex) { /* to the right of specialIndex we only allow values between min + 1 and max -1*/ /* inclusive*/ if (y[i] == maxes[i] - 1) { y[i] = mins[i] + 1; /* continue looping to increment at the next index to the left*/ } else { /* increment happened without carryover so we break and report y*/ y[i] += 1; break; } } else if (i < specialIndex) { /* to the left of specialIndex we allow all values*/ if (y[i] == maxes[i]) { if (i == 0) { return;
@VisibleForTesting static void visitPerimeter(long[] mins, long[] maxes, long[] x, int specialIndex, Consumer<? super long[]> visitor) { long[] y = Arrays.copyOf(x, x.length); for (int i = specialIndex + 1; i < y.length; i++) { if (mins[i] >= maxes[i] - 1) { return; } y[i] = mins[i] + 1; } <BUGS> visitor.accept(y); <BUGE> while (true) { /* try to increment once*/ for (int i = y.length - 1; i >= 0; i--) { if (i > specialIndex) { /* to the right of specialIndex we only allow values between min + 1 and max -1*/ /* inclusive*/ if (y[i] == maxes[i] - 1) { y[i] = mins[i] + 1; /* continue looping to increment at the next index to the left*/ } else { /* increment happened without carryover so we break and report y*/ y[i] += 1; break; } } else if (i < specialIndex) { /* to the left of specialIndex we allow all values*/ if (y[i] == maxes[i]) { if (i == 0) { return;
@VisibleForTesting static void visitPerimeter(long[] mins, long[] maxes, long[] x, int specialIndex, Consumer<? super long[]> visitor) { long[] y = Arrays.copyOf(x, x.length); for (int i = specialIndex + 1; i < y.length; i++) { if (mins[i] >= maxes[i] - 1) { return; } y[i] = mins[i] + 1; } visitor.accept(y); while (true) { /* try to increment once*/ <BUGS> for (int i = y.length - 1; i >= 0; i--) { if (i > specialIndex) { <BUGE> /* to the right of specialIndex we only allow values between min + 1 and max -1*/ /* inclusive*/ if (y[i] == maxes[i] - 1) { y[i] = mins[i] + 1; /* continue looping to increment at the next index to the left*/ } else { /* increment happened without carryover so we break and report y*/ y[i] += 1; break; } } else if (i < specialIndex) { /* to the left of specialIndex we allow all values*/ if (y[i] == maxes[i]) { if (i == 0) { return;
@VisibleForTesting static void visitPerimeter(long[] mins, long[] maxes, long[] x, int specialIndex, Consumer<? super long[]> visitor) { long[] y = Arrays.copyOf(x, x.length); for (int i = specialIndex + 1; i < y.length; i++) { if (mins[i] >= maxes[i] - 1) { return; } y[i] = mins[i] + 1; } visitor.accept(y); while (true) { /* try to increment once*/ for (int i = y.length - 1; i >= 0; i--) { if (i > specialIndex) { /* to the right of specialIndex we only allow values between min + 1 and max -1*/ /* inclusive*/ <BUGS> if (y[i] == maxes[i] - 1) { y[i] = mins[i] + 1; <BUGE> /* continue looping to increment at the next index to the left*/ } else { /* increment happened without carryover so we break and report y*/ y[i] += 1; break; } } else if (i < specialIndex) { /* to the left of specialIndex we allow all values*/ if (y[i] == maxes[i]) { if (i == 0) { return;
@VisibleForTesting static void visitPerimeter(long[] mins, long[] maxes, long[] x, int specialIndex, Consumer<? super long[]> visitor) { long[] y = Arrays.copyOf(x, x.length); for (int i = specialIndex + 1; i < y.length; i++) { if (mins[i] >= maxes[i] - 1) { return; } y[i] = mins[i] + 1; } visitor.accept(y); while (true) { /* try to increment once*/ for (int i = y.length - 1; i >= 0; i--) { if (i > specialIndex) { /* to the right of specialIndex we only allow values between min + 1 and max -1*/ /* inclusive*/ if (y[i] == maxes[i] - 1) { y[i] = mins[i] + 1; /* continue looping to increment at the next index to the left*/ } else { /* increment happened without carryover so we break and report y*/ <BUGS> y[i] += 1; break; <BUGE> } } else if (i < specialIndex) { /* to the left of specialIndex we allow all values*/ if (y[i] == maxes[i]) { if (i == 0) { return;
@VisibleForTesting static void visitPerimeter(long[] mins, long[] maxes, long[] x, int specialIndex, Consumer<? super long[]> visitor) { long[] y = Arrays.copyOf(x, x.length); for (int i = specialIndex + 1; i < y.length; i++) { if (mins[i] >= maxes[i] - 1) { return; } y[i] = mins[i] + 1; } visitor.accept(y); while (true) { /* try to increment once*/ for (int i = y.length - 1; i >= 0; i--) { if (i > specialIndex) { /* to the right of specialIndex we only allow values between min + 1 and max -1*/ /* inclusive*/ if (y[i] == maxes[i] - 1) { y[i] = mins[i] + 1; /* continue looping to increment at the next index to the left*/ } else { /* increment happened without carryover so we break and report y*/ y[i] += 1; break; } <BUGS> } else if (i < specialIndex) { <BUGE> /* to the left of specialIndex we allow all values*/ if (y[i] == maxes[i]) { if (i == 0) { return;
@VisibleForTesting static void visitPerimeter(long[] mins, long[] maxes, long[] x, int specialIndex, Consumer<? super long[]> visitor) { long[] y = Arrays.copyOf(x, x.length); for (int i = specialIndex + 1; i < y.length; i++) { if (mins[i] >= maxes[i] - 1) { return; } y[i] = mins[i] + 1; } visitor.accept(y); while (true) { /* try to increment once*/ for (int i = y.length - 1; i >= 0; i--) { if (i > specialIndex) { /* to the right of specialIndex we only allow values between min + 1 and max -1*/ /* inclusive*/ if (y[i] == maxes[i] - 1) { y[i] = mins[i] + 1; /* continue looping to increment at the next index to the left*/ } else { /* increment happened without carryover so we break and report y*/ y[i] += 1; break; } } else if (i < specialIndex) { /* to the left of specialIndex we allow all values*/ <BUGS> if (y[i] == maxes[i]) { if (i == 0) { return; <BUGE>
long[] x = Arrays.copyOf(mins, mins.length); /* visit for the minimum at specialIndex*/ visitPerimeter(mins, maxes, x, specialIndex, visitor); if (mins[specialIndex] != maxes[specialIndex]) { /* visit for the maximum at specialIndex*/ long[] y = Arrays.copyOf(mins, mins.length); y[specialIndex] = maxes[specialIndex]; visitPerimeter(mins, maxes, y, specialIndex, visitor); } else { break; } } }  } else { <BUGS> y[i] = mins[i]; <BUGE> } } else { y[i] += 1; break; } } else if (i == specialIndex && i == 0) { return; } } visitor.accept(y); } }  @VisibleForTesting
long[] x = Arrays.copyOf(mins, mins.length); /* visit for the minimum at specialIndex*/ visitPerimeter(mins, maxes, x, specialIndex, visitor); if (mins[specialIndex] != maxes[specialIndex]) { /* visit for the maximum at specialIndex*/ long[] y = Arrays.copyOf(mins, mins.length); y[specialIndex] = maxes[specialIndex]; visitPerimeter(mins, maxes, y, specialIndex, visitor); } else { break; } } }  } else { <BUGS> y[i] += 1; break; <BUGE> } } else if (i == specialIndex && i == 0) { return; } } visitor.accept(y); } }  @VisibleForTesting static void addOne(long[] x, long[] mins, long[] maxes) { for (int i = x.length - 1; i >= 0; i--) { if (x[i] != maxes[i]) {
long[] x = Arrays.copyOf(mins, mins.length); /* visit for the minimum at specialIndex*/ visitPerimeter(mins, maxes, x, specialIndex, visitor); if (mins[specialIndex] != maxes[specialIndex]) { /* visit for the maximum at specialIndex*/ long[] y = Arrays.copyOf(mins, mins.length); y[specialIndex] = maxes[specialIndex]; visitPerimeter(mins, maxes, y, specialIndex, visitor); } else { break; } } }  } <BUGS> } else if (i == specialIndex && i == 0) { return; <BUGE> } } visitor.accept(y); } }  @VisibleForTesting static void addOne(long[] x, long[] mins, long[] maxes) { for (int i = x.length - 1; i >= 0; i--) { if (x[i] != maxes[i]) { x[i]++; break; } else {
long[] x = Arrays.copyOf(mins, mins.length); /* visit for the minimum at specialIndex*/ visitPerimeter(mins, maxes, x, specialIndex, visitor); if (mins[specialIndex] != maxes[specialIndex]) { /* visit for the maximum at specialIndex*/ long[] y = Arrays.copyOf(mins, mins.length); y[specialIndex] = maxes[specialIndex]; visitPerimeter(mins, maxes, y, specialIndex, visitor); } else { break; } } }  } <BUGS> visitor.accept(y); <BUGE> } }  @VisibleForTesting static void addOne(long[] x, long[] mins, long[] maxes) { for (int i = x.length - 1; i >= 0; i--) { if (x[i] != maxes[i]) { x[i]++; break; } else { x[i] = mins[i]; } } }
public static Range create(long value) { <BUGS> return new Range(value, value); <BUGE> }
@Override public ObjectInspector init(Mode m, ObjectInspector[] parameters) throws HiveException { <BUGS> super.init(m, parameters); <BUGE>  /* Setup the object inspectors and return type*/ switch (m) { case PARTIAL1: actionObjectInspector = parameters[0]; timestampObjectInspector = parameters[1]; funnelObjectInspector = (ListObjectInspector) parameters[2]; List<String> fieldNames = new ArrayList<>(); fieldNames.add(ACTION); fieldNames.add(TIMESTAMP); fieldNames.add(FUNNEL); List<ObjectInspector> fieldInspectors = new ArrayList<>(); fieldInspectors.add(ObjectInspectorFactory.getStandardListObjectInspector(ObjectInspectorUtils.getStandardObjectInspector(actionObjectInspector))); fieldInspectors.add(ObjectInspectorFactory.getStandardListObjectInspector(ObjectInspectorUtils.getStandardObjectInspector(timestampObjectInspector))); fieldInspectors.add(ObjectInspectorFactory.getStandardListObjectInspector(ObjectInspectorUtils.getStandardObjectInspector(actionObjectInspector))); /* Want lazystring, not text*/ return ObjectInspectorFactory.getStandardStructObjectInspector(fieldNames, fieldInspectors); case PARTIAL2: internalMergeObjectInspector = (StandardStructObjectInspector) parameters[0]; return internalMergeObjectInspector; case FINAL: internalMergeObjectInspector = (StandardStructObjectInspector) parameters[0]; return ObjectInspectorFactory.getStandardListObjectInspector(PrimitiveObjectInspectorFactory.javaLongObjectInspector); case COMPLETE: actionObjectInspector = parameters[0]; timestampObjectInspector = parameters[1]; funnelObjectInspector = (ListObjectInspector) parameters[2]; return ObjectInspectorFactory.getStandardListObjectInspector(PrimitiveObjectInspectorFactory.javaLongObjectInspector);
@Override public ObjectInspector init(Mode m, ObjectInspector[] parameters) throws HiveException { super.init(m, parameters);  /* Setup the object inspectors and return type*/ <BUGS> switch (m) { <BUGE> case PARTIAL1: actionObjectInspector = parameters[0]; timestampObjectInspector = parameters[1]; funnelObjectInspector = (ListObjectInspector) parameters[2]; List<String> fieldNames = new ArrayList<>(); fieldNames.add(ACTION); fieldNames.add(TIMESTAMP); fieldNames.add(FUNNEL); List<ObjectInspector> fieldInspectors = new ArrayList<>(); fieldInspectors.add(ObjectInspectorFactory.getStandardListObjectInspector(ObjectInspectorUtils.getStandardObjectInspector(actionObjectInspector))); fieldInspectors.add(ObjectInspectorFactory.getStandardListObjectInspector(ObjectInspectorUtils.getStandardObjectInspector(timestampObjectInspector))); fieldInspectors.add(ObjectInspectorFactory.getStandardListObjectInspector(ObjectInspectorUtils.getStandardObjectInspector(actionObjectInspector))); /* Want lazystring, not text*/ return ObjectInspectorFactory.getStandardStructObjectInspector(fieldNames, fieldInspectors); case PARTIAL2: internalMergeObjectInspector = (StandardStructObjectInspector) parameters[0]; return internalMergeObjectInspector; case FINAL: internalMergeObjectInspector = (StandardStructObjectInspector) parameters[0]; return ObjectInspectorFactory.getStandardListObjectInspector(PrimitiveObjectInspectorFactory.javaLongObjectInspector); case COMPLETE: actionObjectInspector = parameters[0]; timestampObjectInspector = parameters[1]; funnelObjectInspector = (ListObjectInspector) parameters[2]; return ObjectInspectorFactory.getStandardListObjectInspector(PrimitiveObjectInspectorFactory.javaLongObjectInspector);
@Override public ObjectInspector init(Mode m, ObjectInspector[] parameters) throws HiveException { super.init(m, parameters);  /* Setup the object inspectors and return type*/ switch (m) { case PARTIAL1: <BUGS> actionObjectInspector = parameters[0]; timestampObjectInspector = parameters[1]; funnelObjectInspector = (ListObjectInspector) parameters[2]; List<String> fieldNames = new ArrayList<>(); fieldNames.add(ACTION); fieldNames.add(TIMESTAMP); fieldNames.add(FUNNEL); List<ObjectInspector> fieldInspectors = new ArrayList<>(); fieldInspectors.add(ObjectInspectorFactory.getStandardListObjectInspector(ObjectInspectorUtils.getStandardObjectInspector(actionObjectInspector))); fieldInspectors.add(ObjectInspectorFactory.getStandardListObjectInspector(ObjectInspectorUtils.getStandardObjectInspector(timestampObjectInspector))); fieldInspectors.add(ObjectInspectorFactory.getStandardListObjectInspector(ObjectInspectorUtils.getStandardObjectInspector(actionObjectInspector))); /* Want lazystring, not text*/ return ObjectInspectorFactory.getStandardStructObjectInspector(fieldNames, fieldInspectors); <BUGE> case PARTIAL2: internalMergeObjectInspector = (StandardStructObjectInspector) parameters[0]; return internalMergeObjectInspector; case FINAL: internalMergeObjectInspector = (StandardStructObjectInspector) parameters[0]; return ObjectInspectorFactory.getStandardListObjectInspector(PrimitiveObjectInspectorFactory.javaLongObjectInspector); case COMPLETE: actionObjectInspector = parameters[0]; timestampObjectInspector = parameters[1]; funnelObjectInspector = (ListObjectInspector) parameters[2]; return ObjectInspectorFactory.getStandardListObjectInspector(PrimitiveObjectInspectorFactory.javaLongObjectInspector);
*/ public final void transform( String sourcefile, String destfile, Locale locale, String inputEncoding, String outputEncoding, String javadocLinkDir, String revision ) throws IOException { <BUGS> this.setCurrentFilename( sourcefile ); <BUGE>  this.sourcefile = sourcefile; this.destfile = destfile;  /*make sure that the parent directories exist...*/ new File( new File( destfile ).getParent() ).mkdirs();  Reader fr = null; Writer fw = null; try { if ( inputEncoding != null ) { fr = new InputStreamReader( new FileInputStream( sourcefile ), inputEncoding ); } else { fr = new FileReader( sourcefile ); } if ( outputEncoding != null ) { fw = new OutputStreamWriter( new FileOutputStream( destfile ), outputEncoding ); } else
*/ public final void transform( String sourcefile, String destfile, Locale locale, String inputEncoding, String outputEncoding, String javadocLinkDir, String revision ) throws IOException { this.setCurrentFilename( sourcefile );  <BUGS> this.sourcefile = sourcefile; this.destfile = destfile; <BUGE>  /*make sure that the parent directories exist...*/ new File( new File( destfile ).getParent() ).mkdirs();  Reader fr = null; Writer fw = null; try { if ( inputEncoding != null ) { fr = new InputStreamReader( new FileInputStream( sourcefile ), inputEncoding ); } else { fr = new FileReader( sourcefile ); } if ( outputEncoding != null ) { fw = new OutputStreamWriter( new FileOutputStream( destfile ), outputEncoding ); } else
*/ public final void transform( String sourcefile, String destfile, Locale locale, String inputEncoding, String outputEncoding, String javadocLinkDir, String revision ) throws IOException { this.setCurrentFilename( sourcefile );  this.sourcefile = sourcefile; this.destfile = destfile;  /*make sure that the parent directories exist...*/ <BUGS> new File( new File( destfile ).getParent() ).mkdirs(); <BUGE>  Reader fr = null; Writer fw = null; try { if ( inputEncoding != null ) { fr = new InputStreamReader( new FileInputStream( sourcefile ), inputEncoding ); } else { fr = new FileReader( sourcefile ); } if ( outputEncoding != null ) { fw = new OutputStreamWriter( new FileOutputStream( destfile ), outputEncoding ); } else
*/ public final void transform( String sourcefile, String destfile, Locale locale, String inputEncoding, String outputEncoding, String javadocLinkDir, String revision ) throws IOException { this.setCurrentFilename( sourcefile );  this.sourcefile = sourcefile; this.destfile = destfile;  /*make sure that the parent directories exist...*/ new File( new File( destfile ).getParent() ).mkdirs();  <BUGS> Reader fr = null; Writer fw = null; <BUGE> try { if ( inputEncoding != null ) { fr = new InputStreamReader( new FileInputStream( sourcefile ), inputEncoding ); } else { fr = new FileReader( sourcefile ); } if ( outputEncoding != null ) { fw = new OutputStreamWriter( new FileOutputStream( destfile ), outputEncoding ); } else
*/ public final void transform( String sourcefile, String destfile, Locale locale, String inputEncoding, String outputEncoding, String javadocLinkDir, String revision ) throws IOException { this.setCurrentFilename( sourcefile );  this.sourcefile = sourcefile; this.destfile = destfile;  /*make sure that the parent directories exist...*/ new File( new File( destfile ).getParent() ).mkdirs();  Reader fr = null; Writer fw = null; try { <BUGS> if ( inputEncoding != null ) <BUGE> { fr = new InputStreamReader( new FileInputStream( sourcefile ), inputEncoding ); } else { fr = new FileReader( sourcefile ); } if ( outputEncoding != null ) { fw = new OutputStreamWriter( new FileOutputStream( destfile ), outputEncoding ); } else
*/ public final void transform( String sourcefile, String destfile, Locale locale, String inputEncoding, String outputEncoding, String javadocLinkDir, String revision ) throws IOException { this.setCurrentFilename( sourcefile );  this.sourcefile = sourcefile; this.destfile = destfile;  /*make sure that the parent directories exist...*/ new File( new File( destfile ).getParent() ).mkdirs();  Reader fr = null; Writer fw = null; try { if ( inputEncoding != null ) { <BUGS> fr = new InputStreamReader( new FileInputStream( sourcefile ), inputEncoding ); <BUGE> } else { fr = new FileReader( sourcefile ); } if ( outputEncoding != null ) { fw = new OutputStreamWriter( new FileOutputStream( destfile ), outputEncoding ); } else
*/ public final void transform( String sourcefile, String destfile, Locale locale, String inputEncoding, String outputEncoding, String javadocLinkDir, String revision ) throws IOException { this.setCurrentFilename( sourcefile );  this.sourcefile = sourcefile; this.destfile = destfile;  /*make sure that the parent directories exist...*/ new File( new File( destfile ).getParent() ).mkdirs();  Reader fr = null; Writer fw = null; try { if ( inputEncoding != null ) { fr = new InputStreamReader( new FileInputStream( sourcefile ), inputEncoding ); } else { fr = new FileReader( sourcefile ); } <BUGS> if ( outputEncoding != null ) <BUGE> { fw = new OutputStreamWriter( new FileOutputStream( destfile ), outputEncoding ); } else
*/ public final void transform( String sourcefile, String destfile, Locale locale, String inputEncoding, String outputEncoding, String javadocLinkDir, String revision ) throws IOException { this.setCurrentFilename( sourcefile );  this.sourcefile = sourcefile; this.destfile = destfile;  /*make sure that the parent directories exist...*/ new File( new File( destfile ).getParent() ).mkdirs();  Reader fr = null; Writer fw = null; try { if ( inputEncoding != null ) { fr = new InputStreamReader( new FileInputStream( sourcefile ), inputEncoding ); } else { fr = new FileReader( sourcefile ); } if ( outputEncoding != null ) { <BUGS> fw = new OutputStreamWriter( new FileOutputStream( destfile ), outputEncoding ); <BUGE> } else
out.flush(); }  /** * This is the public method for doing all transforms of code. * * @param sourcefile String * @param destfile String * @param locale String * @param inputEncoding String * @param outputEncoding String * @param javadocLinkDir String * @param revision String * @throws IOException  <BUGS> transform( fr, fw, locale, inputEncoding, outputEncoding, javadocLinkDir, revision, true, true ); <BUGE> } catch ( RuntimeException e ) { System.out.println( "Unable to processPath " + sourcefile + " => " + destfile ); throw e; } finally { if ( fr != null ) { try { fr.close(); }
out.flush(); }  /** * This is the public method for doing all transforms of code. * * @param sourcefile String * @param destfile String * @param locale String * @param inputEncoding String * @param outputEncoding String * @param javadocLinkDir String * @param revision String * @throws IOException } <BUGS> catch ( RuntimeException e ) <BUGE> { System.out.println( "Unable to processPath " + sourcefile + " => " + destfile ); throw e; } finally { if ( fr != null ) { try { fr.close(); } catch ( Exception ex ) {
out.flush(); }  /** * This is the public method for doing all transforms of code. * * @param sourcefile String * @param destfile String * @param locale String * @param inputEncoding String * @param outputEncoding String * @param javadocLinkDir String * @param revision String * @throws IOException { <BUGS> System.out.println( "Unable to processPath " + sourcefile + " => " + destfile ); throw e; <BUGE> } finally { if ( fr != null ) { try { fr.close(); } catch ( Exception ex ) { ex.printStackTrace(); }
out.flush(); }  /** * This is the public method for doing all transforms of code. * * @param sourcefile String * @param destfile String * @param locale String * @param inputEncoding String * @param outputEncoding String * @param javadocLinkDir String * @param revision String * @throws IOException { <BUGS> if ( fr != null ) <BUGE> { try { fr.close(); } catch ( Exception ex ) { ex.printStackTrace(); } } if ( fw != null ) { try {
out.flush(); }  /** * This is the public method for doing all transforms of code. * * @param sourcefile String * @param destfile String * @param locale String * @param inputEncoding String * @param outputEncoding String * @param javadocLinkDir String * @param revision String * @throws IOException { <BUGS> fr.close(); <BUGE> } catch ( Exception ex ) { ex.printStackTrace(); } } if ( fw != null ) { try { fw.close(); } catch ( Exception ex ) {
out.flush(); }  /** * This is the public method for doing all transforms of code. * * @param sourcefile String * @param destfile String * @param locale String * @param inputEncoding String * @param outputEncoding String * @param javadocLinkDir String * @param revision String * @throws IOException ex.printStackTrace(); <BUGS> } <BUGE> } if ( fw != null ) { try { fw.close(); } catch ( Exception ex ) { ex.printStackTrace(); } } } }
out.flush(); }  /** * This is the public method for doing all transforms of code. * * @param sourcefile String * @param destfile String * @param locale String * @param inputEncoding String * @param outputEncoding String * @param javadocLinkDir String * @param revision String * @throws IOException } <BUGS> if ( fw != null ) <BUGE> { try { fw.close(); } catch ( Exception ex ) { ex.printStackTrace(); } } } }  /**
out.flush(); }  /** * This is the public method for doing all transforms of code. * * @param sourcefile String * @param destfile String * @param locale String * @param inputEncoding String * @param outputEncoding String * @param javadocLinkDir String * @param revision String * @throws IOException { <BUGS> fw.close(); <BUGE> } catch ( Exception ex ) { ex.printStackTrace(); } } } }  /** * Get the current filename * * @return String */
out.flush(); }  /** * This is the public method for doing all transforms of code. * * @param sourcefile String * @param destfile String * @param locale String * @param inputEncoding String * @param outputEncoding String * @param javadocLinkDir String * @param revision String * @throws IOException ex.printStackTrace(); <BUGS> } <BUGE> } } }  /** * Get the current filename * * @return String */ public final String getCurrentFilename() { return this.currentFilename; }
/* does not recurse.*/ private void normalise(Element element) { <BUGS> List<Node> toMove = new ArrayList<Node>(); for (Node node: element.childNodes) { if (node instanceof TextNode) { TextNode tn = (TextNode) node; if (!tn.isBlank()) toMove.add(tn); <BUGE> } }  for (Node node: toMove) { element.removeChild(node); body().appendChild(new TextNode(" ", "")); body().appendChild(node); } }
/* does not recurse.*/ private void normalise(Element element) { List<Node> toMove = new ArrayList<Node>(); for (Node node: element.childNodes) { if (node instanceof TextNode) { TextNode tn = (TextNode) node; if (!tn.isBlank()) toMove.add(tn); } <BUGS> } <BUGE>  for (Node node: toMove) { element.removeChild(node); body().appendChild(new TextNode(" ", "")); body().appendChild(node); } }
/* does not recurse.*/ private void normalise(Element element) { List<Node> toMove = new ArrayList<Node>(); for (Node node: element.childNodes) { if (node instanceof TextNode) { TextNode tn = (TextNode) node; if (!tn.isBlank()) toMove.add(tn); } }  <BUGS> for (Node node: toMove) { element.removeChild(node); body().appendChild(new TextNode(" ", "")); body().appendChild(node); } } <BUGE>
static String escape(String string, CharsetEncoder encoder, EscapeMode escapeMode) { <BUGS> StringBuilder accum = new StringBuilder(string.length() * 2); Map<Character, String> map = escapeMode == EscapeMode.extended ? fullByVal : baseByVal; <BUGE>  for (int pos = 0; pos < string.length(); pos++) { Character c = string.charAt(pos); if (map.containsKey(c)) accum.append('&').append(map.get(c)).append(';'); else if (encoder.canEncode(c)) accum.append(c.charValue()); else accum.append("&#").append((int) c).append(';'); }  return accum.toString(); }
static String escape(String string, CharsetEncoder encoder, EscapeMode escapeMode) { StringBuilder accum = new StringBuilder(string.length() * 2); Map<Character, String> map = escapeMode == EscapeMode.extended ? fullByVal : baseByVal;  <BUGS> for (int pos = 0; pos < string.length(); pos++) { Character c = string.charAt(pos); if (map.containsKey(c)) accum.append('&').append(map.get(c)).append(';'); else if (encoder.canEncode(c)) accum.append(c.charValue()); <BUGE> else accum.append("&#").append((int) c).append(';'); }  return accum.toString(); }
static String escape(String string, CharsetEncoder encoder, EscapeMode escapeMode) { StringBuilder accum = new StringBuilder(string.length() * 2); Map<Character, String> map = escapeMode == EscapeMode.extended ? fullByVal : baseByVal;  for (int pos = 0; pos < string.length(); pos++) { Character c = string.charAt(pos); if (map.containsKey(c)) accum.append('&').append(map.get(c)).append(';'); else if (encoder.canEncode(c)) accum.append(c.charValue()); else <BUGS> accum.append("&#").append((int) c).append(';'); <BUGE> }  return accum.toString(); }
static String escape(String string, CharsetEncoder encoder, EscapeMode escapeMode) { StringBuilder accum = new StringBuilder(string.length() * 2); Map<Character, String> map = escapeMode == EscapeMode.extended ? fullByVal : baseByVal;  for (int pos = 0; pos < string.length(); pos++) { Character c = string.charAt(pos); if (map.containsKey(c)) accum.append('&').append(map.get(c)).append(';'); else if (encoder.canEncode(c)) accum.append(c.charValue()); else accum.append("&#").append((int) c).append(';'); }  <BUGS> return accum.toString(); <BUGE> }
private Attribute parseAttribute() { <BUGS> tq.consumeWhitespace(); String key = tq.consumeAttributeKey(); String value = ""; tq.consumeWhitespace(); if (tq.matchChomp("=")) { tq.consumeWhitespace(); <BUGE>  if (tq.matchChomp(SQ)) { value = tq.chompTo(SQ); } else if (tq.matchChomp(DQ)) { value = tq.chompTo(DQ); } else { StringBuilder valueAccum = new StringBuilder(); /* no ' or " to look for, so scan to end tag or space (or end of stream)*/ while (!tq.matchesAny("<", "/>", ">") && !tq.matchesWhitespace() && !tq.isEmpty()) { valueAccum.append(tq.consume()); } value = valueAccum.toString(); } tq.consumeWhitespace(); } if (key.length() != 0) return Attribute.createFromEncoded(key, value); else { tq.consume();  return null; }
private Attribute parseAttribute() { tq.consumeWhitespace(); String key = tq.consumeAttributeKey(); String value = ""; tq.consumeWhitespace(); if (tq.matchChomp("=")) { tq.consumeWhitespace();  <BUGS> if (tq.matchChomp(SQ)) { <BUGE> value = tq.chompTo(SQ); } else if (tq.matchChomp(DQ)) { value = tq.chompTo(DQ); } else { StringBuilder valueAccum = new StringBuilder(); /* no ' or " to look for, so scan to end tag or space (or end of stream)*/ while (!tq.matchesAny("<", "/>", ">") && !tq.matchesWhitespace() && !tq.isEmpty()) { valueAccum.append(tq.consume()); } value = valueAccum.toString(); } tq.consumeWhitespace(); } if (key.length() != 0) return Attribute.createFromEncoded(key, value); else { tq.consume();  return null; }
private Attribute parseAttribute() { tq.consumeWhitespace(); String key = tq.consumeAttributeKey(); String value = ""; tq.consumeWhitespace(); if (tq.matchChomp("=")) { tq.consumeWhitespace();  if (tq.matchChomp(SQ)) { value = tq.chompTo(SQ); <BUGS> } else if (tq.matchChomp(DQ)) { <BUGE> value = tq.chompTo(DQ); } else { StringBuilder valueAccum = new StringBuilder(); /* no ' or " to look for, so scan to end tag or space (or end of stream)*/ while (!tq.matchesAny("<", "/>", ">") && !tq.matchesWhitespace() && !tq.isEmpty()) { valueAccum.append(tq.consume()); } value = valueAccum.toString(); } tq.consumeWhitespace(); } if (key.length() != 0) return Attribute.createFromEncoded(key, value); else { tq.consume();  return null; }
private Attribute parseAttribute() { tq.consumeWhitespace(); String key = tq.consumeAttributeKey(); String value = ""; tq.consumeWhitespace(); if (tq.matchChomp("=")) { tq.consumeWhitespace();  if (tq.matchChomp(SQ)) { value = tq.chompTo(SQ); } else if (tq.matchChomp(DQ)) { value = tq.chompTo(DQ); } else { <BUGS> StringBuilder valueAccum = new StringBuilder(); <BUGE> /* no ' or " to look for, so scan to end tag or space (or end of stream)*/ while (!tq.matchesAny("<", "/>", ">") && !tq.matchesWhitespace() && !tq.isEmpty()) { valueAccum.append(tq.consume()); } value = valueAccum.toString(); } tq.consumeWhitespace(); } if (key.length() != 0) return Attribute.createFromEncoded(key, value); else { tq.consume();  return null; }
private Attribute parseAttribute() { tq.consumeWhitespace(); String key = tq.consumeAttributeKey(); String value = ""; tq.consumeWhitespace(); if (tq.matchChomp("=")) { tq.consumeWhitespace();  if (tq.matchChomp(SQ)) { value = tq.chompTo(SQ); } else if (tq.matchChomp(DQ)) { value = tq.chompTo(DQ); } else { StringBuilder valueAccum = new StringBuilder(); /* no ' or " to look for, so scan to end tag or space (or end of stream)*/ <BUGS> while (!tq.matchesAny("<", "/>", ">") && !tq.matchesWhitespace() && !tq.isEmpty()) { valueAccum.append(tq.consume()); <BUGE> } value = valueAccum.toString(); } tq.consumeWhitespace(); } if (key.length() != 0) return Attribute.createFromEncoded(key, value); else { tq.consume();  return null; }
private Attribute parseAttribute() { tq.consumeWhitespace(); String key = tq.consumeAttributeKey(); String value = ""; tq.consumeWhitespace(); if (tq.matchChomp("=")) { tq.consumeWhitespace();  if (tq.matchChomp(SQ)) { value = tq.chompTo(SQ); } else if (tq.matchChomp(DQ)) { value = tq.chompTo(DQ); } else { StringBuilder valueAccum = new StringBuilder(); /* no ' or " to look for, so scan to end tag or space (or end of stream)*/ while (!tq.matchesAny("<", "/>", ">") && !tq.matchesWhitespace() && !tq.isEmpty()) { valueAccum.append(tq.consume()); } <BUGS> value = valueAccum.toString(); <BUGE> } tq.consumeWhitespace(); } if (key.length() != 0) return Attribute.createFromEncoded(key, value); else { tq.consume();  return null; }
private Attribute parseAttribute() { tq.consumeWhitespace(); String key = tq.consumeAttributeKey(); String value = ""; tq.consumeWhitespace(); if (tq.matchChomp("=")) { tq.consumeWhitespace();  if (tq.matchChomp(SQ)) { value = tq.chompTo(SQ); } else if (tq.matchChomp(DQ)) { value = tq.chompTo(DQ); } else { StringBuilder valueAccum = new StringBuilder(); /* no ' or " to look for, so scan to end tag or space (or end of stream)*/ while (!tq.matchesAny("<", "/>", ">") && !tq.matchesWhitespace() && !tq.isEmpty()) { valueAccum.append(tq.consume()); } value = valueAccum.toString(); } <BUGS> tq.consumeWhitespace(); <BUGE> } if (key.length() != 0) return Attribute.createFromEncoded(key, value); else { tq.consume();  return null; }
private Attribute parseAttribute() { tq.consumeWhitespace(); String key = tq.consumeAttributeKey(); String value = ""; tq.consumeWhitespace(); if (tq.matchChomp("=")) { tq.consumeWhitespace();  if (tq.matchChomp(SQ)) { value = tq.chompTo(SQ); } else if (tq.matchChomp(DQ)) { value = tq.chompTo(DQ); } else { StringBuilder valueAccum = new StringBuilder(); /* no ' or " to look for, so scan to end tag or space (or end of stream)*/ while (!tq.matchesAny("<", "/>", ">") && !tq.matchesWhitespace() && !tq.isEmpty()) { valueAccum.append(tq.consume()); } value = valueAccum.toString(); } tq.consumeWhitespace(); } <BUGS> if (key.length() != 0) return Attribute.createFromEncoded(key, value); <BUGE> else { tq.consume();  return null; }
private Attribute parseAttribute() { tq.consumeWhitespace(); String key = tq.consumeAttributeKey(); String value = ""; tq.consumeWhitespace(); if (tq.matchChomp("=")) { tq.consumeWhitespace();  if (tq.matchChomp(SQ)) { value = tq.chompTo(SQ); } else if (tq.matchChomp(DQ)) { value = tq.chompTo(DQ); } else { StringBuilder valueAccum = new StringBuilder(); /* no ' or " to look for, so scan to end tag or space (or end of stream)*/ while (!tq.matchesAny("<", "/>", ">") && !tq.matchesWhitespace() && !tq.isEmpty()) { valueAccum.append(tq.consume()); } value = valueAccum.toString(); } tq.consumeWhitespace(); } if (key.length() != 0) return Attribute.createFromEncoded(key, value); else { <BUGS> tq.consume(); <BUGE>  return null; }
private Attribute parseAttribute() { tq.consumeWhitespace(); String key = tq.consumeAttributeKey(); String value = ""; tq.consumeWhitespace(); if (tq.matchChomp("=")) { tq.consumeWhitespace();  if (tq.matchChomp(SQ)) { value = tq.chompTo(SQ); } else if (tq.matchChomp(DQ)) { value = tq.chompTo(DQ); } else { StringBuilder valueAccum = new StringBuilder(); /* no ' or " to look for, so scan to end tag or space (or end of stream)*/ while (!tq.matchesAny("<", "/>", ">") && !tq.matchesWhitespace() && !tq.isEmpty()) { valueAccum.append(tq.consume()); } value = valueAccum.toString(); } tq.consumeWhitespace(); } if (key.length() != 0) return Attribute.createFromEncoded(key, value); else { tq.consume();  <BUGS> return null; <BUGE> }
static String unescape(String string) { <BUGS> if (!string.contains("&")) return string; <BUGE>  Matcher m = unescapePattern.matcher(string); /* &(#(x|X)?([0-9a-fA-F]+)|[a-zA-Z]+);?*/ StringBuffer accum = new StringBuffer(string.length()); /* pity matcher can't use stringbuilder, avoid syncs*/ /* todo: replace m.appendReplacement with own impl, so StringBuilder and quoteReplacement not required*/  while (m.find()) { int charval = -1; String num = m.group(3); if (num != null) { try { int base = m.group(2) != null ? 16 : 10; /* 2 is hex indicator*/ charval = Integer.valueOf(num, base); } catch (NumberFormatException e) { } /* skip*/ } else { String name = m.group(1); if (full.containsKey(name)) charval = full.get(name); }  if (charval != -1 || charval > 0xFFFF) { /* out of range*/ String c = Character.toString((char) charval); m.appendReplacement(accum, c); } else { m.appendReplacement(accum, m.group(0)); }
static String unescape(String string) { if (!string.contains("&")) return string;  <BUGS> Matcher m = unescapePattern.matcher(string); /* &(#(x|X)?([0-9a-fA-F]+)|[a-zA-Z]+);?*/ StringBuffer accum = new StringBuffer(string.length()); /* pity matcher can't use stringbuilder, avoid syncs <BUGE>*/ /* todo: replace m.appendReplacement with own impl, so StringBuilder and quoteReplacement not required*/  while (m.find()) { int charval = -1; String num = m.group(3); if (num != null) { try { int base = m.group(2) != null ? 16 : 10; /* 2 is hex indicator*/ charval = Integer.valueOf(num, base); } catch (NumberFormatException e) { } /* skip*/ } else { String name = m.group(1); if (full.containsKey(name)) charval = full.get(name); }  if (charval != -1 || charval > 0xFFFF) { /* out of range*/ String c = Character.toString((char) charval); m.appendReplacement(accum, c); } else { m.appendReplacement(accum, m.group(0)); }
static String unescape(String string) { if (!string.contains("&")) return string;  Matcher m = unescapePattern.matcher(string); /* &(#(x|X)?([0-9a-fA-F]+)|[a-zA-Z]+);?*/ StringBuffer accum = new StringBuffer(string.length()); /* pity matcher can't use stringbuilder, avoid syncs*/ /* todo: replace m.appendReplacement with own impl, so StringBuilder and quoteReplacement not required*/  <BUGS> while (m.find()) { int charval = -1; String num = m.group(3); if (num != null) { <BUGE> try { int base = m.group(2) != null ? 16 : 10; /* 2 is hex indicator*/ charval = Integer.valueOf(num, base); } catch (NumberFormatException e) { } /* skip*/ } else { String name = m.group(1); if (full.containsKey(name)) charval = full.get(name); }  if (charval != -1 || charval > 0xFFFF) { /* out of range*/ String c = Character.toString((char) charval); m.appendReplacement(accum, c); } else { m.appendReplacement(accum, m.group(0)); }
static String unescape(String string) { if (!string.contains("&")) return string;  Matcher m = unescapePattern.matcher(string); /* &(#(x|X)?([0-9a-fA-F]+)|[a-zA-Z]+);?*/ StringBuffer accum = new StringBuffer(string.length()); /* pity matcher can't use stringbuilder, avoid syncs*/ /* todo: replace m.appendReplacement with own impl, so StringBuilder and quoteReplacement not required*/  while (m.find()) { int charval = -1; String num = m.group(3); if (num != null) { try { <BUGS> int base = m.group(2) != null ? 16 : 10; /* 2 is hex indicator*/ charval = Integer.valueOf(num, base); <BUGE> } catch (NumberFormatException e) { } /* skip*/ } else { String name = m.group(1); if (full.containsKey(name)) charval = full.get(name); }  if (charval != -1 || charval > 0xFFFF) { /* out of range*/ String c = Character.toString((char) charval); m.appendReplacement(accum, c); } else { m.appendReplacement(accum, m.group(0)); }
static String unescape(String string) { if (!string.contains("&")) return string;  Matcher m = unescapePattern.matcher(string); /* &(#(x|X)?([0-9a-fA-F]+)|[a-zA-Z]+);?*/ StringBuffer accum = new StringBuffer(string.length()); /* pity matcher can't use stringbuilder, avoid syncs*/ /* todo: replace m.appendReplacement with own impl, so StringBuilder and quoteReplacement not required*/  while (m.find()) { int charval = -1; String num = m.group(3); if (num != null) { try { int base = m.group(2) != null ? 16 : 10; /* 2 is hex indicator*/ charval = Integer.valueOf(num, base); } catch (NumberFormatException e) { <BUGS> } /* skip <BUGE>*/ } else { String name = m.group(1); if (full.containsKey(name)) charval = full.get(name); }  if (charval != -1 || charval > 0xFFFF) { /* out of range*/ String c = Character.toString((char) charval); m.appendReplacement(accum, c); } else { m.appendReplacement(accum, m.group(0)); }
static String unescape(String string) { if (!string.contains("&")) return string;  Matcher m = unescapePattern.matcher(string); /* &(#(x|X)?([0-9a-fA-F]+)|[a-zA-Z]+);?*/ StringBuffer accum = new StringBuffer(string.length()); /* pity matcher can't use stringbuilder, avoid syncs*/ /* todo: replace m.appendReplacement with own impl, so StringBuilder and quoteReplacement not required*/  while (m.find()) { int charval = -1; String num = m.group(3); if (num != null) { try { int base = m.group(2) != null ? 16 : 10; /* 2 is hex indicator*/ charval = Integer.valueOf(num, base); } catch (NumberFormatException e) { } /* skip*/ } else { <BUGS> String name = m.group(1); if (full.containsKey(name)) charval = full.get(name); <BUGE> }  if (charval != -1 || charval > 0xFFFF) { /* out of range*/ String c = Character.toString((char) charval); m.appendReplacement(accum, c); } else { m.appendReplacement(accum, m.group(0)); }
static String unescape(String string) { if (!string.contains("&")) return string;  Matcher m = unescapePattern.matcher(string); /* &(#(x|X)?([0-9a-fA-F]+)|[a-zA-Z]+);?*/ StringBuffer accum = new StringBuffer(string.length()); /* pity matcher can't use stringbuilder, avoid syncs*/ /* todo: replace m.appendReplacement with own impl, so StringBuilder and quoteReplacement not required*/  while (m.find()) { int charval = -1; String num = m.group(3); if (num != null) { try { int base = m.group(2) != null ? 16 : 10; /* 2 is hex indicator*/ charval = Integer.valueOf(num, base); } catch (NumberFormatException e) { } /* skip*/ } else { String name = m.group(1); if (full.containsKey(name)) charval = full.get(name); }  <BUGS> if (charval != -1 || charval > 0xFFFF) { /* out of range*/ String c = Character.toString((char) charval); m.appendReplacement(accum, c); } else { m.appendReplacement(accum, m.group(0)); <BUGE> }
for (int pos = 0; pos < string.length(); pos++) { Character c = string.charAt(pos); if (map.containsKey(c)) accum.append('&').append(map.get(c)).append(';'); else if (encoder.canEncode(c)) accum.append(c.charValue()); else accum.append("&#").append((int) c).append(';'); }  return accum.toString(); } } <BUGS> } m.appendTail(accum); return accum.toString(); <BUGE> }  /* most common, base entities can be unescaped without trailing ;*/ /* e.g. &amp*/ private static final Object[][] baseArray = { {"AElig", 0x000C6}, {"AMP", 0x00026}, {"Aacute", 0x000C1}, {"Acirc", 0x000C2}, {"Agrave", 0x000C0}, {"Aring", 0x000C5}, {"Atilde", 0x000C3}, {"Auml", 0x000C4},
*/ public Document ownerDocument() { <BUGS> if (this instanceof Document) return (Document) this; else if (parentNode == null) return null; <BUGE> else return parentNode.ownerDocument(); }
*/ public Document ownerDocument() { if (this instanceof Document) return (Document) this; else if (parentNode == null) return null; else <BUGS> return parentNode.ownerDocument(); <BUGE> }
static String unescape(String string) { <BUGS> if (!string.contains("&")) <BUGE> return string;  Matcher m = unescapePattern.matcher(string); /* &(#(x|X)?([0-9a-fA-F]+)|[a-zA-Z]\\d*);?*/ StringBuffer accum = new StringBuffer(string.length()); /* pity matcher can't use stringbuilder, avoid syncs*/ /* todo: replace m.appendReplacement with own impl, so StringBuilder and quoteReplacement not required*/  while (m.find()) { int charval = -1; String num = m.group(3); if (num != null) { try { int base = m.group(2) != null ? 16 : 10; /* 2 is hex indicator*/ charval = Integer.valueOf(num, base); } catch (NumberFormatException e) { } /* skip*/ } else { String name = m.group(1); if (full.containsKey(name)) charval = full.get(name); }  if (charval != -1 || charval > 0xFFFF) { /* out of range*/ String c = Character.toString((char) charval); m.appendReplacement(accum, Matcher.quoteReplacement(c)); } else { m.appendReplacement(accum, Matcher.quoteReplacement(m.group(0))); /* replace with original string*/ }
static String unescape(String string) { if (!string.contains("&")) return string;  <BUGS> Matcher m = unescapePattern.matcher(string); /* &(#(x|X)?([0-9a-fA-F]+)|[a-zA-Z]\\d*);?*/ StringBuffer accum = new StringBuffer(string.length()); /* pity matcher can't use stringbuilder, avoid syncs <BUGE>*/ /* todo: replace m.appendReplacement with own impl, so StringBuilder and quoteReplacement not required*/  while (m.find()) { int charval = -1; String num = m.group(3); if (num != null) { try { int base = m.group(2) != null ? 16 : 10; /* 2 is hex indicator*/ charval = Integer.valueOf(num, base); } catch (NumberFormatException e) { } /* skip*/ } else { String name = m.group(1); if (full.containsKey(name)) charval = full.get(name); }  if (charval != -1 || charval > 0xFFFF) { /* out of range*/ String c = Character.toString((char) charval); m.appendReplacement(accum, Matcher.quoteReplacement(c)); } else { m.appendReplacement(accum, Matcher.quoteReplacement(m.group(0))); /* replace with original string*/ }
static String unescape(String string) { if (!string.contains("&")) return string;  Matcher m = unescapePattern.matcher(string); /* &(#(x|X)?([0-9a-fA-F]+)|[a-zA-Z]\\d*);?*/ StringBuffer accum = new StringBuffer(string.length()); /* pity matcher can't use stringbuilder, avoid syncs*/ /* todo: replace m.appendReplacement with own impl, so StringBuilder and quoteReplacement not required*/  <BUGS> while (m.find()) { int charval = -1; String num = m.group(3); if (num != null) { <BUGE> try { int base = m.group(2) != null ? 16 : 10; /* 2 is hex indicator*/ charval = Integer.valueOf(num, base); } catch (NumberFormatException e) { } /* skip*/ } else { String name = m.group(1); if (full.containsKey(name)) charval = full.get(name); }  if (charval != -1 || charval > 0xFFFF) { /* out of range*/ String c = Character.toString((char) charval); m.appendReplacement(accum, Matcher.quoteReplacement(c)); } else { m.appendReplacement(accum, Matcher.quoteReplacement(m.group(0))); /* replace with original string*/ }
static String unescape(String string) { if (!string.contains("&")) return string;  Matcher m = unescapePattern.matcher(string); /* &(#(x|X)?([0-9a-fA-F]+)|[a-zA-Z]\\d*);?*/ StringBuffer accum = new StringBuffer(string.length()); /* pity matcher can't use stringbuilder, avoid syncs*/ /* todo: replace m.appendReplacement with own impl, so StringBuilder and quoteReplacement not required*/  while (m.find()) { int charval = -1; String num = m.group(3); if (num != null) { try { <BUGS> int base = m.group(2) != null ? 16 : 10; /* 2 is hex indicator*/ charval = Integer.valueOf(num, base); <BUGE> } catch (NumberFormatException e) { } /* skip*/ } else { String name = m.group(1); if (full.containsKey(name)) charval = full.get(name); }  if (charval != -1 || charval > 0xFFFF) { /* out of range*/ String c = Character.toString((char) charval); m.appendReplacement(accum, Matcher.quoteReplacement(c)); } else { m.appendReplacement(accum, Matcher.quoteReplacement(m.group(0))); /* replace with original string*/ }
static String unescape(String string) { if (!string.contains("&")) return string;  Matcher m = unescapePattern.matcher(string); /* &(#(x|X)?([0-9a-fA-F]+)|[a-zA-Z]\\d*);?*/ StringBuffer accum = new StringBuffer(string.length()); /* pity matcher can't use stringbuilder, avoid syncs*/ /* todo: replace m.appendReplacement with own impl, so StringBuilder and quoteReplacement not required*/  while (m.find()) { int charval = -1; String num = m.group(3); if (num != null) { try { int base = m.group(2) != null ? 16 : 10; /* 2 is hex indicator*/ charval = Integer.valueOf(num, base); } catch (NumberFormatException e) { <BUGS> } /* skip <BUGE>*/ } else { String name = m.group(1); if (full.containsKey(name)) charval = full.get(name); }  if (charval != -1 || charval > 0xFFFF) { /* out of range*/ String c = Character.toString((char) charval); m.appendReplacement(accum, Matcher.quoteReplacement(c)); } else { m.appendReplacement(accum, Matcher.quoteReplacement(m.group(0))); /* replace with original string*/ }
static String unescape(String string) { if (!string.contains("&")) return string;  Matcher m = unescapePattern.matcher(string); /* &(#(x|X)?([0-9a-fA-F]+)|[a-zA-Z]\\d*);?*/ StringBuffer accum = new StringBuffer(string.length()); /* pity matcher can't use stringbuilder, avoid syncs*/ /* todo: replace m.appendReplacement with own impl, so StringBuilder and quoteReplacement not required*/  while (m.find()) { int charval = -1; String num = m.group(3); if (num != null) { try { int base = m.group(2) != null ? 16 : 10; /* 2 is hex indicator*/ charval = Integer.valueOf(num, base); } catch (NumberFormatException e) { } /* skip*/ } else { <BUGS> String name = m.group(1); if (full.containsKey(name)) charval = full.get(name); <BUGE> }  if (charval != -1 || charval > 0xFFFF) { /* out of range*/ String c = Character.toString((char) charval); m.appendReplacement(accum, Matcher.quoteReplacement(c)); } else { m.appendReplacement(accum, Matcher.quoteReplacement(m.group(0))); /* replace with original string*/ }
static String unescape(String string) { if (!string.contains("&")) return string;  Matcher m = unescapePattern.matcher(string); /* &(#(x|X)?([0-9a-fA-F]+)|[a-zA-Z]\\d*);?*/ StringBuffer accum = new StringBuffer(string.length()); /* pity matcher can't use stringbuilder, avoid syncs*/ /* todo: replace m.appendReplacement with own impl, so StringBuilder and quoteReplacement not required*/  while (m.find()) { int charval = -1; String num = m.group(3); if (num != null) { try { int base = m.group(2) != null ? 16 : 10; /* 2 is hex indicator*/ charval = Integer.valueOf(num, base); } catch (NumberFormatException e) { } /* skip*/ } else { String name = m.group(1); if (full.containsKey(name)) charval = full.get(name); }  <BUGS> if (charval != -1 || charval > 0xFFFF) { /* out of range*/ String c = Character.toString((char) charval); m.appendReplacement(accum, Matcher.quoteReplacement(c)); } else { m.appendReplacement(accum, Matcher.quoteReplacement(m.group(0))); /* replace with original string <BUGE>*/ }
for (int pos = 0; pos < string.length(); pos++) { Character c = string.charAt(pos); if (map.containsKey(c)) accum.append('&').append(map.get(c)).append(';'); else if (encoder.canEncode(c)) accum.append(c.charValue()); else accum.append("&#").append((int) c).append(';'); }  return accum.toString(); } } <BUGS> } m.appendTail(accum); return accum.toString(); <BUGE> }  /* xhtml has restricted entities*/ private static final Object[][] xhtmlArray = { {"quot", 0x00022}, {"amp", 0x00026}, {"apos", 0x00027}, {"lt", 0x0003C}, {"gt", 0x0003E} };  /* most common, base entities can be unescaped without trailing ;*/ /* e.g. &amp*/
*/ public String absUrl(String attributeKey) { <BUGS> Validate.notEmpty(attributeKey); <BUGE>  String relUrl = attr(attributeKey); if (!hasAttr(attributeKey)) { return ""; /* nothing to make absolute with*/ } else { URL base; try { try { base = new URL(baseUri); } catch (MalformedURLException e) { /* the base is unsuitable, but the attribute may be abs on its own, so try that*/ URL abs = new URL(relUrl); return abs.toExternalForm(); } // workaround: java resolves '//path/file + ?foo' to '//path/?foo', not '/*path/file?foo' as desired*/ URL abs = new URL(base, relUrl); return abs.toExternalForm(); } catch (MalformedURLException e) { return ""; } } }
*/ public String absUrl(String attributeKey) { Validate.notEmpty(attributeKey);  <BUGS> String relUrl = attr(attributeKey); if (!hasAttr(attributeKey)) { <BUGE> return ""; /* nothing to make absolute with*/ } else { URL base; try { try { base = new URL(baseUri); } catch (MalformedURLException e) { /* the base is unsuitable, but the attribute may be abs on its own, so try that*/ URL abs = new URL(relUrl); return abs.toExternalForm(); } // workaround: java resolves '//path/file + ?foo' to '//path/?foo', not '/*path/file?foo' as desired*/ URL abs = new URL(base, relUrl); return abs.toExternalForm(); } catch (MalformedURLException e) { return ""; } } }
*/ public String absUrl(String attributeKey) { Validate.notEmpty(attributeKey);  String relUrl = attr(attributeKey); if (!hasAttr(attributeKey)) { return ""; /* nothing to make absolute with*/ } else { URL base; try { try { <BUGS> base = new URL(baseUri); <BUGE> } catch (MalformedURLException e) { /* the base is unsuitable, but the attribute may be abs on its own, so try that*/ URL abs = new URL(relUrl); return abs.toExternalForm(); } // workaround: java resolves '//path/file + ?foo' to '//path/?foo', not '/*path/file?foo' as desired*/ URL abs = new URL(base, relUrl); return abs.toExternalForm(); } catch (MalformedURLException e) { return ""; } } }
*/ public String absUrl(String attributeKey) { Validate.notEmpty(attributeKey);  String relUrl = attr(attributeKey); if (!hasAttr(attributeKey)) { return ""; /* nothing to make absolute with*/ } else { URL base; try { try { base = new URL(baseUri); } catch (MalformedURLException e) { /* the base is unsuitable, but the attribute may be abs on its own, so try that*/ URL abs = new URL(relUrl); return abs.toExternalForm(); <BUGS> } <BUGE> // workaround: java resolves '//path/file + ?foo' to '//path/?foo', not '/*path/file?foo' as desired*/ URL abs = new URL(base, relUrl); return abs.toExternalForm(); } catch (MalformedURLException e) { return ""; } } }
*/ public String absUrl(String attributeKey) { Validate.notEmpty(attributeKey);  String relUrl = attr(attributeKey); if (!hasAttr(attributeKey)) { return ""; /* nothing to make absolute with*/ } else { URL base; try { try { base = new URL(baseUri); } catch (MalformedURLException e) { /* the base is unsuitable, but the attribute may be abs on its own, so try that*/ URL abs = new URL(relUrl); return abs.toExternalForm(); } // workaround: java resolves '//path/file + ?foo' to '//path/?foo', not '/*path/file?foo' as desired*/ <BUGS> URL abs = new URL(base, relUrl); return abs.toExternalForm(); <BUGE> } catch (MalformedURLException e) { return ""; } } }
private Elements findElements() { <BUGS> if (tq.matchChomp("#")) { <BUGE> return byId(); } else if (tq.matchChomp(".")) { return byClass(); } else if (tq.matchesWord()) { return byTag(); } else if (tq.matches("[")) { return byAttribute(); } else if (tq.matchChomp("*")) { return allElements(); } else if (tq.matchChomp(":lt(")) { return indexLessThan(); } else if (tq.matchChomp(":gt(")) { return indexGreaterThan(); } else if (tq.matchChomp(":eq(")) { return indexEquals(); } else if (tq.matches(":has(")) { return has(); } else if (tq.matches(":contains(")) { return contains(false); } else if (tq.matches(":containsOwn(")) { return contains(true); } else if (tq.matches(":matches(")) { return matches(false); } else if (tq.matches(":matchesOwn(")) { return matches(true); } else { /* unhandled*/ throw new SelectorParseException("Could not parse query '%s': unexpected token at '%s'", query, tq.remainder());
private Elements findElements() { if (tq.matchChomp("#")) { return byId(); <BUGS> } else if (tq.matchChomp(".")) { <BUGE> return byClass(); } else if (tq.matchesWord()) { return byTag(); } else if (tq.matches("[")) { return byAttribute(); } else if (tq.matchChomp("*")) { return allElements(); } else if (tq.matchChomp(":lt(")) { return indexLessThan(); } else if (tq.matchChomp(":gt(")) { return indexGreaterThan(); } else if (tq.matchChomp(":eq(")) { return indexEquals(); } else if (tq.matches(":has(")) { return has(); } else if (tq.matches(":contains(")) { return contains(false); } else if (tq.matches(":containsOwn(")) { return contains(true); } else if (tq.matches(":matches(")) { return matches(false); } else if (tq.matches(":matchesOwn(")) { return matches(true); } else { /* unhandled*/ throw new SelectorParseException("Could not parse query '%s': unexpected token at '%s'", query, tq.remainder());
private Elements findElements() { if (tq.matchChomp("#")) { return byId(); } else if (tq.matchChomp(".")) { return byClass(); <BUGS> } else if (tq.matchesWord()) { return byTag(); } else if (tq.matches("[")) { return byAttribute(); } else if (tq.matchChomp("*")) { <BUGE> return allElements(); } else if (tq.matchChomp(":lt(")) { return indexLessThan(); } else if (tq.matchChomp(":gt(")) { return indexGreaterThan(); } else if (tq.matchChomp(":eq(")) { return indexEquals(); } else if (tq.matches(":has(")) { return has(); } else if (tq.matches(":contains(")) { return contains(false); } else if (tq.matches(":containsOwn(")) { return contains(true); } else if (tq.matches(":matches(")) { return matches(false); } else if (tq.matches(":matchesOwn(")) { return matches(true); } else { /* unhandled*/ throw new SelectorParseException("Could not parse query '%s': unexpected token at '%s'", query, tq.remainder());
private Elements findElements() { if (tq.matchChomp("#")) { return byId(); } else if (tq.matchChomp(".")) { return byClass(); } else if (tq.matchesWord()) { return byTag(); } else if (tq.matches("[")) { return byAttribute(); } else if (tq.matchChomp("*")) { return allElements(); <BUGS> } else if (tq.matchChomp(":lt(")) { <BUGE> return indexLessThan(); } else if (tq.matchChomp(":gt(")) { return indexGreaterThan(); } else if (tq.matchChomp(":eq(")) { return indexEquals(); } else if (tq.matches(":has(")) { return has(); } else if (tq.matches(":contains(")) { return contains(false); } else if (tq.matches(":containsOwn(")) { return contains(true); } else if (tq.matches(":matches(")) { return matches(false); } else if (tq.matches(":matchesOwn(")) { return matches(true); } else { /* unhandled*/ throw new SelectorParseException("Could not parse query '%s': unexpected token at '%s'", query, tq.remainder());
private Elements findElements() { if (tq.matchChomp("#")) { return byId(); } else if (tq.matchChomp(".")) { return byClass(); } else if (tq.matchesWord()) { return byTag(); } else if (tq.matches("[")) { return byAttribute(); } else if (tq.matchChomp("*")) { return allElements(); } else if (tq.matchChomp(":lt(")) { return indexLessThan(); <BUGS> } else if (tq.matchChomp(":gt(")) { <BUGE> return indexGreaterThan(); } else if (tq.matchChomp(":eq(")) { return indexEquals(); } else if (tq.matches(":has(")) { return has(); } else if (tq.matches(":contains(")) { return contains(false); } else if (tq.matches(":containsOwn(")) { return contains(true); } else if (tq.matches(":matches(")) { return matches(false); } else if (tq.matches(":matchesOwn(")) { return matches(true); } else { /* unhandled*/ throw new SelectorParseException("Could not parse query '%s': unexpected token at '%s'", query, tq.remainder());
private Elements findElements() { if (tq.matchChomp("#")) { return byId(); } else if (tq.matchChomp(".")) { return byClass(); } else if (tq.matchesWord()) { return byTag(); } else if (tq.matches("[")) { return byAttribute(); } else if (tq.matchChomp("*")) { return allElements(); } else if (tq.matchChomp(":lt(")) { return indexLessThan(); } else if (tq.matchChomp(":gt(")) { return indexGreaterThan(); <BUGS> } else if (tq.matchChomp(":eq(")) { <BUGE> return indexEquals(); } else if (tq.matches(":has(")) { return has(); } else if (tq.matches(":contains(")) { return contains(false); } else if (tq.matches(":containsOwn(")) { return contains(true); } else if (tq.matches(":matches(")) { return matches(false); } else if (tq.matches(":matchesOwn(")) { return matches(true); } else { /* unhandled*/ throw new SelectorParseException("Could not parse query '%s': unexpected token at '%s'", query, tq.remainder());
private Elements findElements() { if (tq.matchChomp("#")) { return byId(); } else if (tq.matchChomp(".")) { return byClass(); } else if (tq.matchesWord()) { return byTag(); } else if (tq.matches("[")) { return byAttribute(); } else if (tq.matchChomp("*")) { return allElements(); } else if (tq.matchChomp(":lt(")) { return indexLessThan(); } else if (tq.matchChomp(":gt(")) { return indexGreaterThan(); } else if (tq.matchChomp(":eq(")) { return indexEquals(); <BUGS> } else if (tq.matches(":has(")) { return has(); } else if (tq.matches(":contains(")) { <BUGE> return contains(false); } else if (tq.matches(":containsOwn(")) { return contains(true); } else if (tq.matches(":matches(")) { return matches(false); } else if (tq.matches(":matchesOwn(")) { return matches(true); } else { /* unhandled*/ throw new SelectorParseException("Could not parse query '%s': unexpected token at '%s'", query, tq.remainder());
private Elements findElements() { if (tq.matchChomp("#")) { return byId(); } else if (tq.matchChomp(".")) { return byClass(); } else if (tq.matchesWord()) { return byTag(); } else if (tq.matches("[")) { return byAttribute(); } else if (tq.matchChomp("*")) { return allElements(); } else if (tq.matchChomp(":lt(")) { return indexLessThan(); } else if (tq.matchChomp(":gt(")) { return indexGreaterThan(); } else if (tq.matchChomp(":eq(")) { return indexEquals(); } else if (tq.matches(":has(")) { return has(); } else if (tq.matches(":contains(")) { return contains(false); <BUGS> } else if (tq.matches(":containsOwn(")) { <BUGE> return contains(true); } else if (tq.matches(":matches(")) { return matches(false); } else if (tq.matches(":matchesOwn(")) { return matches(true); } else { /* unhandled*/ throw new SelectorParseException("Could not parse query '%s': unexpected token at '%s'", query, tq.remainder());
private Elements findElements() { if (tq.matchChomp("#")) { return byId(); } else if (tq.matchChomp(".")) { return byClass(); } else if (tq.matchesWord()) { return byTag(); } else if (tq.matches("[")) { return byAttribute(); } else if (tq.matchChomp("*")) { return allElements(); } else if (tq.matchChomp(":lt(")) { return indexLessThan(); } else if (tq.matchChomp(":gt(")) { return indexGreaterThan(); } else if (tq.matchChomp(":eq(")) { return indexEquals(); } else if (tq.matches(":has(")) { return has(); } else if (tq.matches(":contains(")) { return contains(false); } else if (tq.matches(":containsOwn(")) { return contains(true); <BUGS> } else if (tq.matches(":matches(")) { <BUGE> return matches(false); } else if (tq.matches(":matchesOwn(")) { return matches(true); } else { /* unhandled*/ throw new SelectorParseException("Could not parse query '%s': unexpected token at '%s'", query, tq.remainder());
private Elements findElements() { if (tq.matchChomp("#")) { return byId(); } else if (tq.matchChomp(".")) { return byClass(); } else if (tq.matchesWord()) { return byTag(); } else if (tq.matches("[")) { return byAttribute(); } else if (tq.matchChomp("*")) { return allElements(); } else if (tq.matchChomp(":lt(")) { return indexLessThan(); } else if (tq.matchChomp(":gt(")) { return indexGreaterThan(); } else if (tq.matchChomp(":eq(")) { return indexEquals(); } else if (tq.matches(":has(")) { return has(); } else if (tq.matches(":contains(")) { return contains(false); } else if (tq.matches(":containsOwn(")) { return contains(true); } else if (tq.matches(":matches(")) { return matches(false); <BUGS> } else if (tq.matches(":matchesOwn(")) { <BUGE> return matches(true); } else { /* unhandled*/ throw new SelectorParseException("Could not parse query '%s': unexpected token at '%s'", query, tq.remainder());
private Elements findElements() { if (tq.matchChomp("#")) { return byId(); } else if (tq.matchChomp(".")) { return byClass(); } else if (tq.matchesWord()) { return byTag(); } else if (tq.matches("[")) { return byAttribute(); } else if (tq.matchChomp("*")) { return allElements(); } else if (tq.matchChomp(":lt(")) { return indexLessThan(); } else if (tq.matchChomp(":gt(")) { return indexGreaterThan(); } else if (tq.matchChomp(":eq(")) { return indexEquals(); } else if (tq.matches(":has(")) { return has(); } else if (tq.matches(":contains(")) { return contains(false); } else if (tq.matches(":containsOwn(")) { return contains(true); } else if (tq.matches(":matches(")) { return matches(false); } else if (tq.matches(":matchesOwn(")) { return matches(true); } else { /* unhandled*/ <BUGS> throw new SelectorParseException("Could not parse query '%s': unexpected token at '%s'", query, tq.remainder()); <BUGE>
private Elements findElements() { <BUGS> if (tq.matchChomp("#")) { <BUGE> return byId(); } else if (tq.matchChomp(".")) { return byClass(); } else if (tq.matchesWord()) { return byTag(); } else if (tq.matches("[")) { return byAttribute(); } else if (tq.matchChomp("*")) { return allElements(); } else if (tq.matchChomp(":lt(")) { return indexLessThan(); } else if (tq.matchChomp(":gt(")) { return indexGreaterThan(); } else if (tq.matchChomp(":eq(")) { return indexEquals(); } else if (tq.matches(":has(")) { return has(); } else if (tq.matches(":contains(")) { return contains(false); } else if (tq.matches(":containsOwn(")) { return contains(true); } else if (tq.matches(":matches(")) { return matches(false); } else if (tq.matches(":matchesOwn(")) { return matches(true); } else if (tq.matches(":not(")) { return not();
private Elements findElements() { if (tq.matchChomp("#")) { return byId(); <BUGS> } else if (tq.matchChomp(".")) { <BUGE> return byClass(); } else if (tq.matchesWord()) { return byTag(); } else if (tq.matches("[")) { return byAttribute(); } else if (tq.matchChomp("*")) { return allElements(); } else if (tq.matchChomp(":lt(")) { return indexLessThan(); } else if (tq.matchChomp(":gt(")) { return indexGreaterThan(); } else if (tq.matchChomp(":eq(")) { return indexEquals(); } else if (tq.matches(":has(")) { return has(); } else if (tq.matches(":contains(")) { return contains(false); } else if (tq.matches(":containsOwn(")) { return contains(true); } else if (tq.matches(":matches(")) { return matches(false); } else if (tq.matches(":matchesOwn(")) { return matches(true); } else if (tq.matches(":not(")) { return not();
private Elements findElements() { if (tq.matchChomp("#")) { return byId(); } else if (tq.matchChomp(".")) { return byClass(); <BUGS> } else if (tq.matchesWord()) { return byTag(); } else if (tq.matches("[")) { return byAttribute(); } else if (tq.matchChomp("*")) { <BUGE> return allElements(); } else if (tq.matchChomp(":lt(")) { return indexLessThan(); } else if (tq.matchChomp(":gt(")) { return indexGreaterThan(); } else if (tq.matchChomp(":eq(")) { return indexEquals(); } else if (tq.matches(":has(")) { return has(); } else if (tq.matches(":contains(")) { return contains(false); } else if (tq.matches(":containsOwn(")) { return contains(true); } else if (tq.matches(":matches(")) { return matches(false); } else if (tq.matches(":matchesOwn(")) { return matches(true); } else if (tq.matches(":not(")) { return not();
private Elements findElements() { if (tq.matchChomp("#")) { return byId(); } else if (tq.matchChomp(".")) { return byClass(); } else if (tq.matchesWord()) { return byTag(); } else if (tq.matches("[")) { return byAttribute(); } else if (tq.matchChomp("*")) { return allElements(); <BUGS> } else if (tq.matchChomp(":lt(")) { <BUGE> return indexLessThan(); } else if (tq.matchChomp(":gt(")) { return indexGreaterThan(); } else if (tq.matchChomp(":eq(")) { return indexEquals(); } else if (tq.matches(":has(")) { return has(); } else if (tq.matches(":contains(")) { return contains(false); } else if (tq.matches(":containsOwn(")) { return contains(true); } else if (tq.matches(":matches(")) { return matches(false); } else if (tq.matches(":matchesOwn(")) { return matches(true); } else if (tq.matches(":not(")) { return not();
private Elements findElements() { if (tq.matchChomp("#")) { return byId(); } else if (tq.matchChomp(".")) { return byClass(); } else if (tq.matchesWord()) { return byTag(); } else if (tq.matches("[")) { return byAttribute(); } else if (tq.matchChomp("*")) { return allElements(); } else if (tq.matchChomp(":lt(")) { return indexLessThan(); <BUGS> } else if (tq.matchChomp(":gt(")) { <BUGE> return indexGreaterThan(); } else if (tq.matchChomp(":eq(")) { return indexEquals(); } else if (tq.matches(":has(")) { return has(); } else if (tq.matches(":contains(")) { return contains(false); } else if (tq.matches(":containsOwn(")) { return contains(true); } else if (tq.matches(":matches(")) { return matches(false); } else if (tq.matches(":matchesOwn(")) { return matches(true); } else if (tq.matches(":not(")) { return not();
private Elements findElements() { if (tq.matchChomp("#")) { return byId(); } else if (tq.matchChomp(".")) { return byClass(); } else if (tq.matchesWord()) { return byTag(); } else if (tq.matches("[")) { return byAttribute(); } else if (tq.matchChomp("*")) { return allElements(); } else if (tq.matchChomp(":lt(")) { return indexLessThan(); } else if (tq.matchChomp(":gt(")) { return indexGreaterThan(); <BUGS> } else if (tq.matchChomp(":eq(")) { <BUGE> return indexEquals(); } else if (tq.matches(":has(")) { return has(); } else if (tq.matches(":contains(")) { return contains(false); } else if (tq.matches(":containsOwn(")) { return contains(true); } else if (tq.matches(":matches(")) { return matches(false); } else if (tq.matches(":matchesOwn(")) { return matches(true); } else if (tq.matches(":not(")) { return not();
private Elements findElements() { if (tq.matchChomp("#")) { return byId(); } else if (tq.matchChomp(".")) { return byClass(); } else if (tq.matchesWord()) { return byTag(); } else if (tq.matches("[")) { return byAttribute(); } else if (tq.matchChomp("*")) { return allElements(); } else if (tq.matchChomp(":lt(")) { return indexLessThan(); } else if (tq.matchChomp(":gt(")) { return indexGreaterThan(); } else if (tq.matchChomp(":eq(")) { return indexEquals(); <BUGS> } else if (tq.matches(":has(")) { <BUGE> return has(); } else if (tq.matches(":contains(")) { return contains(false); } else if (tq.matches(":containsOwn(")) { return contains(true); } else if (tq.matches(":matches(")) { return matches(false); } else if (tq.matches(":matchesOwn(")) { return matches(true); } else if (tq.matches(":not(")) { return not();
private Elements findElements() { if (tq.matchChomp("#")) { return byId(); } else if (tq.matchChomp(".")) { return byClass(); } else if (tq.matchesWord()) { return byTag(); } else if (tq.matches("[")) { return byAttribute(); } else if (tq.matchChomp("*")) { return allElements(); } else if (tq.matchChomp(":lt(")) { return indexLessThan(); } else if (tq.matchChomp(":gt(")) { return indexGreaterThan(); } else if (tq.matchChomp(":eq(")) { return indexEquals(); } else if (tq.matches(":has(")) { return has(); <BUGS> } else if (tq.matches(":contains(")) { <BUGE> return contains(false); } else if (tq.matches(":containsOwn(")) { return contains(true); } else if (tq.matches(":matches(")) { return matches(false); } else if (tq.matches(":matchesOwn(")) { return matches(true); } else if (tq.matches(":not(")) { return not();
private Elements findElements() { if (tq.matchChomp("#")) { return byId(); } else if (tq.matchChomp(".")) { return byClass(); } else if (tq.matchesWord()) { return byTag(); } else if (tq.matches("[")) { return byAttribute(); } else if (tq.matchChomp("*")) { return allElements(); } else if (tq.matchChomp(":lt(")) { return indexLessThan(); } else if (tq.matchChomp(":gt(")) { return indexGreaterThan(); } else if (tq.matchChomp(":eq(")) { return indexEquals(); } else if (tq.matches(":has(")) { return has(); } else if (tq.matches(":contains(")) { return contains(false); <BUGS> } else if (tq.matches(":containsOwn(")) { <BUGE> return contains(true); } else if (tq.matches(":matches(")) { return matches(false); } else if (tq.matches(":matchesOwn(")) { return matches(true); } else if (tq.matches(":not(")) { return not();
private Elements findElements() { if (tq.matchChomp("#")) { return byId(); } else if (tq.matchChomp(".")) { return byClass(); } else if (tq.matchesWord()) { return byTag(); } else if (tq.matches("[")) { return byAttribute(); } else if (tq.matchChomp("*")) { return allElements(); } else if (tq.matchChomp(":lt(")) { return indexLessThan(); } else if (tq.matchChomp(":gt(")) { return indexGreaterThan(); } else if (tq.matchChomp(":eq(")) { return indexEquals(); } else if (tq.matches(":has(")) { return has(); } else if (tq.matches(":contains(")) { return contains(false); } else if (tq.matches(":containsOwn(")) { return contains(true); <BUGS> } else if (tq.matches(":matches(")) { <BUGE> return matches(false); } else if (tq.matches(":matchesOwn(")) { return matches(true); } else if (tq.matches(":not(")) { return not();
private Elements findElements() { if (tq.matchChomp("#")) { return byId(); } else if (tq.matchChomp(".")) { return byClass(); } else if (tq.matchesWord()) { return byTag(); } else if (tq.matches("[")) { return byAttribute(); } else if (tq.matchChomp("*")) { return allElements(); } else if (tq.matchChomp(":lt(")) { return indexLessThan(); } else if (tq.matchChomp(":gt(")) { return indexGreaterThan(); } else if (tq.matchChomp(":eq(")) { return indexEquals(); } else if (tq.matches(":has(")) { return has(); } else if (tq.matches(":contains(")) { return contains(false); } else if (tq.matches(":containsOwn(")) { return contains(true); } else if (tq.matches(":matches(")) { return matches(false); <BUGS> } else if (tq.matches(":matchesOwn(")) { <BUGE> return matches(true); } else if (tq.matches(":not(")) { return not();
private Elements findElements() { if (tq.matchChomp("#")) { return byId(); } else if (tq.matchChomp(".")) { return byClass(); } else if (tq.matchesWord()) { return byTag(); } else if (tq.matches("[")) { return byAttribute(); } else if (tq.matchChomp("*")) { return allElements(); } else if (tq.matchChomp(":lt(")) { return indexLessThan(); } else if (tq.matchChomp(":gt(")) { return indexGreaterThan(); } else if (tq.matchChomp(":eq(")) { return indexEquals(); } else if (tq.matches(":has(")) { return has(); } else if (tq.matches(":contains(")) { return contains(false); } else if (tq.matches(":containsOwn(")) { return contains(true); } else if (tq.matches(":matches(")) { return matches(false); } else if (tq.matches(":matchesOwn(")) { return matches(true); <BUGS> } else if (tq.matches(":not(")) { <BUGE> return not();
if (combinator == '>') output = filterForChildren(elements, select(subQuery, elements)); else if (combinator == ' ') output = filterForDescendants(elements, select(subQuery, elements)); else if (combinator == '+') output = filterForAdjacentSiblings(elements, select(subQuery, root)); else if (combinator == '~') output = filterForGeneralSiblings(elements, select(subQuery, root)); else throw new IllegalStateException("Unknown combinator: " + combinator);  elements.clear(); elements.addAll(output); }  } else { /* unhandled*/ <BUGS> throw new SelectorParseException("Could not parse query '%s': unexpected token at '%s'", query, tq.remainder()); <BUGE> } }  private void addElements(Collection<Element> add) { elements.addAll(add); }  private void intersectElements(Collection<Element> intersect) { elements.retainAll(intersect); }  private Elements byId() { String id = tq.consumeCssIdentifier(); Validate.notEmpty(id);
*/ public String attr(String attributeKey) { <BUGS> for (Element element : contents) { if (element.hasAttr(attributeKey)) <BUGE> return element.attr(attributeKey); } return ""; }
*/ public String attr(String attributeKey) { for (Element element : contents) { if (element.hasAttr(attributeKey)) return element.attr(attributeKey); <BUGS> } return ""; <BUGE> }
*/ public String data() { <BUGS> StringBuilder sb = new StringBuilder(); <BUGE>  for (Node childNode : childNodes) { if (childNode instanceof DataNode) { DataNode data = (DataNode) childNode; sb.append(data.getWholeData()); } else if (childNode instanceof Element) { Element element = (Element) childNode; String elementData = element.data(); sb.append(elementData); } } return sb.toString(); }
*/ public String data() { StringBuilder sb = new StringBuilder();  <BUGS> for (Node childNode : childNodes) { if (childNode instanceof DataNode) { DataNode data = (DataNode) childNode; sb.append(data.getWholeData()); } else if (childNode instanceof Element) { <BUGE> Element element = (Element) childNode; String elementData = element.data(); sb.append(elementData); } } return sb.toString(); }
*/ public String data() { StringBuilder sb = new StringBuilder();  for (Node childNode : childNodes) { if (childNode instanceof DataNode) { DataNode data = (DataNode) childNode; sb.append(data.getWholeData()); } else if (childNode instanceof Element) { Element element = (Element) childNode; String elementData = element.data(); sb.append(elementData); } <BUGS> } return sb.toString(); <BUGE> }
*/ public Whitelist addProtocols(String tag, String key, String... protocols) { <BUGS> Validate.notEmpty(tag); Validate.notEmpty(key); Validate.notNull(protocols); <BUGE>  TagName tagName = TagName.valueOf(tag); AttributeKey attrKey = AttributeKey.valueOf(key); Map<AttributeKey, Set<Protocol>> attrMap; Set<Protocol> protSet;  if (this.protocols.containsKey(tagName)) { attrMap = this.protocols.get(tagName); } else { attrMap = new HashMap<AttributeKey, Set<Protocol>>(); this.protocols.put(tagName, attrMap); } if (attrMap.containsKey(attrKey)) { protSet = attrMap.get(attrKey); } else { protSet = new HashSet<Protocol>(); attrMap.put(attrKey, protSet); } for (String protocol : protocols) { Validate.notEmpty(protocol); Protocol prot = Protocol.valueOf(protocol); protSet.add(prot); } return this; }
*/ public Whitelist addProtocols(String tag, String key, String... protocols) { Validate.notEmpty(tag); Validate.notEmpty(key); Validate.notNull(protocols);  <BUGS> TagName tagName = TagName.valueOf(tag); AttributeKey attrKey = AttributeKey.valueOf(key); <BUGE> Map<AttributeKey, Set<Protocol>> attrMap; Set<Protocol> protSet;  if (this.protocols.containsKey(tagName)) { attrMap = this.protocols.get(tagName); } else { attrMap = new HashMap<AttributeKey, Set<Protocol>>(); this.protocols.put(tagName, attrMap); } if (attrMap.containsKey(attrKey)) { protSet = attrMap.get(attrKey); } else { protSet = new HashSet<Protocol>(); attrMap.put(attrKey, protSet); } for (String protocol : protocols) { Validate.notEmpty(protocol); Protocol prot = Protocol.valueOf(protocol); protSet.add(prot); } return this; }
*/ public Whitelist addProtocols(String tag, String key, String... protocols) { Validate.notEmpty(tag); Validate.notEmpty(key); Validate.notNull(protocols);  TagName tagName = TagName.valueOf(tag); AttributeKey attrKey = AttributeKey.valueOf(key); Map<AttributeKey, Set<Protocol>> attrMap; Set<Protocol> protSet;  <BUGS> if (this.protocols.containsKey(tagName)) { attrMap = this.protocols.get(tagName); <BUGE> } else { attrMap = new HashMap<AttributeKey, Set<Protocol>>(); this.protocols.put(tagName, attrMap); } if (attrMap.containsKey(attrKey)) { protSet = attrMap.get(attrKey); } else { protSet = new HashSet<Protocol>(); attrMap.put(attrKey, protSet); } for (String protocol : protocols) { Validate.notEmpty(protocol); Protocol prot = Protocol.valueOf(protocol); protSet.add(prot); } return this; }
*/ public Whitelist addProtocols(String tag, String key, String... protocols) { Validate.notEmpty(tag); Validate.notEmpty(key); Validate.notNull(protocols);  TagName tagName = TagName.valueOf(tag); AttributeKey attrKey = AttributeKey.valueOf(key); Map<AttributeKey, Set<Protocol>> attrMap; Set<Protocol> protSet;  if (this.protocols.containsKey(tagName)) { attrMap = this.protocols.get(tagName); } else { <BUGS> attrMap = new HashMap<AttributeKey, Set<Protocol>>(); this.protocols.put(tagName, attrMap); <BUGE> } if (attrMap.containsKey(attrKey)) { protSet = attrMap.get(attrKey); } else { protSet = new HashSet<Protocol>(); attrMap.put(attrKey, protSet); } for (String protocol : protocols) { Validate.notEmpty(protocol); Protocol prot = Protocol.valueOf(protocol); protSet.add(prot); } return this; }
*/ public Whitelist addProtocols(String tag, String key, String... protocols) { Validate.notEmpty(tag); Validate.notEmpty(key); Validate.notNull(protocols);  TagName tagName = TagName.valueOf(tag); AttributeKey attrKey = AttributeKey.valueOf(key); Map<AttributeKey, Set<Protocol>> attrMap; Set<Protocol> protSet;  if (this.protocols.containsKey(tagName)) { attrMap = this.protocols.get(tagName); } else { attrMap = new HashMap<AttributeKey, Set<Protocol>>(); this.protocols.put(tagName, attrMap); } <BUGS> if (attrMap.containsKey(attrKey)) { protSet = attrMap.get(attrKey); <BUGE> } else { protSet = new HashSet<Protocol>(); attrMap.put(attrKey, protSet); } for (String protocol : protocols) { Validate.notEmpty(protocol); Protocol prot = Protocol.valueOf(protocol); protSet.add(prot); } return this; }
*/ public Whitelist addProtocols(String tag, String key, String... protocols) { Validate.notEmpty(tag); Validate.notEmpty(key); Validate.notNull(protocols);  TagName tagName = TagName.valueOf(tag); AttributeKey attrKey = AttributeKey.valueOf(key); Map<AttributeKey, Set<Protocol>> attrMap; Set<Protocol> protSet;  if (this.protocols.containsKey(tagName)) { attrMap = this.protocols.get(tagName); } else { attrMap = new HashMap<AttributeKey, Set<Protocol>>(); this.protocols.put(tagName, attrMap); } if (attrMap.containsKey(attrKey)) { protSet = attrMap.get(attrKey); } else { <BUGS> protSet = new HashSet<Protocol>(); attrMap.put(attrKey, protSet); <BUGE> } for (String protocol : protocols) { Validate.notEmpty(protocol); Protocol prot = Protocol.valueOf(protocol); protSet.add(prot); } return this; }
*/ public Whitelist addProtocols(String tag, String key, String... protocols) { Validate.notEmpty(tag); Validate.notEmpty(key); Validate.notNull(protocols);  TagName tagName = TagName.valueOf(tag); AttributeKey attrKey = AttributeKey.valueOf(key); Map<AttributeKey, Set<Protocol>> attrMap; Set<Protocol> protSet;  if (this.protocols.containsKey(tagName)) { attrMap = this.protocols.get(tagName); } else { attrMap = new HashMap<AttributeKey, Set<Protocol>>(); this.protocols.put(tagName, attrMap); } if (attrMap.containsKey(attrKey)) { protSet = attrMap.get(attrKey); } else { protSet = new HashSet<Protocol>(); attrMap.put(attrKey, protSet); } <BUGS> for (String protocol : protocols) { Validate.notEmpty(protocol); Protocol prot = Protocol.valueOf(protocol); protSet.add(prot); <BUGE> } return this; }
*/ public Whitelist addProtocols(String tag, String key, String... protocols) { Validate.notEmpty(tag); Validate.notEmpty(key); Validate.notNull(protocols);  TagName tagName = TagName.valueOf(tag); AttributeKey attrKey = AttributeKey.valueOf(key); Map<AttributeKey, Set<Protocol>> attrMap; Set<Protocol> protSet;  if (this.protocols.containsKey(tagName)) { attrMap = this.protocols.get(tagName); } else { attrMap = new HashMap<AttributeKey, Set<Protocol>>(); this.protocols.put(tagName, attrMap); } if (attrMap.containsKey(attrKey)) { protSet = attrMap.get(attrKey); } else { protSet = new HashSet<Protocol>(); attrMap.put(attrKey, protSet); } for (String protocol : protocols) { Validate.notEmpty(protocol); Protocol prot = Protocol.valueOf(protocol); protSet.add(prot); } <BUGS> return this; <BUGE> }
*/ public List<Node> siblingNodes() {  <BUGS> return parent().childNodes(); <BUGE> }
*/ public static Document parse(String html) { <BUGS> return Parser.parse(html, ""); <BUGE> }
*/ public void title(String title) { <BUGS> Validate.notNull(title); Element titleEl = getElementsByTag("title").first(); if (titleEl == null) { /* add to head*/ head().appendElement("title").text(title); <BUGE> } else { titleEl.text(title); } }
*/ public void title(String title) { Validate.notNull(title); Element titleEl = getElementsByTag("title").first(); if (titleEl == null) { /* add to head*/ head().appendElement("title").text(title); } else { <BUGS> titleEl.text(title); <BUGE> } }
*/ public void title(String title) { Validate.notNull(title); Element titleEl = getElementsByTag("title").first(); if (titleEl == null) { /* add to head*/ head().appendElement("title").text(title); } else { titleEl.text(title); } <BUGS> } <BUGE>
*/ public static boolean isValid(String bodyHtml, Whitelist whitelist) { <BUGS> Document dirty = parseBodyFragment(bodyHtml, ""); Cleaner cleaner = new Cleaner(whitelist); return cleaner.isValid(dirty); <BUGE> }
@Override protected boolean process(Token token) { /* start tag, end tag, doctype, comment, character, eof*/ <BUGS> switch (token.type) { <BUGE> case StartTag: insert(token.asStartTag()); break; case EndTag: popStackToClose(token.asEndTag()); break; case Comment: insert(token.asComment()); break; case Character: insert(token.asCharacter()); break; case Doctype: insert(token.asDoctype()); break; case EOF: /* could put some normalisation here if desired*/ break; default: Validate.fail("Unexpected token type: " + token.type); } return true; }
@Override protected boolean process(Token token) { /* start tag, end tag, doctype, comment, character, eof*/ switch (token.type) { case StartTag: <BUGS> insert(token.asStartTag()); break; <BUGE> case EndTag: popStackToClose(token.asEndTag()); break; case Comment: insert(token.asComment()); break; case Character: insert(token.asCharacter()); break; case Doctype: insert(token.asDoctype()); break; case EOF: /* could put some normalisation here if desired*/ break; default: Validate.fail("Unexpected token type: " + token.type); } return true; }
@Override protected boolean process(Token token) { /* start tag, end tag, doctype, comment, character, eof*/ switch (token.type) { case StartTag: insert(token.asStartTag()); break; case EndTag: <BUGS> popStackToClose(token.asEndTag()); break; <BUGE> case Comment: insert(token.asComment()); break; case Character: insert(token.asCharacter()); break; case Doctype: insert(token.asDoctype()); break; case EOF: /* could put some normalisation here if desired*/ break; default: Validate.fail("Unexpected token type: " + token.type); } return true; }
@Override protected boolean process(Token token) { /* start tag, end tag, doctype, comment, character, eof*/ switch (token.type) { case StartTag: insert(token.asStartTag()); break; case EndTag: popStackToClose(token.asEndTag()); break; case Comment: <BUGS> insert(token.asComment()); break; <BUGE> case Character: insert(token.asCharacter()); break; case Doctype: insert(token.asDoctype()); break; case EOF: /* could put some normalisation here if desired*/ break; default: Validate.fail("Unexpected token type: " + token.type); } return true; }
@Override protected boolean process(Token token) { /* start tag, end tag, doctype, comment, character, eof*/ switch (token.type) { case StartTag: insert(token.asStartTag()); break; case EndTag: popStackToClose(token.asEndTag()); break; case Comment: insert(token.asComment()); break; case Character: <BUGS> insert(token.asCharacter()); break; <BUGE> case Doctype: insert(token.asDoctype()); break; case EOF: /* could put some normalisation here if desired*/ break; default: Validate.fail("Unexpected token type: " + token.type); } return true; }
@Override protected boolean process(Token token) { /* start tag, end tag, doctype, comment, character, eof*/ switch (token.type) { case StartTag: insert(token.asStartTag()); break; case EndTag: popStackToClose(token.asEndTag()); break; case Comment: insert(token.asComment()); break; case Character: insert(token.asCharacter()); break; case Doctype: insert(token.asDoctype()); break; case EOF: /* could put some normalisation here if desired*/ <BUGS> break; <BUGE> default: Validate.fail("Unexpected token type: " + token.type); } return true; }
@Override protected boolean process(Token token) { /* start tag, end tag, doctype, comment, character, eof*/ switch (token.type) { case StartTag: insert(token.asStartTag()); break; case EndTag: popStackToClose(token.asEndTag()); break; case Comment: insert(token.asComment()); break; case Character: insert(token.asCharacter()); break; case Doctype: insert(token.asDoctype()); break; case EOF: /* could put some normalisation here if desired*/ break; default: Validate.fail("Unexpected token type: " + token.type); } <BUGS> return true; <BUGE> }
@Override public Attributes clone() { <BUGS> if (attributes == null) <BUGE> return new Attributes();  Attributes clone; try { clone = (Attributes) super.clone(); } catch (CloneNotSupportedException e) { throw new RuntimeException(e); } clone.attributes = new LinkedHashMap<String, Attribute>(attributes.size()); for (Attribute attribute: this) clone.attributes.put(attribute.getKey(), attribute.clone()); return clone; }
@Override public Attributes clone() { if (attributes == null) return new Attributes();  Attributes clone; try { <BUGS> clone = (Attributes) super.clone(); <BUGE> } catch (CloneNotSupportedException e) { throw new RuntimeException(e); } clone.attributes = new LinkedHashMap<String, Attribute>(attributes.size()); for (Attribute attribute: this) clone.attributes.put(attribute.getKey(), attribute.clone()); return clone; }
@Override public Attributes clone() { if (attributes == null) return new Attributes();  Attributes clone; try { clone = (Attributes) super.clone(); } catch (CloneNotSupportedException e) { throw new RuntimeException(e); <BUGS> } clone.attributes = new LinkedHashMap<String, Attribute>(attributes.size()); for (Attribute attribute: this) clone.attributes.put(attribute.getKey(), attribute.clone()); return clone; <BUGE> }
*/ static String getCharsetFromContentType(String contentType) { <BUGS> if (contentType == null) return null; Matcher m = charsetPattern.matcher(contentType); if (m.find()) { String charset = m.group(1).trim(); if (Charset.isSupported(charset)) return charset; charset = charset.toUpperCase(Locale.ENGLISH); if (Charset.isSupported(charset)) return charset; <BUGE> /* if our advanced charset matching fails.... we just take the default*/ } return null; }
*/ static String getCharsetFromContentType(String contentType) { if (contentType == null) return null; Matcher m = charsetPattern.matcher(contentType); if (m.find()) { String charset = m.group(1).trim(); if (Charset.isSupported(charset)) return charset; charset = charset.toUpperCase(Locale.ENGLISH); if (Charset.isSupported(charset)) return charset; /* if our advanced charset matching fails.... we just take the default*/ } <BUGS> return null; <BUGE> }
*/ public OutputSettings prettyPrint(boolean pretty) { <BUGS> prettyPrint = pretty; return this; <BUGE> }
*/ public static void notEmpty(String string) { <BUGS> if (string == null || string.length() == 0) throw new IllegalArgumentException("String must not be empty"); } <BUGE>
@Override public boolean equals(Object o) { <BUGS> if (this == o) return true; if (!(o instanceof Attribute)) return false; <BUGE>  Attribute attribute = (Attribute) o;  if (key != null ? !key.equals(attribute.key) : attribute.key != null) return false; if (value != null ? !value.equals(attribute.value) : attribute.value != null) return false;  return true; }
@Override public boolean equals(Object o) { if (this == o) return true; if (!(o instanceof Attribute)) return false;  <BUGS> Attribute attribute = (Attribute) o; <BUGE>  if (key != null ? !key.equals(attribute.key) : attribute.key != null) return false; if (value != null ? !value.equals(attribute.value) : attribute.value != null) return false;  return true; }
@Override public boolean equals(Object o) { if (this == o) return true; if (!(o instanceof Attribute)) return false;  Attribute attribute = (Attribute) o;  <BUGS> if (key != null ? !key.equals(attribute.key) : attribute.key != null) return false; if (value != null ? !value.equals(attribute.value) : attribute.value != null) return false; <BUGE>  return true; }
@Override public boolean equals(Object o) { if (this == o) return true; if (!(o instanceof Attribute)) return false;  Attribute attribute = (Attribute) o;  if (key != null ? !key.equals(attribute.key) : attribute.key != null) return false; if (value != null ? !value.equals(attribute.value) : attribute.value != null) return false;  <BUGS> return true; <BUGE> }
*/ public Element nextElementSibling() { <BUGS> if (parentNode == null) return null; List<Element> siblings = parent().children(); Integer index = indexInList(this, siblings); Validate.notNull(index); if (siblings.size() > index+1) return siblings.get(index+1); <BUGE> else return null; }
/* this method is ugly, and does a lot. but other breakups cause rescanning and stringbuilder generations*/ static void escape(StringBuilder accum, String string, Document.OutputSettings out, boolean inAttribute, boolean normaliseWhite, boolean stripLeadingWhite) {  <BUGS> boolean lastWasWhite = false; boolean reachedNonWhite = false; final EscapeMode escapeMode = out.escapeMode(); final CharsetEncoder encoder = out.encoder(); final CoreCharset coreCharset = CoreCharset.byName(encoder.charset().name()); final Map<Character, String> map = escapeMode.getMap(); final int length = string.length(); <BUGE>  int codePoint; for (int offset = 0; offset < length; offset += Character.charCount(codePoint)) { codePoint = string.codePointAt(offset);  if (normaliseWhite) { if (StringUtil.isWhitespace(codePoint)) { if ((stripLeadingWhite && !reachedNonWhite) || lastWasWhite) continue; accum.append(' '); lastWasWhite = true; continue; } else { lastWasWhite = false; reachedNonWhite = true; } } /* surrogate pairs, split implementation for efficiency on single char common case (saves creating strings, char[]):*/ if (codePoint < Character.MIN_SUPPLEMENTARY_CODE_POINT) {
/* this method is ugly, and does a lot. but other breakups cause rescanning and stringbuilder generations*/ static void escape(StringBuilder accum, String string, Document.OutputSettings out, boolean inAttribute, boolean normaliseWhite, boolean stripLeadingWhite) {  boolean lastWasWhite = false; boolean reachedNonWhite = false; final EscapeMode escapeMode = out.escapeMode(); final CharsetEncoder encoder = out.encoder(); final CoreCharset coreCharset = CoreCharset.byName(encoder.charset().name()); final Map<Character, String> map = escapeMode.getMap(); final int length = string.length();  int codePoint; <BUGS> for (int offset = 0; offset < length; offset += Character.charCount(codePoint)) { codePoint = string.codePointAt(offset); <BUGE>  if (normaliseWhite) { if (StringUtil.isWhitespace(codePoint)) { if ((stripLeadingWhite && !reachedNonWhite) || lastWasWhite) continue; accum.append(' '); lastWasWhite = true; continue; } else { lastWasWhite = false; reachedNonWhite = true; } } /* surrogate pairs, split implementation for efficiency on single char common case (saves creating strings, char[]):*/ if (codePoint < Character.MIN_SUPPLEMENTARY_CODE_POINT) {
/* this method is ugly, and does a lot. but other breakups cause rescanning and stringbuilder generations*/ static void escape(StringBuilder accum, String string, Document.OutputSettings out, boolean inAttribute, boolean normaliseWhite, boolean stripLeadingWhite) {  boolean lastWasWhite = false; boolean reachedNonWhite = false; final EscapeMode escapeMode = out.escapeMode(); final CharsetEncoder encoder = out.encoder(); final CoreCharset coreCharset = CoreCharset.byName(encoder.charset().name()); final Map<Character, String> map = escapeMode.getMap(); final int length = string.length();  int codePoint; for (int offset = 0; offset < length; offset += Character.charCount(codePoint)) { codePoint = string.codePointAt(offset);  <BUGS> if (normaliseWhite) { if (StringUtil.isWhitespace(codePoint)) { <BUGE> if ((stripLeadingWhite && !reachedNonWhite) || lastWasWhite) continue; accum.append(' '); lastWasWhite = true; continue; } else { lastWasWhite = false; reachedNonWhite = true; } } /* surrogate pairs, split implementation for efficiency on single char common case (saves creating strings, char[]):*/ if (codePoint < Character.MIN_SUPPLEMENTARY_CODE_POINT) {
/* this method is ugly, and does a lot. but other breakups cause rescanning and stringbuilder generations*/ static void escape(StringBuilder accum, String string, Document.OutputSettings out, boolean inAttribute, boolean normaliseWhite, boolean stripLeadingWhite) {  boolean lastWasWhite = false; boolean reachedNonWhite = false; final EscapeMode escapeMode = out.escapeMode(); final CharsetEncoder encoder = out.encoder(); final CoreCharset coreCharset = CoreCharset.byName(encoder.charset().name()); final Map<Character, String> map = escapeMode.getMap(); final int length = string.length();  int codePoint; for (int offset = 0; offset < length; offset += Character.charCount(codePoint)) { codePoint = string.codePointAt(offset);  if (normaliseWhite) { if (StringUtil.isWhitespace(codePoint)) { if ((stripLeadingWhite && !reachedNonWhite) || lastWasWhite) continue; accum.append(' '); lastWasWhite = true; continue; } else { <BUGS> lastWasWhite = false; reachedNonWhite = true; <BUGE> } } /* surrogate pairs, split implementation for efficiency on single char common case (saves creating strings, char[]):*/ if (codePoint < Character.MIN_SUPPLEMENTARY_CODE_POINT) {
/* this method is ugly, and does a lot. but other breakups cause rescanning and stringbuilder generations*/ static void escape(StringBuilder accum, String string, Document.OutputSettings out, boolean inAttribute, boolean normaliseWhite, boolean stripLeadingWhite) {  boolean lastWasWhite = false; boolean reachedNonWhite = false; final EscapeMode escapeMode = out.escapeMode(); final CharsetEncoder encoder = out.encoder(); final CoreCharset coreCharset = CoreCharset.byName(encoder.charset().name()); final Map<Character, String> map = escapeMode.getMap(); final int length = string.length();  int codePoint; for (int offset = 0; offset < length; offset += Character.charCount(codePoint)) { codePoint = string.codePointAt(offset);  if (normaliseWhite) { if (StringUtil.isWhitespace(codePoint)) { if ((stripLeadingWhite && !reachedNonWhite) || lastWasWhite) continue; accum.append(' '); lastWasWhite = true; continue; } else { lastWasWhite = false; reachedNonWhite = true; } } /* surrogate pairs, split implementation for efficiency on single char common case (saves creating strings, char[]):*/ <BUGS> if (codePoint < Character.MIN_SUPPLEMENTARY_CODE_POINT) {
* Get the Character value of the named entity * @param name named entity (e.g. "lt" or "amp") * @return the Character value of the named entity (e.g. '{@literal <}' or '{@literal &}') */ public static Character getCharacterByName(String name) { return full.get(name); }  static String escape(String string, Document.OutputSettings out) { StringBuilder accum = new StringBuilder(string.length() * 2); escape(accum, string, out, false, false, false); return accum.toString(); }  /* html specific and required escapes:*/ <BUGS> switch (c) { <BUGE> case '&': accum.append("&amp;"); break; case 0xA0: if (escapeMode != EscapeMode.xhtml) accum.append("&nbsp;"); else accum.append(c); break; case '<': if (!inAttribute) accum.append("&lt;"); else accum.append(c);
* Get the Character value of the named entity * @param name named entity (e.g. "lt" or "amp") * @return the Character value of the named entity (e.g. '{@literal <}' or '{@literal &}') */ public static Character getCharacterByName(String name) { return full.get(name); }  static String escape(String string, Document.OutputSettings out) { StringBuilder accum = new StringBuilder(string.length() * 2); escape(accum, string, out, false, false, false); return accum.toString(); }  case 0xA0: <BUGS> if (escapeMode != EscapeMode.xhtml) <BUGE> accum.append("&nbsp;"); else accum.append(c); break; case '<': if (!inAttribute) accum.append("&lt;"); else accum.append(c); break; case '>': if (!inAttribute) accum.append("&gt;"); else
* Get the Character value of the named entity * @param name named entity (e.g. "lt" or "amp") * @return the Character value of the named entity (e.g. '{@literal <}' or '{@literal &}') */ public static Character getCharacterByName(String name) { return full.get(name); }  static String escape(String string, Document.OutputSettings out) { StringBuilder accum = new StringBuilder(string.length() * 2); escape(accum, string, out, false, false, false); return accum.toString(); }  else <BUGS> accum.append(c); break; <BUGE> case '<': if (!inAttribute) accum.append("&lt;"); else accum.append(c); break; case '>': if (!inAttribute) accum.append("&gt;"); else accum.append(c); break; case '"':
* Get the Character value of the named entity * @param name named entity (e.g. "lt" or "amp") * @return the Character value of the named entity (e.g. '{@literal <}' or '{@literal &}') */ public static Character getCharacterByName(String name) { return full.get(name); }  static String escape(String string, Document.OutputSettings out) { StringBuilder accum = new StringBuilder(string.length() * 2); escape(accum, string, out, false, false, false); return accum.toString(); }  default: <BUGS> if (canEncode(coreCharset, c, encoder)) accum.append(c); <BUGE> else if (map.containsKey(c)) accum.append('&').append(map.get(c)).append(';'); else accum.append("&#x").append(Integer.toHexString(codePoint)).append(';'); } } else { final String c = new String(Character.toChars(codePoint)); if (encoder.canEncode(c)) /* uses fallback encoder for simplicity*/ accum.append(c); else accum.append("&#x").append(Integer.toHexString(codePoint)).append(';'); } }
* Get the Character value of the named entity * @param name named entity (e.g. "lt" or "amp") * @return the Character value of the named entity (e.g. '{@literal <}' or '{@literal &}') */ public static Character getCharacterByName(String name) { return full.get(name); }  static String escape(String string, Document.OutputSettings out) { StringBuilder accum = new StringBuilder(string.length() * 2); escape(accum, string, out, false, false, false); return accum.toString(); }  } <BUGS> } else { <BUGE> final String c = new String(Character.toChars(codePoint)); if (encoder.canEncode(c)) /* uses fallback encoder for simplicity*/ accum.append(c); else accum.append("&#x").append(Integer.toHexString(codePoint)).append(';'); } } }  static String unescape(String string) { return unescape(string, false); }  /**
* Get the Character value of the named entity * @param name named entity (e.g. "lt" or "amp") * @return the Character value of the named entity (e.g. '{@literal <}' or '{@literal &}') */ public static Character getCharacterByName(String name) { return full.get(name); }  static String escape(String string, Document.OutputSettings out) { StringBuilder accum = new StringBuilder(string.length() * 2); escape(accum, string, out, false, false, false); return accum.toString(); }  } <BUGS> } <BUGE>  static String unescape(String string) { return unescape(string, false); }  /** * Unescape the input string. * @param string to un-HTML-escape * @param strict if "strict" (that is, requires trailing ';' char, otherwise that's optional) * @return unescaped string */ static String unescape(String string, boolean strict) { return Parser.unescapeEntities(string, strict); }
/* this method is ugly, and does a lot. but other breakups cause rescanning and stringbuilder generations*/ static void escape(StringBuilder accum, String string, Document.OutputSettings out, boolean inAttribute, boolean normaliseWhite, boolean stripLeadingWhite) {  <BUGS> boolean lastWasWhite = false; boolean reachedNonWhite = false; final EscapeMode escapeMode = out.escapeMode(); final CharsetEncoder encoder = out.encoder(); final CoreCharset coreCharset = CoreCharset.byName(encoder.charset().name()); final Map<Character, String> map = escapeMode.getMap(); final int length = string.length(); <BUGE>  int codePoint; for (int offset = 0; offset < length; offset += Character.charCount(codePoint)) { codePoint = string.codePointAt(offset);  if (normaliseWhite) { if (StringUtil.isWhitespace(codePoint)) { if ((stripLeadingWhite && !reachedNonWhite) || lastWasWhite) continue; accum.append(' '); lastWasWhite = true; continue; } else { lastWasWhite = false; reachedNonWhite = true; } } /* surrogate pairs, split implementation for efficiency on single char common case (saves creating strings, char[]):*/ if (codePoint < Character.MIN_SUPPLEMENTARY_CODE_POINT) {
/* this method is ugly, and does a lot. but other breakups cause rescanning and stringbuilder generations*/ static void escape(StringBuilder accum, String string, Document.OutputSettings out, boolean inAttribute, boolean normaliseWhite, boolean stripLeadingWhite) {  boolean lastWasWhite = false; boolean reachedNonWhite = false; final EscapeMode escapeMode = out.escapeMode(); final CharsetEncoder encoder = out.encoder(); final CoreCharset coreCharset = CoreCharset.byName(encoder.charset().name()); final Map<Character, String> map = escapeMode.getMap(); final int length = string.length();  int codePoint; <BUGS> for (int offset = 0; offset < length; offset += Character.charCount(codePoint)) { codePoint = string.codePointAt(offset); <BUGE>  if (normaliseWhite) { if (StringUtil.isWhitespace(codePoint)) { if ((stripLeadingWhite && !reachedNonWhite) || lastWasWhite) continue; accum.append(' '); lastWasWhite = true; continue; } else { lastWasWhite = false; reachedNonWhite = true; } } /* surrogate pairs, split implementation for efficiency on single char common case (saves creating strings, char[]):*/ if (codePoint < Character.MIN_SUPPLEMENTARY_CODE_POINT) {
/* this method is ugly, and does a lot. but other breakups cause rescanning and stringbuilder generations*/ static void escape(StringBuilder accum, String string, Document.OutputSettings out, boolean inAttribute, boolean normaliseWhite, boolean stripLeadingWhite) {  boolean lastWasWhite = false; boolean reachedNonWhite = false; final EscapeMode escapeMode = out.escapeMode(); final CharsetEncoder encoder = out.encoder(); final CoreCharset coreCharset = CoreCharset.byName(encoder.charset().name()); final Map<Character, String> map = escapeMode.getMap(); final int length = string.length();  int codePoint; for (int offset = 0; offset < length; offset += Character.charCount(codePoint)) { codePoint = string.codePointAt(offset);  <BUGS> if (normaliseWhite) { if (StringUtil.isWhitespace(codePoint)) { <BUGE> if ((stripLeadingWhite && !reachedNonWhite) || lastWasWhite) continue; accum.append(' '); lastWasWhite = true; continue; } else { lastWasWhite = false; reachedNonWhite = true; } } /* surrogate pairs, split implementation for efficiency on single char common case (saves creating strings, char[]):*/ if (codePoint < Character.MIN_SUPPLEMENTARY_CODE_POINT) {
/* this method is ugly, and does a lot. but other breakups cause rescanning and stringbuilder generations*/ static void escape(StringBuilder accum, String string, Document.OutputSettings out, boolean inAttribute, boolean normaliseWhite, boolean stripLeadingWhite) {  boolean lastWasWhite = false; boolean reachedNonWhite = false; final EscapeMode escapeMode = out.escapeMode(); final CharsetEncoder encoder = out.encoder(); final CoreCharset coreCharset = CoreCharset.byName(encoder.charset().name()); final Map<Character, String> map = escapeMode.getMap(); final int length = string.length();  int codePoint; for (int offset = 0; offset < length; offset += Character.charCount(codePoint)) { codePoint = string.codePointAt(offset);  if (normaliseWhite) { if (StringUtil.isWhitespace(codePoint)) { if ((stripLeadingWhite && !reachedNonWhite) || lastWasWhite) continue; accum.append(' '); lastWasWhite = true; continue; } else { <BUGS> lastWasWhite = false; reachedNonWhite = true; <BUGE> } } /* surrogate pairs, split implementation for efficiency on single char common case (saves creating strings, char[]):*/ if (codePoint < Character.MIN_SUPPLEMENTARY_CODE_POINT) {
/* this method is ugly, and does a lot. but other breakups cause rescanning and stringbuilder generations*/ static void escape(StringBuilder accum, String string, Document.OutputSettings out, boolean inAttribute, boolean normaliseWhite, boolean stripLeadingWhite) {  boolean lastWasWhite = false; boolean reachedNonWhite = false; final EscapeMode escapeMode = out.escapeMode(); final CharsetEncoder encoder = out.encoder(); final CoreCharset coreCharset = CoreCharset.byName(encoder.charset().name()); final Map<Character, String> map = escapeMode.getMap(); final int length = string.length();  int codePoint; for (int offset = 0; offset < length; offset += Character.charCount(codePoint)) { codePoint = string.codePointAt(offset);  if (normaliseWhite) { if (StringUtil.isWhitespace(codePoint)) { if ((stripLeadingWhite && !reachedNonWhite) || lastWasWhite) continue; accum.append(' '); lastWasWhite = true; continue; } else { lastWasWhite = false; reachedNonWhite = true; } } /* surrogate pairs, split implementation for efficiency on single char common case (saves creating strings, char[]):*/ <BUGS> if (codePoint < Character.MIN_SUPPLEMENTARY_CODE_POINT) {
* Get the Character value of the named entity * @param name named entity (e.g. "lt" or "amp") * @return the Character value of the named entity (e.g. '{@literal <}' or '{@literal &}') */ public static Character getCharacterByName(String name) { return full.get(name); }  static String escape(String string, Document.OutputSettings out) { StringBuilder accum = new StringBuilder(string.length() * 2); escape(accum, string, out, false, false, false); return accum.toString(); }  /* html specific and required escapes:*/ <BUGS> switch (c) { <BUGE> case '&': accum.append("&amp;"); break; case 0xA0: if (escapeMode != EscapeMode.xhtml) accum.append("&nbsp;"); else accum.append("&#xa0;"); break; case '<': /* escape when in character data or when in a xml attribue val; not needed in html attr val*/ if (!inAttribute) accum.append("&lt;"); else
* Get the Character value of the named entity * @param name named entity (e.g. "lt" or "amp") * @return the Character value of the named entity (e.g. '{@literal <}' or '{@literal &}') */ public static Character getCharacterByName(String name) { return full.get(name); }  static String escape(String string, Document.OutputSettings out) { StringBuilder accum = new StringBuilder(string.length() * 2); escape(accum, string, out, false, false, false); return accum.toString(); }  /* escape when in character data or when in a xml attribue val; not needed in html attr val*/ <BUGS> if (!inAttribute) <BUGE> accum.append("&lt;"); else accum.append(c); break; case '>': if (!inAttribute) accum.append("&gt;"); else accum.append(c); break; case '"': if (inAttribute) accum.append("&quot;"); else
* Get the Character value of the named entity * @param name named entity (e.g. "lt" or "amp") * @return the Character value of the named entity (e.g. '{@literal <}' or '{@literal &}') */ public static Character getCharacterByName(String name) { return full.get(name); }  static String escape(String string, Document.OutputSettings out) { StringBuilder accum = new StringBuilder(string.length() * 2); escape(accum, string, out, false, false, false); return accum.toString(); }  else <BUGS> accum.append(c); break; <BUGE> case '>': if (!inAttribute) accum.append("&gt;"); else accum.append(c); break; case '"': if (inAttribute) accum.append("&quot;"); else accum.append(c); break; default:
* Get the Character value of the named entity * @param name named entity (e.g. "lt" or "amp") * @return the Character value of the named entity (e.g. '{@literal <}' or '{@literal &}') */ public static Character getCharacterByName(String name) { return full.get(name); }  static String escape(String string, Document.OutputSettings out) { StringBuilder accum = new StringBuilder(string.length() * 2); escape(accum, string, out, false, false, false); return accum.toString(); }  case '>': <BUGS> if (!inAttribute) <BUGE> accum.append("&gt;"); else accum.append(c); break; case '"': if (inAttribute) accum.append("&quot;"); else accum.append(c); break; default: if (canEncode(coreCharset, c, encoder)) accum.append(c); else if (map.containsKey(c))
* Get the Character value of the named entity * @param name named entity (e.g. "lt" or "amp") * @return the Character value of the named entity (e.g. '{@literal <}' or '{@literal &}') */ public static Character getCharacterByName(String name) { return full.get(name); }  static String escape(String string, Document.OutputSettings out) { StringBuilder accum = new StringBuilder(string.length() * 2); escape(accum, string, out, false, false, false); return accum.toString(); }  else <BUGS> accum.append(c); break; <BUGE> case '"': if (inAttribute) accum.append("&quot;"); else accum.append(c); break; default: if (canEncode(coreCharset, c, encoder)) accum.append(c); else if (map.containsKey(c)) accum.append('&').append(map.get(c)).append(';'); else accum.append("&#x").append(Integer.toHexString(codePoint)).append(';');
* Get the Character value of the named entity * @param name named entity (e.g. "lt" or "amp") * @return the Character value of the named entity (e.g. '{@literal <}' or '{@literal &}') */ public static Character getCharacterByName(String name) { return full.get(name); }  static String escape(String string, Document.OutputSettings out) { StringBuilder accum = new StringBuilder(string.length() * 2); escape(accum, string, out, false, false, false); return accum.toString(); }  default: <BUGS> if (canEncode(coreCharset, c, encoder)) accum.append(c); <BUGE> else if (map.containsKey(c)) accum.append('&').append(map.get(c)).append(';'); else accum.append("&#x").append(Integer.toHexString(codePoint)).append(';'); } } else { final String c = new String(Character.toChars(codePoint)); if (encoder.canEncode(c)) /* uses fallback encoder for simplicity*/ accum.append(c); else accum.append("&#x").append(Integer.toHexString(codePoint)).append(';'); } }
* Get the Character value of the named entity * @param name named entity (e.g. "lt" or "amp") * @return the Character value of the named entity (e.g. '{@literal <}' or '{@literal &}') */ public static Character getCharacterByName(String name) { return full.get(name); }  static String escape(String string, Document.OutputSettings out) { StringBuilder accum = new StringBuilder(string.length() * 2); escape(accum, string, out, false, false, false); return accum.toString(); }  } <BUGS> } else { <BUGE> final String c = new String(Character.toChars(codePoint)); if (encoder.canEncode(c)) /* uses fallback encoder for simplicity*/ accum.append(c); else accum.append("&#x").append(Integer.toHexString(codePoint)).append(';'); } } }  static String unescape(String string) { return unescape(string, false); }  /**
* Get the Character value of the named entity * @param name named entity (e.g. "lt" or "amp") * @return the Character value of the named entity (e.g. '{@literal <}' or '{@literal &}') */ public static Character getCharacterByName(String name) { return full.get(name); }  static String escape(String string, Document.OutputSettings out) { StringBuilder accum = new StringBuilder(string.length() * 2); escape(accum, string, out, false, false, false); return accum.toString(); }  } <BUGS> } <BUGE>  static String unescape(String string) { return unescape(string, false); }  /** * Unescape the input string. * @param string to un-HTML-escape * @param strict if "strict" (that is, requires trailing ';' char, otherwise that's optional) * @return unescaped string */ static String unescape(String string, boolean strict) { return Parser.unescapeEntities(string, strict); }
*/ public Element insertChildren(int index, Collection<? extends Node> children) { <BUGS> Validate.notNull(children, "Children collection to be inserted must not be null."); int currentSize = childNodeSize(); if (index < 0) index += currentSize +1; /* roll around*/ Validate.isTrue(index >= 0 && index <= currentSize, "Insert position out of bounds."); <BUGE>  ArrayList<Node> nodes = new ArrayList<Node>(children); Node[] nodeArray = nodes.toArray(new Node[nodes.size()]); addChildren(index, nodeArray); return this; }
*/ public Element insertChildren(int index, Collection<? extends Node> children) { Validate.notNull(children, "Children collection to be inserted must not be null."); int currentSize = childNodeSize(); if (index < 0) index += currentSize +1; /* roll around*/ Validate.isTrue(index >= 0 && index <= currentSize, "Insert position out of bounds.");  <BUGS> ArrayList<Node> nodes = new ArrayList<Node>(children); Node[] nodeArray = nodes.toArray(new Node[nodes.size()]); addChildren(index, nodeArray); return this; <BUGE> }
*/ public XmlDeclaration(String name, String baseUri, boolean isProcessingInstruction) { <BUGS> super(baseUri); Validate.notNull(name); this.name = name; this.isProcessingInstruction = isProcessingInstruction; } <BUGE>
private void findElements() { <BUGS> if (tq.matchChomp("#")) <BUGE> byId(); else if (tq.matchChomp(".")) byClass(); else if (tq.matchesWord()) byTag(); else if (tq.matches("[")) byAttribute(); else if (tq.matchChomp("*")) allElements(); else if (tq.matchChomp(":lt(")) indexLessThan(); else if (tq.matchChomp(":gt(")) indexGreaterThan(); else if (tq.matchChomp(":eq(")) indexEquals(); else if (tq.matches(":has(")) has(); else if (tq.matches(":contains(")) contains(false); else if (tq.matches(":containsOwn(")) contains(true); else if (tq.matches(":matches(")) matches(false); else if (tq.matches(":matchesOwn(")) matches(true); else if (tq.matches(":not(")) not();
private void findElements() { if (tq.matchChomp("#")) byId(); <BUGS> else if (tq.matchChomp(".")) <BUGE> byClass(); else if (tq.matchesWord()) byTag(); else if (tq.matches("[")) byAttribute(); else if (tq.matchChomp("*")) allElements(); else if (tq.matchChomp(":lt(")) indexLessThan(); else if (tq.matchChomp(":gt(")) indexGreaterThan(); else if (tq.matchChomp(":eq(")) indexEquals(); else if (tq.matches(":has(")) has(); else if (tq.matches(":contains(")) contains(false); else if (tq.matches(":containsOwn(")) contains(true); else if (tq.matches(":matches(")) matches(false); else if (tq.matches(":matchesOwn(")) matches(true); else if (tq.matches(":not(")) not();
private void findElements() { if (tq.matchChomp("#")) byId(); else if (tq.matchChomp(".")) byClass(); <BUGS> else if (tq.matchesWord()) byTag(); else if (tq.matches("[")) byAttribute(); else if (tq.matchChomp("*")) <BUGE> allElements(); else if (tq.matchChomp(":lt(")) indexLessThan(); else if (tq.matchChomp(":gt(")) indexGreaterThan(); else if (tq.matchChomp(":eq(")) indexEquals(); else if (tq.matches(":has(")) has(); else if (tq.matches(":contains(")) contains(false); else if (tq.matches(":containsOwn(")) contains(true); else if (tq.matches(":matches(")) matches(false); else if (tq.matches(":matchesOwn(")) matches(true); else if (tq.matches(":not(")) not();
private void findElements() { if (tq.matchChomp("#")) byId(); else if (tq.matchChomp(".")) byClass(); else if (tq.matchesWord()) byTag(); else if (tq.matches("[")) byAttribute(); else if (tq.matchChomp("*")) allElements(); <BUGS> else if (tq.matchChomp(":lt(")) <BUGE> indexLessThan(); else if (tq.matchChomp(":gt(")) indexGreaterThan(); else if (tq.matchChomp(":eq(")) indexEquals(); else if (tq.matches(":has(")) has(); else if (tq.matches(":contains(")) contains(false); else if (tq.matches(":containsOwn(")) contains(true); else if (tq.matches(":matches(")) matches(false); else if (tq.matches(":matchesOwn(")) matches(true); else if (tq.matches(":not(")) not();
private void findElements() { if (tq.matchChomp("#")) byId(); else if (tq.matchChomp(".")) byClass(); else if (tq.matchesWord()) byTag(); else if (tq.matches("[")) byAttribute(); else if (tq.matchChomp("*")) allElements(); else if (tq.matchChomp(":lt(")) indexLessThan(); <BUGS> else if (tq.matchChomp(":gt(")) <BUGE> indexGreaterThan(); else if (tq.matchChomp(":eq(")) indexEquals(); else if (tq.matches(":has(")) has(); else if (tq.matches(":contains(")) contains(false); else if (tq.matches(":containsOwn(")) contains(true); else if (tq.matches(":matches(")) matches(false); else if (tq.matches(":matchesOwn(")) matches(true); else if (tq.matches(":not(")) not();
private void findElements() { if (tq.matchChomp("#")) byId(); else if (tq.matchChomp(".")) byClass(); else if (tq.matchesWord()) byTag(); else if (tq.matches("[")) byAttribute(); else if (tq.matchChomp("*")) allElements(); else if (tq.matchChomp(":lt(")) indexLessThan(); else if (tq.matchChomp(":gt(")) indexGreaterThan(); <BUGS> else if (tq.matchChomp(":eq(")) <BUGE> indexEquals(); else if (tq.matches(":has(")) has(); else if (tq.matches(":contains(")) contains(false); else if (tq.matches(":containsOwn(")) contains(true); else if (tq.matches(":matches(")) matches(false); else if (tq.matches(":matchesOwn(")) matches(true); else if (tq.matches(":not(")) not();
private void findElements() { if (tq.matchChomp("#")) byId(); else if (tq.matchChomp(".")) byClass(); else if (tq.matchesWord()) byTag(); else if (tq.matches("[")) byAttribute(); else if (tq.matchChomp("*")) allElements(); else if (tq.matchChomp(":lt(")) indexLessThan(); else if (tq.matchChomp(":gt(")) indexGreaterThan(); else if (tq.matchChomp(":eq(")) indexEquals(); <BUGS> else if (tq.matches(":has(")) <BUGE> has(); else if (tq.matches(":contains(")) contains(false); else if (tq.matches(":containsOwn(")) contains(true); else if (tq.matches(":matches(")) matches(false); else if (tq.matches(":matchesOwn(")) matches(true); else if (tq.matches(":not(")) not();
private void findElements() { if (tq.matchChomp("#")) byId(); else if (tq.matchChomp(".")) byClass(); else if (tq.matchesWord()) byTag(); else if (tq.matches("[")) byAttribute(); else if (tq.matchChomp("*")) allElements(); else if (tq.matchChomp(":lt(")) indexLessThan(); else if (tq.matchChomp(":gt(")) indexGreaterThan(); else if (tq.matchChomp(":eq(")) indexEquals(); else if (tq.matches(":has(")) has(); <BUGS> else if (tq.matches(":contains(")) <BUGE> contains(false); else if (tq.matches(":containsOwn(")) contains(true); else if (tq.matches(":matches(")) matches(false); else if (tq.matches(":matchesOwn(")) matches(true); else if (tq.matches(":not(")) not();
private void findElements() { if (tq.matchChomp("#")) byId(); else if (tq.matchChomp(".")) byClass(); else if (tq.matchesWord()) byTag(); else if (tq.matches("[")) byAttribute(); else if (tq.matchChomp("*")) allElements(); else if (tq.matchChomp(":lt(")) indexLessThan(); else if (tq.matchChomp(":gt(")) indexGreaterThan(); else if (tq.matchChomp(":eq(")) indexEquals(); else if (tq.matches(":has(")) has(); else if (tq.matches(":contains(")) contains(false); <BUGS> else if (tq.matches(":containsOwn(")) <BUGE> contains(true); else if (tq.matches(":matches(")) matches(false); else if (tq.matches(":matchesOwn(")) matches(true); else if (tq.matches(":not(")) not();
private void findElements() { if (tq.matchChomp("#")) byId(); else if (tq.matchChomp(".")) byClass(); else if (tq.matchesWord()) byTag(); else if (tq.matches("[")) byAttribute(); else if (tq.matchChomp("*")) allElements(); else if (tq.matchChomp(":lt(")) indexLessThan(); else if (tq.matchChomp(":gt(")) indexGreaterThan(); else if (tq.matchChomp(":eq(")) indexEquals(); else if (tq.matches(":has(")) has(); else if (tq.matches(":contains(")) contains(false); else if (tq.matches(":containsOwn(")) contains(true); <BUGS> else if (tq.matches(":matches(")) <BUGE> matches(false); else if (tq.matches(":matchesOwn(")) matches(true); else if (tq.matches(":not(")) not();
private void findElements() { if (tq.matchChomp("#")) byId(); else if (tq.matchChomp(".")) byClass(); else if (tq.matchesWord()) byTag(); else if (tq.matches("[")) byAttribute(); else if (tq.matchChomp("*")) allElements(); else if (tq.matchChomp(":lt(")) indexLessThan(); else if (tq.matchChomp(":gt(")) indexGreaterThan(); else if (tq.matchChomp(":eq(")) indexEquals(); else if (tq.matches(":has(")) has(); else if (tq.matches(":contains(")) contains(false); else if (tq.matches(":containsOwn(")) contains(true); else if (tq.matches(":matches(")) matches(false); <BUGS> else if (tq.matches(":matchesOwn(")) <BUGE> matches(true); else if (tq.matches(":not(")) not();
private void findElements() { if (tq.matchChomp("#")) byId(); else if (tq.matchChomp(".")) byClass(); else if (tq.matchesWord()) byTag(); else if (tq.matches("[")) byAttribute(); else if (tq.matchChomp("*")) allElements(); else if (tq.matchChomp(":lt(")) indexLessThan(); else if (tq.matchChomp(":gt(")) indexGreaterThan(); else if (tq.matchChomp(":eq(")) indexEquals(); else if (tq.matches(":has(")) has(); else if (tq.matches(":contains(")) contains(false); else if (tq.matches(":containsOwn(")) contains(true); else if (tq.matches(":matches(")) matches(false); else if (tq.matches(":matchesOwn(")) matches(true); <BUGS> else if (tq.matches(":not(")) <BUGE> not();
private void findElements() { if (tq.matchChomp("#")) byId(); else if (tq.matchChomp(".")) byClass(); else if (tq.matchesWord()) byTag(); else if (tq.matches("[")) byAttribute(); else if (tq.matchChomp("*")) allElements(); else if (tq.matchChomp(":lt(")) indexLessThan(); else if (tq.matchChomp(":gt(")) indexGreaterThan(); else if (tq.matchChomp(":eq(")) indexEquals(); else if (tq.matches(":has(")) has(); else if (tq.matches(":contains(")) contains(false); else if (tq.matches(":containsOwn(")) contains(true); else if (tq.matches(":matches(")) matches(false); else if (tq.matches(":matchesOwn(")) matches(true); else if (tq.matches(":not(")) not();
private String consumeSubQuery() { StringBuilder sq = new StringBuilder(); while (!tq.isEmpty()) { if (tq.matches("(")) sq.append("(").append(tq.chompBalanced('(', ')')).append(")"); else if (tq.matches("[")) sq.append("[").append(tq.chompBalanced('[', ']')).append("]"); else if (tq.matchesAny(combinators)) break; else sq.append(tq.consume()); } return sq.toString(); } cssNthChild(false, false); <BUGS> else if (tq.matchChomp(":nth-last-child(")) <BUGE> cssNthChild(true, false); else if (tq.matchChomp(":nth-of-type(")) cssNthChild(false, true); else if (tq.matchChomp(":nth-last-of-type(")) cssNthChild(true, true); else if (tq.matchChomp(":first-child")) evals.add(new Evaluator.IsFirstChild()); else if (tq.matchChomp(":last-child")) evals.add(new Evaluator.IsLastChild()); else if (tq.matchChomp(":first-of-type")) evals.add(new Evaluator.IsFirstOfType()); else if (tq.matchChomp(":last-of-type")) evals.add(new Evaluator.IsLastOfType()); else if (tq.matchChomp(":only-child"))
private String consumeSubQuery() { StringBuilder sq = new StringBuilder(); while (!tq.isEmpty()) { if (tq.matches("(")) sq.append("(").append(tq.chompBalanced('(', ')')).append(")"); else if (tq.matches("[")) sq.append("[").append(tq.chompBalanced('[', ']')).append("]"); else if (tq.matchesAny(combinators)) break; else sq.append(tq.consume()); } return sq.toString(); } cssNthChild(true, false); <BUGS> else if (tq.matchChomp(":nth-of-type(")) <BUGE> cssNthChild(false, true); else if (tq.matchChomp(":nth-last-of-type(")) cssNthChild(true, true); else if (tq.matchChomp(":first-child")) evals.add(new Evaluator.IsFirstChild()); else if (tq.matchChomp(":last-child")) evals.add(new Evaluator.IsLastChild()); else if (tq.matchChomp(":first-of-type")) evals.add(new Evaluator.IsFirstOfType()); else if (tq.matchChomp(":last-of-type")) evals.add(new Evaluator.IsLastOfType()); else if (tq.matchChomp(":only-child")) evals.add(new Evaluator.IsOnlyChild()); else if (tq.matchChomp(":only-of-type"))
private String consumeSubQuery() { StringBuilder sq = new StringBuilder(); while (!tq.isEmpty()) { if (tq.matches("(")) sq.append("(").append(tq.chompBalanced('(', ')')).append(")"); else if (tq.matches("[")) sq.append("[").append(tq.chompBalanced('[', ']')).append("]"); else if (tq.matchesAny(combinators)) break; else sq.append(tq.consume()); } return sq.toString(); } cssNthChild(false, true); <BUGS> else if (tq.matchChomp(":nth-last-of-type(")) <BUGE> cssNthChild(true, true); else if (tq.matchChomp(":first-child")) evals.add(new Evaluator.IsFirstChild()); else if (tq.matchChomp(":last-child")) evals.add(new Evaluator.IsLastChild()); else if (tq.matchChomp(":first-of-type")) evals.add(new Evaluator.IsFirstOfType()); else if (tq.matchChomp(":last-of-type")) evals.add(new Evaluator.IsLastOfType()); else if (tq.matchChomp(":only-child")) evals.add(new Evaluator.IsOnlyChild()); else if (tq.matchChomp(":only-of-type")) evals.add(new Evaluator.IsOnlyOfType()); else if (tq.matchChomp(":empty"))
private String consumeSubQuery() { StringBuilder sq = new StringBuilder(); while (!tq.isEmpty()) { if (tq.matches("(")) sq.append("(").append(tq.chompBalanced('(', ')')).append(")"); else if (tq.matches("[")) sq.append("[").append(tq.chompBalanced('[', ']')).append("]"); else if (tq.matchesAny(combinators)) break; else sq.append(tq.consume()); } return sq.toString(); } cssNthChild(true, true); <BUGS> else if (tq.matchChomp(":first-child")) <BUGE> evals.add(new Evaluator.IsFirstChild()); else if (tq.matchChomp(":last-child")) evals.add(new Evaluator.IsLastChild()); else if (tq.matchChomp(":first-of-type")) evals.add(new Evaluator.IsFirstOfType()); else if (tq.matchChomp(":last-of-type")) evals.add(new Evaluator.IsLastOfType()); else if (tq.matchChomp(":only-child")) evals.add(new Evaluator.IsOnlyChild()); else if (tq.matchChomp(":only-of-type")) evals.add(new Evaluator.IsOnlyOfType()); else if (tq.matchChomp(":empty")) evals.add(new Evaluator.IsEmpty()); else if (tq.matchChomp(":root"))
private String consumeSubQuery() { StringBuilder sq = new StringBuilder(); while (!tq.isEmpty()) { if (tq.matches("(")) sq.append("(").append(tq.chompBalanced('(', ')')).append(")"); else if (tq.matches("[")) sq.append("[").append(tq.chompBalanced('[', ']')).append("]"); else if (tq.matchesAny(combinators)) break; else sq.append(tq.consume()); } return sq.toString(); } evals.add(new Evaluator.IsFirstChild()); <BUGS> else if (tq.matchChomp(":last-child")) <BUGE> evals.add(new Evaluator.IsLastChild()); else if (tq.matchChomp(":first-of-type")) evals.add(new Evaluator.IsFirstOfType()); else if (tq.matchChomp(":last-of-type")) evals.add(new Evaluator.IsLastOfType()); else if (tq.matchChomp(":only-child")) evals.add(new Evaluator.IsOnlyChild()); else if (tq.matchChomp(":only-of-type")) evals.add(new Evaluator.IsOnlyOfType()); else if (tq.matchChomp(":empty")) evals.add(new Evaluator.IsEmpty()); else if (tq.matchChomp(":root")) evals.add(new Evaluator.IsRoot()); else /* unhandled*/
private String consumeSubQuery() { StringBuilder sq = new StringBuilder(); while (!tq.isEmpty()) { if (tq.matches("(")) sq.append("(").append(tq.chompBalanced('(', ')')).append(")"); else if (tq.matches("[")) sq.append("[").append(tq.chompBalanced('[', ']')).append("]"); else if (tq.matchesAny(combinators)) break; else sq.append(tq.consume()); } return sq.toString(); } evals.add(new Evaluator.IsLastChild()); <BUGS> else if (tq.matchChomp(":first-of-type")) <BUGE> evals.add(new Evaluator.IsFirstOfType()); else if (tq.matchChomp(":last-of-type")) evals.add(new Evaluator.IsLastOfType()); else if (tq.matchChomp(":only-child")) evals.add(new Evaluator.IsOnlyChild()); else if (tq.matchChomp(":only-of-type")) evals.add(new Evaluator.IsOnlyOfType()); else if (tq.matchChomp(":empty")) evals.add(new Evaluator.IsEmpty()); else if (tq.matchChomp(":root")) evals.add(new Evaluator.IsRoot()); else /* unhandled*/ throw new Selector.SelectorParseException("Could not parse query '%s': unexpected token at '%s'", query, tq.remainder());
private String consumeSubQuery() { StringBuilder sq = new StringBuilder(); while (!tq.isEmpty()) { if (tq.matches("(")) sq.append("(").append(tq.chompBalanced('(', ')')).append(")"); else if (tq.matches("[")) sq.append("[").append(tq.chompBalanced('[', ']')).append("]"); else if (tq.matchesAny(combinators)) break; else sq.append(tq.consume()); } return sq.toString(); } evals.add(new Evaluator.IsFirstOfType()); <BUGS> else if (tq.matchChomp(":last-of-type")) <BUGE> evals.add(new Evaluator.IsLastOfType()); else if (tq.matchChomp(":only-child")) evals.add(new Evaluator.IsOnlyChild()); else if (tq.matchChomp(":only-of-type")) evals.add(new Evaluator.IsOnlyOfType()); else if (tq.matchChomp(":empty")) evals.add(new Evaluator.IsEmpty()); else if (tq.matchChomp(":root")) evals.add(new Evaluator.IsRoot()); else /* unhandled*/ throw new Selector.SelectorParseException("Could not parse query '%s': unexpected token at '%s'", query, tq.remainder());  }
private String consumeSubQuery() { StringBuilder sq = new StringBuilder(); while (!tq.isEmpty()) { if (tq.matches("(")) sq.append("(").append(tq.chompBalanced('(', ')')).append(")"); else if (tq.matches("[")) sq.append("[").append(tq.chompBalanced('[', ']')).append("]"); else if (tq.matchesAny(combinators)) break; else sq.append(tq.consume()); } return sq.toString(); } evals.add(new Evaluator.IsLastOfType()); <BUGS> else if (tq.matchChomp(":only-child")) <BUGE> evals.add(new Evaluator.IsOnlyChild()); else if (tq.matchChomp(":only-of-type")) evals.add(new Evaluator.IsOnlyOfType()); else if (tq.matchChomp(":empty")) evals.add(new Evaluator.IsEmpty()); else if (tq.matchChomp(":root")) evals.add(new Evaluator.IsRoot()); else /* unhandled*/ throw new Selector.SelectorParseException("Could not parse query '%s': unexpected token at '%s'", query, tq.remainder());  }  private void byId() { String id = tq.consumeCssIdentifier();
private String consumeSubQuery() { StringBuilder sq = new StringBuilder(); while (!tq.isEmpty()) { if (tq.matches("(")) sq.append("(").append(tq.chompBalanced('(', ')')).append(")"); else if (tq.matches("[")) sq.append("[").append(tq.chompBalanced('[', ']')).append("]"); else if (tq.matchesAny(combinators)) break; else sq.append(tq.consume()); } return sq.toString(); } evals.add(new Evaluator.IsOnlyChild()); <BUGS> else if (tq.matchChomp(":only-of-type")) <BUGE> evals.add(new Evaluator.IsOnlyOfType()); else if (tq.matchChomp(":empty")) evals.add(new Evaluator.IsEmpty()); else if (tq.matchChomp(":root")) evals.add(new Evaluator.IsRoot()); else /* unhandled*/ throw new Selector.SelectorParseException("Could not parse query '%s': unexpected token at '%s'", query, tq.remainder());  }  private void byId() { String id = tq.consumeCssIdentifier(); Validate.notEmpty(id); evals.add(new Evaluator.Id(id));
private String consumeSubQuery() { StringBuilder sq = new StringBuilder(); while (!tq.isEmpty()) { if (tq.matches("(")) sq.append("(").append(tq.chompBalanced('(', ')')).append(")"); else if (tq.matches("[")) sq.append("[").append(tq.chompBalanced('[', ']')).append("]"); else if (tq.matchesAny(combinators)) break; else sq.append(tq.consume()); } return sq.toString(); } evals.add(new Evaluator.IsOnlyOfType()); <BUGS> else if (tq.matchChomp(":empty")) <BUGE> evals.add(new Evaluator.IsEmpty()); else if (tq.matchChomp(":root")) evals.add(new Evaluator.IsRoot()); else /* unhandled*/ throw new Selector.SelectorParseException("Could not parse query '%s': unexpected token at '%s'", query, tq.remainder());  }  private void byId() { String id = tq.consumeCssIdentifier(); Validate.notEmpty(id); evals.add(new Evaluator.Id(id)); }
private String consumeSubQuery() { StringBuilder sq = new StringBuilder(); while (!tq.isEmpty()) { if (tq.matches("(")) sq.append("(").append(tq.chompBalanced('(', ')')).append(")"); else if (tq.matches("[")) sq.append("[").append(tq.chompBalanced('[', ']')).append("]"); else if (tq.matchesAny(combinators)) break; else sq.append(tq.consume()); } return sq.toString(); } evals.add(new Evaluator.IsEmpty()); <BUGS> else if (tq.matchChomp(":root")) <BUGE> evals.add(new Evaluator.IsRoot()); else /* unhandled*/ throw new Selector.SelectorParseException("Could not parse query '%s': unexpected token at '%s'", query, tq.remainder());  }  private void byId() { String id = tq.consumeCssIdentifier(); Validate.notEmpty(id); evals.add(new Evaluator.Id(id)); }  private void byClass() { String className = tq.consumeCssIdentifier();
private String consumeSubQuery() { StringBuilder sq = new StringBuilder(); while (!tq.isEmpty()) { if (tq.matches("(")) sq.append("(").append(tq.chompBalanced('(', ')')).append(")"); else if (tq.matches("[")) sq.append("[").append(tq.chompBalanced('[', ']')).append("]"); else if (tq.matchesAny(combinators)) break; else sq.append(tq.consume()); } return sq.toString(); } else /* unhandled*/ <BUGS> throw new Selector.SelectorParseException("Could not parse query '%s': unexpected token at '%s'", query, tq.remainder()); <BUGE>  }  private void byId() { String id = tq.consumeCssIdentifier(); Validate.notEmpty(id); evals.add(new Evaluator.Id(id)); }  private void byClass() { String className = tq.consumeCssIdentifier(); Validate.notEmpty(className); evals.add(new Evaluator.Class(className.trim().toLowerCase())); }
private String consumeSubQuery() { StringBuilder sq = new StringBuilder(); while (!tq.isEmpty()) { if (tq.matches("(")) sq.append("(").append(tq.chompBalanced('(', ')')).append(")"); else if (tq.matches("[")) sq.append("[").append(tq.chompBalanced('[', ']')).append("]"); else if (tq.matchesAny(combinators)) break; else sq.append(tq.consume()); } return sq.toString(); }  <BUGS> } <BUGE>  private void byId() { String id = tq.consumeCssIdentifier(); Validate.notEmpty(id); evals.add(new Evaluator.Id(id)); }  private void byClass() { String className = tq.consumeCssIdentifier(); Validate.notEmpty(className); evals.add(new Evaluator.Class(className.trim().toLowerCase())); }  private void byTag() {
*/ public static String getByName(String name) { <BUGS> String val = multipoints.get(name); if (val != null) <BUGE> return val; int codepoint = extended.codepointForName(name); if (codepoint != empty) return new String(new int[]{codepoint}, 0, 1); return emptyName; }
*/ public static String getByName(String name) { String val = multipoints.get(name); if (val != null) return val; <BUGS> int codepoint = extended.codepointForName(name); if (codepoint != empty) return new String(new int[]{codepoint}, 0, 1); <BUGE> return emptyName; }
*/ public static String getByName(String name) { <BUGS> String val = multipoints.get(name); if (val != null) <BUGE> return val; int codepoint = extended.codepointForName(name); if (codepoint != empty) return new String(new int[]{codepoint}, 0, 1); return emptyName; }
*/ public static String getByName(String name) { String val = multipoints.get(name); if (val != null) return val; <BUGS> int codepoint = extended.codepointForName(name); if (codepoint != empty) return new String(new int[]{codepoint}, 0, 1); <BUGE> return emptyName; }
*/ public static String getByName(String name) { <BUGS> String val = multipoints.get(name); if (val != null) <BUGE> return val; int codepoint = extended.codepointForName(name); if (codepoint != empty) return new String(new int[]{codepoint}, 0, 1); return emptyName; }
*/ public static String getByName(String name) { String val = multipoints.get(name); if (val != null) return val; <BUGS> int codepoint = extended.codepointForName(name); if (codepoint != empty) return new String(new int[]{codepoint}, 0, 1); <BUGE> return emptyName; }
*/ public boolean isValid(Document dirtyDocument) { <BUGS> Validate.notNull(dirtyDocument); <BUGE>  Document clean = Document.createShell(dirtyDocument.baseUri()); int numDiscarded = copySafeNodes(dirtyDocument.body(), clean.body()); return numDiscarded == 0; }
*/ public boolean isValid(Document dirtyDocument) { Validate.notNull(dirtyDocument);  <BUGS> Document clean = Document.createShell(dirtyDocument.baseUri()); int numDiscarded = copySafeNodes(dirtyDocument.body(), clean.body()); return numDiscarded == 0; <BUGE> }
*/ public static void notEmpty(String string) { <BUGS> if (string == null || string.length() == 0) throw new IllegalArgumentException("String must not be empty"); } <BUGE>
*/ public static void notEmpty(String string) { <BUGS> if (string == null || string.length() == 0) throw new IllegalArgumentException("String must not be empty"); } <BUGE>
*/ public static String getByName(String name) { <BUGS> String val = multipoints.get(name); if (val != null) <BUGE> return val; int codepoint = extended.codepointForName(name); if (codepoint != empty) return new String(new int[]{codepoint}, 0, 1); return emptyName; }
*/ public static String getByName(String name) { String val = multipoints.get(name); if (val != null) return val; <BUGS> int codepoint = extended.codepointForName(name); if (codepoint != empty) return new String(new int[]{codepoint}, 0, 1); <BUGE> return emptyName; }
*/ public static String getByName(String name) { <BUGS> String val = multipoints.get(name); if (val != null) <BUGE> return val; int codepoint = extended.codepointForName(name); if (codepoint != empty) return new String(new int[]{codepoint}, 0, 1); return emptyName; }
*/ public static String getByName(String name) { String val = multipoints.get(name); if (val != null) return val; <BUGS> int codepoint = extended.codepointForName(name); if (codepoint != empty) return new String(new int[]{codepoint}, 0, 1); <BUGE> return emptyName; }
*/ public static String getByName(String name) { <BUGS> String val = multipoints.get(name); if (val != null) <BUGE> return val; int codepoint = extended.codepointForName(name); if (codepoint != empty) return new String(new int[]{codepoint}, 0, 1); return emptyName; }
*/ public static String getByName(String name) { String val = multipoints.get(name); if (val != null) return val; <BUGS> int codepoint = extended.codepointForName(name); if (codepoint != empty) return new String(new int[]{codepoint}, 0, 1); <BUGE> return emptyName; }
*/ public static String getByName(String name) { <BUGS> String val = multipoints.get(name); if (val != null) <BUGE> return val; int codepoint = extended.codepointForName(name); if (codepoint != empty) return new String(new int[]{codepoint}, 0, 1); return emptyName; }
*/ public static String getByName(String name) { String val = multipoints.get(name); if (val != null) return val; <BUGS> int codepoint = extended.codepointForName(name); if (codepoint != empty) return new String(new int[]{codepoint}, 0, 1); <BUGE> return emptyName; }
private boolean inSpecificScope(String[] targetNames, String[] baseTypes, String[] extraTypes) { // https:/*html.spec.whatwg.org/multipage/parsing.html#has-an-element-in-the-specific-scope*/ <BUGS> int bottom = stack.size() -1; if (bottom > MaxScopeSearchDepth) { bottom = MaxScopeSearchDepth; <BUGE> } final int top = bottom > MaxScopeSearchDepth ? bottom - MaxScopeSearchDepth : 0; /* don't walk too far up the tree*/  for (int pos = bottom; pos >= top; pos--) { final String elName = stack.get(pos).nodeName(); if (inSorted(elName, targetNames)) return true; if (inSorted(elName, baseTypes)) return false; if (extraTypes != null && inSorted(elName, extraTypes)) return false; } //Validate.fail("Should not be reachable"); /* would end up false because hitting 'html' at root (basetypes)*/ return false; }
private boolean inSpecificScope(String[] targetNames, String[] baseTypes, String[] extraTypes) { // https:/*html.spec.whatwg.org/multipage/parsing.html#has-an-element-in-the-specific-scope*/ int bottom = stack.size() -1; if (bottom > MaxScopeSearchDepth) { bottom = MaxScopeSearchDepth; } <BUGS> final int top = bottom > MaxScopeSearchDepth ? bottom - MaxScopeSearchDepth : 0; <BUGE> /* don't walk too far up the tree*/  for (int pos = bottom; pos >= top; pos--) { final String elName = stack.get(pos).nodeName(); if (inSorted(elName, targetNames)) return true; if (inSorted(elName, baseTypes)) return false; if (extraTypes != null && inSorted(elName, extraTypes)) return false; } //Validate.fail("Should not be reachable"); /* would end up false because hitting 'html' at root (basetypes)*/ return false; }
private boolean inSpecificScope(String[] targetNames, String[] baseTypes, String[] extraTypes) { // https:/*html.spec.whatwg.org/multipage/parsing.html#has-an-element-in-the-specific-scope*/ int bottom = stack.size() -1; if (bottom > MaxScopeSearchDepth) { bottom = MaxScopeSearchDepth; } final int top = bottom > MaxScopeSearchDepth ? bottom - MaxScopeSearchDepth : 0; /* don't walk too far up the tree*/  <BUGS> for (int pos = bottom; pos >= top; pos--) { final String elName = stack.get(pos).nodeName(); if (inSorted(elName, targetNames)) <BUGE> return true; if (inSorted(elName, baseTypes)) return false; if (extraTypes != null && inSorted(elName, extraTypes)) return false; } //Validate.fail("Should not be reachable"); /* would end up false because hitting 'html' at root (basetypes)*/ return false; }
private boolean inSpecificScope(String[] targetNames, String[] baseTypes, String[] extraTypes) { // https:/*html.spec.whatwg.org/multipage/parsing.html#has-an-element-in-the-specific-scope*/ int bottom = stack.size() -1; if (bottom > MaxScopeSearchDepth) { bottom = MaxScopeSearchDepth; } final int top = bottom > MaxScopeSearchDepth ? bottom - MaxScopeSearchDepth : 0; /* don't walk too far up the tree*/  for (int pos = bottom; pos >= top; pos--) { final String elName = stack.get(pos).nodeName(); if (inSorted(elName, targetNames)) return true; <BUGS> if (inSorted(elName, baseTypes)) return false; if (extraTypes != null && inSorted(elName, extraTypes)) <BUGE> return false; } //Validate.fail("Should not be reachable"); /* would end up false because hitting 'html' at root (basetypes)*/ return false; }
*/ public Element selectFirst(String cssQuery) { <BUGS> return Selector.selectFirst(cssQuery, this); <BUGE> }
private void findElements() { <BUGS> if (tq.matchChomp("#")) <BUGE> byId(); else if (tq.matchChomp(".")) byClass(); else if (tq.matchesWord() || tq.matches("*|")) byTag(); else if (tq.matches("[")) byAttribute(); else if (tq.matchChomp("*")) allElements(); else if (tq.matchChomp(":lt(")) indexLessThan(); else if (tq.matchChomp(":gt(")) indexGreaterThan(); else if (tq.matchChomp(":eq(")) indexEquals(); else if (tq.matches(":has(")) has(); else if (tq.matches(":contains(")) contains(false); else if (tq.matches(":containsOwn(")) contains(true); else if (tq.matches(":containsData(")) containsData(); else if (tq.matches(":matches(")) matches(false); else if (tq.matches(":matchesOwn(")) matches(true);
private void findElements() { if (tq.matchChomp("#")) byId(); <BUGS> else if (tq.matchChomp(".")) <BUGE> byClass(); else if (tq.matchesWord() || tq.matches("*|")) byTag(); else if (tq.matches("[")) byAttribute(); else if (tq.matchChomp("*")) allElements(); else if (tq.matchChomp(":lt(")) indexLessThan(); else if (tq.matchChomp(":gt(")) indexGreaterThan(); else if (tq.matchChomp(":eq(")) indexEquals(); else if (tq.matches(":has(")) has(); else if (tq.matches(":contains(")) contains(false); else if (tq.matches(":containsOwn(")) contains(true); else if (tq.matches(":containsData(")) containsData(); else if (tq.matches(":matches(")) matches(false); else if (tq.matches(":matchesOwn(")) matches(true);
private void findElements() { if (tq.matchChomp("#")) byId(); else if (tq.matchChomp(".")) byClass(); <BUGS> else if (tq.matchesWord() || tq.matches("*|")) byTag(); else if (tq.matches("[")) <BUGE> byAttribute(); else if (tq.matchChomp("*")) allElements(); else if (tq.matchChomp(":lt(")) indexLessThan(); else if (tq.matchChomp(":gt(")) indexGreaterThan(); else if (tq.matchChomp(":eq(")) indexEquals(); else if (tq.matches(":has(")) has(); else if (tq.matches(":contains(")) contains(false); else if (tq.matches(":containsOwn(")) contains(true); else if (tq.matches(":containsData(")) containsData(); else if (tq.matches(":matches(")) matches(false); else if (tq.matches(":matchesOwn(")) matches(true);
private void findElements() { if (tq.matchChomp("#")) byId(); else if (tq.matchChomp(".")) byClass(); else if (tq.matchesWord() || tq.matches("*|")) byTag(); else if (tq.matches("[")) byAttribute(); <BUGS> else if (tq.matchChomp("*")) <BUGE> allElements(); else if (tq.matchChomp(":lt(")) indexLessThan(); else if (tq.matchChomp(":gt(")) indexGreaterThan(); else if (tq.matchChomp(":eq(")) indexEquals(); else if (tq.matches(":has(")) has(); else if (tq.matches(":contains(")) contains(false); else if (tq.matches(":containsOwn(")) contains(true); else if (tq.matches(":containsData(")) containsData(); else if (tq.matches(":matches(")) matches(false); else if (tq.matches(":matchesOwn(")) matches(true);
private void findElements() { if (tq.matchChomp("#")) byId(); else if (tq.matchChomp(".")) byClass(); else if (tq.matchesWord() || tq.matches("*|")) byTag(); else if (tq.matches("[")) byAttribute(); else if (tq.matchChomp("*")) allElements(); <BUGS> else if (tq.matchChomp(":lt(")) <BUGE> indexLessThan(); else if (tq.matchChomp(":gt(")) indexGreaterThan(); else if (tq.matchChomp(":eq(")) indexEquals(); else if (tq.matches(":has(")) has(); else if (tq.matches(":contains(")) contains(false); else if (tq.matches(":containsOwn(")) contains(true); else if (tq.matches(":containsData(")) containsData(); else if (tq.matches(":matches(")) matches(false); else if (tq.matches(":matchesOwn(")) matches(true);
private void findElements() { if (tq.matchChomp("#")) byId(); else if (tq.matchChomp(".")) byClass(); else if (tq.matchesWord() || tq.matches("*|")) byTag(); else if (tq.matches("[")) byAttribute(); else if (tq.matchChomp("*")) allElements(); else if (tq.matchChomp(":lt(")) indexLessThan(); <BUGS> else if (tq.matchChomp(":gt(")) <BUGE> indexGreaterThan(); else if (tq.matchChomp(":eq(")) indexEquals(); else if (tq.matches(":has(")) has(); else if (tq.matches(":contains(")) contains(false); else if (tq.matches(":containsOwn(")) contains(true); else if (tq.matches(":containsData(")) containsData(); else if (tq.matches(":matches(")) matches(false); else if (tq.matches(":matchesOwn(")) matches(true);
private void findElements() { if (tq.matchChomp("#")) byId(); else if (tq.matchChomp(".")) byClass(); else if (tq.matchesWord() || tq.matches("*|")) byTag(); else if (tq.matches("[")) byAttribute(); else if (tq.matchChomp("*")) allElements(); else if (tq.matchChomp(":lt(")) indexLessThan(); else if (tq.matchChomp(":gt(")) indexGreaterThan(); <BUGS> else if (tq.matchChomp(":eq(")) <BUGE> indexEquals(); else if (tq.matches(":has(")) has(); else if (tq.matches(":contains(")) contains(false); else if (tq.matches(":containsOwn(")) contains(true); else if (tq.matches(":containsData(")) containsData(); else if (tq.matches(":matches(")) matches(false); else if (tq.matches(":matchesOwn(")) matches(true);
private void findElements() { if (tq.matchChomp("#")) byId(); else if (tq.matchChomp(".")) byClass(); else if (tq.matchesWord() || tq.matches("*|")) byTag(); else if (tq.matches("[")) byAttribute(); else if (tq.matchChomp("*")) allElements(); else if (tq.matchChomp(":lt(")) indexLessThan(); else if (tq.matchChomp(":gt(")) indexGreaterThan(); else if (tq.matchChomp(":eq(")) indexEquals(); <BUGS> else if (tq.matches(":has(")) <BUGE> has(); else if (tq.matches(":contains(")) contains(false); else if (tq.matches(":containsOwn(")) contains(true); else if (tq.matches(":containsData(")) containsData(); else if (tq.matches(":matches(")) matches(false); else if (tq.matches(":matchesOwn(")) matches(true);
private void findElements() { if (tq.matchChomp("#")) byId(); else if (tq.matchChomp(".")) byClass(); else if (tq.matchesWord() || tq.matches("*|")) byTag(); else if (tq.matches("[")) byAttribute(); else if (tq.matchChomp("*")) allElements(); else if (tq.matchChomp(":lt(")) indexLessThan(); else if (tq.matchChomp(":gt(")) indexGreaterThan(); else if (tq.matchChomp(":eq(")) indexEquals(); else if (tq.matches(":has(")) has(); <BUGS> else if (tq.matches(":contains(")) <BUGE> contains(false); else if (tq.matches(":containsOwn(")) contains(true); else if (tq.matches(":containsData(")) containsData(); else if (tq.matches(":matches(")) matches(false); else if (tq.matches(":matchesOwn(")) matches(true);
private void findElements() { if (tq.matchChomp("#")) byId(); else if (tq.matchChomp(".")) byClass(); else if (tq.matchesWord() || tq.matches("*|")) byTag(); else if (tq.matches("[")) byAttribute(); else if (tq.matchChomp("*")) allElements(); else if (tq.matchChomp(":lt(")) indexLessThan(); else if (tq.matchChomp(":gt(")) indexGreaterThan(); else if (tq.matchChomp(":eq(")) indexEquals(); else if (tq.matches(":has(")) has(); else if (tq.matches(":contains(")) contains(false); <BUGS> else if (tq.matches(":containsOwn(")) <BUGE> contains(true); else if (tq.matches(":containsData(")) containsData(); else if (tq.matches(":matches(")) matches(false); else if (tq.matches(":matchesOwn(")) matches(true);
private void findElements() { if (tq.matchChomp("#")) byId(); else if (tq.matchChomp(".")) byClass(); else if (tq.matchesWord() || tq.matches("*|")) byTag(); else if (tq.matches("[")) byAttribute(); else if (tq.matchChomp("*")) allElements(); else if (tq.matchChomp(":lt(")) indexLessThan(); else if (tq.matchChomp(":gt(")) indexGreaterThan(); else if (tq.matchChomp(":eq(")) indexEquals(); else if (tq.matches(":has(")) has(); else if (tq.matches(":contains(")) contains(false); else if (tq.matches(":containsOwn(")) contains(true); <BUGS> else if (tq.matches(":containsData(")) <BUGE> containsData(); else if (tq.matches(":matches(")) matches(false); else if (tq.matches(":matchesOwn(")) matches(true);
private void findElements() { if (tq.matchChomp("#")) byId(); else if (tq.matchChomp(".")) byClass(); else if (tq.matchesWord() || tq.matches("*|")) byTag(); else if (tq.matches("[")) byAttribute(); else if (tq.matchChomp("*")) allElements(); else if (tq.matchChomp(":lt(")) indexLessThan(); else if (tq.matchChomp(":gt(")) indexGreaterThan(); else if (tq.matchChomp(":eq(")) indexEquals(); else if (tq.matches(":has(")) has(); else if (tq.matches(":contains(")) contains(false); else if (tq.matches(":containsOwn(")) contains(true); else if (tq.matches(":containsData(")) containsData(); <BUGS> else if (tq.matches(":matches(")) <BUGE> matches(false); else if (tq.matches(":matchesOwn(")) matches(true);
private void findElements() { if (tq.matchChomp("#")) byId(); else if (tq.matchChomp(".")) byClass(); else if (tq.matchesWord() || tq.matches("*|")) byTag(); else if (tq.matches("[")) byAttribute(); else if (tq.matchChomp("*")) allElements(); else if (tq.matchChomp(":lt(")) indexLessThan(); else if (tq.matchChomp(":gt(")) indexGreaterThan(); else if (tq.matchChomp(":eq(")) indexEquals(); else if (tq.matches(":has(")) has(); else if (tq.matches(":contains(")) contains(false); else if (tq.matches(":containsOwn(")) contains(true); else if (tq.matches(":containsData(")) containsData(); else if (tq.matches(":matches(")) matches(false); <BUGS> else if (tq.matches(":matchesOwn(")) <BUGE> matches(true);
private void findElements() { if (tq.matchChomp("#")) byId(); else if (tq.matchChomp(".")) byClass(); else if (tq.matchesWord() || tq.matches("*|")) byTag(); else if (tq.matches("[")) byAttribute(); else if (tq.matchChomp("*")) allElements(); else if (tq.matchChomp(":lt(")) indexLessThan(); else if (tq.matchChomp(":gt(")) indexGreaterThan(); else if (tq.matchChomp(":eq(")) indexEquals(); else if (tq.matches(":has(")) has(); else if (tq.matches(":contains(")) contains(false); else if (tq.matches(":containsOwn(")) contains(true); else if (tq.matches(":containsData(")) containsData(); else if (tq.matches(":matches(")) matches(false); else if (tq.matches(":matchesOwn(")) matches(true);
private String consumeSubQuery() { StringBuilder sq = new StringBuilder(); while (!tq.isEmpty()) { if (tq.matches("(")) sq.append("(").append(tq.chompBalanced('(', ')')).append(")"); else if (tq.matches("[")) sq.append("[").append(tq.chompBalanced('[', ']')).append("]"); else if (tq.matchesAny(combinators)) break; else sq.append(tq.consume()); } return sq.toString(); } not(); <BUGS> else if (tq.matchChomp(":nth-child(")) <BUGE> cssNthChild(false, false); else if (tq.matchChomp(":nth-last-child(")) cssNthChild(true, false); else if (tq.matchChomp(":nth-of-type(")) cssNthChild(false, true); else if (tq.matchChomp(":nth-last-of-type(")) cssNthChild(true, true); else if (tq.matchChomp(":first-child")) evals.add(new Evaluator.IsFirstChild()); else if (tq.matchChomp(":last-child")) evals.add(new Evaluator.IsLastChild()); else if (tq.matchChomp(":first-of-type")) evals.add(new Evaluator.IsFirstOfType()); else if (tq.matchChomp(":last-of-type"))
private String consumeSubQuery() { StringBuilder sq = new StringBuilder(); while (!tq.isEmpty()) { if (tq.matches("(")) sq.append("(").append(tq.chompBalanced('(', ')')).append(")"); else if (tq.matches("[")) sq.append("[").append(tq.chompBalanced('[', ']')).append("]"); else if (tq.matchesAny(combinators)) break; else sq.append(tq.consume()); } return sq.toString(); } cssNthChild(false, false); <BUGS> else if (tq.matchChomp(":nth-last-child(")) <BUGE> cssNthChild(true, false); else if (tq.matchChomp(":nth-of-type(")) cssNthChild(false, true); else if (tq.matchChomp(":nth-last-of-type(")) cssNthChild(true, true); else if (tq.matchChomp(":first-child")) evals.add(new Evaluator.IsFirstChild()); else if (tq.matchChomp(":last-child")) evals.add(new Evaluator.IsLastChild()); else if (tq.matchChomp(":first-of-type")) evals.add(new Evaluator.IsFirstOfType()); else if (tq.matchChomp(":last-of-type")) evals.add(new Evaluator.IsLastOfType()); else if (tq.matchChomp(":only-child"))
private String consumeSubQuery() { StringBuilder sq = new StringBuilder(); while (!tq.isEmpty()) { if (tq.matches("(")) sq.append("(").append(tq.chompBalanced('(', ')')).append(")"); else if (tq.matches("[")) sq.append("[").append(tq.chompBalanced('[', ']')).append("]"); else if (tq.matchesAny(combinators)) break; else sq.append(tq.consume()); } return sq.toString(); } cssNthChild(true, false); <BUGS> else if (tq.matchChomp(":nth-of-type(")) <BUGE> cssNthChild(false, true); else if (tq.matchChomp(":nth-last-of-type(")) cssNthChild(true, true); else if (tq.matchChomp(":first-child")) evals.add(new Evaluator.IsFirstChild()); else if (tq.matchChomp(":last-child")) evals.add(new Evaluator.IsLastChild()); else if (tq.matchChomp(":first-of-type")) evals.add(new Evaluator.IsFirstOfType()); else if (tq.matchChomp(":last-of-type")) evals.add(new Evaluator.IsLastOfType()); else if (tq.matchChomp(":only-child")) evals.add(new Evaluator.IsOnlyChild()); else if (tq.matchChomp(":only-of-type"))
private String consumeSubQuery() { StringBuilder sq = new StringBuilder(); while (!tq.isEmpty()) { if (tq.matches("(")) sq.append("(").append(tq.chompBalanced('(', ')')).append(")"); else if (tq.matches("[")) sq.append("[").append(tq.chompBalanced('[', ']')).append("]"); else if (tq.matchesAny(combinators)) break; else sq.append(tq.consume()); } return sq.toString(); } cssNthChild(false, true); <BUGS> else if (tq.matchChomp(":nth-last-of-type(")) <BUGE> cssNthChild(true, true); else if (tq.matchChomp(":first-child")) evals.add(new Evaluator.IsFirstChild()); else if (tq.matchChomp(":last-child")) evals.add(new Evaluator.IsLastChild()); else if (tq.matchChomp(":first-of-type")) evals.add(new Evaluator.IsFirstOfType()); else if (tq.matchChomp(":last-of-type")) evals.add(new Evaluator.IsLastOfType()); else if (tq.matchChomp(":only-child")) evals.add(new Evaluator.IsOnlyChild()); else if (tq.matchChomp(":only-of-type")) evals.add(new Evaluator.IsOnlyOfType()); else if (tq.matchChomp(":empty"))
private String consumeSubQuery() { StringBuilder sq = new StringBuilder(); while (!tq.isEmpty()) { if (tq.matches("(")) sq.append("(").append(tq.chompBalanced('(', ')')).append(")"); else if (tq.matches("[")) sq.append("[").append(tq.chompBalanced('[', ']')).append("]"); else if (tq.matchesAny(combinators)) break; else sq.append(tq.consume()); } return sq.toString(); } cssNthChild(true, true); <BUGS> else if (tq.matchChomp(":first-child")) <BUGE> evals.add(new Evaluator.IsFirstChild()); else if (tq.matchChomp(":last-child")) evals.add(new Evaluator.IsLastChild()); else if (tq.matchChomp(":first-of-type")) evals.add(new Evaluator.IsFirstOfType()); else if (tq.matchChomp(":last-of-type")) evals.add(new Evaluator.IsLastOfType()); else if (tq.matchChomp(":only-child")) evals.add(new Evaluator.IsOnlyChild()); else if (tq.matchChomp(":only-of-type")) evals.add(new Evaluator.IsOnlyOfType()); else if (tq.matchChomp(":empty")) evals.add(new Evaluator.IsEmpty()); else if (tq.matchChomp(":root"))
private String consumeSubQuery() { StringBuilder sq = new StringBuilder(); while (!tq.isEmpty()) { if (tq.matches("(")) sq.append("(").append(tq.chompBalanced('(', ')')).append(")"); else if (tq.matches("[")) sq.append("[").append(tq.chompBalanced('[', ']')).append("]"); else if (tq.matchesAny(combinators)) break; else sq.append(tq.consume()); } return sq.toString(); } evals.add(new Evaluator.IsFirstChild()); <BUGS> else if (tq.matchChomp(":last-child")) <BUGE> evals.add(new Evaluator.IsLastChild()); else if (tq.matchChomp(":first-of-type")) evals.add(new Evaluator.IsFirstOfType()); else if (tq.matchChomp(":last-of-type")) evals.add(new Evaluator.IsLastOfType()); else if (tq.matchChomp(":only-child")) evals.add(new Evaluator.IsOnlyChild()); else if (tq.matchChomp(":only-of-type")) evals.add(new Evaluator.IsOnlyOfType()); else if (tq.matchChomp(":empty")) evals.add(new Evaluator.IsEmpty()); else if (tq.matchChomp(":root")) evals.add(new Evaluator.IsRoot()); else /* unhandled*/
private String consumeSubQuery() { StringBuilder sq = new StringBuilder(); while (!tq.isEmpty()) { if (tq.matches("(")) sq.append("(").append(tq.chompBalanced('(', ')')).append(")"); else if (tq.matches("[")) sq.append("[").append(tq.chompBalanced('[', ']')).append("]"); else if (tq.matchesAny(combinators)) break; else sq.append(tq.consume()); } return sq.toString(); } evals.add(new Evaluator.IsLastChild()); <BUGS> else if (tq.matchChomp(":first-of-type")) <BUGE> evals.add(new Evaluator.IsFirstOfType()); else if (tq.matchChomp(":last-of-type")) evals.add(new Evaluator.IsLastOfType()); else if (tq.matchChomp(":only-child")) evals.add(new Evaluator.IsOnlyChild()); else if (tq.matchChomp(":only-of-type")) evals.add(new Evaluator.IsOnlyOfType()); else if (tq.matchChomp(":empty")) evals.add(new Evaluator.IsEmpty()); else if (tq.matchChomp(":root")) evals.add(new Evaluator.IsRoot()); else /* unhandled*/ throw new Selector.SelectorParseException("Could not parse query '%s': unexpected token at '%s'", query, tq.remainder());
private String consumeSubQuery() { StringBuilder sq = new StringBuilder(); while (!tq.isEmpty()) { if (tq.matches("(")) sq.append("(").append(tq.chompBalanced('(', ')')).append(")"); else if (tq.matches("[")) sq.append("[").append(tq.chompBalanced('[', ']')).append("]"); else if (tq.matchesAny(combinators)) break; else sq.append(tq.consume()); } return sq.toString(); } evals.add(new Evaluator.IsFirstOfType()); <BUGS> else if (tq.matchChomp(":last-of-type")) <BUGE> evals.add(new Evaluator.IsLastOfType()); else if (tq.matchChomp(":only-child")) evals.add(new Evaluator.IsOnlyChild()); else if (tq.matchChomp(":only-of-type")) evals.add(new Evaluator.IsOnlyOfType()); else if (tq.matchChomp(":empty")) evals.add(new Evaluator.IsEmpty()); else if (tq.matchChomp(":root")) evals.add(new Evaluator.IsRoot()); else /* unhandled*/ throw new Selector.SelectorParseException("Could not parse query '%s': unexpected token at '%s'", query, tq.remainder());  }
private String consumeSubQuery() { StringBuilder sq = new StringBuilder(); while (!tq.isEmpty()) { if (tq.matches("(")) sq.append("(").append(tq.chompBalanced('(', ')')).append(")"); else if (tq.matches("[")) sq.append("[").append(tq.chompBalanced('[', ']')).append("]"); else if (tq.matchesAny(combinators)) break; else sq.append(tq.consume()); } return sq.toString(); } evals.add(new Evaluator.IsLastOfType()); <BUGS> else if (tq.matchChomp(":only-child")) <BUGE> evals.add(new Evaluator.IsOnlyChild()); else if (tq.matchChomp(":only-of-type")) evals.add(new Evaluator.IsOnlyOfType()); else if (tq.matchChomp(":empty")) evals.add(new Evaluator.IsEmpty()); else if (tq.matchChomp(":root")) evals.add(new Evaluator.IsRoot()); else /* unhandled*/ throw new Selector.SelectorParseException("Could not parse query '%s': unexpected token at '%s'", query, tq.remainder());  }  private void byId() { String id = tq.consumeCssIdentifier();
private String consumeSubQuery() { StringBuilder sq = new StringBuilder(); while (!tq.isEmpty()) { if (tq.matches("(")) sq.append("(").append(tq.chompBalanced('(', ')')).append(")"); else if (tq.matches("[")) sq.append("[").append(tq.chompBalanced('[', ']')).append("]"); else if (tq.matchesAny(combinators)) break; else sq.append(tq.consume()); } return sq.toString(); } evals.add(new Evaluator.IsOnlyChild()); <BUGS> else if (tq.matchChomp(":only-of-type")) <BUGE> evals.add(new Evaluator.IsOnlyOfType()); else if (tq.matchChomp(":empty")) evals.add(new Evaluator.IsEmpty()); else if (tq.matchChomp(":root")) evals.add(new Evaluator.IsRoot()); else /* unhandled*/ throw new Selector.SelectorParseException("Could not parse query '%s': unexpected token at '%s'", query, tq.remainder());  }  private void byId() { String id = tq.consumeCssIdentifier(); Validate.notEmpty(id); evals.add(new Evaluator.Id(id));
private String consumeSubQuery() { StringBuilder sq = new StringBuilder(); while (!tq.isEmpty()) { if (tq.matches("(")) sq.append("(").append(tq.chompBalanced('(', ')')).append(")"); else if (tq.matches("[")) sq.append("[").append(tq.chompBalanced('[', ']')).append("]"); else if (tq.matchesAny(combinators)) break; else sq.append(tq.consume()); } return sq.toString(); } evals.add(new Evaluator.IsOnlyOfType()); <BUGS> else if (tq.matchChomp(":empty")) <BUGE> evals.add(new Evaluator.IsEmpty()); else if (tq.matchChomp(":root")) evals.add(new Evaluator.IsRoot()); else /* unhandled*/ throw new Selector.SelectorParseException("Could not parse query '%s': unexpected token at '%s'", query, tq.remainder());  }  private void byId() { String id = tq.consumeCssIdentifier(); Validate.notEmpty(id); evals.add(new Evaluator.Id(id)); }
private String consumeSubQuery() { StringBuilder sq = new StringBuilder(); while (!tq.isEmpty()) { if (tq.matches("(")) sq.append("(").append(tq.chompBalanced('(', ')')).append(")"); else if (tq.matches("[")) sq.append("[").append(tq.chompBalanced('[', ']')).append("]"); else if (tq.matchesAny(combinators)) break; else sq.append(tq.consume()); } return sq.toString(); } evals.add(new Evaluator.IsEmpty()); <BUGS> else if (tq.matchChomp(":root")) <BUGE> evals.add(new Evaluator.IsRoot()); else /* unhandled*/ throw new Selector.SelectorParseException("Could not parse query '%s': unexpected token at '%s'", query, tq.remainder());  }  private void byId() { String id = tq.consumeCssIdentifier(); Validate.notEmpty(id); evals.add(new Evaluator.Id(id)); }  private void byClass() { String className = tq.consumeCssIdentifier();
private String consumeSubQuery() { StringBuilder sq = new StringBuilder(); while (!tq.isEmpty()) { if (tq.matches("(")) sq.append("(").append(tq.chompBalanced('(', ')')).append(")"); else if (tq.matches("[")) sq.append("[").append(tq.chompBalanced('[', ']')).append("]"); else if (tq.matchesAny(combinators)) break; else sq.append(tq.consume()); } return sq.toString(); } else /* unhandled*/ <BUGS> throw new Selector.SelectorParseException("Could not parse query '%s': unexpected token at '%s'", query, tq.remainder()); <BUGE>  }  private void byId() { String id = tq.consumeCssIdentifier(); Validate.notEmpty(id); evals.add(new Evaluator.Id(id)); }  private void byClass() { String className = tq.consumeCssIdentifier(); Validate.notEmpty(className); evals.add(new Evaluator.Class(className.trim())); }
private String consumeSubQuery() { StringBuilder sq = new StringBuilder(); while (!tq.isEmpty()) { if (tq.matches("(")) sq.append("(").append(tq.chompBalanced('(', ')')).append(")"); else if (tq.matches("[")) sq.append("[").append(tq.chompBalanced('[', ']')).append("]"); else if (tq.matchesAny(combinators)) break; else sq.append(tq.consume()); } return sq.toString(); }  <BUGS> } <BUGE>  private void byId() { String id = tq.consumeCssIdentifier(); Validate.notEmpty(id); evals.add(new Evaluator.Id(id)); }  private void byClass() { String className = tq.consumeCssIdentifier(); Validate.notEmpty(className); evals.add(new Evaluator.Class(className.trim())); }  private void byTag() {
*/ protected static boolean isBooleanAttribute(final String key) { <BUGS> return Arrays.binarySearch(booleanAttributes, key) >= 0; <BUGE> }
*/ public String wholeText() { <BUGS> final StringBuilder accum = new StringBuilder(); NodeTraversor.traverse(new NodeVisitor() { <BUGE> public void head(Node node, int depth) { if (node instanceof TextNode) { TextNode textNode = (TextNode) node; accum.append(textNode.getWholeText()); } }  public void tail(Node node, int depth) { } }, this); return accum.toString(); }
*/ public String wholeText() { final StringBuilder accum = new StringBuilder(); NodeTraversor.traverse(new NodeVisitor() { public void head(Node node, int depth) { if (node instanceof TextNode) { TextNode textNode = (TextNode) node; accum.append(textNode.getWholeText()); } }  public void tail(Node node, int depth) { } }, this); <BUGS> return accum.toString(); <BUGE> }
*/ private void popStackToClose(Token.EndTag endTag) { <BUGS> String elName = endTag.name(); Element firstFound = null; <BUGE>  for (int pos = stack.size() -1; pos >= 0; pos--) { Element next = stack.get(pos); if (next.nodeName().equals(elName)) { firstFound = next; break; } } if (firstFound == null) return; /* not found, skip*/  for (int pos = stack.size() -1; pos >= 0; pos--) { Element next = stack.get(pos); stack.remove(pos); if (next == firstFound) break; } }
*/ private void popStackToClose(Token.EndTag endTag) { String elName = endTag.name(); Element firstFound = null;  <BUGS> for (int pos = stack.size() -1; pos >= 0; pos--) { Element next = stack.get(pos); if (next.nodeName().equals(elName)) { firstFound = next; break; <BUGE> } } if (firstFound == null) return; /* not found, skip*/  for (int pos = stack.size() -1; pos >= 0; pos--) { Element next = stack.get(pos); stack.remove(pos); if (next == firstFound) break; } }
*/ private void popStackToClose(Token.EndTag endTag) { String elName = endTag.name(); Element firstFound = null;  for (int pos = stack.size() -1; pos >= 0; pos--) { Element next = stack.get(pos); if (next.nodeName().equals(elName)) { firstFound = next; break; } } <BUGS> if (firstFound == null) return; /* not found, skip <BUGE>*/  for (int pos = stack.size() -1; pos >= 0; pos--) { Element next = stack.get(pos); stack.remove(pos); if (next == firstFound) break; } }
*/ private void popStackToClose(Token.EndTag endTag) { String elName = endTag.name(); Element firstFound = null;  for (int pos = stack.size() -1; pos >= 0; pos--) { Element next = stack.get(pos); if (next.nodeName().equals(elName)) { firstFound = next; break; } } if (firstFound == null) return; /* not found, skip*/  <BUGS> for (int pos = stack.size() -1; pos >= 0; pos--) { Element next = stack.get(pos); stack.remove(pos); if (next == firstFound) break; <BUGE> } }
*/ private void popStackToClose(Token.EndTag endTag) { String elName = endTag.name(); Element firstFound = null;  for (int pos = stack.size() -1; pos >= 0; pos--) { Element next = stack.get(pos); if (next.nodeName().equals(elName)) { firstFound = next; break; } } if (firstFound == null) return; /* not found, skip*/  for (int pos = stack.size() -1; pos >= 0; pos--) { Element next = stack.get(pos); stack.remove(pos); if (next == firstFound) break; } <BUGS> } <BUGE>
private void bufferUp() { <BUGS> if (bufPos < bufSplitPoint) return; <BUGE>  try { reader.skip(bufPos); reader.mark(maxBufferLen); final int read = reader.read(charBuf); reader.reset(); if (read != -1) { bufLength = read; readerPos += bufPos; bufPos = 0; bufMark = 0; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength; } } catch (IOException e) { throw new UncheckedIOException(e); } }
private void bufferUp() { if (bufPos < bufSplitPoint) return;  try { <BUGS> reader.skip(bufPos); reader.mark(maxBufferLen); final int read = reader.read(charBuf); reader.reset(); if (read != -1) { bufLength = read; readerPos += bufPos; bufPos = 0; bufMark = 0; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength; <BUGE> } } catch (IOException e) { throw new UncheckedIOException(e); } }
private void bufferUp() { if (bufPos < bufSplitPoint) return;  try { reader.skip(bufPos); reader.mark(maxBufferLen); final int read = reader.read(charBuf); reader.reset(); if (read != -1) { bufLength = read; readerPos += bufPos; bufPos = 0; bufMark = 0; bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength; } <BUGS> } catch (IOException e) { throw new UncheckedIOException(e); } } <BUGE>
@Override protected List<Node> ensureChildNodes() { <BUGS> throw new UnsupportedOperationException("Leaf Nodes do not have child nodes."); <BUGE> }
*/ public static Document parse(InputStream in, String charsetName, String baseUri) throws IOException { <BUGS> return DataUtil.load(in, charsetName, baseUri); <BUGE> }
*/ public static Document parse(InputStream in, String charsetName, String baseUri) throws IOException { <BUGS> return DataUtil.load(in, charsetName, baseUri); <BUGE> }
*/ public Attribute(String key, String value) { <BUGS> this(key, value, null); } <BUGE>
*/ public void setKey(String key) { <BUGS> Validate.notNull(key); key = key.trim(); Validate.notEmpty(key); /* trimming could potentially make empty, so validate here*/ if (parent != null) { <BUGE> int i = parent.indexOfKey(this.key); if (i != Attributes.NotFound) parent.keys[i] = key; } this.key = key; }
*/ public void setKey(String key) { Validate.notNull(key); key = key.trim(); Validate.notEmpty(key); /* trimming could potentially make empty, so validate here*/ if (parent != null) { int i = parent.indexOfKey(this.key); if (i != Attributes.NotFound) parent.keys[i] = key; } <BUGS> this.key = key; } <BUGE>
private static boolean looksLikeUtf8(byte[] input) { <BUGS> int i = 0; <BUGE> /* BOM:*/ if (input.length >= 3 && (input[0] & 0xFF) == 0xEF && (input[1] & 0xFF) == 0xBB & (input[2] & 0xFF) == 0xBF) { i = 3; }  int end; for (int j = input.length; i < j; ++i) { int o = input[i]; if ((o & 0x80) == 0) { continue; /* ASCII*/ }  /* UTF-8 leading:*/ if ((o & 0xE0) == 0xC0) { end = i + 1; } else if ((o & 0xF0) == 0xE0) { end = i + 2; } else if ((o & 0xF8) == 0xF0) { end = i + 3; } else { return false; }   while (i < end) { i++;
private static boolean looksLikeUtf8(byte[] input) { int i = 0; /* BOM:*/ <BUGS> if (input.length >= 3 && (input[0] & 0xFF) == 0xEF <BUGE> && (input[1] & 0xFF) == 0xBB & (input[2] & 0xFF) == 0xBF) { i = 3; }  int end; for (int j = input.length; i < j; ++i) { int o = input[i]; if ((o & 0x80) == 0) { continue; /* ASCII*/ }  /* UTF-8 leading:*/ if ((o & 0xE0) == 0xC0) { end = i + 1; } else if ((o & 0xF0) == 0xE0) { end = i + 2; } else if ((o & 0xF8) == 0xF0) { end = i + 3; } else { return false; }   while (i < end) { i++;
private static boolean looksLikeUtf8(byte[] input) { int i = 0; /* BOM:*/ if (input.length >= 3 && (input[0] & 0xFF) == 0xEF && (input[1] & 0xFF) == 0xBB & (input[2] & 0xFF) == 0xBF) { i = 3; }  int end; <BUGS> for (int j = input.length; i < j; ++i) { int o = input[i]; if ((o & 0x80) == 0) { continue; /* ASCII <BUGE>*/ }  /* UTF-8 leading:*/ if ((o & 0xE0) == 0xC0) { end = i + 1; } else if ((o & 0xF0) == 0xE0) { end = i + 2; } else if ((o & 0xF8) == 0xF0) { end = i + 3; } else { return false; }   while (i < end) { i++;
private static boolean looksLikeUtf8(byte[] input) { int i = 0; /* BOM:*/ if (input.length >= 3 && (input[0] & 0xFF) == 0xEF && (input[1] & 0xFF) == 0xBB & (input[2] & 0xFF) == 0xBF) { i = 3; }  int end; for (int j = input.length; i < j; ++i) { int o = input[i]; if ((o & 0x80) == 0) { continue; /* ASCII*/ }  /* UTF-8 leading:*/ <BUGS> if ((o & 0xE0) == 0xC0) { <BUGE> end = i + 1; } else if ((o & 0xF0) == 0xE0) { end = i + 2; } else if ((o & 0xF8) == 0xF0) { end = i + 3; } else { return false; }   while (i < end) { i++;
private static boolean looksLikeUtf8(byte[] input) { int i = 0; /* BOM:*/ if (input.length >= 3 && (input[0] & 0xFF) == 0xEF && (input[1] & 0xFF) == 0xBB & (input[2] & 0xFF) == 0xBF) { i = 3; }  int end; for (int j = input.length; i < j; ++i) { int o = input[i]; if ((o & 0x80) == 0) { continue; /* ASCII*/ }  /* UTF-8 leading:*/ if ((o & 0xE0) == 0xC0) { end = i + 1; <BUGS> } else if ((o & 0xF0) == 0xE0) { end = i + 2; <BUGE> } else if ((o & 0xF8) == 0xF0) { end = i + 3; } else { return false; }   while (i < end) { i++;
private static boolean looksLikeUtf8(byte[] input) { int i = 0; /* BOM:*/ if (input.length >= 3 && (input[0] & 0xFF) == 0xEF && (input[1] & 0xFF) == 0xBB & (input[2] & 0xFF) == 0xBF) { i = 3; }  int end; for (int j = input.length; i < j; ++i) { int o = input[i]; if ((o & 0x80) == 0) { continue; /* ASCII*/ }  /* UTF-8 leading:*/ if ((o & 0xE0) == 0xC0) { end = i + 1; } else if ((o & 0xF0) == 0xE0) { end = i + 2; } else if ((o & 0xF8) == 0xF0) { end = i + 3; } else { return false; }   <BUGS> while (i < end) { i++;
return getHeadersCaseInsensitive(name); }  private static String fixHeaderEncoding(String val) { try { byte[] bytes = val.getBytes("ISO-8859-1"); if (!looksLikeUtf8(bytes)) return val; return new String(bytes, "UTF-8"); } catch (UnsupportedEncodingException e) { /* shouldn't happen as these both always exist*/ return val; } } } <BUGS> return true; <BUGE> }  public T header(String name, String value) { Validate.notEmpty(name, "Header name must not be empty"); removeHeader(name); /* ensures we don't get an "accept-encoding" and a "Accept-Encoding"*/ addHeader(name, value); return (T) this; }  public boolean hasHeader(String name) { Validate.notEmpty(name, "Header name must not be empty"); return getHeadersCaseInsensitive(name).size() != 0; }
public Connection ignoreContentType(boolean ignoreContentType) { <BUGS> req.ignoreContentType(ignoreContentType); return this; <BUGE> }
public Connection ignoreContentType(boolean ignoreContentType) { req.ignoreContentType(ignoreContentType); return this; }
*/ public Attributes put(String key, String value) { <BUGS> int i = indexOfKey(key); if (i != NotFound) vals[i] = value; <BUGE> else add(key, value); return this; }
*/ public Attributes put(String key, String value) { int i = indexOfKey(key); if (i != NotFound) vals[i] = value; else <BUGS> add(key, value); return this; <BUGE> }
/** {@inheritDoc} */
/** {@inheritDoc} */
/** {@inheritDoc} */
*/ public int sample() { <BUGS> return inverseCumulativeProbability(random.nextDouble()); <BUGE> }
*/ public static double linearCombination(final double[] a, final double[] b) throws DimensionMismatchException { <BUGS> final int len = a.length; if (len != b.length) { <BUGE> throw new DimensionMismatchException(len, b.length); }  /* Revert to scalar multiplication.*/  final double[] prodHigh = new double[len]; double prodLowSum = 0;  for (int i = 0; i < len; i++) { final double ai = a[i]; final double ca = SPLIT_FACTOR * ai; final double aHigh = ca - (ca - ai); final double aLow = ai - aHigh;  final double bi = b[i]; final double cb = SPLIT_FACTOR * bi; final double bHigh = cb - (cb - bi); final double bLow = bi - bHigh; prodHigh[i] = ai * bi; final double prodLow = aLow * bLow - (((prodHigh[i] - aHigh * bHigh) - aLow * bHigh) - aHigh * bLow); prodLowSum += prodLow; }
*/ public static double linearCombination(final double[] a, final double[] b) throws DimensionMismatchException { final int len = a.length; if (len != b.length) { throw new DimensionMismatchException(len, b.length); }  /* Revert to scalar multiplication.*/  <BUGS> final double[] prodHigh = new double[len]; double prodLowSum = 0; <BUGE>  for (int i = 0; i < len; i++) { final double ai = a[i]; final double ca = SPLIT_FACTOR * ai; final double aHigh = ca - (ca - ai); final double aLow = ai - aHigh;  final double bi = b[i]; final double cb = SPLIT_FACTOR * bi; final double bHigh = cb - (cb - bi); final double bLow = bi - bHigh; prodHigh[i] = ai * bi; final double prodLow = aLow * bLow - (((prodHigh[i] - aHigh * bHigh) - aLow * bHigh) - aHigh * bLow); prodLowSum += prodLow; }
*/ public static double linearCombination(final double[] a, final double[] b) throws DimensionMismatchException { final int len = a.length; if (len != b.length) { throw new DimensionMismatchException(len, b.length); }  /* Revert to scalar multiplication.*/  final double[] prodHigh = new double[len]; double prodLowSum = 0;  <BUGS> for (int i = 0; i < len; i++) { final double ai = a[i]; final double ca = SPLIT_FACTOR * ai; final double aHigh = ca - (ca - ai); final double aLow = ai - aHigh; <BUGE>  final double bi = b[i]; final double cb = SPLIT_FACTOR * bi; final double bHigh = cb - (cb - bi); final double bLow = bi - bHigh; prodHigh[i] = ai * bi; final double prodLow = aLow * bLow - (((prodHigh[i] - aHigh * bHigh) - aLow * bHigh) - aHigh * bLow); prodLowSum += prodLow; }
*/ public static double linearCombination(final double[] a, final double[] b) throws DimensionMismatchException { final int len = a.length; if (len != b.length) { throw new DimensionMismatchException(len, b.length); }  /* Revert to scalar multiplication.*/  final double[] prodHigh = new double[len]; double prodLowSum = 0;  for (int i = 0; i < len; i++) { final double ai = a[i]; final double ca = SPLIT_FACTOR * ai; final double aHigh = ca - (ca - ai); final double aLow = ai - aHigh;  <BUGS> final double bi = b[i]; final double cb = SPLIT_FACTOR * bi; final double bHigh = cb - (cb - bi); final double bLow = bi - bHigh; prodHigh[i] = ai * bi; final double prodLow = aLow * bLow - (((prodHigh[i] - <BUGE> aHigh * bHigh) - aLow * bHigh) - aHigh * bLow); prodLowSum += prodLow; }
*/ public static double linearCombination(final double[] a, final double[] b) throws DimensionMismatchException { final int len = a.length; if (len != b.length) { throw new DimensionMismatchException(len, b.length); }  /* Revert to scalar multiplication.*/  final double[] prodHigh = new double[len]; double prodLowSum = 0;  for (int i = 0; i < len; i++) { final double ai = a[i]; final double ca = SPLIT_FACTOR * ai; final double aHigh = ca - (ca - ai); final double aLow = ai - aHigh;  final double bi = b[i]; final double cb = SPLIT_FACTOR * bi; final double bHigh = cb - (cb - bi); final double bLow = bi - bHigh; prodHigh[i] = ai * bi; final double prodLow = aLow * bLow - (((prodHigh[i] - aHigh * bHigh) - aLow * bHigh) - aHigh * bLow); <BUGS> prodLowSum += prodLow; <BUGE> }
* This method computes the sum of the products * <code>a<sub>i</sub> b<sub>i</sub></code> to high accuracy. * It does so by using specific multiplication and addition algorithms to * preserve accuracy and reduce cancellation effects. * <br/> * It is based on the 2005 paper * <a href="http:/*citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.2.1547">*/ * Accurate Sum and Dot Product</a> by Takeshi Ogita, Siegfried M. Rump, * and Shin'ichi Oishi published in SIAM J. Sci. Comput. * * @param a Factors. * @param b Factors. * @return <code>&Sigma;<sub>i</sub> a<sub>i</sub> b<sub>i</sub></code>. * @throws DimensionMismatchException if arrays dimensions don't match  <BUGS> final double prodHighCur = prodHigh[0]; double prodHighNext = prodHigh[1]; <BUGE> double sHighPrev = prodHighCur + prodHighNext; double sPrime = sHighPrev - prodHighNext; double sLowSum = (prodHighNext - (sHighPrev - sPrime)) + (prodHighCur - sPrime);  final int lenMinusOne = len - 1; for (int i = 1; i < lenMinusOne; i++) { prodHighNext = prodHigh[i + 1]; final double sHighCur = sHighPrev + prodHighNext; sPrime = sHighCur - prodHighNext; sLowSum += (prodHighNext - (sHighCur - sPrime)) + (sHighPrev - sPrime); sHighPrev = sHighCur; }
*/ public Vector2D intersection(final SubLine subLine, final boolean includeEndPoints) {  /* retrieve the underlying lines*/ <BUGS> Line line1 = (Line) getHyperplane(); Line line2 = (Line) subLine.getHyperplane(); <BUGE>  /* compute the intersection on infinite line*/ Vector2D v2D = line1.intersection(line2);  /* check location of point with respect to first sub-line*/ Location loc1 = getRemainingRegion().checkPoint(line1.toSubSpace(v2D));  /* check location of point with respect to second sub-line*/ Location loc2 = subLine.getRemainingRegion().checkPoint(line2.toSubSpace(v2D));  if (includeEndPoints) { return ((loc1 != Location.OUTSIDE) && (loc2 != Location.OUTSIDE)) ? v2D : null; } else { return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE)) ? v2D : null; }  }
*/ public Vector2D intersection(final SubLine subLine, final boolean includeEndPoints) {  /* retrieve the underlying lines*/ Line line1 = (Line) getHyperplane(); Line line2 = (Line) subLine.getHyperplane();  /* compute the intersection on infinite line*/ <BUGS> Vector2D v2D = line1.intersection(line2); <BUGE>  /* check location of point with respect to first sub-line*/ Location loc1 = getRemainingRegion().checkPoint(line1.toSubSpace(v2D));  /* check location of point with respect to second sub-line*/ Location loc2 = subLine.getRemainingRegion().checkPoint(line2.toSubSpace(v2D));  if (includeEndPoints) { return ((loc1 != Location.OUTSIDE) && (loc2 != Location.OUTSIDE)) ? v2D : null; } else { return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE)) ? v2D : null; }  }
*/ public Vector2D intersection(final SubLine subLine, final boolean includeEndPoints) {  /* retrieve the underlying lines*/ Line line1 = (Line) getHyperplane(); Line line2 = (Line) subLine.getHyperplane();  /* compute the intersection on infinite line*/ Vector2D v2D = line1.intersection(line2);  /* check location of point with respect to first sub-line*/ <BUGS> Location loc1 = getRemainingRegion().checkPoint(line1.toSubSpace(v2D)); <BUGE>  /* check location of point with respect to second sub-line*/ Location loc2 = subLine.getRemainingRegion().checkPoint(line2.toSubSpace(v2D));  if (includeEndPoints) { return ((loc1 != Location.OUTSIDE) && (loc2 != Location.OUTSIDE)) ? v2D : null; } else { return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE)) ? v2D : null; }  }
/** {@inheritDoc} */
/** {@inheritDoc} */
*/ public int getIterations() { <BUGS> return iterations.getCount(); <BUGE> }
*/ public DiscreteDistribution(final List<Pair<T, Double>> samples) throws NotPositiveException, MathArithmeticException, MathIllegalArgumentException { <BUGS> this(new Well19937c(), samples); } <BUGE>
*/ public double[] toArray() { <BUGS> return new double[] { x, y, z }; <BUGE> }
*/ private static double atan(double xa, double xb, boolean leftPlane) { <BUGS> boolean negate = false; <BUGE> int idx;  if (xa == 0.0) { /* Matches +/- 0.0; return correct sign*/ return leftPlane ? copySign(Math.PI, xa) : xa; }  if (xa < 0) { /* negative*/ xa = -xa; xb = -xb; negate = true; }  if (xa > 1.633123935319537E16) { /* Very large input*/ return (negate ^ leftPlane) ? (-Math.PI * F_1_2) : (Math.PI * F_1_2); }  /* Estimate the closest tabulated arctan value, compute eps = xa-tangentTable */ if (xa < 1) { idx = (int) (((-1.7168146928204136 * xa * xa + 8.0) * xa) + 0.5); } else { final double oneOverXa = 1 / xa; idx = (int) (-((-1.7168146928204136 * oneOverXa * oneOverXa + 8.0) * oneOverXa) + 13.07); } double epsA = xa - TANGENT_TABLE_A[idx]; double epsB = -(epsA - xa + TANGENT_TABLE_A[idx]); epsB += xb - TANGENT_TABLE_B[idx];
*/ private static double atan(double xa, double xb, boolean leftPlane) { boolean negate = false; int idx;  <BUGS> if (xa == 0.0) { /* Matches +/- 0.0; return correct sign <BUGE>*/ return leftPlane ? copySign(Math.PI, xa) : xa; }  if (xa < 0) { /* negative*/ xa = -xa; xb = -xb; negate = true; }  if (xa > 1.633123935319537E16) { /* Very large input*/ return (negate ^ leftPlane) ? (-Math.PI * F_1_2) : (Math.PI * F_1_2); }  /* Estimate the closest tabulated arctan value, compute eps = xa-tangentTable */ if (xa < 1) { idx = (int) (((-1.7168146928204136 * xa * xa + 8.0) * xa) + 0.5); } else { final double oneOverXa = 1 / xa; idx = (int) (-((-1.7168146928204136 * oneOverXa * oneOverXa + 8.0) * oneOverXa) + 13.07); } double epsA = xa - TANGENT_TABLE_A[idx]; double epsB = -(epsA - xa + TANGENT_TABLE_A[idx]); epsB += xb - TANGENT_TABLE_B[idx];
*/ private static double atan(double xa, double xb, boolean leftPlane) { boolean negate = false; int idx;  if (xa == 0.0) { /* Matches +/- 0.0; return correct sign*/ return leftPlane ? copySign(Math.PI, xa) : xa; }  <BUGS> if (xa < 0) { <BUGE> /* negative*/ xa = -xa; xb = -xb; negate = true; }  if (xa > 1.633123935319537E16) { /* Very large input*/ return (negate ^ leftPlane) ? (-Math.PI * F_1_2) : (Math.PI * F_1_2); }  /* Estimate the closest tabulated arctan value, compute eps = xa-tangentTable */ if (xa < 1) { idx = (int) (((-1.7168146928204136 * xa * xa + 8.0) * xa) + 0.5); } else { final double oneOverXa = 1 / xa; idx = (int) (-((-1.7168146928204136 * oneOverXa * oneOverXa + 8.0) * oneOverXa) + 13.07); } double epsA = xa - TANGENT_TABLE_A[idx]; double epsB = -(epsA - xa + TANGENT_TABLE_A[idx]); epsB += xb - TANGENT_TABLE_B[idx];
*/ private static double atan(double xa, double xb, boolean leftPlane) { boolean negate = false; int idx;  if (xa == 0.0) { /* Matches +/- 0.0; return correct sign*/ return leftPlane ? copySign(Math.PI, xa) : xa; }  if (xa < 0) { /* negative*/ xa = -xa; xb = -xb; negate = true; }  <BUGS> if (xa > 1.633123935319537E16) { /* Very large input <BUGE>*/ return (negate ^ leftPlane) ? (-Math.PI * F_1_2) : (Math.PI * F_1_2); }  /* Estimate the closest tabulated arctan value, compute eps = xa-tangentTable */ if (xa < 1) { idx = (int) (((-1.7168146928204136 * xa * xa + 8.0) * xa) + 0.5); } else { final double oneOverXa = 1 / xa; idx = (int) (-((-1.7168146928204136 * oneOverXa * oneOverXa + 8.0) * oneOverXa) + 13.07); } double epsA = xa - TANGENT_TABLE_A[idx]; double epsB = -(epsA - xa + TANGENT_TABLE_A[idx]); epsB += xb - TANGENT_TABLE_B[idx];
*/ private static double atan(double xa, double xb, boolean leftPlane) { boolean negate = false; int idx;  if (xa == 0.0) { /* Matches +/- 0.0; return correct sign*/ return leftPlane ? copySign(Math.PI, xa) : xa; }  if (xa < 0) { /* negative*/ xa = -xa; xb = -xb; negate = true; }  if (xa > 1.633123935319537E16) { /* Very large input*/ return (negate ^ leftPlane) ? (-Math.PI * F_1_2) : (Math.PI * F_1_2); }  /* Estimate the closest tabulated arctan value, compute eps = xa-tangentTable */ <BUGS> if (xa < 1) { <BUGE> idx = (int) (((-1.7168146928204136 * xa * xa + 8.0) * xa) + 0.5); } else { final double oneOverXa = 1 / xa; idx = (int) (-((-1.7168146928204136 * oneOverXa * oneOverXa + 8.0) * oneOverXa) + 13.07); } double epsA = xa - TANGENT_TABLE_A[idx]; double epsB = -(epsA - xa + TANGENT_TABLE_A[idx]); epsB += xb - TANGENT_TABLE_B[idx];
*/ private static double atan(double xa, double xb, boolean leftPlane) { boolean negate = false; int idx;  if (xa == 0.0) { /* Matches +/- 0.0; return correct sign*/ return leftPlane ? copySign(Math.PI, xa) : xa; }  if (xa < 0) { /* negative*/ xa = -xa; xb = -xb; negate = true; }  if (xa > 1.633123935319537E16) { /* Very large input*/ return (negate ^ leftPlane) ? (-Math.PI * F_1_2) : (Math.PI * F_1_2); }  /* Estimate the closest tabulated arctan value, compute eps = xa-tangentTable */ if (xa < 1) { idx = (int) (((-1.7168146928204136 * xa * xa + 8.0) * xa) + 0.5); } else { <BUGS> final double oneOverXa = 1 / xa; idx = (int) (-((-1.7168146928204136 * oneOverXa * oneOverXa + 8.0) * oneOverXa) + 13.07); <BUGE> } double epsA = xa - TANGENT_TABLE_A[idx]; double epsB = -(epsA - xa + TANGENT_TABLE_A[idx]); epsB += xb - TANGENT_TABLE_B[idx];
*/ private static double atan(double xa, double xb, boolean leftPlane) { boolean negate = false; int idx;  if (xa == 0.0) { /* Matches +/- 0.0; return correct sign*/ return leftPlane ? copySign(Math.PI, xa) : xa; }  if (xa < 0) { /* negative*/ xa = -xa; xb = -xb; negate = true; }  if (xa > 1.633123935319537E16) { /* Very large input*/ return (negate ^ leftPlane) ? (-Math.PI * F_1_2) : (Math.PI * F_1_2); }  /* Estimate the closest tabulated arctan value, compute eps = xa-tangentTable */ if (xa < 1) { idx = (int) (((-1.7168146928204136 * xa * xa + 8.0) * xa) + 0.5); } else { final double oneOverXa = 1 / xa; idx = (int) (-((-1.7168146928204136 * oneOverXa * oneOverXa + 8.0) * oneOverXa) + 13.07); } <BUGS> double epsA = xa - TANGENT_TABLE_A[idx]; double epsB = -(epsA - xa + TANGENT_TABLE_A[idx]); epsB += xb - TANGENT_TABLE_B[idx]; <BUGE>
* Arctangent function *  @param x a number *  @return atan(x) */ public static double atan(double x) { return atan(x, 0.0, false); }  /** Internal helper function to compute arctangent. * @param xa number from which arctangent is requested * @param xb extra bits for x (may be 0.0) * @param leftPlane if true, result angle must be put in the left half plane * @return atan(xa + xb) (or angle shifted by {@code PI} if leftPlane is true)  <BUGS> double temp = epsA + epsB; epsB = -(temp - epsA - epsB); epsA = temp; <BUGE>  /* Compute eps = eps / (1.0 + xa*tangent) */ temp = xa * HEX_40000000; double ya = xa + temp - temp; double yb = xb + xa - ya; xa = ya; xb += yb;  /*if (idx > 8 || idx == 0)*/ if (idx == 0) { /* If the slope of the arctan is gentle enough (< 0.45), this approximation will suffice */ /*double denom = 1.0 / (1.0 + xa*tangentTableA[idx] + xb*tangentTableA[idx] + xa*tangentTableB[idx] + xb*tangentTableB[idx]);*/ final double denom = 1d / (1d + (xa + xb) * (TANGENT_TABLE_A[idx] + TANGENT_TABLE_B[idx]));
*  @param x a number *  @return atan(x) */ public static double atan(double x) { return atan(x, 0.0, false); }  /** Internal helper function to compute arctangent. * @param xa number from which arctangent is requested * @param xb extra bits for x (may be 0.0) * @param leftPlane if true, result angle must be put in the left half plane * @return atan(xa + xb) (or angle shifted by {@code PI} if leftPlane is true) /* Compute eps = eps / (1.0 + xa*tangent) */ <BUGS> temp = xa * HEX_40000000; double ya = xa + temp - temp; double yb = xb + xa - ya; xa = ya; xb += yb; <BUGE>  /*if (idx > 8 || idx == 0)*/ if (idx == 0) { /* If the slope of the arctan is gentle enough (< 0.45), this approximation will suffice */ /*double denom = 1.0 / (1.0 + xa*tangentTableA[idx] + xb*tangentTableA[idx] + xa*tangentTableB[idx] + xb*tangentTableB[idx]);*/ final double denom = 1d / (1d + (xa + xb) * (TANGENT_TABLE_A[idx] + TANGENT_TABLE_B[idx])); /*double denom = 1.0 / (1.0 + xa*tangentTableA[idx]);*/ ya = epsA * denom; yb = epsB * denom; } else { double temp2 = xa * TANGENT_TABLE_A[idx]; double za = 1d + temp2;
/** * Arctangent function *  @param x a number *  @return atan(x) */ public static double atan(double x) { return atan(x, 0.0, false); }  /** Internal helper function to compute arctangent. * @param xa number from which arctangent is requested * @param xb extra bits for x (may be 0.0) * @param leftPlane if true, result angle must be put in the left half plane * @return atan(xa + xb) (or angle shifted by {@code PI} if leftPlane is true) /*if (idx > 8 || idx == 0)*/ <BUGS> if (idx == 0) { <BUGE> /* If the slope of the arctan is gentle enough (< 0.45), this approximation will suffice */ /*double denom = 1.0 / (1.0 + xa*tangentTableA[idx] + xb*tangentTableA[idx] + xa*tangentTableB[idx] + xb*tangentTableB[idx]);*/ final double denom = 1d / (1d + (xa + xb) * (TANGENT_TABLE_A[idx] + TANGENT_TABLE_B[idx])); /*double denom = 1.0 / (1.0 + xa*tangentTableA[idx]);*/ ya = epsA * denom; yb = epsB * denom; } else { double temp2 = xa * TANGENT_TABLE_A[idx]; double za = 1d + temp2; double zb = -(za - 1d - temp2); temp2 = xb * TANGENT_TABLE_A[idx] + xa * TANGENT_TABLE_B[idx]; temp = za + temp2; zb += -(temp - za - temp2); za = temp;
/** * Arctangent function *  @param x a number *  @return atan(x) */ public static double atan(double x) { return atan(x, 0.0, false); }  /** Internal helper function to compute arctangent. * @param xa number from which arctangent is requested * @param xb extra bits for x (may be 0.0) * @param leftPlane if true, result angle must be put in the left half plane * @return atan(xa + xb) (or angle shifted by {@code PI} if leftPlane is true) /*double denom = 1.0 / (1.0 + xa*tangentTableA[idx] + xb*tangentTableA[idx] + xa*tangentTableB[idx] + xb*tangentTableB[idx]);*/ <BUGS> final double denom = 1d / (1d + (xa + xb) * (TANGENT_TABLE_A[idx] + TANGENT_TABLE_B[idx])); <BUGE> /*double denom = 1.0 / (1.0 + xa*tangentTableA[idx]);*/ ya = epsA * denom; yb = epsB * denom; } else { double temp2 = xa * TANGENT_TABLE_A[idx]; double za = 1d + temp2; double zb = -(za - 1d - temp2); temp2 = xb * TANGENT_TABLE_A[idx] + xa * TANGENT_TABLE_B[idx]; temp = za + temp2; zb += -(temp - za - temp2); za = temp;  zb += xb * TANGENT_TABLE_B[idx]; ya = epsA / za;
* Arctangent function *  @param x a number *  @return atan(x) */ public static double atan(double x) { return atan(x, 0.0, false); }  /** Internal helper function to compute arctangent. * @param xa number from which arctangent is requested * @param xb extra bits for x (may be 0.0) * @param leftPlane if true, result angle must be put in the left half plane * @return atan(xa + xb) (or angle shifted by {@code PI} if leftPlane is true) /*double denom = 1.0 / (1.0 + xa*tangentTableA[idx]);*/ <BUGS> ya = epsA * denom; yb = epsB * denom; } else { <BUGE> double temp2 = xa * TANGENT_TABLE_A[idx]; double za = 1d + temp2; double zb = -(za - 1d - temp2); temp2 = xb * TANGENT_TABLE_A[idx] + xa * TANGENT_TABLE_B[idx]; temp = za + temp2; zb += -(temp - za - temp2); za = temp;  zb += xb * TANGENT_TABLE_B[idx]; ya = epsA / za;  temp = ya * HEX_40000000; final double yaa = (ya + temp) - temp;
/** * Arctangent function *  @param x a number *  @return atan(x) */ public static double atan(double x) { return atan(x, 0.0, false); }  /** Internal helper function to compute arctangent. * @param xa number from which arctangent is requested * @param xb extra bits for x (may be 0.0) * @param leftPlane if true, result angle must be put in the left half plane * @return atan(xa + xb) (or angle shifted by {@code PI} if leftPlane is true)  <BUGS> epsA = ya; epsB = yb; <BUGE>  /* Evaluate polynomial */ final double epsA2 = epsA * epsA;  /* yb = -0.09001346640161823; yb = yb * epsA2 + 0.11110718400605211; yb = yb * epsA2 + -0.1428571349122913; yb = yb * epsA2 + 0.19999999999273194; yb = yb * epsA2 + -0.33333333333333093; yb = yb * epsA2 * epsA; */
/** * Arctangent function *  @param x a number *  @return atan(x) */ public static double atan(double x) { return atan(x, 0.0, false); }  /** Internal helper function to compute arctangent. * @param xa number from which arctangent is requested * @param xb extra bits for x (may be 0.0) * @param leftPlane if true, result angle must be put in the left half plane * @return atan(xa + xb) (or angle shifted by {@code PI} if leftPlane is true) /* Evaluate polynomial */ <BUGS> final double epsA2 = epsA * epsA; <BUGE>  /* yb = -0.09001346640161823; yb = yb * epsA2 + 0.11110718400605211; yb = yb * epsA2 + -0.1428571349122913; yb = yb * epsA2 + 0.19999999999273194; yb = yb * epsA2 + -0.33333333333333093; yb = yb * epsA2 * epsA; */  yb = 0.07490822288864472; yb = yb * epsA2 + -0.09088450866185192; yb = yb * epsA2 + 0.11111095942313305; yb = yb * epsA2 + -0.1428571423679182;
*  @return atan(x) */ public static double atan(double x) { return atan(x, 0.0, false); }  /** Internal helper function to compute arctangent. * @param xa number from which arctangent is requested * @param xb extra bits for x (may be 0.0) * @param leftPlane if true, result angle must be put in the left half plane * @return atan(xa + xb) (or angle shifted by {@code PI} if leftPlane is true)  <BUGS> yb = 0.07490822288864472; yb = yb * epsA2 + -0.09088450866185192; yb = yb * epsA2 + 0.11111095942313305; yb = yb * epsA2 + -0.1428571423679182; yb = yb * epsA2 + 0.19999999999923582; yb = yb * epsA2 + -0.33333333333333287; yb = yb * epsA2 * epsA; <BUGE>   ya = epsA;  temp = ya + yb; yb = -(temp - ya - yb); ya = temp;  /* Add in effect of epsB.   atan'(x) = 1/(1+x^2) */ yb += epsB / (1d + epsA * epsA);
/** * Arctangent function *  @param x a number *  @return atan(x) */ public static double atan(double x) { return atan(x, 0.0, false); }  /** Internal helper function to compute arctangent. * @param xa number from which arctangent is requested * @param xb extra bits for x (may be 0.0) * @param leftPlane if true, result angle must be put in the left half plane * @return atan(xa + xb) (or angle shifted by {@code PI} if leftPlane is true)  <BUGS> ya = epsA; <BUGE>  temp = ya + yb; yb = -(temp - ya - yb); ya = temp;  /* Add in effect of epsB.   atan'(x) = 1/(1+x^2) */ yb += epsB / (1d + epsA * epsA);  /*result = yb + eighths[idx] + ya;*/ double za = EIGHTHS[idx] + ya; double zb = -(za - EIGHTHS[idx] - ya); temp = za + yb; zb += -(temp - za - yb); za = temp;
* Arctangent function *  @param x a number *  @return atan(x) */ public static double atan(double x) { return atan(x, 0.0, false); }  /** Internal helper function to compute arctangent. * @param xa number from which arctangent is requested * @param xb extra bits for x (may be 0.0) * @param leftPlane if true, result angle must be put in the left half plane * @return atan(xa + xb) (or angle shifted by {@code PI} if leftPlane is true)  <BUGS> temp = ya + yb; yb = -(temp - ya - yb); ya = temp; <BUGE>  /* Add in effect of epsB.   atan'(x) = 1/(1+x^2) */ yb += epsB / (1d + epsA * epsA);  /*result = yb + eighths[idx] + ya;*/ double za = EIGHTHS[idx] + ya; double zb = -(za - EIGHTHS[idx] - ya); temp = za + yb; zb += -(temp - za - yb); za = temp;  double result = za + zb; double resultb = -(result - za - zb);
/** * Arctangent function *  @param x a number *  @return atan(x) */ public static double atan(double x) { return atan(x, 0.0, false); }  /** Internal helper function to compute arctangent. * @param xa number from which arctangent is requested * @param xb extra bits for x (may be 0.0) * @param leftPlane if true, result angle must be put in the left half plane * @return atan(xa + xb) (or angle shifted by {@code PI} if leftPlane is true) /* Add in effect of epsB.   atan'(x) = 1/(1+x^2) */ <BUGS> yb += epsB / (1d + epsA * epsA); <BUGE>  /*result = yb + eighths[idx] + ya;*/ double za = EIGHTHS[idx] + ya; double zb = -(za - EIGHTHS[idx] - ya); temp = za + yb; zb += -(temp - za - yb); za = temp;  double result = za + zb; double resultb = -(result - za - zb);  if (leftPlane) { /* Result is in the left plane*/ final double pia = 1.5707963267948966 * 2;
*  @param x a number *  @return atan(x) */ public static double atan(double x) { return atan(x, 0.0, false); }  /** Internal helper function to compute arctangent. * @param xa number from which arctangent is requested * @param xb extra bits for x (may be 0.0) * @param leftPlane if true, result angle must be put in the left half plane * @return atan(xa + xb) (or angle shifted by {@code PI} if leftPlane is true) /*result = yb + eighths[idx] + ya;*/ <BUGS> double za = EIGHTHS[idx] + ya; double zb = -(za - EIGHTHS[idx] - ya); temp = za + yb; zb += -(temp - za - yb); za = temp; <BUGE>  double result = za + zb; double resultb = -(result - za - zb);  if (leftPlane) { /* Result is in the left plane*/ final double pia = 1.5707963267948966 * 2; final double pib = 6.123233995736766E-17 * 2;  za = pia - result; zb = -(za - pia + result); zb += pib - resultb;
/** * Arctangent function *  @param x a number *  @return atan(x) */ public static double atan(double x) { return atan(x, 0.0, false); }  /** Internal helper function to compute arctangent. * @param xa number from which arctangent is requested * @param xb extra bits for x (may be 0.0) * @param leftPlane if true, result angle must be put in the left half plane * @return atan(xa + xb) (or angle shifted by {@code PI} if leftPlane is true)  <BUGS> double result = za + zb; double resultb = -(result - za - zb); <BUGE>  if (leftPlane) { /* Result is in the left plane*/ final double pia = 1.5707963267948966 * 2; final double pib = 6.123233995736766E-17 * 2;  za = pia - result; zb = -(za - pia + result); zb += pib - resultb;  result = za + zb; resultb = -(result - za - zb); }
/** * Arctangent function *  @param x a number *  @return atan(x) */ public static double atan(double x) { return atan(x, 0.0, false); }  /** Internal helper function to compute arctangent. * @param xa number from which arctangent is requested * @param xb extra bits for x (may be 0.0) * @param leftPlane if true, result angle must be put in the left half plane * @return atan(xa + xb) (or angle shifted by {@code PI} if leftPlane is true)  <BUGS> if (leftPlane) { <BUGE> /* Result is in the left plane*/ final double pia = 1.5707963267948966 * 2; final double pib = 6.123233995736766E-17 * 2;  za = pia - result; zb = -(za - pia + result); zb += pib - resultb;  result = za + zb; resultb = -(result - za - zb); }   if (negate ^ leftPlane) {
/** * Arctangent function *  @param x a number *  @return atan(x) */ public static double atan(double x) { return atan(x, 0.0, false); }  /** Internal helper function to compute arctangent. * @param xa number from which arctangent is requested * @param xb extra bits for x (may be 0.0) * @param leftPlane if true, result angle must be put in the left half plane * @return atan(xa + xb) (or angle shifted by {@code PI} if leftPlane is true)  <BUGS> if (negate ^ leftPlane) { <BUGE> result = -result; }  return result; }  /** * Two arguments arctangent function * @param y ordinate * @param x abscissa * @return phase angle of point (x,y) between {@code -PI} and {@code PI} */ public static double atan2(double y, double x) { if (x != x || y != y) {
/** * Arctangent function *  @param x a number *  @return atan(x) */ public static double atan(double x) { return atan(x, 0.0, false); }  /** Internal helper function to compute arctangent. * @param xa number from which arctangent is requested * @param xb extra bits for x (may be 0.0) * @param leftPlane if true, result angle must be put in the left half plane * @return atan(xa + xb) (or angle shifted by {@code PI} if leftPlane is true)  <BUGS> return result; <BUGE> }  /** * Two arguments arctangent function * @param y ordinate * @param x abscissa * @return phase angle of point (x,y) between {@code -PI} and {@code PI} */ public static double atan2(double y, double x) { if (x != x || y != y) { return Double.NaN; }  if (y == 0) {
*/ public static double pow(double d, int e) {  <BUGS> if (e == 0) { return 1.0; <BUGE> } else if (e < 0) { e = -e; d = 1.0 / d; }  /* split d as two 26 bits numbers*/ /* beware the following expressions must NOT be simplified, they rely on floating point arithmetic properties*/ final int splitFactor = 0x8000001; final double cd       = splitFactor * d; final double d1High   = cd - (cd - d); final double d1Low    = d - d1High;  /* prepare result*/ double resultHigh = 1; double resultLow  = 0;  /* d^(2p)*/ double d2p     = d; double d2pHigh = d1High; double d2pLow  = d1Low;  while (e != 0) {  if ((e & 0x1) != 0) { /* accurate multiplication result = result * d^(2p) using Veltkamp TwoProduct algorithm*/
@Override public double sample()  { <BUGS> if (shape < 1) { <BUGE> /* [1]: p. 228, Algorithm GS*/  while (true) { /* Step 1:*/ final double u = random.nextDouble(); final double bGS = 1 + shape / FastMath.E; final double p = bGS * u;  if (p <= 1) { /* Step 2:*/  final double x = FastMath.pow(p, 1 / shape); final double u2 = random.nextDouble();  if (u2 > FastMath.exp(-x)) { /* Reject*/ continue; } else { return scale * x; } } else { /* Step 3:*/  final double x = -1 * FastMath.log((bGS - p) / shape); final double u2 = random.nextDouble();  if (u2 > FastMath.pow(x, shape - 1)) {
* <p>This implementation uses the following algorithms: </p> * * <p>For 0 < shape < 1: <br/> * Ahrens, J. H. and Dieter, U., <i>Computer methods for * sampling from gamma, beta, Poisson and binomial distributions.</i> * Computing, 12, 223-246, 1974.</p> * * <p>For shape >= 1: <br/> * Marsaglia and Tsang, <i>A Simple Method for Generating * Gamma Variables.</i> ACM Transactions on Mathematical Software, * Volume 26 Issue 3, September, 2000.</p> * * @return random value sampled from the Gamma(shape, scale) distribution */  <BUGS> final double d = shape - 0.333333333333333333; final double c = 1 / (3 * FastMath.sqrt(d)); <BUGE>  while (true) { final double x = random.nextGaussian(); final double v = (1 + c * x) * (1 + c * x) * (1 + c * x);  if (v <= 0) { continue; }  final double x2 = x * x; final double u = random.nextDouble();  /* Squeeze*/
* <p>This implementation uses the following algorithms: </p> * * <p>For 0 < shape < 1: <br/> * Ahrens, J. H. and Dieter, U., <i>Computer methods for * sampling from gamma, beta, Poisson and binomial distributions.</i> * Computing, 12, 223-246, 1974.</p> * * <p>For shape >= 1: <br/> * Marsaglia and Tsang, <i>A Simple Method for Generating * Gamma Variables.</i> ACM Transactions on Mathematical Software, * Volume 26 Issue 3, September, 2000.</p> * * @return random value sampled from the Gamma(shape, scale) distribution */ while (true) { <BUGS> final double x = random.nextGaussian(); final double v = (1 + c * x) * (1 + c * x) * (1 + c * x); <BUGE>  if (v <= 0) { continue; }  final double x2 = x * x; final double u = random.nextDouble();  /* Squeeze*/ if (u < 1 - 0.0331 * x2 * x2) { return scale * d * v; }
* <p>This implementation uses the following algorithms: </p> * * <p>For 0 < shape < 1: <br/> * Ahrens, J. H. and Dieter, U., <i>Computer methods for * sampling from gamma, beta, Poisson and binomial distributions.</i> * Computing, 12, 223-246, 1974.</p> * * <p>For shape >= 1: <br/> * Marsaglia and Tsang, <i>A Simple Method for Generating * Gamma Variables.</i> ACM Transactions on Mathematical Software, * Volume 26 Issue 3, September, 2000.</p> * * @return random value sampled from the Gamma(shape, scale) distribution */  <BUGS> if (v <= 0) { <BUGE> continue; }  final double x2 = x * x; final double u = random.nextDouble();  /* Squeeze*/ if (u < 1 - 0.0331 * x2 * x2) { return scale * d * v; }  if (FastMath.log(u) < 0.5 * x2 + d * (1 - v + FastMath.log(v))) { return scale * d * v; }
* <p>This implementation uses the following algorithms: </p> * * <p>For 0 < shape < 1: <br/> * Ahrens, J. H. and Dieter, U., <i>Computer methods for * sampling from gamma, beta, Poisson and binomial distributions.</i> * Computing, 12, 223-246, 1974.</p> * * <p>For shape >= 1: <br/> * Marsaglia and Tsang, <i>A Simple Method for Generating * Gamma Variables.</i> ACM Transactions on Mathematical Software, * Volume 26 Issue 3, September, 2000.</p> * * @return random value sampled from the Gamma(shape, scale) distribution */  <BUGS> final double x2 = x * x; final double u = random.nextDouble(); <BUGE>  /* Squeeze*/ if (u < 1 - 0.0331 * x2 * x2) { return scale * d * v; }  if (FastMath.log(u) < 0.5 * x2 + d * (1 - v + FastMath.log(v))) { return scale * d * v; } } } }
* <p>This implementation uses the following algorithms: </p> * * <p>For 0 < shape < 1: <br/> * Ahrens, J. H. and Dieter, U., <i>Computer methods for * sampling from gamma, beta, Poisson and binomial distributions.</i> * Computing, 12, 223-246, 1974.</p> * * <p>For shape >= 1: <br/> * Marsaglia and Tsang, <i>A Simple Method for Generating * Gamma Variables.</i> ACM Transactions on Mathematical Software, * Volume 26 Issue 3, September, 2000.</p> * * @return random value sampled from the Gamma(shape, scale) distribution */ /* Squeeze*/ <BUGS> if (u < 1 - 0.0331 * x2 * x2) { return scale * d * v; <BUGE> }  if (FastMath.log(u) < 0.5 * x2 + d * (1 - v + FastMath.log(v))) { return scale * d * v; } } } }
* <p>This implementation uses the following algorithms: </p> * * <p>For 0 < shape < 1: <br/> * Ahrens, J. H. and Dieter, U., <i>Computer methods for * sampling from gamma, beta, Poisson and binomial distributions.</i> * Computing, 12, 223-246, 1974.</p> * * <p>For shape >= 1: <br/> * Marsaglia and Tsang, <i>A Simple Method for Generating * Gamma Variables.</i> ACM Transactions on Mathematical Software, * Volume 26 Issue 3, September, 2000.</p> * * @return random value sampled from the Gamma(shape, scale) distribution */  <BUGS> if (FastMath.log(u) < 0.5 * x2 + d * (1 - v + FastMath.log(v))) { return scale * d * v; <BUGE> } } } }
*/ public PolynomialFitter(DifferentiableMultivariateVectorOptimizer optimizer) { <BUGS> super(optimizer); degree = -1; /* To avoid compilation error until the instance variable is removed.*/ } <BUGE>
*/ public PolynomialFitter(MultivariateVectorOptimizer optimizer) { <BUGS> super(optimizer); } <BUGE>
*/ public static double pow(double x, double y) { <BUGS> final double lns[] = new double[2]; <BUGE>  if (y == 0.0) { return 1.0; }  if (x != x) { /* X is NaN*/ return x; }   if (x == 0) { long bits = Double.doubleToLongBits(x); if ((bits & 0x8000000000000000L) != 0) { /* -zero*/ long yi = (long) y;  if (y < 0 && y == yi && (yi & 1) == 1) { return Double.NEGATIVE_INFINITY; }  if (y > 0 && y == yi && (yi & 1) == 1) { return -0.0; } }  if (y < 0) { return Double.POSITIVE_INFINITY;
*/ public static double pow(double x, double y) { final double lns[] = new double[2];  <BUGS> if (y == 0.0) { <BUGE> return 1.0; }  if (x != x) { /* X is NaN*/ return x; }   if (x == 0) { long bits = Double.doubleToLongBits(x); if ((bits & 0x8000000000000000L) != 0) { /* -zero*/ long yi = (long) y;  if (y < 0 && y == yi && (yi & 1) == 1) { return Double.NEGATIVE_INFINITY; }  if (y > 0 && y == yi && (yi & 1) == 1) { return -0.0; } }  if (y < 0) { return Double.POSITIVE_INFINITY;
*/ public static double pow(double x, double y) { final double lns[] = new double[2];  if (y == 0.0) { return 1.0; }  <BUGS> if (x != x) { /* X is NaN <BUGE>*/ return x; }   if (x == 0) { long bits = Double.doubleToLongBits(x); if ((bits & 0x8000000000000000L) != 0) { /* -zero*/ long yi = (long) y;  if (y < 0 && y == yi && (yi & 1) == 1) { return Double.NEGATIVE_INFINITY; }  if (y > 0 && y == yi && (yi & 1) == 1) { return -0.0; } }  if (y < 0) { return Double.POSITIVE_INFINITY;
*/ public static double pow(double x, double y) { final double lns[] = new double[2];  if (y == 0.0) { return 1.0; }  if (x != x) { /* X is NaN*/ return x; }   <BUGS> if (x == 0) { <BUGE> long bits = Double.doubleToLongBits(x); if ((bits & 0x8000000000000000L) != 0) { /* -zero*/ long yi = (long) y;  if (y < 0 && y == yi && (yi & 1) == 1) { return Double.NEGATIVE_INFINITY; }  if (y > 0 && y == yi && (yi & 1) == 1) { return -0.0; } }  if (y < 0) { return Double.POSITIVE_INFINITY;
* @return the value of the logarithm, i.e. the number {@code y} such that * <code>base<sup>y</sup> = x</code>. * @since 1.2 (previously in {@code MathUtils}, moved as of version 3.0) */ public static double log(double base, double x) { return log(x) / log(base); }  /** * Power function.  Compute x^y. * * @param x   a double * @param y   a double * @return double  <BUGS> if (x == Double.POSITIVE_INFINITY) { <BUGE> if (y != y) { /* y is NaN*/ return y; } if (y < 0.0) { return 0.0; } else { return Double.POSITIVE_INFINITY; } }  if (y == Double.POSITIVE_INFINITY) { if (x * x == 1.0) { return Double.NaN; }
* @return the value of the logarithm, i.e. the number {@code y} such that * <code>base<sup>y</sup> = x</code>. * @since 1.2 (previously in {@code MathUtils}, moved as of version 3.0) */ public static double log(double base, double x) { return log(x) / log(base); }  /** * Power function.  Compute x^y. * * @param x   a double * @param y   a double * @return double  <BUGS> if (y == Double.POSITIVE_INFINITY) { <BUGE> if (x * x == 1.0) { return Double.NaN; }  if (x * x > 1.0) { return Double.POSITIVE_INFINITY; } else { return 0.0; } }  if (x == Double.NEGATIVE_INFINITY) { if (y != y) { /* y is NaN*/ return y;
* @return the value of the logarithm, i.e. the number {@code y} such that * <code>base<sup>y</sup> = x</code>. * @since 1.2 (previously in {@code MathUtils}, moved as of version 3.0) */ public static double log(double base, double x) { return log(x) / log(base); }  /** * Power function.  Compute x^y. * * @param x   a double * @param y   a double * @return double  <BUGS> if (x == Double.NEGATIVE_INFINITY) { <BUGE> if (y != y) { /* y is NaN*/ return y; }  if (y < 0) { long yi = (long) y; if (y == yi && (yi & 1) == 1) { return -0.0; }  return 0.0; }  if (y > 0)  {
* @return the value of the logarithm, i.e. the number {@code y} such that * <code>base<sup>y</sup> = x</code>. * @since 1.2 (previously in {@code MathUtils}, moved as of version 3.0) */ public static double log(double base, double x) { return log(x) / log(base); }  /** * Power function.  Compute x^y. * * @param x   a double * @param y   a double * @return double  <BUGS> if (y == Double.NEGATIVE_INFINITY) { <BUGE>  if (x * x == 1.0) { return Double.NaN; }  if (x * x < 1.0) { return Double.POSITIVE_INFINITY; } else { return 0.0; } }  /* Handle special case x<0 */ if (x < 0) {
* @return the value of the logarithm, i.e. the number {@code y} such that * <code>base<sup>y</sup> = x</code>. * @since 1.2 (previously in {@code MathUtils}, moved as of version 3.0) */ public static double log(double base, double x) { return log(x) / log(base); }  /** * Power function.  Compute x^y. * * @param x   a double * @param y   a double * @return double /* Handle special case x<0 */ <BUGS> if (x < 0) { <BUGE> /* y is an even integer in this case*/ if (y >= TWO_POWER_52 || y <= -TWO_POWER_52) { return pow(-x, y); }  if (y == (long) y) { /* If y is an integer*/ return ((long)y & 1) == 0 ? pow(-x, y) : -pow(-x, y); } else { return Double.NaN; } }  /* Split y into ya and yb such that y = ya+yb */
* @return the value of the logarithm, i.e. the number {@code y} such that * <code>base<sup>y</sup> = x</code>. * @since 1.2 (previously in {@code MathUtils}, moved as of version 3.0) */ public static double log(double base, double x) { return log(x) / log(base); }  /** * Power function.  Compute x^y. * * @param x   a double * @param y   a double * @return double /* y is an even integer in this case*/ <BUGS> if (y >= TWO_POWER_52 || y <= -TWO_POWER_52) { return pow(-x, y); <BUGE> }  if (y == (long) y) { /* If y is an integer*/ return ((long)y & 1) == 0 ? pow(-x, y) : -pow(-x, y); } else { return Double.NaN; } }  /* Split y into ya and yb such that y = ya+yb */ double ya; double yb;
* @since 1.2 (previously in {@code MathUtils}, moved as of version 3.0) */ public static double log(double base, double x) { return log(x) / log(base); }  /** * Power function.  Compute x^y. * * @param x   a double * @param y   a double * @return double double yb; <BUGS> if (y < 8e298 && y > -8e298) { double tmp1 = y * HEX_40000000; ya = y + tmp1 - tmp1; yb = y - ya; } else { <BUGE> double tmp1 = y * 9.31322574615478515625E-10; double tmp2 = tmp1 * 9.31322574615478515625E-10; ya = (tmp1 + tmp2 - tmp1) * HEX_40000000 * HEX_40000000; yb = y - ya; }  /* Compute ln(x) */ final double lores = log(x, lns); if (Double.isInfinite(lores)){ /* don't allow this to be converted to NaN*/ return lores; }
* @return the value of the logarithm, i.e. the number {@code y} such that * <code>base<sup>y</sup> = x</code>. * @since 1.2 (previously in {@code MathUtils}, moved as of version 3.0) */ public static double log(double base, double x) { return log(x) / log(base); }  /** * Power function.  Compute x^y. * * @param x   a double * @param y   a double * @return double /* Compute ln(x) */ <BUGS> final double lores = log(x, lns); if (Double.isInfinite(lores)){ /* don't allow this to be converted to NaN <BUGE>*/ return lores; }  double lna = lns[0]; double lnb = lns[1];  /* resplit lns */ double tmp1 = lna * HEX_40000000; double tmp2 = lna + tmp1 - tmp1; lnb += lna - tmp2; lna = tmp2;  /* y*ln(x) = (aa+ab)*/
* @return the value of the logarithm, i.e. the number {@code y} such that * <code>base<sup>y</sup> = x</code>. * @since 1.2 (previously in {@code MathUtils}, moved as of version 3.0) */ public static double log(double base, double x) { return log(x) / log(base); }  /** * Power function.  Compute x^y. * * @param x   a double * @param y   a double * @return double  <BUGS> double lna = lns[0]; double lnb = lns[1]; <BUGE>  /* resplit lns */ double tmp1 = lna * HEX_40000000; double tmp2 = lna + tmp1 - tmp1; lnb += lna - tmp2; lna = tmp2;  /* y*ln(x) = (aa+ab)*/ final double aa = lna * ya; final double ab = lna * yb + lnb * ya + lnb * yb;  lna = aa+ab; lnb = -(lna - aa - ab);
* <code>base<sup>y</sup> = x</code>. * @since 1.2 (previously in {@code MathUtils}, moved as of version 3.0) */ public static double log(double base, double x) { return log(x) / log(base); }  /** * Power function.  Compute x^y. * * @param x   a double * @param y   a double * @return double /* resplit lns */ <BUGS> double tmp1 = lna * HEX_40000000; double tmp2 = lna + tmp1 - tmp1; lnb += lna - tmp2; lna = tmp2; <BUGE>  /* y*ln(x) = (aa+ab)*/ final double aa = lna * ya; final double ab = lna * yb + lnb * ya + lnb * yb;  lna = aa+ab; lnb = -(lna - aa - ab);  double z = 1.0 / 120.0; z = z * lnb + (1.0 / 24.0); z = z * lnb + (1.0 / 6.0); z = z * lnb + 0.5;
* @return the value of the logarithm, i.e. the number {@code y} such that * <code>base<sup>y</sup> = x</code>. * @since 1.2 (previously in {@code MathUtils}, moved as of version 3.0) */ public static double log(double base, double x) { return log(x) / log(base); }  /** * Power function.  Compute x^y. * * @param x   a double * @param y   a double * @return double /* y*ln(x) = (aa+ab)*/ <BUGS> final double aa = lna * ya; final double ab = lna * yb + lnb * ya + lnb * yb; <BUGE>  lna = aa+ab; lnb = -(lna - aa - ab);  double z = 1.0 / 120.0; z = z * lnb + (1.0 / 24.0); z = z * lnb + (1.0 / 6.0); z = z * lnb + 0.5; z = z * lnb + 1.0; z = z * lnb;  final double result = exp(lna, z, null); /*result = result + result * z;*/
* @return the value of the logarithm, i.e. the number {@code y} such that * <code>base<sup>y</sup> = x</code>. * @since 1.2 (previously in {@code MathUtils}, moved as of version 3.0) */ public static double log(double base, double x) { return log(x) / log(base); }  /** * Power function.  Compute x^y. * * @param x   a double * @param y   a double * @return double  <BUGS> lna = aa+ab; lnb = -(lna - aa - ab); <BUGE>  double z = 1.0 / 120.0; z = z * lnb + (1.0 / 24.0); z = z * lnb + (1.0 / 6.0); z = z * lnb + 0.5; z = z * lnb + 1.0; z = z * lnb;  final double result = exp(lna, z, null); /*result = result + result * z;*/ return result; }
* @since 1.2 (previously in {@code MathUtils}, moved as of version 3.0) */ public static double log(double base, double x) { return log(x) / log(base); }  /** * Power function.  Compute x^y. * * @param x   a double * @param y   a double * @return double  <BUGS> double z = 1.0 / 120.0; z = z * lnb + (1.0 / 24.0); z = z * lnb + (1.0 / 6.0); z = z * lnb + 0.5; z = z * lnb + 1.0; z = z * lnb; <BUGE>  final double result = exp(lna, z, null); /*result = result + result * z;*/ return result; }   /** * Raise a double to an int power. * * @param d Number to raise.
* @return the value of the logarithm, i.e. the number {@code y} such that * <code>base<sup>y</sup> = x</code>. * @since 1.2 (previously in {@code MathUtils}, moved as of version 3.0) */ public static double log(double base, double x) { return log(x) / log(base); }  /** * Power function.  Compute x^y. * * @param x   a double * @param y   a double * @return double  <BUGS> final double result = exp(lna, z, null); <BUGE> /*result = result + result * z;*/ return result; }   /** * Raise a double to an int power. * * @param d Number to raise. * @param e Exponent. * @return d<sup>e</sup> */ public static double pow(double d, int e) {
* @return the value of the logarithm, i.e. the number {@code y} such that * <code>base<sup>y</sup> = x</code>. * @since 1.2 (previously in {@code MathUtils}, moved as of version 3.0) */ public static double log(double base, double x) { return log(x) / log(base); }  /** * Power function.  Compute x^y. * * @param x   a double * @param y   a double * @return double /*result = result + result * z;*/ <BUGS> return result; <BUGE> }   /** * Raise a double to an int power. * * @param d Number to raise. * @param e Exponent. * @return d<sup>e</sup> */ public static double pow(double d, int e) {  if (e == 0) { return 1.0;
*/ public static double cosh(double x) { <BUGS> if (x != x) { <BUGE> return x; }  /* cosh[z] = (exp(z) + exp(-z))/2*/  /* for numbers with magnitude 20 or so,*/ /* exp(-z) can be ignored in comparison with exp(z)*/  if (x > 20) { /* Avoid overflow (MATH-905).*/ return 0.5 * exp(x); } if (x < -20) { /* Avoid overflow (MATH-905).*/ return 0.5 * exp(-x); }  final double hiPrec[] = new double[2]; if (x < 0.0) { x = -x; } exp(x, 0.0, hiPrec);  double ya = hiPrec[0] + hiPrec[1]; double yb = -(ya - hiPrec[0] - hiPrec[1]);  double temp = ya * HEX_40000000;
*/ public static double cosh(double x) { if (x != x) { return x; }  /* cosh[z] = (exp(z) + exp(-z))/2*/  /* for numbers with magnitude 20 or so,*/ /* exp(-z) can be ignored in comparison with exp(z)*/  <BUGS> if (x > 20) { <BUGE> /* Avoid overflow (MATH-905).*/ return 0.5 * exp(x); } if (x < -20) { /* Avoid overflow (MATH-905).*/ return 0.5 * exp(-x); }  final double hiPrec[] = new double[2]; if (x < 0.0) { x = -x; } exp(x, 0.0, hiPrec);  double ya = hiPrec[0] + hiPrec[1]; double yb = -(ya - hiPrec[0] - hiPrec[1]);  double temp = ya * HEX_40000000;
*/ public static double cosh(double x) { if (x != x) { return x; }  /* cosh[z] = (exp(z) + exp(-z))/2*/  /* for numbers with magnitude 20 or so,*/ /* exp(-z) can be ignored in comparison with exp(z)*/  if (x > 20) { /* Avoid overflow (MATH-905).*/ <BUGS> return 0.5 * exp(x); <BUGE> } if (x < -20) { /* Avoid overflow (MATH-905).*/ return 0.5 * exp(-x); }  final double hiPrec[] = new double[2]; if (x < 0.0) { x = -x; } exp(x, 0.0, hiPrec);  double ya = hiPrec[0] + hiPrec[1]; double yb = -(ya - hiPrec[0] - hiPrec[1]);  double temp = ya * HEX_40000000;
*/ public static double cosh(double x) { if (x != x) { return x; }  /* cosh[z] = (exp(z) + exp(-z))/2*/  /* for numbers with magnitude 20 or so,*/ /* exp(-z) can be ignored in comparison with exp(z)*/  if (x > 20) { /* Avoid overflow (MATH-905).*/ return 0.5 * exp(x); } <BUGS> if (x < -20) { <BUGE> /* Avoid overflow (MATH-905).*/ return 0.5 * exp(-x); }  final double hiPrec[] = new double[2]; if (x < 0.0) { x = -x; } exp(x, 0.0, hiPrec);  double ya = hiPrec[0] + hiPrec[1]; double yb = -(ya - hiPrec[0] - hiPrec[1]);  double temp = ya * HEX_40000000;
*/ public static double cosh(double x) { if (x != x) { return x; }  /* cosh[z] = (exp(z) + exp(-z))/2*/  /* for numbers with magnitude 20 or so,*/ /* exp(-z) can be ignored in comparison with exp(z)*/  if (x > 20) { /* Avoid overflow (MATH-905).*/ return 0.5 * exp(x); } if (x < -20) { /* Avoid overflow (MATH-905).*/ <BUGS> return 0.5 * exp(-x); <BUGE> }  final double hiPrec[] = new double[2]; if (x < 0.0) { x = -x; } exp(x, 0.0, hiPrec);  double ya = hiPrec[0] + hiPrec[1]; double yb = -(ya - hiPrec[0] - hiPrec[1]);  double temp = ya * HEX_40000000;
*/ public Dfp multiply(final Dfp x) {  /* make sure we don't mix number with different precision*/ <BUGS> if (field.getRadixDigits() != x.field.getRadixDigits()) { <BUGE> field.setIEEEFlagsBits(DfpField.FLAG_INVALID); final Dfp result = newInstance(getZero()); result.nans = QNAN; return dotrap(DfpField.FLAG_INVALID, MULTIPLY_TRAP, x, result); }  Dfp result = newInstance(getZero());  /* handle special cases */ if (nans != FINITE || x.nans != FINITE) { if (isNaN()) { return this; }  if (x.isNaN()) { return x; }  if (nans == INFINITE && x.nans == FINITE && x.mant[mant.length-1] != 0) { result = newInstance(this); result.sign = (byte) (sign * x.sign); return result; }  if (x.nans == INFINITE && nans == FINITE && mant[mant.length-1] != 0) {
*/ public Dfp multiply(final Dfp x) {  /* make sure we don't mix number with different precision*/ if (field.getRadixDigits() != x.field.getRadixDigits()) { field.setIEEEFlagsBits(DfpField.FLAG_INVALID); final Dfp result = newInstance(getZero()); result.nans = QNAN; return dotrap(DfpField.FLAG_INVALID, MULTIPLY_TRAP, x, result); }  <BUGS> Dfp result = newInstance(getZero()); <BUGE>  /* handle special cases */ if (nans != FINITE || x.nans != FINITE) { if (isNaN()) { return this; }  if (x.isNaN()) { return x; }  if (nans == INFINITE && x.nans == FINITE && x.mant[mant.length-1] != 0) { result = newInstance(this); result.sign = (byte) (sign * x.sign); return result; }  if (x.nans == INFINITE && nans == FINITE && mant[mant.length-1] != 0) {
*/ public Dfp multiply(final Dfp x) {  /* make sure we don't mix number with different precision*/ if (field.getRadixDigits() != x.field.getRadixDigits()) { field.setIEEEFlagsBits(DfpField.FLAG_INVALID); final Dfp result = newInstance(getZero()); result.nans = QNAN; return dotrap(DfpField.FLAG_INVALID, MULTIPLY_TRAP, x, result); }  Dfp result = newInstance(getZero());  /* handle special cases */ <BUGS> if (nans != FINITE || x.nans != FINITE) { if (isNaN()) { return this; <BUGE> }  if (x.isNaN()) { return x; }  if (nans == INFINITE && x.nans == FINITE && x.mant[mant.length-1] != 0) { result = newInstance(this); result.sign = (byte) (sign * x.sign); return result; }  if (x.nans == INFINITE && nans == FINITE && mant[mant.length-1] != 0) {
*/ public Dfp multiply(final Dfp x) {  /* make sure we don't mix number with different precision*/ if (field.getRadixDigits() != x.field.getRadixDigits()) { field.setIEEEFlagsBits(DfpField.FLAG_INVALID); final Dfp result = newInstance(getZero()); result.nans = QNAN; return dotrap(DfpField.FLAG_INVALID, MULTIPLY_TRAP, x, result); }  Dfp result = newInstance(getZero());  /* handle special cases */ if (nans != FINITE || x.nans != FINITE) { if (isNaN()) { return this; }  <BUGS> if (x.isNaN()) { return x; <BUGE> }  if (nans == INFINITE && x.nans == FINITE && x.mant[mant.length-1] != 0) { result = newInstance(this); result.sign = (byte) (sign * x.sign); return result; }  if (x.nans == INFINITE && nans == FINITE && mant[mant.length-1] != 0) {
*/ public Dfp multiply(final Dfp x) {  /* make sure we don't mix number with different precision*/ if (field.getRadixDigits() != x.field.getRadixDigits()) { field.setIEEEFlagsBits(DfpField.FLAG_INVALID); final Dfp result = newInstance(getZero()); result.nans = QNAN; return dotrap(DfpField.FLAG_INVALID, MULTIPLY_TRAP, x, result); }  Dfp result = newInstance(getZero());  /* handle special cases */ if (nans != FINITE || x.nans != FINITE) { if (isNaN()) { return this; }  if (x.isNaN()) { return x; }  <BUGS> if (nans == INFINITE && x.nans == FINITE && x.mant[mant.length-1] != 0) { result = newInstance(this); result.sign = (byte) (sign * x.sign); return result; <BUGE> }  if (x.nans == INFINITE && nans == FINITE && mant[mant.length-1] != 0) {
if (n != 0) { /* Inexact*/ field.setIEEEFlagsBits(DfpField.FLAG_INEXACT); return DfpField.FLAG_INEXACT; }  return 0;  }  /** Multiply this by x. * @param x multiplicand * @return product of this and x  <BUGS> if (x.nans == INFINITE && nans == FINITE && mant[mant.length-1] != 0) { result = newInstance(x); result.sign = (byte) (sign * x.sign); return result; <BUGE> }  if (x.nans == INFINITE && nans == INFINITE) { result = newInstance(this); result.sign = (byte) (sign * x.sign); return result; }  if ( (x.nans == INFINITE && nans == FINITE && mant[mant.length-1] == 0) || (nans == INFINITE && x.nans == FINITE && x.mant[mant.length-1] == 0) ) { field.setIEEEFlagsBits(DfpField.FLAG_INVALID); result = newInstance(getZero());
if (n != 0) { /* Inexact*/ field.setIEEEFlagsBits(DfpField.FLAG_INEXACT); return DfpField.FLAG_INEXACT; }  return 0;  }  /** Multiply this by x. * @param x multiplicand * @return product of this and x  <BUGS> if (x.nans == INFINITE && nans == INFINITE) { result = newInstance(this); result.sign = (byte) (sign * x.sign); return result; <BUGE> }  if ( (x.nans == INFINITE && nans == FINITE && mant[mant.length-1] == 0) || (nans == INFINITE && x.nans == FINITE && x.mant[mant.length-1] == 0) ) { field.setIEEEFlagsBits(DfpField.FLAG_INVALID); result = newInstance(getZero()); result.nans = QNAN; result = dotrap(DfpField.FLAG_INVALID, MULTIPLY_TRAP, x, result); return result; } }
if (n != 0) { /* Inexact*/ field.setIEEEFlagsBits(DfpField.FLAG_INEXACT); return DfpField.FLAG_INEXACT; }  return 0;  }  /** Multiply this by x. * @param x multiplicand * @return product of this and x  <BUGS> if ( (x.nans == INFINITE && nans == FINITE && mant[mant.length-1] == 0) || <BUGE> (nans == INFINITE && x.nans == FINITE && x.mant[mant.length-1] == 0) ) { field.setIEEEFlagsBits(DfpField.FLAG_INVALID); result = newInstance(getZero()); result.nans = QNAN; result = dotrap(DfpField.FLAG_INVALID, MULTIPLY_TRAP, x, result); return result; } }  int[] product = new int[mant.length*2];  /* Big enough to hold even the largest result*/  for (int i = 0; i < mant.length; i++) { int rh = 0;  /* acts as a carry*/ for (int j=0; j<mant.length; j++) {
/* Inexact*/ field.setIEEEFlagsBits(DfpField.FLAG_INEXACT); return DfpField.FLAG_INEXACT; }  return 0;  }  /** Multiply this by x. * @param x multiplicand * @return product of this and x (nans == INFINITE && x.nans == FINITE && x.mant[mant.length-1] == 0) ) { <BUGS> field.setIEEEFlagsBits(DfpField.FLAG_INVALID); result = newInstance(getZero()); result.nans = QNAN; result = dotrap(DfpField.FLAG_INVALID, MULTIPLY_TRAP, x, result); return result; <BUGE> } }  int[] product = new int[mant.length*2];  /* Big enough to hold even the largest result*/  for (int i = 0; i < mant.length; i++) { int rh = 0;  /* acts as a carry*/ for (int j=0; j<mant.length; j++) { int r = mant[i] * x.mant[j];    /* multiply the 2 digits*/ r = r + product[i+j] + rh;  /* add to the product digit with carry in*/  rh = r / RADIX;
if (n != 0) { /* Inexact*/ field.setIEEEFlagsBits(DfpField.FLAG_INEXACT); return DfpField.FLAG_INEXACT; }  return 0;  }  /** Multiply this by x. * @param x multiplicand * @return product of this and x  <BUGS> int[] product = new int[mant.length*2];  /* Big enough to hold even the largest result <BUGE>*/  for (int i = 0; i < mant.length; i++) { int rh = 0;  /* acts as a carry*/ for (int j=0; j<mant.length; j++) { int r = mant[i] * x.mant[j];    /* multiply the 2 digits*/ r = r + product[i+j] + rh;  /* add to the product digit with carry in*/  rh = r / RADIX; product[i+j] = r - rh * RADIX; } product[i+mant.length] = rh; }  /* Find the most sig digit*/
/* Inexact*/ field.setIEEEFlagsBits(DfpField.FLAG_INEXACT); return DfpField.FLAG_INEXACT; }  return 0;  }  /** Multiply this by x. * @param x multiplicand * @return product of this and x  <BUGS> for (int i = 0; i < mant.length; i++) { int rh = 0;  /* acts as a carry*/ for (int j=0; j<mant.length; j++) { int r = mant[i] * x.mant[j];    /* multiply the 2 digits*/ r = r + product[i+j] + rh;  /* add to the product digit with carry in <BUGE>*/  rh = r / RADIX; product[i+j] = r - rh * RADIX; } product[i+mant.length] = rh; }  /* Find the most sig digit*/ int md = mant.length * 2 - 1;  /* default, in case result is zero*/ for (int i = mant.length * 2 - 1; i >= 0; i--) { if (product[i] != 0) { md = i;
if (n != 0) { /* Inexact*/ field.setIEEEFlagsBits(DfpField.FLAG_INEXACT); return DfpField.FLAG_INEXACT; }  return 0;  }  /** Multiply this by x. * @param x multiplicand * @return product of this and x  <BUGS> rh = r / RADIX; product[i+j] = r - rh * RADIX; <BUGE> } product[i+mant.length] = rh; }  /* Find the most sig digit*/ int md = mant.length * 2 - 1;  /* default, in case result is zero*/ for (int i = mant.length * 2 - 1; i >= 0; i--) { if (product[i] != 0) { md = i; break; } }
if (n != 0) { /* Inexact*/ field.setIEEEFlagsBits(DfpField.FLAG_INEXACT); return DfpField.FLAG_INEXACT; }  return 0;  }  /** Multiply this by x. * @param x multiplicand * @return product of this and x } <BUGS> product[i+mant.length] = rh; <BUGE> }  /* Find the most sig digit*/ int md = mant.length * 2 - 1;  /* default, in case result is zero*/ for (int i = mant.length * 2 - 1; i >= 0; i--) { if (product[i] != 0) { md = i; break; } }  /* Copy the digits into the result*/ for (int i = 0; i < mant.length; i++) { result.mant[mant.length - i - 1] = product[md - i];
/* Inexact*/ field.setIEEEFlagsBits(DfpField.FLAG_INEXACT); return DfpField.FLAG_INEXACT; }  return 0;  }  /** Multiply this by x. * @param x multiplicand * @return product of this and x /* Find the most sig digit*/ <BUGS> int md = mant.length * 2 - 1;  /* default, in case result is zero*/ for (int i = mant.length * 2 - 1; i >= 0; i--) { if (product[i] != 0) { md = i; break; <BUGE> } }  /* Copy the digits into the result*/ for (int i = 0; i < mant.length; i++) { result.mant[mant.length - i - 1] = product[md - i]; }  /* Fixup the exponent.*/ result.exp = exp + x.exp + md - 2 * mant.length + 1; result.sign = (byte)((sign == x.sign)?1:-1);
if (n != 0) { /* Inexact*/ field.setIEEEFlagsBits(DfpField.FLAG_INEXACT); return DfpField.FLAG_INEXACT; }  return 0;  }  /** Multiply this by x. * @param x multiplicand * @return product of this and x /* Copy the digits into the result*/ <BUGS> for (int i = 0; i < mant.length; i++) { result.mant[mant.length - i - 1] = product[md - i]; <BUGE> }  /* Fixup the exponent.*/ result.exp = exp + x.exp + md - 2 * mant.length + 1; result.sign = (byte)((sign == x.sign)?1:-1);  if (result.mant[mant.length-1] == 0) { /* if result is zero, set exp to zero*/ result.exp = 0; }  final int excp; if (md > (mant.length-1)) {
if (n != 0) { /* Inexact*/ field.setIEEEFlagsBits(DfpField.FLAG_INEXACT); return DfpField.FLAG_INEXACT; }  return 0;  }  /** Multiply this by x. * @param x multiplicand * @return product of this and x /* Fixup the exponent.*/ <BUGS> result.exp = exp + x.exp + md - 2 * mant.length + 1; result.sign = (byte)((sign == x.sign)?1:-1); <BUGE>  if (result.mant[mant.length-1] == 0) { /* if result is zero, set exp to zero*/ result.exp = 0; }  final int excp; if (md > (mant.length-1)) { excp = result.round(product[md-mant.length]); } else { excp = result.round(0); /* has no effect except to check status*/ }
if (n != 0) { /* Inexact*/ field.setIEEEFlagsBits(DfpField.FLAG_INEXACT); return DfpField.FLAG_INEXACT; }  return 0;  }  /** Multiply this by x. * @param x multiplicand * @return product of this and x  <BUGS> if (result.mant[mant.length-1] == 0) { <BUGE> /* if result is zero, set exp to zero*/ result.exp = 0; }  final int excp; if (md > (mant.length-1)) { excp = result.round(product[md-mant.length]); } else { excp = result.round(0); /* has no effect except to check status*/ }  if (excp != 0) { result = dotrap(excp, MULTIPLY_TRAP, x, result); }
if (n != 0) { /* Inexact*/ field.setIEEEFlagsBits(DfpField.FLAG_INEXACT); return DfpField.FLAG_INEXACT; }  return 0;  }  /** Multiply this by x. * @param x multiplicand * @return product of this and x /* if result is zero, set exp to zero*/ <BUGS> result.exp = 0; <BUGE> }  final int excp; if (md > (mant.length-1)) { excp = result.round(product[md-mant.length]); } else { excp = result.round(0); /* has no effect except to check status*/ }  if (excp != 0) { result = dotrap(excp, MULTIPLY_TRAP, x, result); }  return result;
if (n != 0) { /* Inexact*/ field.setIEEEFlagsBits(DfpField.FLAG_INEXACT); return DfpField.FLAG_INEXACT; }  return 0;  }  /** Multiply this by x. * @param x multiplicand * @return product of this and x final int excp; <BUGS> if (md > (mant.length-1)) { excp = result.round(product[md-mant.length]); <BUGE> } else { excp = result.round(0); /* has no effect except to check status*/ }  if (excp != 0) { result = dotrap(excp, MULTIPLY_TRAP, x, result); }  return result;  }  /** Multiply this by a single digit x.
if (n != 0) { /* Inexact*/ field.setIEEEFlagsBits(DfpField.FLAG_INEXACT); return DfpField.FLAG_INEXACT; }  return 0;  }  /** Multiply this by x. * @param x multiplicand * @return product of this and x  <BUGS> if (excp != 0) { result = dotrap(excp, MULTIPLY_TRAP, x, result); <BUGE> }  return result;  }  /** Multiply this by a single digit x. * @param x multiplicand * @return product of this and x */ public Dfp multiply(final int x) { return multiplyFast(x); }
if (n != 0) { /* Inexact*/ field.setIEEEFlagsBits(DfpField.FLAG_INEXACT); return DfpField.FLAG_INEXACT; }  return 0;  }  /** Multiply this by x. * @param x multiplicand * @return product of this and x  <BUGS> return result; <BUGE>  }  /** Multiply this by a single digit x. * @param x multiplicand * @return product of this and x */ public Dfp multiply(final int x) { return multiplyFast(x); }  /** Multiply this by a single digit 0&lt;=x&lt;radix. * There are speed advantages in this special case. * @param x multiplicand
@Override public PointValuePair optimize(int maxEval, FUNC f, GoalType goalType, double[] startPoint) { <BUGS> return optimize(maxEval, f, goalType, startPoint, null, null); <BUGE> }
*/ public static double nextUp(final double a) { <BUGS> return nextAfter(a, Double.POSITIVE_INFINITY); <BUGE> }
*/ public CMAESOptimizer() { <BUGS> this(0); } <BUGE>
*/ public static RealMatrix createRealMatrix(double[][] data) throws NullArgumentException, DimensionMismatchException, NoDataException { <BUGS> if (data == null || <BUGE> data[0] == null) { throw new NullArgumentException(); } return (data.length * data[0].length <= 4096) ? new Array2DRowRealMatrix(data) : new BlockRealMatrix(data); }
*/ public static RealMatrix createRealMatrix(double[][] data) throws NullArgumentException, DimensionMismatchException, NoDataException { if (data == null || data[0] == null) { throw new NullArgumentException(); } <BUGS> return (data.length * data[0].length <= 4096) ? <BUGE> new Array2DRowRealMatrix(data) : new BlockRealMatrix(data); }
/** {@inheritDoc} */
*/ public StepFunction(double[] x, double[] y) throws NullArgumentException, NoDataException, <BUGS> DimensionMismatchException { if (x == null || <BUGE> y == null) { throw new NullArgumentException(); } if (x.length == 0 || y.length == 0) { throw new NoDataException(); } if (y.length != x.length) { throw new DimensionMismatchException(y.length, x.length); } MathArrays.checkOrder(x);  abscissa = MathArrays.copyOf(x); ordinate = MathArrays.copyOf(y); }
*/ public StepFunction(double[] x, double[] y) throws NullArgumentException, NoDataException, DimensionMismatchException { if (x == null || y == null) { throw new NullArgumentException(); } <BUGS> if (x.length == 0 || <BUGE> y.length == 0) { throw new NoDataException(); } if (y.length != x.length) { throw new DimensionMismatchException(y.length, x.length); } MathArrays.checkOrder(x);  abscissa = MathArrays.copyOf(x); ordinate = MathArrays.copyOf(y); }
*/ public StepFunction(double[] x, double[] y) throws NullArgumentException, NoDataException, DimensionMismatchException { if (x == null || y == null) { throw new NullArgumentException(); } if (x.length == 0 || y.length == 0) { throw new NoDataException(); } <BUGS> if (y.length != x.length) { <BUGE> throw new DimensionMismatchException(y.length, x.length); } MathArrays.checkOrder(x);  abscissa = MathArrays.copyOf(x); ordinate = MathArrays.copyOf(y); }
*/ public StepFunction(double[] x, double[] y) throws NullArgumentException, NoDataException, DimensionMismatchException { if (x == null || y == null) { throw new NullArgumentException(); } if (x.length == 0 || y.length == 0) { throw new NoDataException(); } if (y.length != x.length) { throw new DimensionMismatchException(y.length, x.length); } <BUGS> MathArrays.checkOrder(x); <BUGE>  abscissa = MathArrays.copyOf(x); ordinate = MathArrays.copyOf(y); }
*/ public StepFunction(double[] x, double[] y) throws NullArgumentException, NoDataException, DimensionMismatchException { if (x == null || y == null) { throw new NullArgumentException(); } if (x.length == 0 || y.length == 0) { throw new NoDataException(); } if (y.length != x.length) { throw new DimensionMismatchException(y.length, x.length); } MathArrays.checkOrder(x);  <BUGS> abscissa = MathArrays.copyOf(x); ordinate = MathArrays.copyOf(y); } <BUGE>
*/ public StepFunction(double[] x, double[] y) throws NullArgumentException, NoDataException, <BUGS> DimensionMismatchException { if (x == null || <BUGE> y == null) { throw new NullArgumentException(); } if (x.length == 0 || y.length == 0) { throw new NoDataException(); } if (y.length != x.length) { throw new DimensionMismatchException(y.length, x.length); } MathArrays.checkOrder(x);  abscissa = MathArrays.copyOf(x); ordinate = MathArrays.copyOf(y); }
*/ public StepFunction(double[] x, double[] y) throws NullArgumentException, NoDataException, DimensionMismatchException { if (x == null || y == null) { throw new NullArgumentException(); } <BUGS> if (x.length == 0 || <BUGE> y.length == 0) { throw new NoDataException(); } if (y.length != x.length) { throw new DimensionMismatchException(y.length, x.length); } MathArrays.checkOrder(x);  abscissa = MathArrays.copyOf(x); ordinate = MathArrays.copyOf(y); }
*/ public StepFunction(double[] x, double[] y) throws NullArgumentException, NoDataException, DimensionMismatchException { if (x == null || y == null) { throw new NullArgumentException(); } if (x.length == 0 || y.length == 0) { throw new NoDataException(); } <BUGS> if (y.length != x.length) { <BUGE> throw new DimensionMismatchException(y.length, x.length); } MathArrays.checkOrder(x);  abscissa = MathArrays.copyOf(x); ordinate = MathArrays.copyOf(y); }
*/ public StepFunction(double[] x, double[] y) throws NullArgumentException, NoDataException, DimensionMismatchException { if (x == null || y == null) { throw new NullArgumentException(); } if (x.length == 0 || y.length == 0) { throw new NoDataException(); } if (y.length != x.length) { throw new DimensionMismatchException(y.length, x.length); } <BUGS> MathArrays.checkOrder(x); <BUGE>  abscissa = MathArrays.copyOf(x); ordinate = MathArrays.copyOf(y); }
*/ public StepFunction(double[] x, double[] y) throws NullArgumentException, NoDataException, DimensionMismatchException { if (x == null || y == null) { throw new NullArgumentException(); } if (x.length == 0 || y.length == 0) { throw new NoDataException(); } if (y.length != x.length) { throw new DimensionMismatchException(y.length, x.length); } MathArrays.checkOrder(x);  <BUGS> abscissa = MathArrays.copyOf(x); ordinate = MathArrays.copyOf(y); } <BUGE>
*/ private void guessAOmega() { /* initialize the sums for the linear model between the two integrals*/ <BUGS> double sx2 = 0; double sy2 = 0; double sxy = 0; double sxz = 0; double syz = 0; <BUGE>  double currentX = observations[0].getX(); double currentY = observations[0].getY(); double f2Integral = 0; double fPrime2Integral = 0; final double startX = currentX; for (int i = 1; i < observations.length; ++i) { /* one step forward*/ final double previousX = currentX; final double previousY = currentY; currentX = observations[i].getX(); currentY = observations[i].getY();  /* update the integrals of f<sup>2</sup> and f'<sup>2</sup>*/ /* considering a linear model for f (and therefore constant f')*/ final double dx = currentX - previousX; final double dy = currentY - previousY; final double f2StepIntegral = dx * (previousY * previousY + previousY * currentY + currentY * currentY) / 3; final double fPrime2StepIntegral = dy * dy / dx;  final double x = currentX - startX;
*/ private void guessAOmega() { /* initialize the sums for the linear model between the two integrals*/ double sx2 = 0; double sy2 = 0; double sxy = 0; double sxz = 0; double syz = 0;  <BUGS> double currentX = observations[0].getX(); double currentY = observations[0].getY(); double f2Integral = 0; double fPrime2Integral = 0; final double startX = currentX; for (int i = 1; i < observations.length; ++i) { <BUGE> /* one step forward*/ final double previousX = currentX; final double previousY = currentY; currentX = observations[i].getX(); currentY = observations[i].getY();  /* update the integrals of f<sup>2</sup> and f'<sup>2</sup>*/ /* considering a linear model for f (and therefore constant f')*/ final double dx = currentX - previousX; final double dy = currentY - previousY; final double f2StepIntegral = dx * (previousY * previousY + previousY * currentY + currentY * currentY) / 3; final double fPrime2StepIntegral = dy * dy / dx;  final double x = currentX - startX;
*/ private void guessAOmega() { /* initialize the sums for the linear model between the two integrals*/ double sx2 = 0; double sy2 = 0; double sxy = 0; double sxz = 0; double syz = 0;  double currentX = observations[0].getX(); double currentY = observations[0].getY(); double f2Integral = 0; double fPrime2Integral = 0; final double startX = currentX; for (int i = 1; i < observations.length; ++i) { /* one step forward*/ <BUGS> final double previousX = currentX; final double previousY = currentY; currentX = observations[i].getX(); currentY = observations[i].getY(); <BUGE>  /* update the integrals of f<sup>2</sup> and f'<sup>2</sup>*/ /* considering a linear model for f (and therefore constant f')*/ final double dx = currentX - previousX; final double dy = currentY - previousY; final double f2StepIntegral = dx * (previousY * previousY + previousY * currentY + currentY * currentY) / 3; final double fPrime2StepIntegral = dy * dy / dx;  final double x = currentX - startX;
*/ private void guessAOmega() { /* initialize the sums for the linear model between the two integrals*/ double sx2 = 0; double sy2 = 0; double sxy = 0; double sxz = 0; double syz = 0;  double currentX = observations[0].getX(); double currentY = observations[0].getY(); double f2Integral = 0; double fPrime2Integral = 0; final double startX = currentX; for (int i = 1; i < observations.length; ++i) { /* one step forward*/ final double previousX = currentX; final double previousY = currentY; currentX = observations[i].getX(); currentY = observations[i].getY();  /* update the integrals of f<sup>2</sup> and f'<sup>2</sup>*/ /* considering a linear model for f (and therefore constant f')*/ <BUGS> final double dx = currentX - previousX; final double dy = currentY - previousY; final double f2StepIntegral = <BUGE> dx * (previousY * previousY + previousY * currentY + currentY * currentY) / 3; final double fPrime2StepIntegral = dy * dy / dx;  final double x = currentX - startX;
*/ private void guessAOmega() { /* initialize the sums for the linear model between the two integrals*/ double sx2 = 0; double sy2 = 0; double sxy = 0; double sxz = 0; double syz = 0;  double currentX = observations[0].getX(); double currentY = observations[0].getY(); double f2Integral = 0; double fPrime2Integral = 0; final double startX = currentX; for (int i = 1; i < observations.length; ++i) { /* one step forward*/ final double previousX = currentX; final double previousY = currentY; currentX = observations[i].getX(); currentY = observations[i].getY();  /* update the integrals of f<sup>2</sup> and f'<sup>2</sup>*/ /* considering a linear model for f (and therefore constant f')*/ final double dx = currentX - previousX; final double dy = currentY - previousY; final double f2StepIntegral = dx * (previousY * previousY + previousY * currentY + currentY * currentY) / 3; <BUGS> final double fPrime2StepIntegral = dy * dy / dx; <BUGE>  final double x = currentX - startX;
curr = observations[j]; } } }  /** * Estimate a first guess of the amplitude and angular frequency. * This method assumes that the {@link #sortObservations()} method * has been called previously. * * @throws ZeroException if the abscissa range is zero. * @throws MathIllegalStateException when the guessing procedure cannot * produce sensible results.  <BUGS> final double x = currentX - startX; f2Integral += f2StepIntegral; fPrime2Integral += fPrime2StepIntegral; <BUGE>  sx2 += x * x; sy2 += f2Integral * f2Integral; sxy += x * f2Integral; sxz += x * fPrime2Integral; syz += f2Integral * fPrime2Integral; }  /* compute the amplitude and pulsation coefficients*/ double c1 = sy2 * sxz - sxy * syz; double c2 = sxy * sxz - sx2 * syz; double c3 = sx2 * sy2 - sxy * sxy; if ((c1 / c2 < 0) || (c2 / c3 < 0)) {
} } }  /** * Estimate a first guess of the amplitude and angular frequency. * This method assumes that the {@link #sortObservations()} method * has been called previously. * * @throws ZeroException if the abscissa range is zero. * @throws MathIllegalStateException when the guessing procedure cannot * produce sensible results.  <BUGS> sx2 += x * x; sy2 += f2Integral * f2Integral; sxy += x * f2Integral; sxz += x * fPrime2Integral; syz += f2Integral * fPrime2Integral; <BUGE> }  /* compute the amplitude and pulsation coefficients*/ double c1 = sy2 * sxz - sxy * syz; double c2 = sxy * sxz - sx2 * syz; double c3 = sx2 * sy2 - sxy * sxy; if ((c1 / c2 < 0) || (c2 / c3 < 0)) { final int last = observations.length - 1; /* Range of the observations, assuming that the*/ /* observations are sorted.*/ final double xRange = observations[last].getX() - observations[0].getX(); if (xRange == 0) {
curr = observations[j]; } } }  /** * Estimate a first guess of the amplitude and angular frequency. * This method assumes that the {@link #sortObservations()} method * has been called previously. * * @throws ZeroException if the abscissa range is zero. * @throws MathIllegalStateException when the guessing procedure cannot * produce sensible results. /* compute the amplitude and pulsation coefficients*/ <BUGS> double c1 = sy2 * sxz - sxy * syz; double c2 = sxy * sxz - sx2 * syz; double c3 = sx2 * sy2 - sxy * sxy; if ((c1 / c2 < 0) || (c2 / c3 < 0)) { <BUGE> final int last = observations.length - 1; /* Range of the observations, assuming that the*/ /* observations are sorted.*/ final double xRange = observations[last].getX() - observations[0].getX(); if (xRange == 0) { throw new ZeroException(); } omega = 2 * Math.PI / xRange;  double yMin = Double.POSITIVE_INFINITY; double yMax = Double.NEGATIVE_INFINITY; for (int i = 1; i < observations.length; ++i) {
observations[i + 1] = curr; curr = observations[j]; } } }  /** * Estimate a first guess of the amplitude and angular frequency. * This method assumes that the {@link #sortObservations()} method * has been called previously. * * @throws ZeroException if the abscissa range is zero. * @throws MathIllegalStateException when the guessing procedure cannot * produce sensible results.  <BUGS> a = FastMath.sqrt(c1 / c2); omega = FastMath.sqrt(c2 / c3); <BUGE> } }  /** * Estimate a first guess of the phase. */ private void guessPhi() { /* initialize the means*/ double fcMean = 0; double fsMean = 0;  double currentX = observations[0].getX(); double currentY = observations[0].getY();
observations[i + 1] = curr; curr = observations[j]; } } }  /** * Estimate a first guess of the amplitude and angular frequency. * This method assumes that the {@link #sortObservations()} method * has been called previously. * * @throws ZeroException if the abscissa range is zero. * @throws MathIllegalStateException when the guessing procedure cannot * produce sensible results. } <BUGS> } <BUGE>  /** * Estimate a first guess of the phase. */ private void guessPhi() { /* initialize the means*/ double fcMean = 0; double fsMean = 0;  double currentX = observations[0].getX(); double currentY = observations[0].getY(); for (int i = 1; i < observations.length; ++i) { /* one step forward*/ final double previousX = currentX;
*/ private Fraction(double value, double epsilon, int maxDenominator, int maxIterations) throws FractionConversionException <BUGS> { long overflow = Integer.MAX_VALUE; double r0 = value; long a0 = (long)FastMath.floor(r0); if (a0 > overflow) { throw new FractionConversionException(value, a0, 1l); <BUGE> }  /* check for (almost) integer arguments, which should not go*/ /* to iterations.*/ if (FastMath.abs(a0 - value) < epsilon) { this.numerator = (int) a0; this.denominator = 1; return; }  long p0 = 1; long q0 = 0; long p1 = a0; long q1 = 1;  long p2 = 0; long q2 = 1;  int n = 0; boolean stop = false; do {
*/ private Fraction(double value, double epsilon, int maxDenominator, int maxIterations) throws FractionConversionException { long overflow = Integer.MAX_VALUE; double r0 = value; long a0 = (long)FastMath.floor(r0); if (a0 > overflow) { throw new FractionConversionException(value, a0, 1l); }  /* check for (almost) integer arguments, which should not go*/ /* to iterations.*/ <BUGS> if (FastMath.abs(a0 - value) < epsilon) { this.numerator = (int) a0; this.denominator = 1; return; <BUGE> }  long p0 = 1; long q0 = 0; long p1 = a0; long q1 = 1;  long p2 = 0; long q2 = 1;  int n = 0; boolean stop = false; do {
*/ private Fraction(double value, double epsilon, int maxDenominator, int maxIterations) throws FractionConversionException { long overflow = Integer.MAX_VALUE; double r0 = value; long a0 = (long)FastMath.floor(r0); if (a0 > overflow) { throw new FractionConversionException(value, a0, 1l); }  /* check for (almost) integer arguments, which should not go*/ /* to iterations.*/ if (FastMath.abs(a0 - value) < epsilon) { this.numerator = (int) a0; this.denominator = 1; return; }  <BUGS> long p0 = 1; long q0 = 0; long p1 = a0; long q1 = 1; <BUGE>  long p2 = 0; long q2 = 1;  int n = 0; boolean stop = false; do {
*/ private Fraction(double value, double epsilon, int maxDenominator, int maxIterations) throws FractionConversionException { long overflow = Integer.MAX_VALUE; double r0 = value; long a0 = (long)FastMath.floor(r0); if (a0 > overflow) { throw new FractionConversionException(value, a0, 1l); }  /* check for (almost) integer arguments, which should not go*/ /* to iterations.*/ if (FastMath.abs(a0 - value) < epsilon) { this.numerator = (int) a0; this.denominator = 1; return; }  long p0 = 1; long q0 = 0; long p1 = a0; long q1 = 1;  <BUGS> long p2 = 0; long q2 = 1; <BUGE>  int n = 0; boolean stop = false; do {
*/ private Fraction(double value, double epsilon, int maxDenominator, int maxIterations) throws FractionConversionException { long overflow = Integer.MAX_VALUE; double r0 = value; long a0 = (long)FastMath.floor(r0); if (a0 > overflow) { throw new FractionConversionException(value, a0, 1l); }  /* check for (almost) integer arguments, which should not go*/ /* to iterations.*/ if (FastMath.abs(a0 - value) < epsilon) { this.numerator = (int) a0; this.denominator = 1; return; }  long p0 = 1; long q0 = 0; long p1 = a0; long q1 = 1;  long p2 = 0; long q2 = 1;  <BUGS> int n = 0; boolean stop = false; <BUGE> do {
* See JIRA issue ticket MATH-181 for more details: * *     https:/*issues.apache.org/jira/browse/MATH-181*/ * * @param value the double value to convert to a fraction. * @param epsilon maximum error allowed.  The resulting fraction is within *        {@code epsilon} of {@code value}, in absolute terms. * @param maxDenominator maximum denominator value allowed. * @param maxIterations maximum number of convergents * @throws FractionConversionException if the continued fraction failed to *         converge. do { <BUGS> ++n; double r1 = 1.0 / (r0 - a0); long a1 = (long)FastMath.floor(r1); p2 = (a1 * p1) + p0; q2 = (a1 * q1) + q0; if ((p2 > overflow) || (q2 > overflow)) { throw new FractionConversionException(value, p2, q2); <BUGE> }  double convergent = (double)p2 / (double)q2; if (n < maxIterations && FastMath.abs(convergent - value) > epsilon && q2 < maxDenominator) { p0 = p1; p1 = p2; q0 = q1; q1 = q2; a0 = a1; r0 = r1; } else {
* See JIRA issue ticket MATH-181 for more details: * *     https:/*issues.apache.org/jira/browse/MATH-181*/ * * @param value the double value to convert to a fraction. * @param epsilon maximum error allowed.  The resulting fraction is within *        {@code epsilon} of {@code value}, in absolute terms. * @param maxDenominator maximum denominator value allowed. * @param maxIterations maximum number of convergents * @throws FractionConversionException if the continued fraction failed to *         converge.  <BUGS> double convergent = (double)p2 / (double)q2; if (n < maxIterations && FastMath.abs(convergent - value) > epsilon && q2 < maxDenominator) { p0 = p1; p1 = p2; q0 = q1; q1 = q2; a0 = a1; r0 = r1; <BUGE> } else { stop = true; } } while (!stop);  if (n >= maxIterations) { throw new FractionConversionException(value, maxIterations); }  if (q2 < maxDenominator) {
* the public API and this constructor should therefore remain PRIVATE. * </p> * * See JIRA issue ticket MATH-181 for more details: * *     https:/*issues.apache.org/jira/browse/MATH-181*/ * * @param value the double value to convert to a fraction. * @param epsilon maximum error allowed.  The resulting fraction is within *        {@code epsilon} of {@code value}, in absolute terms. * @param maxDenominator maximum denominator value allowed. * @param maxIterations maximum number of convergents * @throws FractionConversionException if the continued fraction failed to *         converge. } <BUGS> } while (!stop); <BUGE>  if (n >= maxIterations) { throw new FractionConversionException(value, maxIterations); }  if (q2 < maxDenominator) { this.numerator = (int) p2; this.denominator = (int) q2; } else { this.numerator = (int) p1; this.denominator = (int) q1; }  }
*/ public double percentageValue() { <BUGS> return multiply(100).doubleValue(); <BUGE> }
*/ protected void incrementIterationsCounter() throws MaxCountExceededException { <BUGS> if (++iterations > maxIterations) { throw new MaxCountExceededException(maxIterations); <BUGE> } }
*/ protected void incrementIterationsCounter() throws MaxCountExceededException { if (++iterations > maxIterations) { throw new MaxCountExceededException(maxIterations); } <BUGS> } <BUGE>
@Override public OpenMapRealVector ebeMultiply(RealVector v) { <BUGS> checkVectorDimensions(v.getDimension()); OpenMapRealVector res = new OpenMapRealVector(this); Iterator iter = entries.iterator(); while (iter.hasNext()) { iter.advance(); res.setEntry(iter.key(), iter.value() * v.getEntry(iter.key())); <BUGE> } /* * MATH-803: the above loop assumes that 0d * x  = 0d for any double x, * which allows to consider only the non-zero entries of this. However, * this fails if this[i] == 0d and (v[i] = NaN or v[i] = Infinity). * * These special cases are handled below. */ return res; }
@Override public OpenMapRealVector ebeMultiply(RealVector v) { checkVectorDimensions(v.getDimension()); OpenMapRealVector res = new OpenMapRealVector(this); Iterator iter = entries.iterator(); while (iter.hasNext()) { iter.advance(); res.setEntry(iter.key(), iter.value() * v.getEntry(iter.key())); } /* * MATH-803: the above loop assumes that 0d * x  = 0d for any double x, * which allows to consider only the non-zero entries of this. However, * this fails if this[i] == 0d and (v[i] = NaN or v[i] = Infinity). * * These special cases are handled below. */ <BUGS> return res; <BUGE> }
*/ public static double max(final double a, final double b) { <BUGS> if (a > b) { <BUGE> return a; } if (a < b) { return b; } /* if either arg is NaN, return NaN */ if (a != b) { return Double.NaN; } /* min(+0.0,-0.0) == -0.0 */ /* 0x8000000000000000L == Double.doubleToRawLongBits(-0.0d) */ long bits = Double.doubleToRawLongBits(a); if (bits == 0x8000000000000000L) { return b; } return a; }
*/ public static double max(final double a, final double b) { if (a > b) { return a; } <BUGS> if (a < b) { return b; <BUGE> } /* if either arg is NaN, return NaN */ if (a != b) { return Double.NaN; } /* min(+0.0,-0.0) == -0.0 */ /* 0x8000000000000000L == Double.doubleToRawLongBits(-0.0d) */ long bits = Double.doubleToRawLongBits(a); if (bits == 0x8000000000000000L) { return b; } return a; }
*/ public double evaluate(double x, double epsilon, int maxIterations) { <BUGS> final double small = 1e-50; double hPrev = getA(0, x); <BUGE>  /* use the value of small as epsilon criteria for zero checks*/ if (Precision.equals(hPrev, 0.0, small)) { hPrev = small; }  int n = 1; double dPrev = 0.0; double p0 = 1.0; double q1 = 1.0; double cPrev = hPrev; double hN = hPrev;  while (n < maxIterations) { final double a = getA(n, x); final double b = getB(n, x);  double cN = a * hPrev + b * p0; double q2 = a * q1 + b * dPrev; if (Double.isInfinite(cN) || Double.isInfinite(q2)) { double scaleFactor = 1d; double lastScaleFactor = 1d; final int maxPower = 5; final double scale = FastMath.max(a,b); if (scale <= 0) {  /* Can't scale*/ throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_INFINITY_DIVERGENCE, x);
*/ public double evaluate(double x, double epsilon, int maxIterations) { final double small = 1e-50; double hPrev = getA(0, x);  /* use the value of small as epsilon criteria for zero checks*/ <BUGS> if (Precision.equals(hPrev, 0.0, small)) { <BUGE> hPrev = small; }  int n = 1; double dPrev = 0.0; double p0 = 1.0; double q1 = 1.0; double cPrev = hPrev; double hN = hPrev;  while (n < maxIterations) { final double a = getA(n, x); final double b = getB(n, x);  double cN = a * hPrev + b * p0; double q2 = a * q1 + b * dPrev; if (Double.isInfinite(cN) || Double.isInfinite(q2)) { double scaleFactor = 1d; double lastScaleFactor = 1d; final int maxPower = 5; final double scale = FastMath.max(a,b); if (scale <= 0) {  /* Can't scale*/ throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_INFINITY_DIVERGENCE, x);
*/ public double evaluate(double x, double epsilon, int maxIterations) { final double small = 1e-50; double hPrev = getA(0, x);  /* use the value of small as epsilon criteria for zero checks*/ if (Precision.equals(hPrev, 0.0, small)) { hPrev = small; }  <BUGS> int n = 1; double dPrev = 0.0; double p0 = 1.0; double q1 = 1.0; double cPrev = hPrev; double hN = hPrev; <BUGE>  while (n < maxIterations) { final double a = getA(n, x); final double b = getB(n, x);  double cN = a * hPrev + b * p0; double q2 = a * q1 + b * dPrev; if (Double.isInfinite(cN) || Double.isInfinite(q2)) { double scaleFactor = 1d; double lastScaleFactor = 1d; final int maxPower = 5; final double scale = FastMath.max(a,b); if (scale <= 0) {  /* Can't scale*/ throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_INFINITY_DIVERGENCE, x);
*/ public double evaluate(double x, double epsilon, int maxIterations) { final double small = 1e-50; double hPrev = getA(0, x);  /* use the value of small as epsilon criteria for zero checks*/ if (Precision.equals(hPrev, 0.0, small)) { hPrev = small; }  int n = 1; double dPrev = 0.0; double p0 = 1.0; double q1 = 1.0; double cPrev = hPrev; double hN = hPrev;  <BUGS> while (n < maxIterations) { final double a = getA(n, x); final double b = getB(n, x); <BUGE>  double cN = a * hPrev + b * p0; double q2 = a * q1 + b * dPrev; if (Double.isInfinite(cN) || Double.isInfinite(q2)) { double scaleFactor = 1d; double lastScaleFactor = 1d; final int maxPower = 5; final double scale = FastMath.max(a,b); if (scale <= 0) {  /* Can't scale*/ throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_INFINITY_DIVERGENCE, x);
*/ public double evaluate(double x, double epsilon, int maxIterations) { final double small = 1e-50; double hPrev = getA(0, x);  /* use the value of small as epsilon criteria for zero checks*/ if (Precision.equals(hPrev, 0.0, small)) { hPrev = small; }  int n = 1; double dPrev = 0.0; double p0 = 1.0; double q1 = 1.0; double cPrev = hPrev; double hN = hPrev;  while (n < maxIterations) { final double a = getA(n, x); final double b = getB(n, x);  <BUGS> double cN = a * hPrev + b * p0; double q2 = a * q1 + b * dPrev; if (Double.isInfinite(cN) || Double.isInfinite(q2)) { <BUGE> double scaleFactor = 1d; double lastScaleFactor = 1d; final int maxPower = 5; final double scale = FastMath.max(a,b); if (scale <= 0) {  /* Can't scale*/ throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_INFINITY_DIVERGENCE, x);
*   I. J. Thompson,  A. R. Barnett. "Coulomb and Bessel Functions of Complex Arguments and Order." *   <a target="_blank" href="http:/*www.fresco.org.uk/papers/Thompson-JCP64p490.pdf">*/ *   http:/*www.fresco.org.uk/papers/Thompson-JCP64p490.pdf</a>*/ * </li> * </ul> * Note: the implementation uses the terms a<sub>i</sub> and b<sub>i</sub> as defined in * <a href="http:/*mathworld.wolfram.com/ContinuedFraction.html">Continued Fraction / MathWorld</a>.*/ * </p> * * @param x the evaluation point. * @param epsilon maximum error allowed. * @param maxIterations maximum number of convergents * @return the value of the continued fraction evaluated at x. * @throws ConvergenceException if the algorithm fails to converge.  <BUGS> final double deltaN = cN / q2 / cPrev; hN = cPrev * deltaN; <BUGE>  if (Double.isInfinite(hN)) { throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_INFINITY_DIVERGENCE, x); } if (Double.isNaN(hN)) { throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_NAN_DIVERGENCE, x); }  if (FastMath.abs(deltaN - 1.0) < epsilon) { break; }
*   I. J. Thompson,  A. R. Barnett. "Coulomb and Bessel Functions of Complex Arguments and Order." *   <a target="_blank" href="http:/*www.fresco.org.uk/papers/Thompson-JCP64p490.pdf">*/ *   http:/*www.fresco.org.uk/papers/Thompson-JCP64p490.pdf</a>*/ * </li> * </ul> * Note: the implementation uses the terms a<sub>i</sub> and b<sub>i</sub> as defined in * <a href="http:/*mathworld.wolfram.com/ContinuedFraction.html">Continued Fraction / MathWorld</a>.*/ * </p> * * @param x the evaluation point. * @param epsilon maximum error allowed. * @param maxIterations maximum number of convergents * @return the value of the continued fraction evaluated at x. * @throws ConvergenceException if the algorithm fails to converge.  <BUGS> if (Double.isInfinite(hN)) { <BUGE> throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_INFINITY_DIVERGENCE, x); } if (Double.isNaN(hN)) { throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_NAN_DIVERGENCE, x); }  if (FastMath.abs(deltaN - 1.0) < epsilon) { break; }  dPrev = q1; cPrev = cN / q2;
*   I. J. Thompson,  A. R. Barnett. "Coulomb and Bessel Functions of Complex Arguments and Order." *   <a target="_blank" href="http:/*www.fresco.org.uk/papers/Thompson-JCP64p490.pdf">*/ *   http:/*www.fresco.org.uk/papers/Thompson-JCP64p490.pdf</a>*/ * </li> * </ul> * Note: the implementation uses the terms a<sub>i</sub> and b<sub>i</sub> as defined in * <a href="http:/*mathworld.wolfram.com/ContinuedFraction.html">Continued Fraction / MathWorld</a>.*/ * </p> * * @param x the evaluation point. * @param epsilon maximum error allowed. * @param maxIterations maximum number of convergents * @return the value of the continued fraction evaluated at x. * @throws ConvergenceException if the algorithm fails to converge. } <BUGS> if (Double.isNaN(hN)) { throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_NAN_DIVERGENCE, <BUGE> x); }  if (FastMath.abs(deltaN - 1.0) < epsilon) { break; }  dPrev = q1; cPrev = cN / q2; p0 = hPrev; hPrev = cN; q1 = q2; n++;
*   I. J. Thompson,  A. R. Barnett. "Coulomb and Bessel Functions of Complex Arguments and Order." *   <a target="_blank" href="http:/*www.fresco.org.uk/papers/Thompson-JCP64p490.pdf">*/ *   http:/*www.fresco.org.uk/papers/Thompson-JCP64p490.pdf</a>*/ * </li> * </ul> * Note: the implementation uses the terms a<sub>i</sub> and b<sub>i</sub> as defined in * <a href="http:/*mathworld.wolfram.com/ContinuedFraction.html">Continued Fraction / MathWorld</a>.*/ * </p> * * @param x the evaluation point. * @param epsilon maximum error allowed. * @param maxIterations maximum number of convergents * @return the value of the continued fraction evaluated at x. * @throws ConvergenceException if the algorithm fails to converge.  <BUGS> if (FastMath.abs(deltaN - 1.0) < epsilon) { break; <BUGE> }  dPrev = q1; cPrev = cN / q2; p0 = hPrev; hPrev = cN; q1 = q2; n++; }  if (n >= maxIterations) { throw new MaxCountExceededException(LocalizedFormats.NON_CONVERGENT_CONTINUED_FRACTION, maxIterations, x);
* </li> * </ul> * Note: the implementation uses the terms a<sub>i</sub> and b<sub>i</sub> as defined in * <a href="http:/*mathworld.wolfram.com/ContinuedFraction.html">Continued Fraction / MathWorld</a>.*/ * </p> * * @param x the evaluation point. * @param epsilon maximum error allowed. * @param maxIterations maximum number of convergents * @return the value of the continued fraction evaluated at x. * @throws ConvergenceException if the algorithm fails to converge.  <BUGS> dPrev = q1; cPrev = cN / q2; p0 = hPrev; hPrev = cN; q1 = q2; n++; } <BUGE>  if (n >= maxIterations) { throw new MaxCountExceededException(LocalizedFormats.NON_CONVERGENT_CONTINUED_FRACTION, maxIterations, x); }  return hN; }  }
*   I. J. Thompson,  A. R. Barnett. "Coulomb and Bessel Functions of Complex Arguments and Order." *   <a target="_blank" href="http:/*www.fresco.org.uk/papers/Thompson-JCP64p490.pdf">*/ *   http:/*www.fresco.org.uk/papers/Thompson-JCP64p490.pdf</a>*/ * </li> * </ul> * Note: the implementation uses the terms a<sub>i</sub> and b<sub>i</sub> as defined in * <a href="http:/*mathworld.wolfram.com/ContinuedFraction.html">Continued Fraction / MathWorld</a>.*/ * </p> * * @param x the evaluation point. * @param epsilon maximum error allowed. * @param maxIterations maximum number of convergents * @return the value of the continued fraction evaluated at x. * @throws ConvergenceException if the algorithm fails to converge.  <BUGS> if (n >= maxIterations) { <BUGE> throw new MaxCountExceededException(LocalizedFormats.NON_CONVERGENT_CONTINUED_FRACTION, maxIterations, x); }  return hN; }  }
*   I. J. Thompson,  A. R. Barnett. "Coulomb and Bessel Functions of Complex Arguments and Order." *   <a target="_blank" href="http:/*www.fresco.org.uk/papers/Thompson-JCP64p490.pdf">*/ *   http:/*www.fresco.org.uk/papers/Thompson-JCP64p490.pdf</a>*/ * </li> * </ul> * Note: the implementation uses the terms a<sub>i</sub> and b<sub>i</sub> as defined in * <a href="http:/*mathworld.wolfram.com/ContinuedFraction.html">Continued Fraction / MathWorld</a>.*/ * </p> * * @param x the evaluation point. * @param epsilon maximum error allowed. * @param maxIterations maximum number of convergents * @return the value of the continued fraction evaluated at x. * @throws ConvergenceException if the algorithm fails to converge.  <BUGS> return hN; <BUGE> }  }
*/ public SubLine(final Vector2D start, final Vector2D end) { <BUGS> super(new Line(start, end), buildIntervalSet(start, end)); } <BUGE>
*/ public Relationship oppositeRelationship() { <BUGS> switch (this) { <BUGE> case LEQ : return GEQ; case GEQ : return LEQ; default : return EQ; } }
*/ public Relationship oppositeRelationship() { switch (this) { case LEQ : <BUGS> return GEQ; <BUGE> case GEQ : return LEQ; default : return EQ; } }
*/ public void addChromosomes(final Collection<Chromosome> chromosomeColl) { <BUGS> if (chromosomes.size() + chromosomeColl.size() > populationLimit) { <BUGE> throw new NumberIsTooLargeException(LocalizedFormats.LIST_OF_CHROMOSOMES_BIGGER_THAN_POPULATION_SIZE, chromosomes.size(), populationLimit, false); } this.chromosomes.addAll(chromosomeColl); }
*/ public void addChromosomes(final Collection<Chromosome> chromosomeColl) { if (chromosomes.size() + chromosomeColl.size() > populationLimit) { throw new NumberIsTooLargeException(LocalizedFormats.LIST_OF_CHROMOSOMES_BIGGER_THAN_POPULATION_SIZE, chromosomes.size(), populationLimit, false); } <BUGS> this.chromosomes.addAll(chromosomeColl); } <BUGE>
*/ <BUGS> public ListPopulation(final List<Chromosome> chromosomes, final int populationLimit) { if (chromosomes.size() > populationLimit) { <BUGE> throw new NumberIsTooLargeException(LocalizedFormats.LIST_OF_CHROMOSOMES_BIGGER_THAN_POPULATION_SIZE, chromosomes.size(), populationLimit, false); } if (populationLimit <= 0) { throw new NotPositiveException(LocalizedFormats.POPULATION_LIMIT_NOT_POSITIVE, populationLimit); }  this.chromosomes = chromosomes; this.populationLimit = populationLimit; }
*/ public ListPopulation(final List<Chromosome> chromosomes, final int populationLimit) { if (chromosomes.size() > populationLimit) { throw new NumberIsTooLargeException(LocalizedFormats.LIST_OF_CHROMOSOMES_BIGGER_THAN_POPULATION_SIZE, chromosomes.size(), populationLimit, false); } <BUGS> if (populationLimit <= 0) { <BUGE> throw new NotPositiveException(LocalizedFormats.POPULATION_LIMIT_NOT_POSITIVE, populationLimit); }  this.chromosomes = chromosomes; this.populationLimit = populationLimit; }
*/ public ListPopulation(final List<Chromosome> chromosomes, final int populationLimit) { if (chromosomes.size() > populationLimit) { throw new NumberIsTooLargeException(LocalizedFormats.LIST_OF_CHROMOSOMES_BIGGER_THAN_POPULATION_SIZE, chromosomes.size(), populationLimit, false); } if (populationLimit <= 0) { throw new NotPositiveException(LocalizedFormats.POPULATION_LIMIT_NOT_POSITIVE, populationLimit); }  <BUGS> this.chromosomes = chromosomes; this.populationLimit = populationLimit; } <BUGE>
@Override public float floatValue() { <BUGS> float result = numerator.floatValue() / denominator.floatValue(); <BUGE> /* Numerator and/or denominator must be out of range:*/ /* Calculate how far to shift them to put them in range.*/ return result; }
@Override public float floatValue() { float result = numerator.floatValue() / denominator.floatValue(); /* Numerator and/or denominator must be out of range:*/ /* Calculate how far to shift them to put them in range.*/ <BUGS> return result; <BUGE> }
*/ public static double cosh(double x) { <BUGS> if (x != x) { <BUGE> return x; }  /* cosh[z] = (exp(z) + exp(-z))/2*/  /* for numbers with magnitude 20 or so,*/ /* exp(-z) can be ignored in comparison with exp(z)*/  if (x > 20.0) { return exp(x)/2.0; }  if (x < -20) { return exp(-x)/2.0; }  double hiPrec[] = new double[2]; if (x < 0.0) { x = -x; } exp(x, 0.0, hiPrec);  double ya = hiPrec[0] + hiPrec[1]; double yb = -(ya - hiPrec[0] - hiPrec[1]);  double temp = ya * HEX_40000000; double yaa = ya + temp - temp;
*/ public static double cosh(double x) { if (x != x) { return x; }  /* cosh[z] = (exp(z) + exp(-z))/2*/  /* for numbers with magnitude 20 or so,*/ /* exp(-z) can be ignored in comparison with exp(z)*/  <BUGS> if (x > 20.0) { return exp(x)/2.0; <BUGE> }  if (x < -20) { return exp(-x)/2.0; }  double hiPrec[] = new double[2]; if (x < 0.0) { x = -x; } exp(x, 0.0, hiPrec);  double ya = hiPrec[0] + hiPrec[1]; double yb = -(ya - hiPrec[0] - hiPrec[1]);  double temp = ya * HEX_40000000; double yaa = ya + temp - temp;
*/ public static double cosh(double x) { if (x != x) { return x; }  /* cosh[z] = (exp(z) + exp(-z))/2*/  /* for numbers with magnitude 20 or so,*/ /* exp(-z) can be ignored in comparison with exp(z)*/  if (x > 20.0) { return exp(x)/2.0; }  <BUGS> if (x < -20) { <BUGE> return exp(-x)/2.0; }  double hiPrec[] = new double[2]; if (x < 0.0) { x = -x; } exp(x, 0.0, hiPrec);  double ya = hiPrec[0] + hiPrec[1]; double yb = -(ya - hiPrec[0] - hiPrec[1]);  double temp = ya * HEX_40000000; double yaa = ya + temp - temp;
*/ public static double cosh(double x) { if (x != x) { return x; }  /* cosh[z] = (exp(z) + exp(-z))/2*/  /* for numbers with magnitude 20 or so,*/ /* exp(-z) can be ignored in comparison with exp(z)*/  if (x > 20.0) { return exp(x)/2.0; }  if (x < -20) { return exp(-x)/2.0; }  <BUGS> double hiPrec[] = new double[2]; if (x < 0.0) { <BUGE> x = -x; } exp(x, 0.0, hiPrec);  double ya = hiPrec[0] + hiPrec[1]; double yb = -(ya - hiPrec[0] - hiPrec[1]);  double temp = ya * HEX_40000000; double yaa = ya + temp - temp;
*/ public static double cosh(double x) { if (x != x) { return x; }  /* cosh[z] = (exp(z) + exp(-z))/2*/  /* for numbers with magnitude 20 or so,*/ /* exp(-z) can be ignored in comparison with exp(z)*/  if (x > 20.0) { return exp(x)/2.0; }  if (x < -20) { return exp(-x)/2.0; }  double hiPrec[] = new double[2]; if (x < 0.0) { x = -x; } <BUGS> exp(x, 0.0, hiPrec); <BUGE>  double ya = hiPrec[0] + hiPrec[1]; double yb = -(ya - hiPrec[0] - hiPrec[1]);  double temp = ya * HEX_40000000; double yaa = ya + temp - temp;
*/ public static double cosh(double x) { if (x != x) { return x; }  /* cosh[z] = (exp(z) + exp(-z))/2*/  /* for numbers with magnitude 20 or so,*/ /* exp(-z) can be ignored in comparison with exp(z)*/  if (x > 20.0) { return exp(x)/2.0; }  if (x < -20) { return exp(-x)/2.0; }  double hiPrec[] = new double[2]; if (x < 0.0) { x = -x; } exp(x, 0.0, hiPrec);  <BUGS> double ya = hiPrec[0] + hiPrec[1]; double yb = -(ya - hiPrec[0] - hiPrec[1]); <BUGE>  double temp = ya * HEX_40000000; double yaa = ya + temp - temp;
*/ public static double cosh(double x) { if (x != x) { return x; }  /* cosh[z] = (exp(z) + exp(-z))/2*/  /* for numbers with magnitude 20 or so,*/ /* exp(-z) can be ignored in comparison with exp(z)*/  if (x > 20.0) { return exp(x)/2.0; }  if (x < -20) { return exp(-x)/2.0; }  double hiPrec[] = new double[2]; if (x < 0.0) { x = -x; } exp(x, 0.0, hiPrec);  double ya = hiPrec[0] + hiPrec[1]; double yb = -(ya - hiPrec[0] - hiPrec[1]);  <BUGS> double temp = ya * HEX_40000000; double yaa = ya + temp - temp;
/** Compute the square root of a number. * <p><b>Note:</b> this implementation currently delegates to {@link Math#sqrt} * @param a number on which evaluation is done * @return square root of a */ public static double sqrt(final double a) { return Math.sqrt(a); }  /** Compute the hyperbolic cosine of a number. * @param x number on which evaluation is done * @return hyperbolic cosine of x /* recip = 1/y*/ <BUGS> double recip = 1.0/ya; temp = recip * HEX_40000000; double recipa = recip + temp - temp; double recipb = recip - recipa; <BUGE>  /* Correct for rounding in division*/ recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip; /* Account for yb*/ recipb += -yb * recip * recip;  /* y = y + 1/y*/ temp = ya + recipa; yb += -(temp - ya - recipa); ya = temp; temp = ya + recipb; yb += -(temp - ya - recipb);
}  /** Compute the square root of a number. * <p><b>Note:</b> this implementation currently delegates to {@link Math#sqrt} * @param a number on which evaluation is done * @return square root of a */ public static double sqrt(final double a) { return Math.sqrt(a); }  /** Compute the hyperbolic cosine of a number. * @param x number on which evaluation is done * @return hyperbolic cosine of x /* Correct for rounding in division*/ <BUGS> recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip; <BUGE> /* Account for yb*/ recipb += -yb * recip * recip;  /* y = y + 1/y*/ temp = ya + recipa; yb += -(temp - ya - recipa); ya = temp; temp = ya + recipb; yb += -(temp - ya - recipb); ya = temp;  double result = ya + yb; result *= 0.5; return result;
}  /** Compute the square root of a number. * <p><b>Note:</b> this implementation currently delegates to {@link Math#sqrt} * @param a number on which evaluation is done * @return square root of a */ public static double sqrt(final double a) { return Math.sqrt(a); }  /** Compute the hyperbolic cosine of a number. * @param x number on which evaluation is done * @return hyperbolic cosine of x /* Account for yb*/ <BUGS> recipb += -yb * recip * recip; <BUGE>  /* y = y + 1/y*/ temp = ya + recipa; yb += -(temp - ya - recipa); ya = temp; temp = ya + recipb; yb += -(temp - ya - recipb); ya = temp;  double result = ya + yb; result *= 0.5; return result; }
/** Compute the square root of a number. * <p><b>Note:</b> this implementation currently delegates to {@link Math#sqrt} * @param a number on which evaluation is done * @return square root of a */ public static double sqrt(final double a) { return Math.sqrt(a); }  /** Compute the hyperbolic cosine of a number. * @param x number on which evaluation is done * @return hyperbolic cosine of x /* y = y + 1/y*/ <BUGS> temp = ya + recipa; yb += -(temp - ya - recipa); ya = temp; temp = ya + recipb; yb += -(temp - ya - recipb); ya = temp; <BUGE>  double result = ya + yb; result *= 0.5; return result; }  /** Compute the hyperbolic sine of a number. * @param x number on which evaluation is done * @return hyperbolic sine of x */ public static double sinh(double x) {
/** Compute the square root of a number. * <p><b>Note:</b> this implementation currently delegates to {@link Math#sqrt} * @param a number on which evaluation is done * @return square root of a */ public static double sqrt(final double a) { return Math.sqrt(a); }  /** Compute the hyperbolic cosine of a number. * @param x number on which evaluation is done * @return hyperbolic cosine of x  <BUGS> double result = ya + yb; result *= 0.5; return result; <BUGE> }  /** Compute the hyperbolic sine of a number. * @param x number on which evaluation is done * @return hyperbolic sine of x */ public static double sinh(double x) { boolean negate = false; if (x != x) { return x; }  /* sinh[z] = (exp(z) - exp(-z) / 2*/
*/ private void prelim(double[] lowerBound, double[] upperBound) { <BUGS> printMethod(); /* XXX <BUGE>*/  final int n = currentBest.getDimension(); final int npt = numberOfInterpolationPoints; final int ndim = bMatrix.getRowDimension();  final double rhosq = initialTrustRegionRadius * initialTrustRegionRadius; final double recip = 1d / rhosq; final int np = n + 1;  /* Set XBASE to the initial vector of variables, and set the initial*/ /* elements of XPT, BMAT, HQ, PQ and ZMAT to zero.*/  for (int j = 0; j < n; j++) { originShift.setEntry(j, currentBest.getEntry(j)); for (int k = 0; k < npt; k++) { interpolationPoints.setEntry(k, j, ZERO); } for (int i = 0; i < ndim; i++) { bMatrix.setEntry(i, j, ZERO); } } for (int i = 0, max = n * np / 2; i < max; i++) { modelSecondDerivativesValues.setEntry(i, ZERO); } for (int k = 0; k < npt; k++) { modelSecondDerivativesParameters.setEntry(k, ZERO);
*/ private void prelim(double[] lowerBound, double[] upperBound) { printMethod(); /* XXX*/  <BUGS> final int n = currentBest.getDimension(); final int npt = numberOfInterpolationPoints; final int ndim = bMatrix.getRowDimension(); <BUGE>  final double rhosq = initialTrustRegionRadius * initialTrustRegionRadius; final double recip = 1d / rhosq; final int np = n + 1;  /* Set XBASE to the initial vector of variables, and set the initial*/ /* elements of XPT, BMAT, HQ, PQ and ZMAT to zero.*/  for (int j = 0; j < n; j++) { originShift.setEntry(j, currentBest.getEntry(j)); for (int k = 0; k < npt; k++) { interpolationPoints.setEntry(k, j, ZERO); } for (int i = 0; i < ndim; i++) { bMatrix.setEntry(i, j, ZERO); } } for (int i = 0, max = n * np / 2; i < max; i++) { modelSecondDerivativesValues.setEntry(i, ZERO); } for (int k = 0; k < npt; k++) { modelSecondDerivativesParameters.setEntry(k, ZERO);
*/ private void prelim(double[] lowerBound, double[] upperBound) { printMethod(); /* XXX*/  final int n = currentBest.getDimension(); final int npt = numberOfInterpolationPoints; final int ndim = bMatrix.getRowDimension();  <BUGS> final double rhosq = initialTrustRegionRadius * initialTrustRegionRadius; final double recip = 1d / rhosq; final int np = n + 1; <BUGE>  /* Set XBASE to the initial vector of variables, and set the initial*/ /* elements of XPT, BMAT, HQ, PQ and ZMAT to zero.*/  for (int j = 0; j < n; j++) { originShift.setEntry(j, currentBest.getEntry(j)); for (int k = 0; k < npt; k++) { interpolationPoints.setEntry(k, j, ZERO); } for (int i = 0; i < ndim; i++) { bMatrix.setEntry(i, j, ZERO); } } for (int i = 0, max = n * np / 2; i < max; i++) { modelSecondDerivativesValues.setEntry(i, ZERO); } for (int k = 0; k < npt; k++) { modelSecondDerivativesParameters.setEntry(k, ZERO);
*/ private void prelim(double[] lowerBound, double[] upperBound) { printMethod(); /* XXX*/  final int n = currentBest.getDimension(); final int npt = numberOfInterpolationPoints; final int ndim = bMatrix.getRowDimension();  final double rhosq = initialTrustRegionRadius * initialTrustRegionRadius; final double recip = 1d / rhosq; final int np = n + 1;  /* Set XBASE to the initial vector of variables, and set the initial*/ /* elements of XPT, BMAT, HQ, PQ and ZMAT to zero.*/  <BUGS> for (int j = 0; j < n; j++) { originShift.setEntry(j, currentBest.getEntry(j)); for (int k = 0; k < npt; k++) { interpolationPoints.setEntry(k, j, ZERO); <BUGE> } for (int i = 0; i < ndim; i++) { bMatrix.setEntry(i, j, ZERO); } } for (int i = 0, max = n * np / 2; i < max; i++) { modelSecondDerivativesValues.setEntry(i, ZERO); } for (int k = 0; k < npt; k++) { modelSecondDerivativesParameters.setEntry(k, ZERO);
*/ private void prelim(double[] lowerBound, double[] upperBound) { printMethod(); /* XXX*/  final int n = currentBest.getDimension(); final int npt = numberOfInterpolationPoints; final int ndim = bMatrix.getRowDimension();  final double rhosq = initialTrustRegionRadius * initialTrustRegionRadius; final double recip = 1d / rhosq; final int np = n + 1;  /* Set XBASE to the initial vector of variables, and set the initial*/ /* elements of XPT, BMAT, HQ, PQ and ZMAT to zero.*/  for (int j = 0; j < n; j++) { originShift.setEntry(j, currentBest.getEntry(j)); for (int k = 0; k < npt; k++) { interpolationPoints.setEntry(k, j, ZERO); } <BUGS> for (int i = 0; i < ndim; i++) { bMatrix.setEntry(i, j, ZERO); <BUGE> } } for (int i = 0, max = n * np / 2; i < max; i++) { modelSecondDerivativesValues.setEntry(i, ZERO); } for (int k = 0; k < npt; k++) { modelSecondDerivativesParameters.setEntry(k, ZERO);
*/ private void prelim(double[] lowerBound, double[] upperBound) { printMethod(); /* XXX*/  final int n = currentBest.getDimension(); final int npt = numberOfInterpolationPoints; final int ndim = bMatrix.getRowDimension();  final double rhosq = initialTrustRegionRadius * initialTrustRegionRadius; final double recip = 1d / rhosq; final int np = n + 1;  /* Set XBASE to the initial vector of variables, and set the initial*/ /* elements of XPT, BMAT, HQ, PQ and ZMAT to zero.*/  for (int j = 0; j < n; j++) { originShift.setEntry(j, currentBest.getEntry(j)); for (int k = 0; k < npt; k++) { interpolationPoints.setEntry(k, j, ZERO); } for (int i = 0; i < ndim; i++) { bMatrix.setEntry(i, j, ZERO); } } <BUGS> for (int i = 0, max = n * np / 2; i < max; i++) { modelSecondDerivativesValues.setEntry(i, ZERO); <BUGE> } for (int k = 0; k < npt; k++) { modelSecondDerivativesParameters.setEntry(k, ZERO);
*       same as the corresponding arguments in SUBROUTINE BOBYQA. *     The arguments XBASE, XPT, FVAL, HQ, PQ, BMAT, ZMAT, NDIM, SL and SU *       are the same as the corresponding arguments in BOBYQB, the elements *       of SL and SU being set in BOBYQA. *     GOPT is usually the gradient of the quadratic model at XOPT+XBASE, but *       it is set by PRELIM to the gradient of the quadratic model at XBASE. *       If XOPT is nonzero, BOBYQB will change it to its usual value later. *     NF is maintaned as the number of calls of CALFUN so far. *     KOPT will be such that the least calculated value of F so far is at *       the point XPT(KOPT,.)+XBASE in the space of the variables. * * @param lowerBound Lower bounds. * @param upperBound Upper bounds. } <BUGS> for (int k = 0; k < npt; k++) { modelSecondDerivativesParameters.setEntry(k, ZERO); for (int j = 0, max = npt - np; j < max; j++) { zMatrix.setEntry(k, j, ZERO); <BUGE> } }  /* Begin the initialization procedure. NF becomes one more than the number*/ /* of function values so far. The coordinates of the displacement of the*/ /* next initial interpolation point from XBASE are set in XPT(NF+1,.).*/  int ipt = 0; int jpt = 0; double fbeg = Double.NaN; do { final int nfm = getEvaluations();
*       same as the corresponding arguments in SUBROUTINE BOBYQA. *     The arguments XBASE, XPT, FVAL, HQ, PQ, BMAT, ZMAT, NDIM, SL and SU *       are the same as the corresponding arguments in BOBYQB, the elements *       of SL and SU being set in BOBYQA. *     GOPT is usually the gradient of the quadratic model at XOPT+XBASE, but *       it is set by PRELIM to the gradient of the quadratic model at XBASE. *       If XOPT is nonzero, BOBYQB will change it to its usual value later. *     NF is maintaned as the number of calls of CALFUN so far. *     KOPT will be such that the least calculated value of F so far is at *       the point XPT(KOPT,.)+XBASE in the space of the variables. * * @param lowerBound Lower bounds. * @param upperBound Upper bounds.  <BUGS> int ipt = 0; int jpt = 0; double fbeg = Double.NaN; <BUGE> do { final int nfm = getEvaluations(); final int nfx = nfm - n; final int nfmm = nfm - 1; final int nfxm = nfx - 1; double stepa = 0; double stepb = 0; if (nfm <= 2 * n) { if (nfm >= 1 && nfm <= n) { stepa = initialTrustRegionRadius; if (upperDifference.getEntry(nfmm) == ZERO) { stepa = -stepa;
*       are the same as the corresponding arguments in BOBYQB, the elements *       of SL and SU being set in BOBYQA. *     GOPT is usually the gradient of the quadratic model at XOPT+XBASE, but *       it is set by PRELIM to the gradient of the quadratic model at XBASE. *       If XOPT is nonzero, BOBYQB will change it to its usual value later. *     NF is maintaned as the number of calls of CALFUN so far. *     KOPT will be such that the least calculated value of F so far is at *       the point XPT(KOPT,.)+XBASE in the space of the variables. * * @param lowerBound Lower bounds. * @param upperBound Upper bounds. do { <BUGS> final int nfm = getEvaluations(); final int nfx = nfm - n; final int nfmm = nfm - 1; final int nfxm = nfx - 1; double stepa = 0; double stepb = 0; if (nfm <= 2 * n) { if (nfm >= 1 && <BUGE> nfm <= n) { stepa = initialTrustRegionRadius; if (upperDifference.getEntry(nfmm) == ZERO) { stepa = -stepa; throw new PathIsExploredException(); /* XXX*/ } interpolationPoints.setEntry(nfm, nfmm, stepa); } else if (nfm > n) { stepa = interpolationPoints.getEntry(nfx, nfxm); stepb = -initialTrustRegionRadius;
*     The arguments N, NPT, X, XL, XU, RHOBEG, IPRINT and MAXFUN are the *       same as the corresponding arguments in SUBROUTINE BOBYQA. *     The arguments XBASE, XPT, FVAL, HQ, PQ, BMAT, ZMAT, NDIM, SL and SU *       are the same as the corresponding arguments in BOBYQB, the elements *       of SL and SU being set in BOBYQA. *     GOPT is usually the gradient of the quadratic model at XOPT+XBASE, but *       it is set by PRELIM to the gradient of the quadratic model at XBASE. *       If XOPT is nonzero, BOBYQB will change it to its usual value later. *     NF is maintaned as the number of calls of CALFUN so far. *     KOPT will be such that the least calculated value of F so far is at *       the point XPT(KOPT,.)+XBASE in the space of the variables. * * @param lowerBound Lower bounds. * @param upperBound Upper bounds. nfm <= n) { <BUGS> stepa = initialTrustRegionRadius; if (upperDifference.getEntry(nfmm) == ZERO) { <BUGE> stepa = -stepa; throw new PathIsExploredException(); /* XXX*/ } interpolationPoints.setEntry(nfm, nfmm, stepa); } else if (nfm > n) { stepa = interpolationPoints.getEntry(nfx, nfxm); stepb = -initialTrustRegionRadius; if (lowerDifference.getEntry(nfxm) == ZERO) { stepb = Math.min(TWO * initialTrustRegionRadius, upperDifference.getEntry(nfxm)); throw new PathIsExploredException(); /* XXX*/ } if (upperDifference.getEntry(nfxm) == ZERO) { stepb = Math.max(-TWO * initialTrustRegionRadius, lowerDifference.getEntry(nfxm));
*     The arguments XBASE, XPT, FVAL, HQ, PQ, BMAT, ZMAT, NDIM, SL and SU *       are the same as the corresponding arguments in BOBYQB, the elements *       of SL and SU being set in BOBYQA. *     GOPT is usually the gradient of the quadratic model at XOPT+XBASE, but *       it is set by PRELIM to the gradient of the quadratic model at XBASE. *       If XOPT is nonzero, BOBYQB will change it to its usual value later. *     NF is maintaned as the number of calls of CALFUN so far. *     KOPT will be such that the least calculated value of F so far is at *       the point XPT(KOPT,.)+XBASE in the space of the variables. * * @param lowerBound Lower bounds. * @param upperBound Upper bounds. } <BUGS> interpolationPoints.setEntry(nfm, nfmm, stepa); } else if (nfm > n) { stepa = interpolationPoints.getEntry(nfx, nfxm); stepb = -initialTrustRegionRadius; if (lowerDifference.getEntry(nfxm) == ZERO) { <BUGE> stepb = Math.min(TWO * initialTrustRegionRadius, upperDifference.getEntry(nfxm)); throw new PathIsExploredException(); /* XXX*/ } if (upperDifference.getEntry(nfxm) == ZERO) { stepb = Math.max(-TWO * initialTrustRegionRadius, lowerDifference.getEntry(nfxm)); throw new PathIsExploredException(); /* XXX*/ } interpolationPoints.setEntry(nfm, nfxm, stepb); } } else { final int tmp1 = (nfm - np) / n; jpt = nfm - tmp1 * n - n;
*     The arguments N, NPT, X, XL, XU, RHOBEG, IPRINT and MAXFUN are the *       same as the corresponding arguments in SUBROUTINE BOBYQA. *     The arguments XBASE, XPT, FVAL, HQ, PQ, BMAT, ZMAT, NDIM, SL and SU *       are the same as the corresponding arguments in BOBYQB, the elements *       of SL and SU being set in BOBYQA. *     GOPT is usually the gradient of the quadratic model at XOPT+XBASE, but *       it is set by PRELIM to the gradient of the quadratic model at XBASE. *       If XOPT is nonzero, BOBYQB will change it to its usual value later. *     NF is maintaned as the number of calls of CALFUN so far. *     KOPT will be such that the least calculated value of F so far is at *       the point XPT(KOPT,.)+XBASE in the space of the variables. * * @param lowerBound Lower bounds. * @param upperBound Upper bounds. } <BUGS> if (upperDifference.getEntry(nfxm) == ZERO) { <BUGE> stepb = Math.max(-TWO * initialTrustRegionRadius, lowerDifference.getEntry(nfxm)); throw new PathIsExploredException(); /* XXX*/ } interpolationPoints.setEntry(nfm, nfxm, stepb); } } else { final int tmp1 = (nfm - np) / n; jpt = nfm - tmp1 * n - n; ipt = jpt + tmp1; if (ipt > n) { final int tmp2 = jpt; jpt = ipt - n; ipt = tmp2; throw new PathIsExploredException(); /* XXX*/
*     The arguments N, NPT, X, XL, XU, RHOBEG, IPRINT and MAXFUN are the *       same as the corresponding arguments in SUBROUTINE BOBYQA. *     The arguments XBASE, XPT, FVAL, HQ, PQ, BMAT, ZMAT, NDIM, SL and SU *       are the same as the corresponding arguments in BOBYQB, the elements *       of SL and SU being set in BOBYQA. *     GOPT is usually the gradient of the quadratic model at XOPT+XBASE, but *       it is set by PRELIM to the gradient of the quadratic model at XBASE. *       If XOPT is nonzero, BOBYQB will change it to its usual value later. *     NF is maintaned as the number of calls of CALFUN so far. *     KOPT will be such that the least calculated value of F so far is at *       the point XPT(KOPT,.)+XBASE in the space of the variables. * * @param lowerBound Lower bounds. * @param upperBound Upper bounds. } <BUGS> interpolationPoints.setEntry(nfm, nfxm, stepb); <BUGE> } } else { final int tmp1 = (nfm - np) / n; jpt = nfm - tmp1 * n - n; ipt = jpt + tmp1; if (ipt > n) { final int tmp2 = jpt; jpt = ipt - n; ipt = tmp2; throw new PathIsExploredException(); /* XXX*/ } final int iptMinus1 = ipt; final int jptMinus1 = jpt; interpolationPoints.setEntry(nfm, iptMinus1, interpolationPoints.getEntry(ipt, iptMinus1));
*       same as the corresponding arguments in SUBROUTINE BOBYQA. *     The arguments XBASE, XPT, FVAL, HQ, PQ, BMAT, ZMAT, NDIM, SL and SU *       are the same as the corresponding arguments in BOBYQB, the elements *       of SL and SU being set in BOBYQA. *     GOPT is usually the gradient of the quadratic model at XOPT+XBASE, but *       it is set by PRELIM to the gradient of the quadratic model at XBASE. *       If XOPT is nonzero, BOBYQB will change it to its usual value later. *     NF is maintaned as the number of calls of CALFUN so far. *     KOPT will be such that the least calculated value of F so far is at *       the point XPT(KOPT,.)+XBASE in the space of the variables. * * @param lowerBound Lower bounds. * @param upperBound Upper bounds. } else { <BUGS> final int tmp1 = (nfm - np) / n; jpt = nfm - tmp1 * n - n; ipt = jpt + tmp1; if (ipt > n) { <BUGE> final int tmp2 = jpt; jpt = ipt - n; ipt = tmp2; throw new PathIsExploredException(); /* XXX*/ } final int iptMinus1 = ipt; final int jptMinus1 = jpt; interpolationPoints.setEntry(nfm, iptMinus1, interpolationPoints.getEntry(ipt, iptMinus1)); interpolationPoints.setEntry(nfm, jptMinus1, interpolationPoints.getEntry(jpt, jptMinus1)); }  /* Calculate the next value of F. The least function value so far and*/
*       same as the corresponding arguments in SUBROUTINE BOBYQA. *     The arguments XBASE, XPT, FVAL, HQ, PQ, BMAT, ZMAT, NDIM, SL and SU *       are the same as the corresponding arguments in BOBYQB, the elements *       of SL and SU being set in BOBYQA. *     GOPT is usually the gradient of the quadratic model at XOPT+XBASE, but *       it is set by PRELIM to the gradient of the quadratic model at XBASE. *       If XOPT is nonzero, BOBYQB will change it to its usual value later. *     NF is maintaned as the number of calls of CALFUN so far. *     KOPT will be such that the least calculated value of F so far is at *       the point XPT(KOPT,.)+XBASE in the space of the variables. * * @param lowerBound Lower bounds. * @param upperBound Upper bounds. } <BUGS> final int iptMinus1 = ipt; final int jptMinus1 = jpt; interpolationPoints.setEntry(nfm, iptMinus1, interpolationPoints.getEntry(ipt, iptMinus1)); interpolationPoints.setEntry(nfm, jptMinus1, interpolationPoints.getEntry(jpt, jptMinus1)); <BUGE> }  /* Calculate the next value of F. The least function value so far and*/ /* its index are required.*/  for (int j = 0; j < n; j++) { currentBest.setEntry(j, Math.min(Math.max(lowerBound[j], originShift.getEntry(j) + interpolationPoints.getEntry(nfm, j)), upperBound[j])); if (interpolationPoints.getEntry(nfm, j) == lowerDifference.getEntry(j)) { currentBest.setEntry(j, lowerBound[j]); }
*     The arguments N, NPT, X, XL, XU, RHOBEG, IPRINT and MAXFUN are the *       same as the corresponding arguments in SUBROUTINE BOBYQA. *     The arguments XBASE, XPT, FVAL, HQ, PQ, BMAT, ZMAT, NDIM, SL and SU *       are the same as the corresponding arguments in BOBYQB, the elements *       of SL and SU being set in BOBYQA. *     GOPT is usually the gradient of the quadratic model at XOPT+XBASE, but *       it is set by PRELIM to the gradient of the quadratic model at XBASE. *       If XOPT is nonzero, BOBYQB will change it to its usual value later. *     NF is maintaned as the number of calls of CALFUN so far. *     KOPT will be such that the least calculated value of F so far is at *       the point XPT(KOPT,.)+XBASE in the space of the variables. * * @param lowerBound Lower bounds. * @param upperBound Upper bounds.  <BUGS> for (int j = 0; j < n; j++) { currentBest.setEntry(j, Math.min(Math.max(lowerBound[j], <BUGE> originShift.getEntry(j) + interpolationPoints.getEntry(nfm, j)), upperBound[j])); if (interpolationPoints.getEntry(nfm, j) == lowerDifference.getEntry(j)) { currentBest.setEntry(j, lowerBound[j]); } if (interpolationPoints.getEntry(nfm, j) == upperDifference.getEntry(j)) { currentBest.setEntry(j, upperBound[j]); } }  final double objectiveValue = computeObjectiveValue(currentBest.toArray()); final double f = isMinimize ? objectiveValue : -objectiveValue; final int numEval = getEvaluations(); /* nfm + 1*/
*     The arguments N, NPT, X, XL, XU, RHOBEG, IPRINT and MAXFUN are the *       same as the corresponding arguments in SUBROUTINE BOBYQA. *     The arguments XBASE, XPT, FVAL, HQ, PQ, BMAT, ZMAT, NDIM, SL and SU *       are the same as the corresponding arguments in BOBYQB, the elements *       of SL and SU being set in BOBYQA. *     GOPT is usually the gradient of the quadratic model at XOPT+XBASE, but *       it is set by PRELIM to the gradient of the quadratic model at XBASE. *       If XOPT is nonzero, BOBYQB will change it to its usual value later. *     NF is maintaned as the number of calls of CALFUN so far. *     KOPT will be such that the least calculated value of F so far is at *       the point XPT(KOPT,.)+XBASE in the space of the variables. * * @param lowerBound Lower bounds. * @param upperBound Upper bounds. upperBound[j])); <BUGS> if (interpolationPoints.getEntry(nfm, j) == lowerDifference.getEntry(j)) { <BUGE> currentBest.setEntry(j, lowerBound[j]); } if (interpolationPoints.getEntry(nfm, j) == upperDifference.getEntry(j)) { currentBest.setEntry(j, upperBound[j]); } }  final double objectiveValue = computeObjectiveValue(currentBest.toArray()); final double f = isMinimize ? objectiveValue : -objectiveValue; final int numEval = getEvaluations(); /* nfm + 1*/ fAtInterpolationPoints.setEntry(nfm, f);  if (numEval == 1) { fbeg = f;
*     The arguments N, NPT, X, XL, XU, RHOBEG, IPRINT and MAXFUN are the *       same as the corresponding arguments in SUBROUTINE BOBYQA. *     The arguments XBASE, XPT, FVAL, HQ, PQ, BMAT, ZMAT, NDIM, SL and SU *       are the same as the corresponding arguments in BOBYQB, the elements *       of SL and SU being set in BOBYQA. *     GOPT is usually the gradient of the quadratic model at XOPT+XBASE, but *       it is set by PRELIM to the gradient of the quadratic model at XBASE. *       If XOPT is nonzero, BOBYQB will change it to its usual value later. *     NF is maintaned as the number of calls of CALFUN so far. *     KOPT will be such that the least calculated value of F so far is at *       the point XPT(KOPT,.)+XBASE in the space of the variables. * * @param lowerBound Lower bounds. * @param upperBound Upper bounds. } <BUGS> if (interpolationPoints.getEntry(nfm, j) == upperDifference.getEntry(j)) { <BUGE> currentBest.setEntry(j, upperBound[j]); } }  final double objectiveValue = computeObjectiveValue(currentBest.toArray()); final double f = isMinimize ? objectiveValue : -objectiveValue; final int numEval = getEvaluations(); /* nfm + 1*/ fAtInterpolationPoints.setEntry(nfm, f);  if (numEval == 1) { fbeg = f; trustRegionCenterInterpolationPointIndex = 0; } else if (f < fAtInterpolationPoints.getEntry(trustRegionCenterInterpolationPointIndex)) { trustRegionCenterInterpolationPointIndex = nfm;
*       same as the corresponding arguments in SUBROUTINE BOBYQA. *     The arguments XBASE, XPT, FVAL, HQ, PQ, BMAT, ZMAT, NDIM, SL and SU *       are the same as the corresponding arguments in BOBYQB, the elements *       of SL and SU being set in BOBYQA. *     GOPT is usually the gradient of the quadratic model at XOPT+XBASE, but *       it is set by PRELIM to the gradient of the quadratic model at XBASE. *       If XOPT is nonzero, BOBYQB will change it to its usual value later. *     NF is maintaned as the number of calls of CALFUN so far. *     KOPT will be such that the least calculated value of F so far is at *       the point XPT(KOPT,.)+XBASE in the space of the variables. * * @param lowerBound Lower bounds. * @param upperBound Upper bounds.  <BUGS> final double objectiveValue = computeObjectiveValue(currentBest.toArray()); final double f = isMinimize ? objectiveValue : -objectiveValue; final int numEval = getEvaluations(); /* nfm + 1*/ fAtInterpolationPoints.setEntry(nfm, f); <BUGE>  if (numEval == 1) { fbeg = f; trustRegionCenterInterpolationPointIndex = 0; } else if (f < fAtInterpolationPoints.getEntry(trustRegionCenterInterpolationPointIndex)) { trustRegionCenterInterpolationPointIndex = nfm; }  /* Set the nonzero initial elements of BMAT and the quadratic model in the*/ /* cases when NF is at most 2*N+1. If NF exceeds N+1, then the positions*/ /* of the NF-th and (NF-N)-th interpolation points may be switched, in*/ /* order that the function value at the first of them contributes to the*/
*       same as the corresponding arguments in SUBROUTINE BOBYQA. *     The arguments XBASE, XPT, FVAL, HQ, PQ, BMAT, ZMAT, NDIM, SL and SU *       are the same as the corresponding arguments in BOBYQB, the elements *       of SL and SU being set in BOBYQA. *     GOPT is usually the gradient of the quadratic model at XOPT+XBASE, but *       it is set by PRELIM to the gradient of the quadratic model at XBASE. *       If XOPT is nonzero, BOBYQB will change it to its usual value later. *     NF is maintaned as the number of calls of CALFUN so far. *     KOPT will be such that the least calculated value of F so far is at *       the point XPT(KOPT,.)+XBASE in the space of the variables. * * @param lowerBound Lower bounds. * @param upperBound Upper bounds.  <BUGS> if (numEval == 1) { fbeg = f; trustRegionCenterInterpolationPointIndex = 0; } else if (f < fAtInterpolationPoints.getEntry(trustRegionCenterInterpolationPointIndex)) { <BUGE> trustRegionCenterInterpolationPointIndex = nfm; }  /* Set the nonzero initial elements of BMAT and the quadratic model in the*/ /* cases when NF is at most 2*N+1. If NF exceeds N+1, then the positions*/ /* of the NF-th and (NF-N)-th interpolation points may be switched, in*/ /* order that the function value at the first of them contributes to the*/ /* off-diagonal second derivative terms of the initial quadratic model.*/  if (numEval <= 2 * n + 1) { if (numEval >= 2 && numEval <= n + 1) {
*     The arguments N, NPT, X, XL, XU, RHOBEG, IPRINT and MAXFUN are the *       same as the corresponding arguments in SUBROUTINE BOBYQA. *     The arguments XBASE, XPT, FVAL, HQ, PQ, BMAT, ZMAT, NDIM, SL and SU *       are the same as the corresponding arguments in BOBYQB, the elements *       of SL and SU being set in BOBYQA. *     GOPT is usually the gradient of the quadratic model at XOPT+XBASE, but *       it is set by PRELIM to the gradient of the quadratic model at XBASE. *       If XOPT is nonzero, BOBYQB will change it to its usual value later. *     NF is maintaned as the number of calls of CALFUN so far. *     KOPT will be such that the least calculated value of F so far is at *       the point XPT(KOPT,.)+XBASE in the space of the variables. * * @param lowerBound Lower bounds. * @param upperBound Upper bounds.  <BUGS> if (numEval <= 2 * n + 1) { if (numEval >= 2 && <BUGE> numEval <= n + 1) { gradientAtTrustRegionCenter.setEntry(nfmm, (f - fbeg) / stepa); if (npt < numEval + n) { final double oneOverStepA = ONE / stepa; bMatrix.setEntry(0, nfmm, -oneOverStepA); bMatrix.setEntry(nfm, nfmm, oneOverStepA); bMatrix.setEntry(npt + nfmm, nfmm, -HALF * rhosq); throw new PathIsExploredException(); /* XXX*/ } } else if (numEval >= n + 2) { final int ih = nfx * (nfx + 1) / 2 - 1; final double tmp = (f - fbeg) / stepb; final double diff = stepb - stepa;
*     The arguments N, NPT, X, XL, XU, RHOBEG, IPRINT and MAXFUN are the *       same as the corresponding arguments in SUBROUTINE BOBYQA. *     The arguments XBASE, XPT, FVAL, HQ, PQ, BMAT, ZMAT, NDIM, SL and SU *       are the same as the corresponding arguments in BOBYQB, the elements *       of SL and SU being set in BOBYQA. *     GOPT is usually the gradient of the quadratic model at XOPT+XBASE, but *       it is set by PRELIM to the gradient of the quadratic model at XBASE. *       If XOPT is nonzero, BOBYQB will change it to its usual value later. *     NF is maintaned as the number of calls of CALFUN so far. *     KOPT will be such that the least calculated value of F so far is at *       the point XPT(KOPT,.)+XBASE in the space of the variables. * * @param lowerBound Lower bounds. * @param upperBound Upper bounds. numEval <= n + 1) { <BUGS> gradientAtTrustRegionCenter.setEntry(nfmm, (f - fbeg) / stepa); if (npt < numEval + n) { <BUGE> final double oneOverStepA = ONE / stepa; bMatrix.setEntry(0, nfmm, -oneOverStepA); bMatrix.setEntry(nfm, nfmm, oneOverStepA); bMatrix.setEntry(npt + nfmm, nfmm, -HALF * rhosq); throw new PathIsExploredException(); /* XXX*/ } } else if (numEval >= n + 2) { final int ih = nfx * (nfx + 1) / 2 - 1; final double tmp = (f - fbeg) / stepb; final double diff = stepb - stepa; modelSecondDerivativesValues.setEntry(ih, TWO * (tmp - gradientAtTrustRegionCenter.getEntry(nfxm)) / diff); gradientAtTrustRegionCenter.setEntry(nfxm, (gradientAtTrustRegionCenter.getEntry(nfxm) * stepb - tmp * stepa) / diff); if (stepa * stepb < ZERO) {
*     GOPT is usually the gradient of the quadratic model at XOPT+XBASE, but *       it is set by PRELIM to the gradient of the quadratic model at XBASE. *       If XOPT is nonzero, BOBYQB will change it to its usual value later. *     NF is maintaned as the number of calls of CALFUN so far. *     KOPT will be such that the least calculated value of F so far is at *       the point XPT(KOPT,.)+XBASE in the space of the variables. * * @param lowerBound Lower bounds. * @param upperBound Upper bounds. } <BUGS> } else if (numEval >= n + 2) { final int ih = nfx * (nfx + 1) / 2 - 1; final double tmp = (f - fbeg) / stepb; final double diff = stepb - stepa; modelSecondDerivativesValues.setEntry(ih, TWO * (tmp - gradientAtTrustRegionCenter.getEntry(nfxm)) / diff); gradientAtTrustRegionCenter.setEntry(nfxm, (gradientAtTrustRegionCenter.getEntry(nfxm) * stepb - tmp * stepa) / diff); if (stepa * stepb < ZERO) { if (f < fAtInterpolationPoints.getEntry(nfm - n)) { fAtInterpolationPoints.setEntry(nfm, fAtInterpolationPoints.getEntry(nfm - n)); fAtInterpolationPoints.setEntry(nfm - n, f); if (trustRegionCenterInterpolationPointIndex == nfm) { <BUGE> trustRegionCenterInterpolationPointIndex = nfm - n; } interpolationPoints.setEntry(nfm - n, nfxm, stepb); interpolationPoints.setEntry(nfm, nfxm, stepa); } } bMatrix.setEntry(0, nfxm, -(stepa + stepb) / (stepa * stepb)); bMatrix.setEntry(nfm, nfxm, -HALF / interpolationPoints.getEntry(nfm - n, nfxm)); bMatrix.setEntry(nfm - n, nfxm,
*     The arguments N, NPT, X, XL, XU, RHOBEG, IPRINT and MAXFUN are the *       same as the corresponding arguments in SUBROUTINE BOBYQA. *     The arguments XBASE, XPT, FVAL, HQ, PQ, BMAT, ZMAT, NDIM, SL and SU *       are the same as the corresponding arguments in BOBYQB, the elements *       of SL and SU being set in BOBYQA. *     GOPT is usually the gradient of the quadratic model at XOPT+XBASE, but *       it is set by PRELIM to the gradient of the quadratic model at XBASE. *       If XOPT is nonzero, BOBYQB will change it to its usual value later. *     NF is maintaned as the number of calls of CALFUN so far. *     KOPT will be such that the least calculated value of F so far is at *       the point XPT(KOPT,.)+XBASE in the space of the variables. * * @param lowerBound Lower bounds. * @param upperBound Upper bounds. } <BUGS> interpolationPoints.setEntry(nfm - n, nfxm, stepb); interpolationPoints.setEntry(nfm, nfxm, stepa); <BUGE> } } bMatrix.setEntry(0, nfxm, -(stepa + stepb) / (stepa * stepb)); bMatrix.setEntry(nfm, nfxm, -HALF / interpolationPoints.getEntry(nfm - n, nfxm)); bMatrix.setEntry(nfm - n, nfxm, -bMatrix.getEntry(0, nfxm) - bMatrix.getEntry(nfm, nfxm)); zMatrix.setEntry(0, nfxm, Math.sqrt(TWO) / (stepa * stepb)); zMatrix.setEntry(nfm, nfxm, Math.sqrt(HALF) / rhosq); // zMatrix.setEntry(nfm, nfxm, Math.sqrt(HALF) * recip); /* XXX "testAckley" and "testDiffPow" fail.*/ zMatrix.setEntry(nfm - n, nfxm, -zMatrix.getEntry(0, nfxm) - zMatrix.getEntry(nfm, nfxm)); }
*       same as the corresponding arguments in SUBROUTINE BOBYQA. *     The arguments XBASE, XPT, FVAL, HQ, PQ, BMAT, ZMAT, NDIM, SL and SU *       are the same as the corresponding arguments in BOBYQB, the elements *       of SL and SU being set in BOBYQA. *     GOPT is usually the gradient of the quadratic model at XOPT+XBASE, but *       it is set by PRELIM to the gradient of the quadratic model at XBASE. *       If XOPT is nonzero, BOBYQB will change it to its usual value later. *     NF is maintaned as the number of calls of CALFUN so far. *     KOPT will be such that the least calculated value of F so far is at *       the point XPT(KOPT,.)+XBASE in the space of the variables. * * @param lowerBound Lower bounds. * @param upperBound Upper bounds. } <BUGS> bMatrix.setEntry(0, nfxm, -(stepa + stepb) / (stepa * stepb)); bMatrix.setEntry(nfm, nfxm, -HALF / interpolationPoints.getEntry(nfm - n, nfxm)); bMatrix.setEntry(nfm - n, nfxm, <BUGE> -bMatrix.getEntry(0, nfxm) - bMatrix.getEntry(nfm, nfxm)); zMatrix.setEntry(0, nfxm, Math.sqrt(TWO) / (stepa * stepb)); zMatrix.setEntry(nfm, nfxm, Math.sqrt(HALF) / rhosq); // zMatrix.setEntry(nfm, nfxm, Math.sqrt(HALF) * recip); /* XXX "testAckley" and "testDiffPow" fail.*/ zMatrix.setEntry(nfm - n, nfxm, -zMatrix.getEntry(0, nfxm) - zMatrix.getEntry(nfm, nfxm)); }  /* Set the off-diagonal second derivatives of the Lagrange functions and*/ /* the initial quadratic model.*/  } else { zMatrix.setEntry(0, nfxm, recip);
*     The arguments N, NPT, X, XL, XU, RHOBEG, IPRINT and MAXFUN are the *       same as the corresponding arguments in SUBROUTINE BOBYQA. *     The arguments XBASE, XPT, FVAL, HQ, PQ, BMAT, ZMAT, NDIM, SL and SU *       are the same as the corresponding arguments in BOBYQB, the elements *       of SL and SU being set in BOBYQA. *     GOPT is usually the gradient of the quadratic model at XOPT+XBASE, but *       it is set by PRELIM to the gradient of the quadratic model at XBASE. *       If XOPT is nonzero, BOBYQB will change it to its usual value later. *     NF is maintaned as the number of calls of CALFUN so far. *     KOPT will be such that the least calculated value of F so far is at *       the point XPT(KOPT,.)+XBASE in the space of the variables. * * @param lowerBound Lower bounds. * @param upperBound Upper bounds. -bMatrix.getEntry(0, nfxm) - bMatrix.getEntry(nfm, nfxm)); <BUGS> zMatrix.setEntry(0, nfxm, Math.sqrt(TWO) / (stepa * stepb)); zMatrix.setEntry(nfm, nfxm, Math.sqrt(HALF) / rhosq); <BUGE> // zMatrix.setEntry(nfm, nfxm, Math.sqrt(HALF) * recip); /* XXX "testAckley" and "testDiffPow" fail.*/ zMatrix.setEntry(nfm - n, nfxm, -zMatrix.getEntry(0, nfxm) - zMatrix.getEntry(nfm, nfxm)); }  /* Set the off-diagonal second derivatives of the Lagrange functions and*/ /* the initial quadratic model.*/  } else { zMatrix.setEntry(0, nfxm, recip); zMatrix.setEntry(nfm, nfxm, recip); zMatrix.setEntry(ipt, nfxm, -recip); zMatrix.setEntry(jpt, nfxm, -recip);
*     The arguments N, NPT, X, XL, XU, RHOBEG, IPRINT and MAXFUN are the *       same as the corresponding arguments in SUBROUTINE BOBYQA. *     The arguments XBASE, XPT, FVAL, HQ, PQ, BMAT, ZMAT, NDIM, SL and SU *       are the same as the corresponding arguments in BOBYQB, the elements *       of SL and SU being set in BOBYQA. *     GOPT is usually the gradient of the quadratic model at XOPT+XBASE, but *       it is set by PRELIM to the gradient of the quadratic model at XBASE. *       If XOPT is nonzero, BOBYQB will change it to its usual value later. *     NF is maintaned as the number of calls of CALFUN so far. *     KOPT will be such that the least calculated value of F so far is at *       the point XPT(KOPT,.)+XBASE in the space of the variables. * * @param lowerBound Lower bounds. * @param upperBound Upper bounds. // zMatrix.setEntry(nfm, nfxm, Math.sqrt(HALF) * recip); /* XXX "testAckley" and "testDiffPow" fail.*/ <BUGS> zMatrix.setEntry(nfm - n, nfxm, <BUGE> -zMatrix.getEntry(0, nfxm) - zMatrix.getEntry(nfm, nfxm)); }  /* Set the off-diagonal second derivatives of the Lagrange functions and*/ /* the initial quadratic model.*/  } else { zMatrix.setEntry(0, nfxm, recip); zMatrix.setEntry(nfm, nfxm, recip); zMatrix.setEntry(ipt, nfxm, -recip); zMatrix.setEntry(jpt, nfxm, -recip);  final int ih = ipt * (ipt - 1) / 2 + jpt - 1; final double tmp = interpolationPoints.getEntry(nfm, ipt - 1) * interpolationPoints.getEntry(nfm, jpt - 1);
*     The arguments N, NPT, X, XL, XU, RHOBEG, IPRINT and MAXFUN are the *       same as the corresponding arguments in SUBROUTINE BOBYQA. *     The arguments XBASE, XPT, FVAL, HQ, PQ, BMAT, ZMAT, NDIM, SL and SU *       are the same as the corresponding arguments in BOBYQB, the elements *       of SL and SU being set in BOBYQA. *     GOPT is usually the gradient of the quadratic model at XOPT+XBASE, but *       it is set by PRELIM to the gradient of the quadratic model at XBASE. *       If XOPT is nonzero, BOBYQB will change it to its usual value later. *     NF is maintaned as the number of calls of CALFUN so far. *     KOPT will be such that the least calculated value of F so far is at *       the point XPT(KOPT,.)+XBASE in the space of the variables. * * @param lowerBound Lower bounds. * @param upperBound Upper bounds. -zMatrix.getEntry(0, nfxm) - zMatrix.getEntry(nfm, nfxm)); <BUGS> } <BUGE>  /* Set the off-diagonal second derivatives of the Lagrange functions and*/ /* the initial quadratic model.*/  } else { zMatrix.setEntry(0, nfxm, recip); zMatrix.setEntry(nfm, nfxm, recip); zMatrix.setEntry(ipt, nfxm, -recip); zMatrix.setEntry(jpt, nfxm, -recip);  final int ih = ipt * (ipt - 1) / 2 + jpt - 1; final double tmp = interpolationPoints.getEntry(nfm, ipt - 1) * interpolationPoints.getEntry(nfm, jpt - 1); modelSecondDerivativesValues.setEntry(ih, (fbeg - fAtInterpolationPoints.getEntry(ipt) - fAtInterpolationPoints.getEntry(jpt) + f) / tmp); throw new PathIsExploredException(); /* XXX*/
*       same as the corresponding arguments in SUBROUTINE BOBYQA. *     The arguments XBASE, XPT, FVAL, HQ, PQ, BMAT, ZMAT, NDIM, SL and SU *       are the same as the corresponding arguments in BOBYQB, the elements *       of SL and SU being set in BOBYQA. *     GOPT is usually the gradient of the quadratic model at XOPT+XBASE, but *       it is set by PRELIM to the gradient of the quadratic model at XBASE. *       If XOPT is nonzero, BOBYQB will change it to its usual value later. *     NF is maintaned as the number of calls of CALFUN so far. *     KOPT will be such that the least calculated value of F so far is at *       the point XPT(KOPT,.)+XBASE in the space of the variables. * * @param lowerBound Lower bounds. * @param upperBound Upper bounds. } else { <BUGS> zMatrix.setEntry(0, nfxm, recip); zMatrix.setEntry(nfm, nfxm, recip); zMatrix.setEntry(ipt, nfxm, -recip); zMatrix.setEntry(jpt, nfxm, -recip); <BUGE>  final int ih = ipt * (ipt - 1) / 2 + jpt - 1; final double tmp = interpolationPoints.getEntry(nfm, ipt - 1) * interpolationPoints.getEntry(nfm, jpt - 1); modelSecondDerivativesValues.setEntry(ih, (fbeg - fAtInterpolationPoints.getEntry(ipt) - fAtInterpolationPoints.getEntry(jpt) + f) / tmp); throw new PathIsExploredException(); /* XXX*/ } } while (getEvaluations() < npt); } /* prelim*/   /* ----------------------------------------------------------------------------------------*/
*       same as the corresponding arguments in SUBROUTINE BOBYQA. *     The arguments XBASE, XPT, FVAL, HQ, PQ, BMAT, ZMAT, NDIM, SL and SU *       are the same as the corresponding arguments in BOBYQB, the elements *       of SL and SU being set in BOBYQA. *     GOPT is usually the gradient of the quadratic model at XOPT+XBASE, but *       it is set by PRELIM to the gradient of the quadratic model at XBASE. *       If XOPT is nonzero, BOBYQB will change it to its usual value later. *     NF is maintaned as the number of calls of CALFUN so far. *     KOPT will be such that the least calculated value of F so far is at *       the point XPT(KOPT,.)+XBASE in the space of the variables. * * @param lowerBound Lower bounds. * @param upperBound Upper bounds.  <BUGS> final int ih = ipt * (ipt - 1) / 2 + jpt - 1; final double tmp = interpolationPoints.getEntry(nfm, ipt - 1) * interpolationPoints.getEntry(nfm, jpt - 1); modelSecondDerivativesValues.setEntry(ih, (fbeg - fAtInterpolationPoints.getEntry(ipt) - fAtInterpolationPoints.getEntry(jpt) + f) / tmp); throw new PathIsExploredException(); /* XXX <BUGE>*/ } } while (getEvaluations() < npt); } /* prelim*/   /* ----------------------------------------------------------------------------------------*/  /** *     A version of the truncated conjugate gradient is applied. If a line *     search is restricted by a constraint, then the procedure is restarted, *     the values of the variables that are at their bounds being fixed. If *     the trust region boundary is reached, then further changes may be made
*     The arguments N, NPT, X, XL, XU, RHOBEG, IPRINT and MAXFUN are the *       same as the corresponding arguments in SUBROUTINE BOBYQA. *     The arguments XBASE, XPT, FVAL, HQ, PQ, BMAT, ZMAT, NDIM, SL and SU *       are the same as the corresponding arguments in BOBYQB, the elements *       of SL and SU being set in BOBYQA. *     GOPT is usually the gradient of the quadratic model at XOPT+XBASE, but *       it is set by PRELIM to the gradient of the quadratic model at XBASE. *       If XOPT is nonzero, BOBYQB will change it to its usual value later. *     NF is maintaned as the number of calls of CALFUN so far. *     KOPT will be such that the least calculated value of F so far is at *       the point XPT(KOPT,.)+XBASE in the space of the variables. * * @param lowerBound Lower bounds. * @param upperBound Upper bounds. } <BUGS> } while (getEvaluations() < npt); <BUGE> } /* prelim*/   /* ----------------------------------------------------------------------------------------*/  /** *     A version of the truncated conjugate gradient is applied. If a line *     search is restricted by a constraint, then the procedure is restarted, *     the values of the variables that are at their bounds being fixed. If *     the trust region boundary is reached, then further changes may be made *     to D, each one being in the two dimensional space that is spanned *     by the current D and the gradient of Q at XOPT+D, staying on the trust *     region boundary. Termination occurs when the reduction in Q seems to *     be close to the greatest reduction that can be achieved.
*/ public static double nextAfter(double d, double direction) {  /* handling of some important special cases*/ <BUGS> if (Double.isNaN(d) || Double.isNaN(direction)) { <BUGE> return Double.NaN; } else if (d == direction) { return direction; } else if (Double.isInfinite(d)) { return (d < 0) ? -Double.MAX_VALUE : Double.MAX_VALUE; } else if (d == 0) { return (direction < 0) ? -Double.MIN_VALUE : Double.MIN_VALUE; } /* special cases MAX_VALUE to infinity and  MIN_VALUE to 0*/ /* are handled just as normal numbers*/  final long bits = Double.doubleToLongBits(d); final long sign = bits & 0x8000000000000000L; if ((direction < d) ^ (sign == 0L)) { return Double.longBitsToDouble(sign | ((bits & 0x7fffffffffffffffL) + 1)); } else { return Double.longBitsToDouble(sign | ((bits & 0x7fffffffffffffffL) - 1)); }  }
*/ public static double nextAfter(double d, double direction) {  /* handling of some important special cases*/ if (Double.isNaN(d) || Double.isNaN(direction)) { return Double.NaN; <BUGS> } else if (d == direction) { <BUGE> return direction; } else if (Double.isInfinite(d)) { return (d < 0) ? -Double.MAX_VALUE : Double.MAX_VALUE; } else if (d == 0) { return (direction < 0) ? -Double.MIN_VALUE : Double.MIN_VALUE; } /* special cases MAX_VALUE to infinity and  MIN_VALUE to 0*/ /* are handled just as normal numbers*/  final long bits = Double.doubleToLongBits(d); final long sign = bits & 0x8000000000000000L; if ((direction < d) ^ (sign == 0L)) { return Double.longBitsToDouble(sign | ((bits & 0x7fffffffffffffffL) + 1)); } else { return Double.longBitsToDouble(sign | ((bits & 0x7fffffffffffffffL) - 1)); }  }
*/ public static double nextAfter(double d, double direction) {  /* handling of some important special cases*/ if (Double.isNaN(d) || Double.isNaN(direction)) { return Double.NaN; } else if (d == direction) { return direction; <BUGS> } else if (Double.isInfinite(d)) { <BUGE> return (d < 0) ? -Double.MAX_VALUE : Double.MAX_VALUE; } else if (d == 0) { return (direction < 0) ? -Double.MIN_VALUE : Double.MIN_VALUE; } /* special cases MAX_VALUE to infinity and  MIN_VALUE to 0*/ /* are handled just as normal numbers*/  final long bits = Double.doubleToLongBits(d); final long sign = bits & 0x8000000000000000L; if ((direction < d) ^ (sign == 0L)) { return Double.longBitsToDouble(sign | ((bits & 0x7fffffffffffffffL) + 1)); } else { return Double.longBitsToDouble(sign | ((bits & 0x7fffffffffffffffL) - 1)); }  }
*/ public static double nextAfter(double d, double direction) {  /* handling of some important special cases*/ if (Double.isNaN(d) || Double.isNaN(direction)) { return Double.NaN; } else if (d == direction) { return direction; } else if (Double.isInfinite(d)) { return (d < 0) ? -Double.MAX_VALUE : Double.MAX_VALUE; <BUGS> } else if (d == 0) { return (direction < 0) ? -Double.MIN_VALUE : Double.MIN_VALUE; <BUGE> } /* special cases MAX_VALUE to infinity and  MIN_VALUE to 0*/ /* are handled just as normal numbers*/  final long bits = Double.doubleToLongBits(d); final long sign = bits & 0x8000000000000000L; if ((direction < d) ^ (sign == 0L)) { return Double.longBitsToDouble(sign | ((bits & 0x7fffffffffffffffL) + 1)); } else { return Double.longBitsToDouble(sign | ((bits & 0x7fffffffffffffffL) - 1)); }  }
*/ public static double nextAfter(double d, double direction) {  /* handling of some important special cases*/ if (Double.isNaN(d) || Double.isNaN(direction)) { return Double.NaN; } else if (d == direction) { return direction; } else if (Double.isInfinite(d)) { return (d < 0) ? -Double.MAX_VALUE : Double.MAX_VALUE; } else if (d == 0) { return (direction < 0) ? -Double.MIN_VALUE : Double.MIN_VALUE; } /* special cases MAX_VALUE to infinity and  MIN_VALUE to 0*/ /* are handled just as normal numbers*/  <BUGS> final long bits = Double.doubleToLongBits(d); final long sign = bits & 0x8000000000000000L; if ((direction < d) ^ (sign == 0L)) { return Double.longBitsToDouble(sign | ((bits & 0x7fffffffffffffffL) + 1)); <BUGE> } else { return Double.longBitsToDouble(sign | ((bits & 0x7fffffffffffffffL) - 1)); }  }
*/ public void incrementCount() { <BUGS> if (++count > maximalCount) { maxCountCallback.trigger(maximalCount); <BUGE> } }
*/ public void incrementCount() { if (++count > maximalCount) { maxCountCallback.trigger(maximalCount); } <BUGS> } <BUGE>
*/ public double evaluate(final double[] values, final double[] weights) { <BUGS> return evaluate(values, weights, 0, values.length); <BUGE> }
*/ public double[] getPoint() { <BUGS> return (point == null) ? null : point.clone(); <BUGE> }
*/ private void checkEmpty() { <BUGS> if (n > 0) { <BUGE> throw new MathIllegalStateException( LocalizedFormats.VALUES_ADDED_BEFORE_CONFIGURING_STATISTIC, n); } }
*/ private void checkEmpty() { if (n > 0) { throw new MathIllegalStateException( LocalizedFormats.VALUES_ADDED_BEFORE_CONFIGURING_STATISTIC, n); } <BUGS> } <BUGE>
*/ public void setInitialStepSize(final double initialStepSize) { <BUGS> if ((initialStepSize < minStep) || (initialStepSize > maxStep)) { <BUGE> initialStep = -1.0; } else { initialStep = initialStepSize; } }
*/ public void setInitialStepSize(final double initialStepSize) { if ((initialStepSize < minStep) || (initialStepSize > maxStep)) { initialStep = -1.0; } else { <BUGS> initialStep = initialStepSize; <BUGE> } }
*/ public void setInitialStepSize(final double initialStepSize) { if ((initialStepSize < minStep) || (initialStepSize > maxStep)) { initialStep = -1.0; } else { initialStep = initialStepSize; } <BUGS> } <BUGE>
*/ public OpenMapRealMatrix(int rowDimension, int columnDimension) { <BUGS> super(rowDimension, columnDimension); this.rows = rowDimension; this.columns = columnDimension; this.entries = new OpenIntToDoubleHashMap(0.0); } <BUGE>
*/ public Complex divide(Complex divisor) throws NullArgumentException { <BUGS> MathUtils.checkNotNull(divisor); if (isNaN || divisor.isNaN) { <BUGE> return NaN; }  if (divisor.isZero) { // return isZero ? NaN : INF; /* See MATH-657*/ return isZero ? NaN : INF; }  if (divisor.isInfinite() && !isInfinite()) { return ZERO; }  final double c = divisor.getReal(); final double d = divisor.getImaginary();  if (FastMath.abs(c) < FastMath.abs(d)) { double q = c / d; double denominator = c * q + d; return createComplex((real * q + imaginary) / denominator, (imaginary * q - real) / denominator); } else { double q = d / c; double denominator = d * q + c; return createComplex((imaginary * q + real) / denominator, (imaginary - real * q) / denominator);
*/ public Complex divide(Complex divisor) throws NullArgumentException { MathUtils.checkNotNull(divisor); if (isNaN || divisor.isNaN) { return NaN; }  <BUGS> if (divisor.isZero) { <BUGE> // return isZero ? NaN : INF; /* See MATH-657*/ return isZero ? NaN : INF; }  if (divisor.isInfinite() && !isInfinite()) { return ZERO; }  final double c = divisor.getReal(); final double d = divisor.getImaginary();  if (FastMath.abs(c) < FastMath.abs(d)) { double q = c / d; double denominator = c * q + d; return createComplex((real * q + imaginary) / denominator, (imaginary * q - real) / denominator); } else { double q = d / c; double denominator = d * q + c; return createComplex((imaginary * q + real) / denominator, (imaginary - real * q) / denominator);
*/ public Complex divide(Complex divisor) throws NullArgumentException { MathUtils.checkNotNull(divisor); if (isNaN || divisor.isNaN) { return NaN; }  if (divisor.isZero) { // return isZero ? NaN : INF; /* See MATH-657*/ <BUGS> return isZero ? NaN : INF; <BUGE> }  if (divisor.isInfinite() && !isInfinite()) { return ZERO; }  final double c = divisor.getReal(); final double d = divisor.getImaginary();  if (FastMath.abs(c) < FastMath.abs(d)) { double q = c / d; double denominator = c * q + d; return createComplex((real * q + imaginary) / denominator, (imaginary * q - real) / denominator); } else { double q = d / c; double denominator = d * q + c; return createComplex((imaginary * q + real) / denominator, (imaginary - real * q) / denominator);
*/ public Complex divide(Complex divisor) throws NullArgumentException { MathUtils.checkNotNull(divisor); if (isNaN || divisor.isNaN) { return NaN; }  if (divisor.isZero) { // return isZero ? NaN : INF; /* See MATH-657*/ return isZero ? NaN : INF; }  <BUGS> if (divisor.isInfinite() && !isInfinite()) { <BUGE> return ZERO; }  final double c = divisor.getReal(); final double d = divisor.getImaginary();  if (FastMath.abs(c) < FastMath.abs(d)) { double q = c / d; double denominator = c * q + d; return createComplex((real * q + imaginary) / denominator, (imaginary * q - real) / denominator); } else { double q = d / c; double denominator = d * q + c; return createComplex((imaginary * q + real) / denominator, (imaginary - real * q) / denominator);
*/ public Complex divide(Complex divisor) throws NullArgumentException { MathUtils.checkNotNull(divisor); if (isNaN || divisor.isNaN) { return NaN; }  if (divisor.isZero) { // return isZero ? NaN : INF; /* See MATH-657*/ return isZero ? NaN : INF; }  if (divisor.isInfinite() && !isInfinite()) { return ZERO; }  <BUGS> final double c = divisor.getReal(); final double d = divisor.getImaginary(); <BUGE>  if (FastMath.abs(c) < FastMath.abs(d)) { double q = c / d; double denominator = c * q + d; return createComplex((real * q + imaginary) / denominator, (imaginary * q - real) / denominator); } else { double q = d / c; double denominator = d * q + c; return createComplex((imaginary * q + real) / denominator, (imaginary - real * q) / denominator);
*/ public Complex divide(Complex divisor) throws NullArgumentException { MathUtils.checkNotNull(divisor); if (isNaN || divisor.isNaN) { return NaN; }  if (divisor.isZero) { // return isZero ? NaN : INF; /* See MATH-657*/ return isZero ? NaN : INF; }  if (divisor.isInfinite() && !isInfinite()) { return ZERO; }  final double c = divisor.getReal(); final double d = divisor.getImaginary();  <BUGS> if (FastMath.abs(c) < FastMath.abs(d)) { <BUGE> double q = c / d; double denominator = c * q + d; return createComplex((real * q + imaginary) / denominator, (imaginary * q - real) / denominator); } else { double q = d / c; double denominator = d * q + c; return createComplex((imaginary * q + real) / denominator, (imaginary - real * q) / denominator);
*/ public Complex divide(Complex divisor) throws NullArgumentException { MathUtils.checkNotNull(divisor); if (isNaN || divisor.isNaN) { return NaN; }  if (divisor.isZero) { // return isZero ? NaN : INF; /* See MATH-657*/ return isZero ? NaN : INF; }  if (divisor.isInfinite() && !isInfinite()) { return ZERO; }  final double c = divisor.getReal(); final double d = divisor.getImaginary();  if (FastMath.abs(c) < FastMath.abs(d)) { double q = c / d; double denominator = c * q + d; return createComplex((real * q + imaginary) / denominator, (imaginary * q - real) / denominator); } else { <BUGS> double q = d / c; double denominator = d * q + c; return createComplex((imaginary * q + real) / denominator, <BUGE> (imaginary - real * q) / denominator);
@Override public String toString() { <BUGS> return "(" + real + ", " + imaginary + ")"; <BUGE> }
*/ protected void incrementEvaluationCount() { try { <BUGS> evaluations.incrementCount(); } catch (MaxCountExceededException e) { throw new TooManyEvaluationsException(e.getMax()); } } <BUGE>
*/ public boolean containsKey(final int key) {  <BUGS> final int hash  = hashOf(key); int index = hash & mask; if (containsKey(key, index)) { return true; <BUGE> }  if (states[index] == FREE) { return false; }  int j = index; for (int perturb = perturb(hash); states[index] != FREE; perturb >>= PERTURB_SHIFT) { j = probe(perturb, j); index = j & mask; if (containsKey(key, index)) { return true; } }  return false;  }
*/ public boolean containsKey(final int key) {  final int hash  = hashOf(key); int index = hash & mask; if (containsKey(key, index)) { return true; }  <BUGS> if (states[index] == FREE) { return false; <BUGE> }  int j = index; for (int perturb = perturb(hash); states[index] != FREE; perturb >>= PERTURB_SHIFT) { j = probe(perturb, j); index = j & mask; if (containsKey(key, index)) { return true; } }  return false;  }
/** {@inheritDoc} */
/** {@inheritDoc} */
/** {@inheritDoc} */
/** {@inheritDoc} */
/** {@inheritDoc} */
/** {@inheritDoc} */
/** {@inheritDoc} */
/** {@inheritDoc} */
/** {@inheritDoc} */
/** {@inheritDoc} */
/** {@inheritDoc} */
/** {@inheritDoc} */
/** {@inheritDoc} */
/** {@inheritDoc} */
/** {@inheritDoc} */
/** {@inheritDoc} */
/** {@inheritDoc} */
/** {@inheritDoc} */
*/ protected void incrementEvaluationCount() { try { <BUGS> evaluations.incrementCount(); } catch (MaxCountExceededException e) { throw new TooManyEvaluationsException(e.getMax()); } } <BUGE>
*/ <BUGS> public Rotation(Vector3D u1, Vector3D u2, Vector3D v1, Vector3D v2) { <BUGE>  /* norms computation*/ double u1u1 = u1.getNormSq(); double u2u2 = u2.getNormSq(); double v1v1 = v1.getNormSq(); double v2v2 = v2.getNormSq(); if ((u1u1 == 0) || (u2u2 == 0) || (v1v1 == 0) || (v2v2 == 0)) { throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.ZERO_NORM_FOR_ROTATION_DEFINING_VECTOR); }  /* normalize v1 in order to have (v1'|v1') = (u1|u1)*/ v1 = new Vector3D(FastMath.sqrt(u1u1 / v1v1), v1);  /* adjust v2 in order to have (u1|u2) = (v1'|v2') and (v2'|v2') = (u2|u2)*/ double u1u2   = u1.dotProduct(u2); double v1v2   = v1.dotProduct(v2); double coeffU = u1u2 / u1u1; double coeffV = v1v2 / u1u1; double beta   = FastMath.sqrt((u2u2 - u1u2 * coeffU) / (v2v2 - v1v2 * coeffV)); double alpha  = coeffU - beta * coeffV; v2 = new Vector3D(alpha, v1, beta, v2);  /* preliminary computation*/ Vector3D uRef  = u1; Vector3D vRef  = v1; Vector3D v1Su1 = v1.subtract(u1); Vector3D v2Su2 = v2.subtract(u2); Vector3D k     = v1Su1.crossProduct(v2Su2);
*/ public Rotation(Vector3D u1, Vector3D u2, Vector3D v1, Vector3D v2) {  /* norms computation*/ <BUGS> double u1u1 = u1.getNormSq(); double u2u2 = u2.getNormSq(); double v1v1 = v1.getNormSq(); double v2v2 = v2.getNormSq(); if ((u1u1 == 0) || (u2u2 == 0) || (v1v1 == 0) || (v2v2 == 0)) { <BUGE> throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.ZERO_NORM_FOR_ROTATION_DEFINING_VECTOR); }  /* normalize v1 in order to have (v1'|v1') = (u1|u1)*/ v1 = new Vector3D(FastMath.sqrt(u1u1 / v1v1), v1);  /* adjust v2 in order to have (u1|u2) = (v1'|v2') and (v2'|v2') = (u2|u2)*/ double u1u2   = u1.dotProduct(u2); double v1v2   = v1.dotProduct(v2); double coeffU = u1u2 / u1u1; double coeffV = v1v2 / u1u1; double beta   = FastMath.sqrt((u2u2 - u1u2 * coeffU) / (v2v2 - v1v2 * coeffV)); double alpha  = coeffU - beta * coeffV; v2 = new Vector3D(alpha, v1, beta, v2);  /* preliminary computation*/ Vector3D uRef  = u1; Vector3D vRef  = v1; Vector3D v1Su1 = v1.subtract(u1); Vector3D v2Su2 = v2.subtract(u2); Vector3D k     = v1Su1.crossProduct(v2Su2);
*/ public Rotation(Vector3D u1, Vector3D u2, Vector3D v1, Vector3D v2) {  /* norms computation*/ double u1u1 = u1.getNormSq(); double u2u2 = u2.getNormSq(); double v1v1 = v1.getNormSq(); double v2v2 = v2.getNormSq(); if ((u1u1 == 0) || (u2u2 == 0) || (v1v1 == 0) || (v2v2 == 0)) { throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.ZERO_NORM_FOR_ROTATION_DEFINING_VECTOR); }  /* normalize v1 in order to have (v1'|v1') = (u1|u1)*/ <BUGS> v1 = new Vector3D(FastMath.sqrt(u1u1 / v1v1), v1); <BUGE>  /* adjust v2 in order to have (u1|u2) = (v1'|v2') and (v2'|v2') = (u2|u2)*/ double u1u2   = u1.dotProduct(u2); double v1v2   = v1.dotProduct(v2); double coeffU = u1u2 / u1u1; double coeffV = v1v2 / u1u1; double beta   = FastMath.sqrt((u2u2 - u1u2 * coeffU) / (v2v2 - v1v2 * coeffV)); double alpha  = coeffU - beta * coeffV; v2 = new Vector3D(alpha, v1, beta, v2);  /* preliminary computation*/ Vector3D uRef  = u1; Vector3D vRef  = v1; Vector3D v1Su1 = v1.subtract(u1); Vector3D v2Su2 = v2.subtract(u2); Vector3D k     = v1Su1.crossProduct(v2Su2);
*/ public Rotation(Vector3D u1, Vector3D u2, Vector3D v1, Vector3D v2) {  /* norms computation*/ double u1u1 = u1.getNormSq(); double u2u2 = u2.getNormSq(); double v1v1 = v1.getNormSq(); double v2v2 = v2.getNormSq(); if ((u1u1 == 0) || (u2u2 == 0) || (v1v1 == 0) || (v2v2 == 0)) { throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.ZERO_NORM_FOR_ROTATION_DEFINING_VECTOR); }  /* normalize v1 in order to have (v1'|v1') = (u1|u1)*/ v1 = new Vector3D(FastMath.sqrt(u1u1 / v1v1), v1);  /* adjust v2 in order to have (u1|u2) = (v1'|v2') and (v2'|v2') = (u2|u2)*/ <BUGS> double u1u2   = u1.dotProduct(u2); double v1v2   = v1.dotProduct(v2); double coeffU = u1u2 / u1u1; double coeffV = v1v2 / u1u1; double beta   = FastMath.sqrt((u2u2 - u1u2 * coeffU) / (v2v2 - v1v2 * coeffV)); double alpha  = coeffU - beta * coeffV; v2 = new Vector3D(alpha, v1, beta, v2); <BUGE>  /* preliminary computation*/ Vector3D uRef  = u1; Vector3D vRef  = v1; Vector3D v1Su1 = v1.subtract(u1); Vector3D v2Su2 = v2.subtract(u2); Vector3D k     = v1Su1.crossProduct(v2Su2);
* <p>If the angular separation between u<sub>1</sub> and u<sub>2</sub> is * not the same as the angular separation between v<sub>1</sub> and * v<sub>2</sub>, then a corrected v'<sub>2</sub> will be used rather than * v<sub>2</sub>, the corrected vector will be in the (v<sub>1</sub>, * v<sub>2</sub>) plane.</p>  * @param u1 first vector of the origin pair * @param u2 second vector of the origin pair * @param v1 desired image of u1 by the rotation * @param v2 desired image of u2 by the rotation * @exception IllegalArgumentException if the norm of one of the vectors is zero /* preliminary computation*/ <BUGS> Vector3D uRef  = u1; Vector3D vRef  = v1; Vector3D v1Su1 = v1.subtract(u1); Vector3D v2Su2 = v2.subtract(u2); Vector3D k     = v1Su1.crossProduct(v2Su2); Vector3D u3    = u1.crossProduct(u2); double c       = k.dotProduct(u3); if (c == 0) { <BUGE> /* the (q1, q2, q3) vector is close to the (u1, u2) plane*/ /* we try other vectors*/ Vector3D v3 = Vector3D.crossProduct(v1, v2); Vector3D v3Su3 = v3.subtract(u3); k = v1Su1.crossProduct(v3Su3); Vector3D u2Prime = u1.crossProduct(u3); c = k.dotProduct(u2Prime);  if (c == 0) { /* the (q1, q2, q3) vector is also close to the (u1, u3) plane,*/
* <p>If the angular separation between u<sub>1</sub> and u<sub>2</sub> is * not the same as the angular separation between v<sub>1</sub> and * v<sub>2</sub>, then a corrected v'<sub>2</sub> will be used rather than * v<sub>2</sub>, the corrected vector will be in the (v<sub>1</sub>, * v<sub>2</sub>) plane.</p>  * @param u1 first vector of the origin pair * @param u2 second vector of the origin pair * @param v1 desired image of u1 by the rotation * @param v2 desired image of u2 by the rotation * @exception IllegalArgumentException if the norm of one of the vectors is zero /* compute the vectorial part*/ <BUGS> c = FastMath.sqrt(c); double inv = 1.0 / (c + c); q1 = inv * k.getX(); q2 = inv * k.getY(); q3 = inv * k.getZ(); <BUGE>  /* compute the scalar part*/ k = new Vector3D(uRef.getY() * q3 - uRef.getZ() * q2, uRef.getZ() * q1 - uRef.getX() * q3, uRef.getX() * q2 - uRef.getY() * q1); q0 = vRef.dotProduct(k) / (2 * k.getNormSq());  }  /** Build one of the rotations that transform one vector into another one.  * <p>Except for a possible scale factor, if the instance were
* the pair (u<sub>1</sub>, u<sub>2</sub>) it will produce the pair * (v<sub>1</sub>, v<sub>2</sub>).</p>  * <p>If the angular separation between u<sub>1</sub> and u<sub>2</sub> is * not the same as the angular separation between v<sub>1</sub> and * v<sub>2</sub>, then a corrected v'<sub>2</sub> will be used rather than * v<sub>2</sub>, the corrected vector will be in the (v<sub>1</sub>, * v<sub>2</sub>) plane.</p>  * @param u1 first vector of the origin pair * @param u2 second vector of the origin pair * @param v1 desired image of u1 by the rotation * @param v2 desired image of u2 by the rotation * @exception IllegalArgumentException if the norm of one of the vectors is zero /* compute the scalar part*/ <BUGS> k = new Vector3D(uRef.getY() * q3 - uRef.getZ() * q2, <BUGE> uRef.getZ() * q1 - uRef.getX() * q3, uRef.getX() * q2 - uRef.getY() * q1); q0 = vRef.dotProduct(k) / (2 * k.getNormSq());  }  /** Build one of the rotations that transform one vector into another one.  * <p>Except for a possible scale factor, if the instance were * applied to the vector u it will produce the vector v. There is an * infinite number of such rotations, this constructor choose the * one with the smallest associated angle (i.e. the one whose axis * is orthogonal to the (u, v) plane). If u and v are colinear, an * arbitrary rotation axis is chosen.</p>
* the pair (u<sub>1</sub>, u<sub>2</sub>) it will produce the pair * (v<sub>1</sub>, v<sub>2</sub>).</p>  * <p>If the angular separation between u<sub>1</sub> and u<sub>2</sub> is * not the same as the angular separation between v<sub>1</sub> and * v<sub>2</sub>, then a corrected v'<sub>2</sub> will be used rather than * v<sub>2</sub>, the corrected vector will be in the (v<sub>1</sub>, * v<sub>2</sub>) plane.</p>  * @param u1 first vector of the origin pair * @param u2 second vector of the origin pair * @param v1 desired image of u1 by the rotation * @param v2 desired image of u2 by the rotation * @exception IllegalArgumentException if the norm of one of the vectors is zero uRef.getX() * q2 - uRef.getY() * q1); <BUGS> q0 = vRef.dotProduct(k) / (2 * k.getNormSq()); <BUGE>  }  /** Build one of the rotations that transform one vector into another one.  * <p>Except for a possible scale factor, if the instance were * applied to the vector u it will produce the vector v. There is an * infinite number of such rotations, this constructor choose the * one with the smallest associated angle (i.e. the one whose axis * is orthogonal to the (u, v) plane). If u and v are colinear, an * arbitrary rotation axis is chosen.</p>  * @param u origin vector * @param v desired image of u by the rotation
* the pair (u<sub>1</sub>, u<sub>2</sub>) it will produce the pair * (v<sub>1</sub>, v<sub>2</sub>).</p>  * <p>If the angular separation between u<sub>1</sub> and u<sub>2</sub> is * not the same as the angular separation between v<sub>1</sub> and * v<sub>2</sub>, then a corrected v'<sub>2</sub> will be used rather than * v<sub>2</sub>, the corrected vector will be in the (v<sub>1</sub>, * v<sub>2</sub>) plane.</p>  * @param u1 first vector of the origin pair * @param u2 second vector of the origin pair * @param v1 desired image of u1 by the rotation * @param v2 desired image of u2 by the rotation * @exception IllegalArgumentException if the norm of one of the vectors is zero  <BUGS> } <BUGE>  /** Build one of the rotations that transform one vector into another one.  * <p>Except for a possible scale factor, if the instance were * applied to the vector u it will produce the vector v. There is an * infinite number of such rotations, this constructor choose the * one with the smallest associated angle (i.e. the one whose axis * is orthogonal to the (u, v) plane). If u and v are colinear, an * arbitrary rotation axis is chosen.</p>  * @param u origin vector * @param v desired image of u by the rotation * @exception IllegalArgumentException if the norm of one of the vectors is zero */
*/ public Complex add(Complex rhs) throws NullArgumentException { <BUGS> MathUtils.checkNotNull(rhs); return createComplex(real + rhs.getReal(), <BUGE> imaginary + rhs.getImaginary()); }
*/ protected String dfp2string() { <BUGS> char buffer[] = new char[mant.length*4 + 20]; int p = 1; <BUGE> int q; int e = exp; boolean pointInserted = false;  buffer[0] = ' ';  if (e <= 0) { buffer[p++] = '0'; buffer[p++] = '.'; pointInserted = true; }  while (e < 0) { buffer[p++] = '0'; buffer[p++] = '0'; buffer[p++] = '0'; buffer[p++] = '0'; e++; }  for (int i = mant.length - 1; i >= 0; i--) { buffer[p++] = (char) ((mant[i] / 1000) + '0'); buffer[p++] = (char) (((mant[i] / 100) % 10) + '0'); buffer[p++] = (char) (((mant[i] / 10) % 10) + '0'); buffer[p++] = (char) (((mant[i]) % 10) + '0'); if (--e == 0) {
*/ protected String dfp2string() { char buffer[] = new char[mant.length*4 + 20]; int p = 1; int q; <BUGS> int e = exp; boolean pointInserted = false; <BUGE>  buffer[0] = ' ';  if (e <= 0) { buffer[p++] = '0'; buffer[p++] = '.'; pointInserted = true; }  while (e < 0) { buffer[p++] = '0'; buffer[p++] = '0'; buffer[p++] = '0'; buffer[p++] = '0'; e++; }  for (int i = mant.length - 1; i >= 0; i--) { buffer[p++] = (char) ((mant[i] / 1000) + '0'); buffer[p++] = (char) (((mant[i] / 100) % 10) + '0'); buffer[p++] = (char) (((mant[i] / 10) % 10) + '0'); buffer[p++] = (char) (((mant[i]) % 10) + '0'); if (--e == 0) {
*/ protected String dfp2string() { char buffer[] = new char[mant.length*4 + 20]; int p = 1; int q; int e = exp; boolean pointInserted = false;  <BUGS> buffer[0] = ' '; <BUGE>  if (e <= 0) { buffer[p++] = '0'; buffer[p++] = '.'; pointInserted = true; }  while (e < 0) { buffer[p++] = '0'; buffer[p++] = '0'; buffer[p++] = '0'; buffer[p++] = '0'; e++; }  for (int i = mant.length - 1; i >= 0; i--) { buffer[p++] = (char) ((mant[i] / 1000) + '0'); buffer[p++] = (char) (((mant[i] / 100) % 10) + '0'); buffer[p++] = (char) (((mant[i] / 10) % 10) + '0'); buffer[p++] = (char) (((mant[i]) % 10) + '0'); if (--e == 0) {
*/ protected String dfp2string() { char buffer[] = new char[mant.length*4 + 20]; int p = 1; int q; int e = exp; boolean pointInserted = false;  buffer[0] = ' ';  <BUGS> if (e <= 0) { buffer[p++] = '0'; buffer[p++] = '.'; pointInserted = true; <BUGE> }  while (e < 0) { buffer[p++] = '0'; buffer[p++] = '0'; buffer[p++] = '0'; buffer[p++] = '0'; e++; }  for (int i = mant.length - 1; i >= 0; i--) { buffer[p++] = (char) ((mant[i] / 1000) + '0'); buffer[p++] = (char) (((mant[i] / 100) % 10) + '0'); buffer[p++] = (char) (((mant[i] / 10) % 10) + '0'); buffer[p++] = (char) (((mant[i]) % 10) + '0'); if (--e == 0) {
*/ protected String dfp2string() { char buffer[] = new char[mant.length*4 + 20]; int p = 1; int q; int e = exp; boolean pointInserted = false;  buffer[0] = ' ';  if (e <= 0) { buffer[p++] = '0'; buffer[p++] = '.'; pointInserted = true; }  <BUGS> while (e < 0) { <BUGE> buffer[p++] = '0'; buffer[p++] = '0'; buffer[p++] = '0'; buffer[p++] = '0'; e++; }  for (int i = mant.length - 1; i >= 0; i--) { buffer[p++] = (char) ((mant[i] / 1000) + '0'); buffer[p++] = (char) (((mant[i] / 100) % 10) + '0'); buffer[p++] = (char) (((mant[i] / 10) % 10) + '0'); buffer[p++] = (char) (((mant[i]) % 10) + '0'); if (--e == 0) {
outputbuffer[q++] = (char)(ae / p + '0'); ae = ae % p; p = p / 10; }  return new String(outputbuffer, 0, q);  }  /** Convert an instance to a string using normal notation. * @return string representation of the instance in normal notation  <BUGS> for (int i = mant.length - 1; i >= 0; i--) { buffer[p++] = (char) ((mant[i] / 1000) + '0'); buffer[p++] = (char) (((mant[i] / 100) % 10) + '0'); buffer[p++] = (char) (((mant[i] / 10) % 10) + '0'); buffer[p++] = (char) (((mant[i]) % 10) + '0'); if (--e == 0) { buffer[p++] = '.'; pointInserted = true; <BUGE> } }  while (e > 0) { buffer[p++] = '0'; buffer[p++] = '0'; buffer[p++] = '0'; buffer[p++] = '0'; e--; }
}  while (p > 0) { outputbuffer[q++] = (char)(ae / p + '0'); ae = ae % p; p = p / 10; }  return new String(outputbuffer, 0, q);  }  /** Convert an instance to a string using normal notation. * @return string representation of the instance in normal notation  <BUGS> while (e > 0) { <BUGE> buffer[p++] = '0'; buffer[p++] = '0'; buffer[p++] = '0'; buffer[p++] = '0'; e--; }  if (!pointInserted) { /* Ensure we have a radix point!*/ buffer[p++] = '.'; }  /* Suppress leading zeros*/ q = 1;
}  while (p > 0) { outputbuffer[q++] = (char)(ae / p + '0'); ae = ae % p; p = p / 10; }  return new String(outputbuffer, 0, q);  }  /** Convert an instance to a string using normal notation. * @return string representation of the instance in normal notation  <BUGS> if (!pointInserted) { <BUGE> /* Ensure we have a radix point!*/ buffer[p++] = '.'; }  /* Suppress leading zeros*/ q = 1; while (buffer[q] == '0') { q++; } if (buffer[q] == '.') { q--; }  /* Suppress trailing zeros*/
while (p > 0) { outputbuffer[q++] = (char)(ae / p + '0'); ae = ae % p; p = p / 10; }  return new String(outputbuffer, 0, q);  }  /** Convert an instance to a string using normal notation. * @return string representation of the instance in normal notation /* Suppress leading zeros*/ <BUGS> q = 1; while (buffer[q] == '0') { q++; <BUGE> } if (buffer[q] == '.') { q--; }  /* Suppress trailing zeros*/ while (buffer[p-1] == '0') { p--; }  /* Insert sign*/ if (sign < 0) { buffer[--q] = '-';
}  while (p > 0) { outputbuffer[q++] = (char)(ae / p + '0'); ae = ae % p; p = p / 10; }  return new String(outputbuffer, 0, q);  }  /** Convert an instance to a string using normal notation. * @return string representation of the instance in normal notation } <BUGS> if (buffer[q] == '.') { q--; <BUGE> }  /* Suppress trailing zeros*/ while (buffer[p-1] == '0') { p--; }  /* Insert sign*/ if (sign < 0) { buffer[--q] = '-'; }  return new String(buffer, q, p - q);
}  while (p > 0) { outputbuffer[q++] = (char)(ae / p + '0'); ae = ae % p; p = p / 10; }  return new String(outputbuffer, 0, q);  }  /** Convert an instance to a string using normal notation. * @return string representation of the instance in normal notation /* Suppress trailing zeros*/ <BUGS> while (buffer[p-1] == '0') { p--; <BUGE> }  /* Insert sign*/ if (sign < 0) { buffer[--q] = '-'; }  return new String(buffer, q, p - q);  }  /** Raises a trap.  This does not set the corresponding flag however. *  @param type the trap type
}  while (p > 0) { outputbuffer[q++] = (char)(ae / p + '0'); ae = ae % p; p = p / 10; }  return new String(outputbuffer, 0, q);  }  /** Convert an instance to a string using normal notation. * @return string representation of the instance in normal notation /* Insert sign*/ <BUGS> if (sign < 0) { buffer[--q] = '-'; <BUGE> }  return new String(buffer, q, p - q);  }  /** Raises a trap.  This does not set the corresponding flag however. *  @param type the trap type *  @param what - name of routine trap occurred in *  @param oper - input operator to function *  @param result - the result computed prior to the trap *  @return The suggested return value from the trap handler */
}  while (p > 0) { outputbuffer[q++] = (char)(ae / p + '0'); ae = ae % p; p = p / 10; }  return new String(outputbuffer, 0, q);  }  /** Convert an instance to a string using normal notation. * @return string representation of the instance in normal notation  <BUGS> return new String(buffer, q, p - q); <BUGE>  }  /** Raises a trap.  This does not set the corresponding flag however. *  @param type the trap type *  @param what - name of routine trap occurred in *  @param oper - input operator to function *  @param result - the result computed prior to the trap *  @return The suggested return value from the trap handler */ public Dfp dotrap(int type, String what, Dfp oper, Dfp result) { Dfp def = result;  switch (type) {
*/ public static Vector3D crossProduct(final Vector3D v1, final Vector3D v2) {   /* rescale both vectors without losing precision,*/ /* to ensure their norm are the same order of magnitude*/  /* we reduce cancellation errors by preconditioning,*/ /* we replace v1 by v3 = v1 - rho v2 with rho chosen in order to compute*/ /* v3 without loss of precision. See Kahan lecture*/ /* "Computing Cross-Products and Rotations in 2- and 3-Dimensional Euclidean Spaces"*/ // available at http:/*www.cs.berkeley.edu/~wkahan/MathH110/Cross.pdf*/  /* compute rho as an 8 bits approximation of v1.v2 / v2.v2*/   /* compute cross product from v3 and v2 instead of v1 and v2*/ <BUGS> return new Vector3D(v1.y * v2.z - v1.z * v2.y, v1.z * v2.x - v1.x * v2.z, v1.x * v2.y - v1.y * v2.x); <BUGE>  }
*/ public int[] getCounts(int index) { <BUGS> if (index < 0 || <BUGE> index >= totalSize) { throw new OutOfRangeException(index, 0, totalSize); }  final int[] indices = new int[dimension];  int count = 0; for (int i = 0; i < last; i++) { int idx = 0; final int offset = uniCounterOffset[i]; while (count <= index) { count += offset; ++idx; } --idx; count -= offset; indices[i] = idx; }  int idx = 1; while (count < index) { count += idx; ++idx; } --idx; indices[last] = idx;
*/ public int[] getCounts(int index) { if (index < 0 || index >= totalSize) { throw new OutOfRangeException(index, 0, totalSize); }  <BUGS> final int[] indices = new int[dimension]; <BUGE>  int count = 0; for (int i = 0; i < last; i++) { int idx = 0; final int offset = uniCounterOffset[i]; while (count <= index) { count += offset; ++idx; } --idx; count -= offset; indices[i] = idx; }  int idx = 1; while (count < index) { count += idx; ++idx; } --idx; indices[last] = idx;
*/ public int[] getCounts(int index) { if (index < 0 || index >= totalSize) { throw new OutOfRangeException(index, 0, totalSize); }  final int[] indices = new int[dimension];  <BUGS> int count = 0; for (int i = 0; i < last; i++) { int idx = 0; final int offset = uniCounterOffset[i]; while (count <= index) { count += offset; ++idx; <BUGE> } --idx; count -= offset; indices[i] = idx; }  int idx = 1; while (count < index) { count += idx; ++idx; } --idx; indices[last] = idx;
*/ public int[] getCounts(int index) { if (index < 0 || index >= totalSize) { throw new OutOfRangeException(index, 0, totalSize); }  final int[] indices = new int[dimension];  int count = 0; for (int i = 0; i < last; i++) { int idx = 0; final int offset = uniCounterOffset[i]; while (count <= index) { count += offset; ++idx; } <BUGS> --idx; count -= offset; indices[i] = idx; <BUGE> }  int idx = 1; while (count < index) { count += idx; ++idx; } --idx; indices[last] = idx;
*/ public int[] getCounts(int index) { if (index < 0 || index >= totalSize) { throw new OutOfRangeException(index, 0, totalSize); }  final int[] indices = new int[dimension];  int count = 0; for (int i = 0; i < last; i++) { int idx = 0; final int offset = uniCounterOffset[i]; while (count <= index) { count += offset; ++idx; } --idx; count -= offset; indices[i] = idx; }  <BUGS> int idx = 1; while (count < index) { count += idx; ++idx; <BUGE> } --idx; indices[last] = idx;
*/ public int[] getCounts(int index) { if (index < 0 || index >= totalSize) { throw new OutOfRangeException(index, 0, totalSize); }  final int[] indices = new int[dimension];  int count = 0; for (int i = 0; i < last; i++) { int idx = 0; final int offset = uniCounterOffset[i]; while (count <= index) { count += offset; ++idx; } --idx; count -= offset; indices[i] = idx; }  int idx = 1; while (count < index) { count += idx; ++idx; } <BUGS> --idx; indices[last] = idx; <BUGE>
*/ public int[] getCounts(int index) { if (index < 0 || index >= totalSize) { throw new OutOfRangeException(index, 0, totalSize); }  final int[] indices = new int[dimension];  int count = 0; for (int i = 0; i < last; i++) { int idx = 0; final int offset = uniCounterOffset[i]; while (count <= index) { count += offset; ++idx; } --idx; count -= offset; indices[i] = idx; }  int idx = 1; while (count < index) { count += idx; ++idx; } --idx; indices[last] = idx;
*/ public KMeansPlusPlusClusterer(final Random random) { <BUGS> this(random, EmptyClusterStrategy.LARGEST_VARIANCE); } <BUGE>
@Override protected VectorialPointValuePair doOptimize() throws MathUserException { /* arrays shared with the other private methods*/ <BUGS> solvedCols  = FastMath.min(rows, cols); diagR       = new double[cols]; jacNorm     = new double[cols]; beta        = new double[cols]; permutation = new int[cols]; lmDir       = new double[cols]; <BUGE>  /* local point*/ double   delta   = 0; double   xNorm   = 0; double[] diag    = new double[cols]; double[] oldX    = new double[cols]; double[] oldRes  = new double[rows]; double[] oldObj  = new double[rows]; double[] qtf     = new double[rows]; double[] work1   = new double[cols]; double[] work2   = new double[cols]; double[] work3   = new double[cols];  /* evaluate the function at the starting point and calculate its norm*/ updateResidualsAndCost();  /* outer loop*/ lmPar = 0; boolean firstIteration = true; VectorialPointValuePair current = new VectorialPointValuePair(point, objective); int iter = 0;
@Override protected VectorialPointValuePair doOptimize() throws MathUserException { /* arrays shared with the other private methods*/ solvedCols  = FastMath.min(rows, cols); diagR       = new double[cols]; jacNorm     = new double[cols]; beta        = new double[cols]; permutation = new int[cols]; lmDir       = new double[cols];  /* local point*/ <BUGS> double   delta   = 0; double   xNorm   = 0; double[] diag    = new double[cols]; double[] oldX    = new double[cols]; double[] oldRes  = new double[rows]; double[] oldObj  = new double[rows]; double[] qtf     = new double[rows]; double[] work1   = new double[cols]; double[] work2   = new double[cols]; double[] work3   = new double[cols]; <BUGE>  /* evaluate the function at the starting point and calculate its norm*/ updateResidualsAndCost();  /* outer loop*/ lmPar = 0; boolean firstIteration = true; VectorialPointValuePair current = new VectorialPointValuePair(point, objective); int iter = 0;
@Override protected VectorialPointValuePair doOptimize() throws MathUserException { /* arrays shared with the other private methods*/ solvedCols  = FastMath.min(rows, cols); diagR       = new double[cols]; jacNorm     = new double[cols]; beta        = new double[cols]; permutation = new int[cols]; lmDir       = new double[cols];  /* local point*/ double   delta   = 0; double   xNorm   = 0; double[] diag    = new double[cols]; double[] oldX    = new double[cols]; double[] oldRes  = new double[rows]; double[] oldObj  = new double[rows]; double[] qtf     = new double[rows]; double[] work1   = new double[cols]; double[] work2   = new double[cols]; double[] work3   = new double[cols];  /* evaluate the function at the starting point and calculate its norm*/ <BUGS> updateResidualsAndCost(); <BUGE>  /* outer loop*/ lmPar = 0; boolean firstIteration = true; VectorialPointValuePair current = new VectorialPointValuePair(point, objective); int iter = 0;
@Override protected VectorialPointValuePair doOptimize() throws MathUserException { /* arrays shared with the other private methods*/ solvedCols  = FastMath.min(rows, cols); diagR       = new double[cols]; jacNorm     = new double[cols]; beta        = new double[cols]; permutation = new int[cols]; lmDir       = new double[cols];  /* local point*/ double   delta   = 0; double   xNorm   = 0; double[] diag    = new double[cols]; double[] oldX    = new double[cols]; double[] oldRes  = new double[rows]; double[] oldObj  = new double[rows]; double[] qtf     = new double[rows]; double[] work1   = new double[cols]; double[] work2   = new double[cols]; double[] work3   = new double[cols];  /* evaluate the function at the starting point and calculate its norm*/ updateResidualsAndCost();  /* outer loop*/ <BUGS> lmPar = 0; boolean firstIteration = true; VectorialPointValuePair current = new VectorialPointValuePair(point, objective); int iter = 0;
*/ public LevenbergMarquardtOptimizer(double initialStepBoundFactor, double costRelativeTolerance, double parRelativeTolerance, double orthoTolerance, double threshold) { this.initialStepBoundFactor = initialStepBoundFactor; this.costRelativeTolerance = costRelativeTolerance; this.parRelativeTolerance = parRelativeTolerance; this.orthoTolerance = orthoTolerance; this.qrRankingThreshold = threshold; }  /** {@inheritDoc} */ while (true) { <BUGS> ++iter; <BUGE>  for (int i=0;i<rows;i++) { qtf[i]=weightedResiduals[i]; }  /* compute the Q.R. decomposition of the jacobian matrix*/ VectorialPointValuePair previous = current; updateJacobian(); qrDecomposition();  /* compute Qt.res*/ qTy(qtf); /* now we don't need Q anymore,*/ /* so let jacobian contain the R matrix with its diagonal elements*/
*/ public LevenbergMarquardtOptimizer(double initialStepBoundFactor, double costRelativeTolerance, double parRelativeTolerance, double orthoTolerance, double threshold) { this.initialStepBoundFactor = initialStepBoundFactor; this.costRelativeTolerance = costRelativeTolerance; this.parRelativeTolerance = parRelativeTolerance; this.orthoTolerance = orthoTolerance; this.qrRankingThreshold = threshold; }  /** {@inheritDoc} */  <BUGS> for (int i=0;i<rows;i++) { qtf[i]=weightedResiduals[i]; <BUGE> }  /* compute the Q.R. decomposition of the jacobian matrix*/ VectorialPointValuePair previous = current; updateJacobian(); qrDecomposition();  /* compute Qt.res*/ qTy(qtf); /* now we don't need Q anymore,*/ /* so let jacobian contain the R matrix with its diagonal elements*/ for (int k = 0; k < solvedCols; ++k) { int pk = permutation[k];
public LevenbergMarquardtOptimizer(double initialStepBoundFactor, double costRelativeTolerance, double parRelativeTolerance, double orthoTolerance, double threshold) { this.initialStepBoundFactor = initialStepBoundFactor; this.costRelativeTolerance = costRelativeTolerance; this.parRelativeTolerance = parRelativeTolerance; this.orthoTolerance = orthoTolerance; this.qrRankingThreshold = threshold; }  /** {@inheritDoc} */ /* compute the Q.R. decomposition of the jacobian matrix*/ <BUGS> VectorialPointValuePair previous = current; updateJacobian(); qrDecomposition(); <BUGE>  /* compute Qt.res*/ qTy(qtf); /* now we don't need Q anymore,*/ /* so let jacobian contain the R matrix with its diagonal elements*/ for (int k = 0; k < solvedCols; ++k) { int pk = permutation[k]; weightedResidualJacobian[k][pk] = diagR[pk]; }  if (firstIteration) { /* scale the point according to the norms of the columns*/ /* of the initial jacobian*/
*/ public LevenbergMarquardtOptimizer(double initialStepBoundFactor, double costRelativeTolerance, double parRelativeTolerance, double orthoTolerance, double threshold) { this.initialStepBoundFactor = initialStepBoundFactor; this.costRelativeTolerance = costRelativeTolerance; this.parRelativeTolerance = parRelativeTolerance; this.orthoTolerance = orthoTolerance; this.qrRankingThreshold = threshold; }  /** {@inheritDoc} */ /* compute Qt.res*/ <BUGS> qTy(qtf); <BUGE> /* now we don't need Q anymore,*/ /* so let jacobian contain the R matrix with its diagonal elements*/ for (int k = 0; k < solvedCols; ++k) { int pk = permutation[k]; weightedResidualJacobian[k][pk] = diagR[pk]; }  if (firstIteration) { /* scale the point according to the norms of the columns*/ /* of the initial jacobian*/ xNorm = 0; for (int k = 0; k < cols; ++k) { double dk = jacNorm[k]; if (dk == 0) {
public LevenbergMarquardtOptimizer(double initialStepBoundFactor, double costRelativeTolerance, double parRelativeTolerance, double orthoTolerance, double threshold) { this.initialStepBoundFactor = initialStepBoundFactor; this.costRelativeTolerance = costRelativeTolerance; this.parRelativeTolerance = parRelativeTolerance; this.orthoTolerance = orthoTolerance; this.qrRankingThreshold = threshold; }  /** {@inheritDoc} */ /* so let jacobian contain the R matrix with its diagonal elements*/ <BUGS> for (int k = 0; k < solvedCols; ++k) { int pk = permutation[k]; weightedResidualJacobian[k][pk] = diagR[pk]; <BUGE> }  if (firstIteration) { /* scale the point according to the norms of the columns*/ /* of the initial jacobian*/ xNorm = 0; for (int k = 0; k < cols; ++k) { double dk = jacNorm[k]; if (dk == 0) { dk = 1.0; } double xk = dk * point[k]; xNorm  += xk * xk;
*/ public LevenbergMarquardtOptimizer(double initialStepBoundFactor, double costRelativeTolerance, double parRelativeTolerance, double orthoTolerance, double threshold) { this.initialStepBoundFactor = initialStepBoundFactor; this.costRelativeTolerance = costRelativeTolerance; this.parRelativeTolerance = parRelativeTolerance; this.orthoTolerance = orthoTolerance; this.qrRankingThreshold = threshold; }  /** {@inheritDoc} */  <BUGS> if (firstIteration) { <BUGE> /* scale the point according to the norms of the columns*/ /* of the initial jacobian*/ xNorm = 0; for (int k = 0; k < cols; ++k) { double dk = jacNorm[k]; if (dk == 0) { dk = 1.0; } double xk = dk * point[k]; xNorm  += xk * xk; diag[k] = dk; } xNorm = FastMath.sqrt(xNorm);
public LevenbergMarquardtOptimizer(double initialStepBoundFactor, double costRelativeTolerance, double parRelativeTolerance, double orthoTolerance, double threshold) { this.initialStepBoundFactor = initialStepBoundFactor; this.costRelativeTolerance = costRelativeTolerance; this.parRelativeTolerance = parRelativeTolerance; this.orthoTolerance = orthoTolerance; this.qrRankingThreshold = threshold; }  /** {@inheritDoc} */ /* of the initial jacobian*/ <BUGS> xNorm = 0; for (int k = 0; k < cols; ++k) { double dk = jacNorm[k]; if (dk == 0) { <BUGE> dk = 1.0; } double xk = dk * point[k]; xNorm  += xk * xk; diag[k] = dk; } xNorm = FastMath.sqrt(xNorm);  /* initialize the step bound delta*/ delta = (xNorm == 0) ? initialStepBoundFactor : (initialStepBoundFactor * xNorm); }
public LevenbergMarquardtOptimizer(double initialStepBoundFactor, double costRelativeTolerance, double parRelativeTolerance, double orthoTolerance, double threshold) { this.initialStepBoundFactor = initialStepBoundFactor; this.costRelativeTolerance = costRelativeTolerance; this.parRelativeTolerance = parRelativeTolerance; this.orthoTolerance = orthoTolerance; this.qrRankingThreshold = threshold; }  /** {@inheritDoc} */ } <BUGS> double xk = dk * point[k]; xNorm  += xk * xk; diag[k] = dk; <BUGE> } xNorm = FastMath.sqrt(xNorm);  /* initialize the step bound delta*/ delta = (xNorm == 0) ? initialStepBoundFactor : (initialStepBoundFactor * xNorm); }  /* check orthogonality between function vector and jacobian columns*/ double maxCosine = 0; if (cost != 0) { for (int j = 0; j < solvedCols; ++j) { int    pj = permutation[j]; double s  = jacNorm[pj];
*/ public LevenbergMarquardtOptimizer(double initialStepBoundFactor, double costRelativeTolerance, double parRelativeTolerance, double orthoTolerance, double threshold) { this.initialStepBoundFactor = initialStepBoundFactor; this.costRelativeTolerance = costRelativeTolerance; this.parRelativeTolerance = parRelativeTolerance; this.orthoTolerance = orthoTolerance; this.qrRankingThreshold = threshold; }  /** {@inheritDoc} */ } <BUGS> xNorm = FastMath.sqrt(xNorm); <BUGE>  /* initialize the step bound delta*/ delta = (xNorm == 0) ? initialStepBoundFactor : (initialStepBoundFactor * xNorm); }  /* check orthogonality between function vector and jacobian columns*/ double maxCosine = 0; if (cost != 0) { for (int j = 0; j < solvedCols; ++j) { int    pj = permutation[j]; double s  = jacNorm[pj]; if (s != 0) { double sum = 0; for (int i = 0; i <= j; ++i) {
*/ public LevenbergMarquardtOptimizer(double initialStepBoundFactor, double costRelativeTolerance, double parRelativeTolerance, double orthoTolerance, double threshold) { this.initialStepBoundFactor = initialStepBoundFactor; this.costRelativeTolerance = costRelativeTolerance; this.parRelativeTolerance = parRelativeTolerance; this.orthoTolerance = orthoTolerance; this.qrRankingThreshold = threshold; }  /** {@inheritDoc} */ /* initialize the step bound delta*/ <BUGS> delta = (xNorm == 0) ? initialStepBoundFactor : (initialStepBoundFactor * xNorm); <BUGE> }  /* check orthogonality between function vector and jacobian columns*/ double maxCosine = 0; if (cost != 0) { for (int j = 0; j < solvedCols; ++j) { int    pj = permutation[j]; double s  = jacNorm[pj]; if (s != 0) { double sum = 0; for (int i = 0; i <= j; ++i) { sum += weightedResidualJacobian[i][pj] * qtf[i]; } maxCosine = FastMath.max(maxCosine, FastMath.abs(sum) / (s * cost));
double orthoTolerance, double threshold) { this.initialStepBoundFactor = initialStepBoundFactor; this.costRelativeTolerance = costRelativeTolerance; this.parRelativeTolerance = parRelativeTolerance; this.orthoTolerance = orthoTolerance; this.qrRankingThreshold = threshold; }  /** {@inheritDoc} */ /* check orthogonality between function vector and jacobian columns*/ <BUGS> double maxCosine = 0; if (cost != 0) { for (int j = 0; j < solvedCols; ++j) { int    pj = permutation[j]; double s  = jacNorm[pj]; if (s != 0) { double sum = 0; for (int i = 0; i <= j; ++i) { sum += weightedResidualJacobian[i][pj] * qtf[i]; <BUGE> } maxCosine = FastMath.max(maxCosine, FastMath.abs(sum) / (s * cost)); } } } if (maxCosine <= orthoTolerance) { /* convergence has been reached*/ updateResidualsAndCost(); current = new VectorialPointValuePair(point, objective); return current;
*/ public LevenbergMarquardtOptimizer(double initialStepBoundFactor, double costRelativeTolerance, double parRelativeTolerance, double orthoTolerance, double threshold) { this.initialStepBoundFactor = initialStepBoundFactor; this.costRelativeTolerance = costRelativeTolerance; this.parRelativeTolerance = parRelativeTolerance; this.orthoTolerance = orthoTolerance; this.qrRankingThreshold = threshold; }  /** {@inheritDoc} */ } <BUGS> maxCosine = FastMath.max(maxCosine, FastMath.abs(sum) / (s * cost)); <BUGE> } } } if (maxCosine <= orthoTolerance) { /* convergence has been reached*/ updateResidualsAndCost(); current = new VectorialPointValuePair(point, objective); return current; }  /* rescale if necessary*/ for (int j = 0; j < cols; ++j) { diag[j] = FastMath.max(diag[j], jacNorm[j]); }
*/ public LevenbergMarquardtOptimizer(double initialStepBoundFactor, double costRelativeTolerance, double parRelativeTolerance, double orthoTolerance, double threshold) { this.initialStepBoundFactor = initialStepBoundFactor; this.costRelativeTolerance = costRelativeTolerance; this.parRelativeTolerance = parRelativeTolerance; this.orthoTolerance = orthoTolerance; this.qrRankingThreshold = threshold; }  /** {@inheritDoc} */ } <BUGS> if (maxCosine <= orthoTolerance) { <BUGE> /* convergence has been reached*/ updateResidualsAndCost(); current = new VectorialPointValuePair(point, objective); return current; }  /* rescale if necessary*/ for (int j = 0; j < cols; ++j) { diag[j] = FastMath.max(diag[j], jacNorm[j]); }  /* inner loop*/ for (double ratio = 0; ratio < 1.0e-4;) {
*/ public LevenbergMarquardtOptimizer(double initialStepBoundFactor, double costRelativeTolerance, double parRelativeTolerance, double orthoTolerance, double threshold) { this.initialStepBoundFactor = initialStepBoundFactor; this.costRelativeTolerance = costRelativeTolerance; this.parRelativeTolerance = parRelativeTolerance; this.orthoTolerance = orthoTolerance; this.qrRankingThreshold = threshold; }  /** {@inheritDoc} */ /* rescale if necessary*/ <BUGS> for (int j = 0; j < cols; ++j) { diag[j] = FastMath.max(diag[j], jacNorm[j]); <BUGE> }  /* inner loop*/ for (double ratio = 0; ratio < 1.0e-4;) {  /* save the state*/ for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; oldX[pj] = point[pj]; } double previousCost = cost; double[] tmpVec = weightedResiduals; weightedResiduals = oldRes;
*/ public LevenbergMarquardtOptimizer(double initialStepBoundFactor, double costRelativeTolerance, double parRelativeTolerance, double orthoTolerance, double threshold) { this.initialStepBoundFactor = initialStepBoundFactor; this.costRelativeTolerance = costRelativeTolerance; this.parRelativeTolerance = parRelativeTolerance; this.orthoTolerance = orthoTolerance; this.qrRankingThreshold = threshold; }  /** {@inheritDoc} */ /* inner loop*/ <BUGS> for (double ratio = 0; ratio < 1.0e-4;) { <BUGE>  /* save the state*/ for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; oldX[pj] = point[pj]; } double previousCost = cost; double[] tmpVec = weightedResiduals; weightedResiduals = oldRes; oldRes    = tmpVec; tmpVec    = objective; objective = oldObj; oldObj    = tmpVec;
public LevenbergMarquardtOptimizer(double initialStepBoundFactor, double costRelativeTolerance, double parRelativeTolerance, double orthoTolerance, double threshold) { this.initialStepBoundFactor = initialStepBoundFactor; this.costRelativeTolerance = costRelativeTolerance; this.parRelativeTolerance = parRelativeTolerance; this.orthoTolerance = orthoTolerance; this.qrRankingThreshold = threshold; }  /** {@inheritDoc} */ /* save the state*/ <BUGS> for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; oldX[pj] = point[pj]; <BUGE> } double previousCost = cost; double[] tmpVec = weightedResiduals; weightedResiduals = oldRes; oldRes    = tmpVec; tmpVec    = objective; objective = oldObj; oldObj    = tmpVec;  /* determine the Levenberg-Marquardt parameter*/ determineLMParameter(qtf, delta, diag, work1, work2, work3);  /* compute the new point and the norm of the evolution direction*/
double parRelativeTolerance, double orthoTolerance, double threshold) { this.initialStepBoundFactor = initialStepBoundFactor; this.costRelativeTolerance = costRelativeTolerance; this.parRelativeTolerance = parRelativeTolerance; this.orthoTolerance = orthoTolerance; this.qrRankingThreshold = threshold; }  /** {@inheritDoc} */ } <BUGS> double previousCost = cost; double[] tmpVec = weightedResiduals; weightedResiduals = oldRes; oldRes    = tmpVec; tmpVec    = objective; objective = oldObj; oldObj    = tmpVec; <BUGE>  /* determine the Levenberg-Marquardt parameter*/ determineLMParameter(qtf, delta, diag, work1, work2, work3);  /* compute the new point and the norm of the evolution direction*/ double lmNorm = 0; for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; lmDir[pj] = -lmDir[pj]; point[pj] = oldX[pj] + lmDir[pj]; double s = diag[pj] * lmDir[pj];
*/ public LevenbergMarquardtOptimizer(double initialStepBoundFactor, double costRelativeTolerance, double parRelativeTolerance, double orthoTolerance, double threshold) { this.initialStepBoundFactor = initialStepBoundFactor; this.costRelativeTolerance = costRelativeTolerance; this.parRelativeTolerance = parRelativeTolerance; this.orthoTolerance = orthoTolerance; this.qrRankingThreshold = threshold; }  /** {@inheritDoc} */ /* determine the Levenberg-Marquardt parameter*/ <BUGS> determineLMParameter(qtf, delta, diag, work1, work2, work3); <BUGE>  /* compute the new point and the norm of the evolution direction*/ double lmNorm = 0; for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; lmDir[pj] = -lmDir[pj]; point[pj] = oldX[pj] + lmDir[pj]; double s = diag[pj] * lmDir[pj]; lmNorm  += s * s; } lmNorm = FastMath.sqrt(lmNorm); /* on the first iteration, adjust the initial step bound.*/ if (firstIteration) { delta = FastMath.min(delta, lmNorm);
double parRelativeTolerance, double orthoTolerance, double threshold) { this.initialStepBoundFactor = initialStepBoundFactor; this.costRelativeTolerance = costRelativeTolerance; this.parRelativeTolerance = parRelativeTolerance; this.orthoTolerance = orthoTolerance; this.qrRankingThreshold = threshold; }  /** {@inheritDoc} */ /* compute the new point and the norm of the evolution direction*/ <BUGS> double lmNorm = 0; for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; lmDir[pj] = -lmDir[pj]; point[pj] = oldX[pj] + lmDir[pj]; double s = diag[pj] * lmDir[pj]; lmNorm  += s * s; <BUGE> } lmNorm = FastMath.sqrt(lmNorm); /* on the first iteration, adjust the initial step bound.*/ if (firstIteration) { delta = FastMath.min(delta, lmNorm); }  /* evaluate the function at x + p and calculate its norm*/ updateResidualsAndCost();  /* compute the scaled actual reduction*/
*/ public LevenbergMarquardtOptimizer(double initialStepBoundFactor, double costRelativeTolerance, double parRelativeTolerance, double orthoTolerance, double threshold) { this.initialStepBoundFactor = initialStepBoundFactor; this.costRelativeTolerance = costRelativeTolerance; this.parRelativeTolerance = parRelativeTolerance; this.orthoTolerance = orthoTolerance; this.qrRankingThreshold = threshold; }  /** {@inheritDoc} */ } <BUGS> lmNorm = FastMath.sqrt(lmNorm); <BUGE> /* on the first iteration, adjust the initial step bound.*/ if (firstIteration) { delta = FastMath.min(delta, lmNorm); }  /* evaluate the function at x + p and calculate its norm*/ updateResidualsAndCost();  /* compute the scaled actual reduction*/ double actRed = -1.0; if (0.1 * cost < previousCost) { double r = cost / previousCost; actRed = 1.0 - r * r; }
*/ public LevenbergMarquardtOptimizer(double initialStepBoundFactor, double costRelativeTolerance, double parRelativeTolerance, double orthoTolerance, double threshold) { this.initialStepBoundFactor = initialStepBoundFactor; this.costRelativeTolerance = costRelativeTolerance; this.parRelativeTolerance = parRelativeTolerance; this.orthoTolerance = orthoTolerance; this.qrRankingThreshold = threshold; }  /** {@inheritDoc} */ /* on the first iteration, adjust the initial step bound.*/ <BUGS> if (firstIteration) { delta = FastMath.min(delta, lmNorm); <BUGE> }  /* evaluate the function at x + p and calculate its norm*/ updateResidualsAndCost();  /* compute the scaled actual reduction*/ double actRed = -1.0; if (0.1 * cost < previousCost) { double r = cost / previousCost; actRed = 1.0 - r * r; }  /* compute the scaled predicted reduction*/
*/ public LevenbergMarquardtOptimizer(double initialStepBoundFactor, double costRelativeTolerance, double parRelativeTolerance, double orthoTolerance, double threshold) { this.initialStepBoundFactor = initialStepBoundFactor; this.costRelativeTolerance = costRelativeTolerance; this.parRelativeTolerance = parRelativeTolerance; this.orthoTolerance = orthoTolerance; this.qrRankingThreshold = threshold; }  /** {@inheritDoc} */ /* evaluate the function at x + p and calculate its norm*/ <BUGS> updateResidualsAndCost(); <BUGE>  /* compute the scaled actual reduction*/ double actRed = -1.0; if (0.1 * cost < previousCost) { double r = cost / previousCost; actRed = 1.0 - r * r; }  /* compute the scaled predicted reduction*/ /* and the scaled directional derivative*/ for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; double dirJ = lmDir[pj]; work1[j] = 0;
public LevenbergMarquardtOptimizer(double initialStepBoundFactor, double costRelativeTolerance, double parRelativeTolerance, double orthoTolerance, double threshold) { this.initialStepBoundFactor = initialStepBoundFactor; this.costRelativeTolerance = costRelativeTolerance; this.parRelativeTolerance = parRelativeTolerance; this.orthoTolerance = orthoTolerance; this.qrRankingThreshold = threshold; }  /** {@inheritDoc} */ /* compute the scaled actual reduction*/ <BUGS> double actRed = -1.0; if (0.1 * cost < previousCost) { double r = cost / previousCost; actRed = 1.0 - r * r; <BUGE> }  /* compute the scaled predicted reduction*/ /* and the scaled directional derivative*/ for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; double dirJ = lmDir[pj]; work1[j] = 0; for (int i = 0; i <= j; ++i) { work1[i] += weightedResidualJacobian[i][pj] * dirJ; } }
double costRelativeTolerance, double parRelativeTolerance, double orthoTolerance, double threshold) { this.initialStepBoundFactor = initialStepBoundFactor; this.costRelativeTolerance = costRelativeTolerance; this.parRelativeTolerance = parRelativeTolerance; this.orthoTolerance = orthoTolerance; this.qrRankingThreshold = threshold; }  /** {@inheritDoc} */ /* and the scaled directional derivative*/ <BUGS> for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; double dirJ = lmDir[pj]; work1[j] = 0; for (int i = 0; i <= j; ++i) { work1[i] += weightedResidualJacobian[i][pj] * dirJ; <BUGE> } } double coeff1 = 0; for (int j = 0; j < solvedCols; ++j) { coeff1 += work1[j] * work1[j]; } double pc2 = previousCost * previousCost; coeff1 = coeff1 / pc2; double coeff2 = lmPar * lmNorm * lmNorm / pc2; double preRed = coeff1 + 2 * coeff2; double dirDer = -(coeff1 + coeff2);
public LevenbergMarquardtOptimizer(double initialStepBoundFactor, double costRelativeTolerance, double parRelativeTolerance, double orthoTolerance, double threshold) { this.initialStepBoundFactor = initialStepBoundFactor; this.costRelativeTolerance = costRelativeTolerance; this.parRelativeTolerance = parRelativeTolerance; this.orthoTolerance = orthoTolerance; this.qrRankingThreshold = threshold; }  /** {@inheritDoc} */ } <BUGS> double coeff1 = 0; for (int j = 0; j < solvedCols; ++j) { coeff1 += work1[j] * work1[j]; <BUGE> } double pc2 = previousCost * previousCost; coeff1 = coeff1 / pc2; double coeff2 = lmPar * lmNorm * lmNorm / pc2; double preRed = coeff1 + 2 * coeff2; double dirDer = -(coeff1 + coeff2);  /* ratio of the actual to the predicted reduction*/ ratio = (preRed == 0) ? 0 : (actRed / preRed);  /* update the step bound*/ if (ratio <= 0.25) { double tmp =
double costRelativeTolerance, double parRelativeTolerance, double orthoTolerance, double threshold) { this.initialStepBoundFactor = initialStepBoundFactor; this.costRelativeTolerance = costRelativeTolerance; this.parRelativeTolerance = parRelativeTolerance; this.orthoTolerance = orthoTolerance; this.qrRankingThreshold = threshold; }  /** {@inheritDoc} */ } <BUGS> double pc2 = previousCost * previousCost; coeff1 = coeff1 / pc2; double coeff2 = lmPar * lmNorm * lmNorm / pc2; double preRed = coeff1 + 2 * coeff2; double dirDer = -(coeff1 + coeff2); <BUGE>  /* ratio of the actual to the predicted reduction*/ ratio = (preRed == 0) ? 0 : (actRed / preRed);  /* update the step bound*/ if (ratio <= 0.25) { double tmp = (actRed < 0) ? (0.5 * dirDer / (dirDer + 0.5 * actRed)) : 0.5; if ((0.1 * cost >= previousCost) || (tmp < 0.1)) { tmp = 0.1; } delta = tmp * FastMath.min(delta, 10.0 * lmNorm);
*/ public LevenbergMarquardtOptimizer(double initialStepBoundFactor, double costRelativeTolerance, double parRelativeTolerance, double orthoTolerance, double threshold) { this.initialStepBoundFactor = initialStepBoundFactor; this.costRelativeTolerance = costRelativeTolerance; this.parRelativeTolerance = parRelativeTolerance; this.orthoTolerance = orthoTolerance; this.qrRankingThreshold = threshold; }  /** {@inheritDoc} */ /* ratio of the actual to the predicted reduction*/ <BUGS> ratio = (preRed == 0) ? 0 : (actRed / preRed); <BUGE>  /* update the step bound*/ if (ratio <= 0.25) { double tmp = (actRed < 0) ? (0.5 * dirDer / (dirDer + 0.5 * actRed)) : 0.5; if ((0.1 * cost >= previousCost) || (tmp < 0.1)) { tmp = 0.1; } delta = tmp * FastMath.min(delta, 10.0 * lmNorm); lmPar /= tmp; } else if ((lmPar == 0) || (ratio >= 0.75)) { delta = 2 * lmNorm; lmPar *= 0.5; }
*/ public LevenbergMarquardtOptimizer(double initialStepBoundFactor, double costRelativeTolerance, double parRelativeTolerance, double orthoTolerance, double threshold) { this.initialStepBoundFactor = initialStepBoundFactor; this.costRelativeTolerance = costRelativeTolerance; this.parRelativeTolerance = parRelativeTolerance; this.orthoTolerance = orthoTolerance; this.qrRankingThreshold = threshold; }  /** {@inheritDoc} */ /* update the step bound*/ <BUGS> if (ratio <= 0.25) { double tmp = <BUGE> (actRed < 0) ? (0.5 * dirDer / (dirDer + 0.5 * actRed)) : 0.5; if ((0.1 * cost >= previousCost) || (tmp < 0.1)) { tmp = 0.1; } delta = tmp * FastMath.min(delta, 10.0 * lmNorm); lmPar /= tmp; } else if ((lmPar == 0) || (ratio >= 0.75)) { delta = 2 * lmNorm; lmPar *= 0.5; }  /* test for successful iteration.*/ if (ratio >= 1.0e-4) {
*/ public LevenbergMarquardtOptimizer(double initialStepBoundFactor, double costRelativeTolerance, double parRelativeTolerance, double orthoTolerance, double threshold) { this.initialStepBoundFactor = initialStepBoundFactor; this.costRelativeTolerance = costRelativeTolerance; this.parRelativeTolerance = parRelativeTolerance; this.orthoTolerance = orthoTolerance; this.qrRankingThreshold = threshold; }  /** {@inheritDoc} */ (actRed < 0) ? (0.5 * dirDer / (dirDer + 0.5 * actRed)) : 0.5; <BUGS> if ((0.1 * cost >= previousCost) || (tmp < 0.1)) { <BUGE> tmp = 0.1; } delta = tmp * FastMath.min(delta, 10.0 * lmNorm); lmPar /= tmp; } else if ((lmPar == 0) || (ratio >= 0.75)) { delta = 2 * lmNorm; lmPar *= 0.5; }  /* test for successful iteration.*/ if (ratio >= 1.0e-4) { /* successful iteration, update the norm*/ firstIteration = false; xNorm = 0;
double costRelativeTolerance, double parRelativeTolerance, double orthoTolerance, double threshold) { this.initialStepBoundFactor = initialStepBoundFactor; this.costRelativeTolerance = costRelativeTolerance; this.parRelativeTolerance = parRelativeTolerance; this.orthoTolerance = orthoTolerance; this.qrRankingThreshold = threshold; }  /** {@inheritDoc} */ } <BUGS> delta = tmp * FastMath.min(delta, 10.0 * lmNorm); lmPar /= tmp; } else if ((lmPar == 0) || (ratio >= 0.75)) { delta = 2 * lmNorm; lmPar *= 0.5; <BUGE> }  /* test for successful iteration.*/ if (ratio >= 1.0e-4) { /* successful iteration, update the norm*/ firstIteration = false; xNorm = 0; for (int k = 0; k < cols; ++k) { double xK = diag[k] * point[k]; xNorm += xK * xK; } xNorm = FastMath.sqrt(xNorm);
*/ public LevenbergMarquardtOptimizer(double initialStepBoundFactor, double costRelativeTolerance, double parRelativeTolerance, double orthoTolerance, double threshold) { this.initialStepBoundFactor = initialStepBoundFactor; this.costRelativeTolerance = costRelativeTolerance; this.parRelativeTolerance = parRelativeTolerance; this.orthoTolerance = orthoTolerance; this.qrRankingThreshold = threshold; }  /** {@inheritDoc} */ /* test for successful iteration.*/ <BUGS> if (ratio >= 1.0e-4) { <BUGE> /* successful iteration, update the norm*/ firstIteration = false; xNorm = 0; for (int k = 0; k < cols; ++k) { double xK = diag[k] * point[k]; xNorm += xK * xK; } xNorm = FastMath.sqrt(xNorm); current = new VectorialPointValuePair(point, objective);  /* tests for convergence.*/ if (checker != null) { /* we use the vectorial convergence checker*/ if (checker.converged(iter, previous, current)) {
double costRelativeTolerance, double parRelativeTolerance, double orthoTolerance, double threshold) { this.initialStepBoundFactor = initialStepBoundFactor; this.costRelativeTolerance = costRelativeTolerance; this.parRelativeTolerance = parRelativeTolerance; this.orthoTolerance = orthoTolerance; this.qrRankingThreshold = threshold; }  /** {@inheritDoc} */ /* successful iteration, update the norm*/ <BUGS> firstIteration = false; xNorm = 0; for (int k = 0; k < cols; ++k) { double xK = diag[k] * point[k]; xNorm += xK * xK; <BUGE> } xNorm = FastMath.sqrt(xNorm); current = new VectorialPointValuePair(point, objective);  /* tests for convergence.*/ if (checker != null) { /* we use the vectorial convergence checker*/ if (checker.converged(iter, previous, current)) { return current; } } } else {
*/ public LevenbergMarquardtOptimizer(double initialStepBoundFactor, double costRelativeTolerance, double parRelativeTolerance, double orthoTolerance, double threshold) { this.initialStepBoundFactor = initialStepBoundFactor; this.costRelativeTolerance = costRelativeTolerance; this.parRelativeTolerance = parRelativeTolerance; this.orthoTolerance = orthoTolerance; this.qrRankingThreshold = threshold; }  /** {@inheritDoc} */ } <BUGS> xNorm = FastMath.sqrt(xNorm); current = new VectorialPointValuePair(point, objective); <BUGE>  /* tests for convergence.*/ if (checker != null) { /* we use the vectorial convergence checker*/ if (checker.converged(iter, previous, current)) { return current; } } } else { /* failed iteration, reset the previous values*/ cost = previousCost; for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j];
*/ public LevenbergMarquardtOptimizer(double initialStepBoundFactor, double costRelativeTolerance, double parRelativeTolerance, double orthoTolerance, double threshold) { this.initialStepBoundFactor = initialStepBoundFactor; this.costRelativeTolerance = costRelativeTolerance; this.parRelativeTolerance = parRelativeTolerance; this.orthoTolerance = orthoTolerance; this.qrRankingThreshold = threshold; }  /** {@inheritDoc} */ /* tests for convergence.*/ <BUGS> if (checker != null) { <BUGE> /* we use the vectorial convergence checker*/ if (checker.converged(iter, previous, current)) { return current; } } } else { /* failed iteration, reset the previous values*/ cost = previousCost; for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; point[pj] = oldX[pj]; } tmpVec    = weightedResiduals; weightedResiduals = oldRes;
*/ public LevenbergMarquardtOptimizer(double initialStepBoundFactor, double costRelativeTolerance, double parRelativeTolerance, double orthoTolerance, double threshold) { this.initialStepBoundFactor = initialStepBoundFactor; this.costRelativeTolerance = costRelativeTolerance; this.parRelativeTolerance = parRelativeTolerance; this.orthoTolerance = orthoTolerance; this.qrRankingThreshold = threshold; }  /** {@inheritDoc} */ /* we use the vectorial convergence checker*/ <BUGS> if (checker.converged(iter, previous, current)) { <BUGE> return current; } } } else { /* failed iteration, reset the previous values*/ cost = previousCost; for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; point[pj] = oldX[pj]; } tmpVec    = weightedResiduals; weightedResiduals = oldRes; oldRes    = tmpVec; tmpVec    = objective;
public LevenbergMarquardtOptimizer(double initialStepBoundFactor, double costRelativeTolerance, double parRelativeTolerance, double orthoTolerance, double threshold) { this.initialStepBoundFactor = initialStepBoundFactor; this.costRelativeTolerance = costRelativeTolerance; this.parRelativeTolerance = parRelativeTolerance; this.orthoTolerance = orthoTolerance; this.qrRankingThreshold = threshold; }  /** {@inheritDoc} */ /* failed iteration, reset the previous values*/ <BUGS> cost = previousCost; for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; point[pj] = oldX[pj]; <BUGE> } tmpVec    = weightedResiduals; weightedResiduals = oldRes; oldRes    = tmpVec; tmpVec    = objective; objective = oldObj; oldObj    = tmpVec; }  /* Default convergence criteria.*/ if ((FastMath.abs(actRed) <= costRelativeTolerance && preRed <= costRelativeTolerance &&
double costRelativeTolerance, double parRelativeTolerance, double orthoTolerance, double threshold) { this.initialStepBoundFactor = initialStepBoundFactor; this.costRelativeTolerance = costRelativeTolerance; this.parRelativeTolerance = parRelativeTolerance; this.orthoTolerance = orthoTolerance; this.qrRankingThreshold = threshold; }  /** {@inheritDoc} */ } <BUGS> tmpVec    = weightedResiduals; weightedResiduals = oldRes; oldRes    = tmpVec; tmpVec    = objective; objective = oldObj; oldObj    = tmpVec; <BUGE> }  /* Default convergence criteria.*/ if ((FastMath.abs(actRed) <= costRelativeTolerance && preRed <= costRelativeTolerance && ratio <= 2.0) || delta <= parRelativeTolerance * xNorm) { return current; }  /* tests for termination and stringent tolerances*/
*/ public LevenbergMarquardtOptimizer(double initialStepBoundFactor, double costRelativeTolerance, double parRelativeTolerance, double orthoTolerance, double threshold) { this.initialStepBoundFactor = initialStepBoundFactor; this.costRelativeTolerance = costRelativeTolerance; this.parRelativeTolerance = parRelativeTolerance; this.orthoTolerance = orthoTolerance; this.qrRankingThreshold = threshold; }  /** {@inheritDoc} */ /* Default convergence criteria.*/ <BUGS> if ((FastMath.abs(actRed) <= costRelativeTolerance && <BUGE> preRed <= costRelativeTolerance && ratio <= 2.0) || delta <= parRelativeTolerance * xNorm) { return current; }  /* tests for termination and stringent tolerances*/ /* (2.2204e-16 is the machine epsilon for IEEE754)*/ if ((FastMath.abs(actRed) <= 2.2204e-16) && (preRed <= 2.2204e-16) && (ratio <= 2.0)) { throw new ConvergenceException(LocalizedFormats.TOO_SMALL_COST_RELATIVE_TOLERANCE, costRelativeTolerance); } else if (delta <= 2.2204e-16 * xNorm) { throw new ConvergenceException(LocalizedFormats.TOO_SMALL_PARAMETERS_RELATIVE_TOLERANCE, parRelativeTolerance);
*/ public LevenbergMarquardtOptimizer(double initialStepBoundFactor, double costRelativeTolerance, double parRelativeTolerance, double orthoTolerance, double threshold) { this.initialStepBoundFactor = initialStepBoundFactor; this.costRelativeTolerance = costRelativeTolerance; this.parRelativeTolerance = parRelativeTolerance; this.orthoTolerance = orthoTolerance; this.qrRankingThreshold = threshold; }  /** {@inheritDoc} */ /* (2.2204e-16 is the machine epsilon for IEEE754)*/ <BUGS> if ((FastMath.abs(actRed) <= 2.2204e-16) && (preRed <= 2.2204e-16) && (ratio <= 2.0)) { <BUGE> throw new ConvergenceException(LocalizedFormats.TOO_SMALL_COST_RELATIVE_TOLERANCE, costRelativeTolerance); } else if (delta <= 2.2204e-16 * xNorm) { throw new ConvergenceException(LocalizedFormats.TOO_SMALL_PARAMETERS_RELATIVE_TOLERANCE, parRelativeTolerance); } else if (maxCosine <= 2.2204e-16)  { throw new ConvergenceException(LocalizedFormats.TOO_SMALL_ORTHOGONALITY_TOLERANCE, orthoTolerance); } } } }  /**
*/ public LevenbergMarquardtOptimizer(double initialStepBoundFactor, double costRelativeTolerance, double parRelativeTolerance, double orthoTolerance, double threshold) { this.initialStepBoundFactor = initialStepBoundFactor; this.costRelativeTolerance = costRelativeTolerance; this.parRelativeTolerance = parRelativeTolerance; this.orthoTolerance = orthoTolerance; this.qrRankingThreshold = threshold; }  /** {@inheritDoc} */ costRelativeTolerance); <BUGS> } else if (delta <= 2.2204e-16 * xNorm) { <BUGE> throw new ConvergenceException(LocalizedFormats.TOO_SMALL_PARAMETERS_RELATIVE_TOLERANCE, parRelativeTolerance); } else if (maxCosine <= 2.2204e-16)  { throw new ConvergenceException(LocalizedFormats.TOO_SMALL_ORTHOGONALITY_TOLERANCE, orthoTolerance); } } } }  /** * Determine the Levenberg-Marquardt parameter. * <p>This implementation is a translation in Java of the MINPACK * <a href="http:/*www.netlib.org/minpack/lmpar.f">lmpar</a>*/
*/ public LevenbergMarquardtOptimizer(double initialStepBoundFactor, double costRelativeTolerance, double parRelativeTolerance, double orthoTolerance, double threshold) { this.initialStepBoundFactor = initialStepBoundFactor; this.costRelativeTolerance = costRelativeTolerance; this.parRelativeTolerance = parRelativeTolerance; this.orthoTolerance = orthoTolerance; this.qrRankingThreshold = threshold; }  /** {@inheritDoc} */ parRelativeTolerance); <BUGS> } else if (maxCosine <= 2.2204e-16)  { <BUGE> throw new ConvergenceException(LocalizedFormats.TOO_SMALL_ORTHOGONALITY_TOLERANCE, orthoTolerance); } } } }  /** * Determine the Levenberg-Marquardt parameter. * <p>This implementation is a translation in Java of the MINPACK * <a href="http:/*www.netlib.org/minpack/lmpar.f">lmpar</a>*/ * routine.</p> * <p>This method sets the lmPar and lmDir attributes.</p> * <p>The authors of the original fortran function are:</p>
*/ public LevenbergMarquardtOptimizer(double initialStepBoundFactor, double costRelativeTolerance, double parRelativeTolerance, double orthoTolerance, double threshold) { this.initialStepBoundFactor = initialStepBoundFactor; this.costRelativeTolerance = costRelativeTolerance; this.parRelativeTolerance = parRelativeTolerance; this.orthoTolerance = orthoTolerance; this.qrRankingThreshold = threshold; }  /** {@inheritDoc} */ } <BUGS> } } <BUGE> }  /** * Determine the Levenberg-Marquardt parameter. * <p>This implementation is a translation in Java of the MINPACK * <a href="http:/*www.netlib.org/minpack/lmpar.f">lmpar</a>*/ * routine.</p> * <p>This method sets the lmPar and lmDir attributes.</p> * <p>The authors of the original fortran function are:</p> * <ul> *   <li>Argonne National Laboratory. MINPACK project. March 1980</li> *   <li>Burton  S. Garbow</li> *   <li>Kenneth E. Hillstrom</li>
*/ private static double exp(double x, double extra, double[] hiPrec) { double intPartA; double intPartB; int intVal;  /* Lookup exp(floor(x)). * intPartA will have the upper 22 bits, intPartB will have the lower * 52 bits. */ <BUGS> if (x < 0.0) { intVal = (int) -x; <BUGE>  if (intVal > 746) { if (hiPrec != null) { hiPrec[0] = 0.0; hiPrec[1] = 0.0; } return 0.0; }  if (intVal > 709) { /* This will produce a subnormal output */ final double result = exp(x+40.19140625, extra, hiPrec) / 285040095144011776.0; if (hiPrec != null) { hiPrec[0] /= 285040095144011776.0; hiPrec[1] /= 285040095144011776.0; } return result; }
*/ private static double exp(double x, double extra, double[] hiPrec) { double intPartA; double intPartB; int intVal;  /* Lookup exp(floor(x)). * intPartA will have the upper 22 bits, intPartB will have the lower * 52 bits. */ if (x < 0.0) { intVal = (int) -x;  <BUGS> if (intVal > 746) { if (hiPrec != null) { <BUGE> hiPrec[0] = 0.0; hiPrec[1] = 0.0; } return 0.0; }  if (intVal > 709) { /* This will produce a subnormal output */ final double result = exp(x+40.19140625, extra, hiPrec) / 285040095144011776.0; if (hiPrec != null) { hiPrec[0] /= 285040095144011776.0; hiPrec[1] /= 285040095144011776.0; } return result; }
*/ private static double exp(double x, double extra, double[] hiPrec) { double intPartA; double intPartB; int intVal;  /* Lookup exp(floor(x)). * intPartA will have the upper 22 bits, intPartB will have the lower * 52 bits. */ if (x < 0.0) { intVal = (int) -x;  if (intVal > 746) { if (hiPrec != null) { hiPrec[0] = 0.0; hiPrec[1] = 0.0; } <BUGS> return 0.0; <BUGE> }  if (intVal > 709) { /* This will produce a subnormal output */ final double result = exp(x+40.19140625, extra, hiPrec) / 285040095144011776.0; if (hiPrec != null) { hiPrec[0] /= 285040095144011776.0; hiPrec[1] /= 285040095144011776.0; } return result; }
*/ private static double exp(double x, double extra, double[] hiPrec) { double intPartA; double intPartB; int intVal;  /* Lookup exp(floor(x)). * intPartA will have the upper 22 bits, intPartB will have the lower * 52 bits. */ if (x < 0.0) { intVal = (int) -x;  if (intVal > 746) { if (hiPrec != null) { hiPrec[0] = 0.0; hiPrec[1] = 0.0; } return 0.0; }  <BUGS> if (intVal > 709) { <BUGE> /* This will produce a subnormal output */ final double result = exp(x+40.19140625, extra, hiPrec) / 285040095144011776.0; if (hiPrec != null) { hiPrec[0] /= 285040095144011776.0; hiPrec[1] /= 285040095144011776.0; } return result; }
*/ private static double exp(double x, double extra, double[] hiPrec) { double intPartA; double intPartB; int intVal;  /* Lookup exp(floor(x)). * intPartA will have the upper 22 bits, intPartB will have the lower * 52 bits. */ if (x < 0.0) { intVal = (int) -x;  if (intVal > 746) { if (hiPrec != null) { hiPrec[0] = 0.0; hiPrec[1] = 0.0; } return 0.0; }  if (intVal > 709) { /* This will produce a subnormal output */ <BUGS> final double result = exp(x+40.19140625, extra, hiPrec) / 285040095144011776.0; if (hiPrec != null) { <BUGE> hiPrec[0] /= 285040095144011776.0; hiPrec[1] /= 285040095144011776.0; } return result; }
*/ private static double exp(double x, double extra, double[] hiPrec) { double intPartA; double intPartB; int intVal;  /* Lookup exp(floor(x)). * intPartA will have the upper 22 bits, intPartB will have the lower * 52 bits. */ if (x < 0.0) { intVal = (int) -x;  if (intVal > 746) { if (hiPrec != null) { hiPrec[0] = 0.0; hiPrec[1] = 0.0; } return 0.0; }  if (intVal > 709) { /* This will produce a subnormal output */ final double result = exp(x+40.19140625, extra, hiPrec) / 285040095144011776.0; if (hiPrec != null) { hiPrec[0] /= 285040095144011776.0; hiPrec[1] /= 285040095144011776.0; } <BUGS> return result; <BUGE> }
* * @param x   a double * @return double e<sup>x</sup> */ public static double exp(double x) { return exp(x, 0.0, null); }  /** * Internal helper method for exponential function. * @param x original argument of the exponential function * @param extra extra bits of precision on input (To Be Confirmed) * @param hiPrec extra bits of precision on output (To Be Confirmed) * @return exp(x)  <BUGS> if (intVal == 709) { <BUGE> /* exp(1.494140625) is nearly a machine number... */ final double result = exp(x+1.494140625, extra, hiPrec) / 4.455505956692756620; if (hiPrec != null) { hiPrec[0] /= 4.455505956692756620; hiPrec[1] /= 4.455505956692756620; } return result; }  intVal++;  intPartA = EXP_INT_TABLE_A[750-intVal]; intPartB = EXP_INT_TABLE_B[750-intVal];
* * @param x   a double * @return double e<sup>x</sup> */ public static double exp(double x) { return exp(x, 0.0, null); }  /** * Internal helper method for exponential function. * @param x original argument of the exponential function * @param extra extra bits of precision on input (To Be Confirmed) * @param hiPrec extra bits of precision on output (To Be Confirmed) * @return exp(x)  <BUGS> intVal++; <BUGE>  intPartA = EXP_INT_TABLE_A[750-intVal]; intPartB = EXP_INT_TABLE_B[750-intVal];  intVal = -intVal; } else { intVal = (int) x;  if (intVal > 709) { if (hiPrec != null) { hiPrec[0] = Double.POSITIVE_INFINITY; hiPrec[1] = 0.0; } return Double.POSITIVE_INFINITY;
* * @param x   a double * @return double e<sup>x</sup> */ public static double exp(double x) { return exp(x, 0.0, null); }  /** * Internal helper method for exponential function. * @param x original argument of the exponential function * @param extra extra bits of precision on input (To Be Confirmed) * @param hiPrec extra bits of precision on output (To Be Confirmed) * @return exp(x)  <BUGS> intPartA = EXP_INT_TABLE_A[750-intVal]; intPartB = EXP_INT_TABLE_B[750-intVal]; <BUGE>  intVal = -intVal; } else { intVal = (int) x;  if (intVal > 709) { if (hiPrec != null) { hiPrec[0] = Double.POSITIVE_INFINITY; hiPrec[1] = 0.0; } return Double.POSITIVE_INFINITY; }
* * @param x   a double * @return double e<sup>x</sup> */ public static double exp(double x) { return exp(x, 0.0, null); }  /** * Internal helper method for exponential function. * @param x original argument of the exponential function * @param extra extra bits of precision on input (To Be Confirmed) * @param hiPrec extra bits of precision on output (To Be Confirmed) * @return exp(x)  <BUGS> intVal = -intVal; <BUGE> } else { intVal = (int) x;  if (intVal > 709) { if (hiPrec != null) { hiPrec[0] = Double.POSITIVE_INFINITY; hiPrec[1] = 0.0; } return Double.POSITIVE_INFINITY; }  intPartA = EXP_INT_TABLE_A[750+intVal]; intPartB = EXP_INT_TABLE_B[750+intVal]; }
* @param x   a double * @return double e<sup>x</sup> */ public static double exp(double x) { return exp(x, 0.0, null); }  /** * Internal helper method for exponential function. * @param x original argument of the exponential function * @param extra extra bits of precision on input (To Be Confirmed) * @param hiPrec extra bits of precision on output (To Be Confirmed) * @return exp(x) */ <BUGS> final int intFrac = (int) ((x - intVal) * 1024.0); final double fracPartA = EXP_FRAC_TABLE_A[intFrac]; final double fracPartB = EXP_FRAC_TABLE_B[intFrac]; <BUGE>  /* epsilon is the difference in x from the nearest multiple of 2^-10.  It * has a value in the range 0 <= epsilon < 2^-10. * Do the subtraction from x as the last step to avoid possible loss of percison. */ final double epsilon = x - (intVal + intFrac / 1024.0);  /* Compute z = exp(epsilon) - 1.0 via a minimax polynomial.  z has full double precision (52 bits).  Since z < 2^-10, we will have 62 bits of precision when combined with the contant 1.  This will be used in the last addition below to get proper rounding. */  /* Remez generated polynomial.  Converges on the interval [0, 2^-10], error
* * @param x   a double * @return double e<sup>x</sup> */ public static double exp(double x) { return exp(x, 0.0, null); }  /** * Internal helper method for exponential function. * @param x original argument of the exponential function * @param extra extra bits of precision on input (To Be Confirmed) * @param hiPrec extra bits of precision on output (To Be Confirmed) * @return exp(x) */ <BUGS> final double epsilon = x - (intVal + intFrac / 1024.0); <BUGE>  /* Compute z = exp(epsilon) - 1.0 via a minimax polynomial.  z has full double precision (52 bits).  Since z < 2^-10, we will have 62 bits of precision when combined with the contant 1.  This will be used in the last addition below to get proper rounding. */  /* Remez generated polynomial.  Converges on the interval [0, 2^-10], error is less than 0.5 ULP */ double z = 0.04168701738764507; z = z * epsilon + 0.1666666505023083; z = z * epsilon + 0.5000000000042687; z = z * epsilon + 1.0; z = z * epsilon + -3.940510424527919E-20;
* @return double e<sup>x</sup> */ public static double exp(double x) { return exp(x, 0.0, null); }  /** * Internal helper method for exponential function. * @param x original argument of the exponential function * @param extra extra bits of precision on input (To Be Confirmed) * @param hiPrec extra bits of precision on output (To Be Confirmed) * @return exp(x) is less than 0.5 ULP */ <BUGS> double z = 0.04168701738764507; z = z * epsilon + 0.1666666505023083; z = z * epsilon + 0.5000000000042687; z = z * epsilon + 1.0; z = z * epsilon + -3.940510424527919E-20; <BUGE>  /* Compute (intPartA+intPartB) * (fracPartA+fracPartB) by binomial expansion. tempA is exact since intPartA and intPartB only have 22 bits each. tempB will have 52 bits of precision. */ double tempA = intPartA * fracPartA; double tempB = intPartA * fracPartB + intPartB * fracPartA + intPartB * fracPartB;  /* Compute the result.  (1+z)(tempA+tempB).  Order of operations is important.  For accuracy add by increasing size.  tempA is exact and much larger than the others.  If there are extra bits specified from the
* * @param x   a double * @return double e<sup>x</sup> */ public static double exp(double x) { return exp(x, 0.0, null); }  /** * Internal helper method for exponential function. * @param x original argument of the exponential function * @param extra extra bits of precision on input (To Be Confirmed) * @param hiPrec extra bits of precision on output (To Be Confirmed) * @return exp(x) */ <BUGS> double tempA = intPartA * fracPartA; double tempB = intPartA * fracPartB + intPartB * fracPartA + intPartB * fracPartB; <BUGE>  /* Compute the result.  (1+z)(tempA+tempB).  Order of operations is important.  For accuracy add by increasing size.  tempA is exact and much larger than the others.  If there are extra bits specified from the pow() function, use them. */ final double tempC = tempB + tempA; final double result; if (extra != 0.0) { result = tempC*extra*z + tempC*extra + tempC*z + tempB + tempA; } else { result = tempC*z + tempB + tempA; }
* * @param x   a double * @return double e<sup>x</sup> */ public static double exp(double x) { return exp(x, 0.0, null); }  /** * Internal helper method for exponential function. * @param x original argument of the exponential function * @param extra extra bits of precision on input (To Be Confirmed) * @param hiPrec extra bits of precision on output (To Be Confirmed) * @return exp(x) pow() function, use them. */ <BUGS> final double tempC = tempB + tempA; <BUGE> final double result; if (extra != 0.0) { result = tempC*extra*z + tempC*extra + tempC*z + tempB + tempA; } else { result = tempC*z + tempB + tempA; }  if (hiPrec != null) { /* If requesting high precision*/ hiPrec[0] = tempA; hiPrec[1] = tempC*extra*z + tempC*extra + tempC*z + tempB; }  return result;
* * @param x   a double * @return double e<sup>x</sup> */ public static double exp(double x) { return exp(x, 0.0, null); }  /** * Internal helper method for exponential function. * @param x original argument of the exponential function * @param extra extra bits of precision on input (To Be Confirmed) * @param hiPrec extra bits of precision on output (To Be Confirmed) * @return exp(x) final double result; <BUGS> if (extra != 0.0) { <BUGE> result = tempC*extra*z + tempC*extra + tempC*z + tempB + tempA; } else { result = tempC*z + tempB + tempA; }  if (hiPrec != null) { /* If requesting high precision*/ hiPrec[0] = tempA; hiPrec[1] = tempC*extra*z + tempC*extra + tempC*z + tempB; }  return result; }
* * @param x   a double * @return double e<sup>x</sup> */ public static double exp(double x) { return exp(x, 0.0, null); }  /** * Internal helper method for exponential function. * @param x original argument of the exponential function * @param extra extra bits of precision on input (To Be Confirmed) * @param hiPrec extra bits of precision on output (To Be Confirmed) * @return exp(x) } else { <BUGS> result = tempC*z + tempB + tempA; <BUGE> }  if (hiPrec != null) { /* If requesting high precision*/ hiPrec[0] = tempA; hiPrec[1] = tempC*extra*z + tempC*extra + tempC*z + tempB; }  return result; }  /** Compute exp(x) - 1 * @param x number to compute shifted exponential * @return exp(x) - 1
* * @param x   a double * @return double e<sup>x</sup> */ public static double exp(double x) { return exp(x, 0.0, null); }  /** * Internal helper method for exponential function. * @param x original argument of the exponential function * @param extra extra bits of precision on input (To Be Confirmed) * @param hiPrec extra bits of precision on output (To Be Confirmed) * @return exp(x)  <BUGS> if (hiPrec != null) { <BUGE> /* If requesting high precision*/ hiPrec[0] = tempA; hiPrec[1] = tempC*extra*z + tempC*extra + tempC*z + tempB; }  return result; }  /** Compute exp(x) - 1 * @param x number to compute shifted exponential * @return exp(x) - 1 */ public static double expm1(double x) { return expm1(x, null);
* * @param x   a double * @return double e<sup>x</sup> */ public static double exp(double x) { return exp(x, 0.0, null); }  /** * Internal helper method for exponential function. * @param x original argument of the exponential function * @param extra extra bits of precision on input (To Be Confirmed) * @param hiPrec extra bits of precision on output (To Be Confirmed) * @return exp(x)  <BUGS> return result; <BUGE> }  /** Compute exp(x) - 1 * @param x number to compute shifted exponential * @return exp(x) - 1 */ public static double expm1(double x) { return expm1(x, null); }  /** Internal helper method for expm1 * @param x number to compute shifted exponential * @param hiPrecOut receive high precision result for -1.0 < x < 1.0 * @return exp(x) - 1
*/ public PoissonDistributionImpl(double p, double epsilon, int maxIterations) { if (p <= 0) { throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.NOT_POSITIVE_POISSON_MEAN, p); } mean = p; normal = new NormalDistributionImpl(p, FastMath.sqrt(p)); this.epsilon = epsilon; this.maxIterations = maxIterations; }
*/ public PoissonDistributionImpl(double p, double epsilon, int maxIterations) { if (p <= 0) { throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.NOT_POSITIVE_POISSON_MEAN, p); } mean = p; normal = new NormalDistributionImpl(p, FastMath.sqrt(p)); this.epsilon = epsilon; this.maxIterations = maxIterations; }
*/ <BUGS> public PoissonDistributionImpl(double p, double epsilon, int maxIterations) { if (p <= 0) { throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.NOT_POSITIVE_POISSON_MEAN, p); <BUGE> } mean = p; normal = new NormalDistributionImpl(p, FastMath.sqrt(p)); this.epsilon = epsilon; this.maxIterations = maxIterations; }
*/ public PoissonDistributionImpl(double p, double epsilon, int maxIterations) { if (p <= 0) { throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.NOT_POSITIVE_POISSON_MEAN, p); } <BUGS> mean = p; normal = new NormalDistributionImpl(p, FastMath.sqrt(p)); this.epsilon = epsilon; this.maxIterations = maxIterations; } <BUGE>
@Override protected VectorialPointValuePair doOptimize() throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {  /* arrays shared with the other private methods*/ <BUGS> solvedCols  = Math.min(rows, cols); diagR       = new double[cols]; jacNorm     = new double[cols]; beta        = new double[cols]; permutation = new int[cols]; lmDir       = new double[cols]; <BUGE>  /* local point*/ double   delta   = 0; double   xNorm   = 0; double[] diag    = new double[cols]; double[] oldX    = new double[cols]; double[] oldRes  = new double[rows]; double[] work1   = new double[cols]; double[] work2   = new double[cols]; double[] work3   = new double[cols];  /* evaluate the function at the starting point and calculate its norm*/ updateResidualsAndCost();  /* outer loop*/ lmPar = 0; boolean firstIteration = true; VectorialPointValuePair current = new VectorialPointValuePair(point, objective); while (true) {
@Override protected VectorialPointValuePair doOptimize() throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {  /* arrays shared with the other private methods*/ solvedCols  = Math.min(rows, cols); diagR       = new double[cols]; jacNorm     = new double[cols]; beta        = new double[cols]; permutation = new int[cols]; lmDir       = new double[cols];  /* local point*/ <BUGS> double   delta   = 0; double   xNorm   = 0; double[] diag    = new double[cols]; double[] oldX    = new double[cols]; double[] oldRes  = new double[rows]; double[] work1   = new double[cols]; double[] work2   = new double[cols]; double[] work3   = new double[cols]; <BUGE>  /* evaluate the function at the starting point and calculate its norm*/ updateResidualsAndCost();  /* outer loop*/ lmPar = 0; boolean firstIteration = true; VectorialPointValuePair current = new VectorialPointValuePair(point, objective); while (true) {
@Override protected VectorialPointValuePair doOptimize() throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {  /* arrays shared with the other private methods*/ solvedCols  = Math.min(rows, cols); diagR       = new double[cols]; jacNorm     = new double[cols]; beta        = new double[cols]; permutation = new int[cols]; lmDir       = new double[cols];  /* local point*/ double   delta   = 0; double   xNorm   = 0; double[] diag    = new double[cols]; double[] oldX    = new double[cols]; double[] oldRes  = new double[rows]; double[] work1   = new double[cols]; double[] work2   = new double[cols]; double[] work3   = new double[cols];  /* evaluate the function at the starting point and calculate its norm*/ <BUGS> updateResidualsAndCost(); <BUGE>  /* outer loop*/ lmPar = 0; boolean firstIteration = true; VectorialPointValuePair current = new VectorialPointValuePair(point, objective); while (true) {
@Override protected VectorialPointValuePair doOptimize() throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {  /* arrays shared with the other private methods*/ solvedCols  = Math.min(rows, cols); diagR       = new double[cols]; jacNorm     = new double[cols]; beta        = new double[cols]; permutation = new int[cols]; lmDir       = new double[cols];  /* local point*/ double   delta   = 0; double   xNorm   = 0; double[] diag    = new double[cols]; double[] oldX    = new double[cols]; double[] oldRes  = new double[rows]; double[] work1   = new double[cols]; double[] work2   = new double[cols]; double[] work3   = new double[cols];  /* evaluate the function at the starting point and calculate its norm*/ updateResidualsAndCost();  /* outer loop*/ <BUGS> lmPar = 0; boolean firstIteration = true; VectorialPointValuePair current = new VectorialPointValuePair(point, objective); <BUGE> while (true) {
@Override protected VectorialPointValuePair doOptimize() throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {  /* arrays shared with the other private methods*/ solvedCols  = Math.min(rows, cols); diagR       = new double[cols]; jacNorm     = new double[cols]; beta        = new double[cols]; permutation = new int[cols]; lmDir       = new double[cols];  /* local point*/ double   delta   = 0; double   xNorm   = 0; double[] diag    = new double[cols]; double[] oldX    = new double[cols]; double[] oldRes  = new double[rows]; double[] work1   = new double[cols]; double[] work2   = new double[cols]; double[] work3   = new double[cols];  /* evaluate the function at the starting point and calculate its norm*/ updateResidualsAndCost();  /* outer loop*/ lmPar = 0; boolean firstIteration = true; VectorialPointValuePair current = new VectorialPointValuePair(point, objective); while (true) {
* Set the desired threshold for QR ranking. * <p> * If the squared norm of a column vector is smaller or equal to this threshold * during QR decomposition, it is considered to be a zero vector and hence the * rank of the matrix is reduced. * </p> * @param threshold threshold for QR ranking */ public void setQRRankingThreshold(final double threshold) { this.qrRankingThreshold = threshold; }  /** {@inheritDoc} */ /* compute the Q.R. decomposition of the jacobian matrix*/ <BUGS> VectorialPointValuePair previous = current; updateJacobian(); qrDecomposition(); <BUGE>  /* compute Qt.res*/ qTy(residuals); /* now we don't need Q anymore,*/ /* so let jacobian contain the R matrix with its diagonal elements*/ for (int k = 0; k < solvedCols; ++k) { int pk = permutation[k]; jacobian[k][pk] = diagR[pk]; }  if (firstIteration) {  /* scale the point according to the norms of the columns*/
/** * Set the desired threshold for QR ranking. * <p> * If the squared norm of a column vector is smaller or equal to this threshold * during QR decomposition, it is considered to be a zero vector and hence the * rank of the matrix is reduced. * </p> * @param threshold threshold for QR ranking */ public void setQRRankingThreshold(final double threshold) { this.qrRankingThreshold = threshold; }  /** {@inheritDoc} */ /* compute Qt.res*/ <BUGS> qTy(residuals); <BUGE> /* now we don't need Q anymore,*/ /* so let jacobian contain the R matrix with its diagonal elements*/ for (int k = 0; k < solvedCols; ++k) { int pk = permutation[k]; jacobian[k][pk] = diagR[pk]; }  if (firstIteration) {  /* scale the point according to the norms of the columns*/ /* of the initial jacobian*/ xNorm = 0; for (int k = 0; k < cols; ++k) { double dk = jacNorm[k];
* Set the desired threshold for QR ranking. * <p> * If the squared norm of a column vector is smaller or equal to this threshold * during QR decomposition, it is considered to be a zero vector and hence the * rank of the matrix is reduced. * </p> * @param threshold threshold for QR ranking */ public void setQRRankingThreshold(final double threshold) { this.qrRankingThreshold = threshold; }  /** {@inheritDoc} */ /* so let jacobian contain the R matrix with its diagonal elements*/ <BUGS> for (int k = 0; k < solvedCols; ++k) { int pk = permutation[k]; jacobian[k][pk] = diagR[pk]; <BUGE> }  if (firstIteration) {  /* scale the point according to the norms of the columns*/ /* of the initial jacobian*/ xNorm = 0; for (int k = 0; k < cols; ++k) { double dk = jacNorm[k]; if (dk == 0) { dk = 1.0; } double xk = dk * point[k];
/** * Set the desired threshold for QR ranking. * <p> * If the squared norm of a column vector is smaller or equal to this threshold * during QR decomposition, it is considered to be a zero vector and hence the * rank of the matrix is reduced. * </p> * @param threshold threshold for QR ranking */ public void setQRRankingThreshold(final double threshold) { this.qrRankingThreshold = threshold; }  /** {@inheritDoc} */  <BUGS> if (firstIteration) { <BUGE>  /* scale the point according to the norms of the columns*/ /* of the initial jacobian*/ xNorm = 0; for (int k = 0; k < cols; ++k) { double dk = jacNorm[k]; if (dk == 0) { dk = 1.0; } double xk = dk * point[k]; xNorm  += xk * xk; diag[k] = dk; } xNorm = Math.sqrt(xNorm);
* Set the desired threshold for QR ranking. * <p> * If the squared norm of a column vector is smaller or equal to this threshold * during QR decomposition, it is considered to be a zero vector and hence the * rank of the matrix is reduced. * </p> * @param threshold threshold for QR ranking */ public void setQRRankingThreshold(final double threshold) { this.qrRankingThreshold = threshold; }  /** {@inheritDoc} */ /* of the initial jacobian*/ <BUGS> xNorm = 0; for (int k = 0; k < cols; ++k) { double dk = jacNorm[k]; if (dk == 0) { <BUGE> dk = 1.0; } double xk = dk * point[k]; xNorm  += xk * xk; diag[k] = dk; } xNorm = Math.sqrt(xNorm);  /* initialize the step bound delta*/ delta = (xNorm == 0) ? initialStepBoundFactor : (initialStepBoundFactor * xNorm);  }
* Set the desired threshold for QR ranking. * <p> * If the squared norm of a column vector is smaller or equal to this threshold * during QR decomposition, it is considered to be a zero vector and hence the * rank of the matrix is reduced. * </p> * @param threshold threshold for QR ranking */ public void setQRRankingThreshold(final double threshold) { this.qrRankingThreshold = threshold; }  /** {@inheritDoc} */ } <BUGS> double xk = dk * point[k]; xNorm  += xk * xk; diag[k] = dk; <BUGE> } xNorm = Math.sqrt(xNorm);  /* initialize the step bound delta*/ delta = (xNorm == 0) ? initialStepBoundFactor : (initialStepBoundFactor * xNorm);  }  /* check orthogonality between function vector and jacobian columns*/ double maxCosine = 0; if (cost != 0) { for (int j = 0; j < solvedCols; ++j) { int    pj = permutation[j];
/** * Set the desired threshold for QR ranking. * <p> * If the squared norm of a column vector is smaller or equal to this threshold * during QR decomposition, it is considered to be a zero vector and hence the * rank of the matrix is reduced. * </p> * @param threshold threshold for QR ranking */ public void setQRRankingThreshold(final double threshold) { this.qrRankingThreshold = threshold; }  /** {@inheritDoc} */ } <BUGS> xNorm = Math.sqrt(xNorm); <BUGE>  /* initialize the step bound delta*/ delta = (xNorm == 0) ? initialStepBoundFactor : (initialStepBoundFactor * xNorm);  }  /* check orthogonality between function vector and jacobian columns*/ double maxCosine = 0; if (cost != 0) { for (int j = 0; j < solvedCols; ++j) { int    pj = permutation[j]; double s  = jacNorm[pj]; if (s != 0) { double sum = 0;
/** * Set the desired threshold for QR ranking. * <p> * If the squared norm of a column vector is smaller or equal to this threshold * during QR decomposition, it is considered to be a zero vector and hence the * rank of the matrix is reduced. * </p> * @param threshold threshold for QR ranking */ public void setQRRankingThreshold(final double threshold) { this.qrRankingThreshold = threshold; }  /** {@inheritDoc} */ /* initialize the step bound delta*/ <BUGS> delta = (xNorm == 0) ? initialStepBoundFactor : (initialStepBoundFactor * xNorm); <BUGE>  }  /* check orthogonality between function vector and jacobian columns*/ double maxCosine = 0; if (cost != 0) { for (int j = 0; j < solvedCols; ++j) { int    pj = permutation[j]; double s  = jacNorm[pj]; if (s != 0) { double sum = 0; for (int i = 0; i <= j; ++i) { sum += jacobian[i][pj] * residuals[i]; }
* during QR decomposition, it is considered to be a zero vector and hence the * rank of the matrix is reduced. * </p> * @param threshold threshold for QR ranking */ public void setQRRankingThreshold(final double threshold) { this.qrRankingThreshold = threshold; }  /** {@inheritDoc} */ /* check orthogonality between function vector and jacobian columns*/ <BUGS> double maxCosine = 0; if (cost != 0) { for (int j = 0; j < solvedCols; ++j) { int    pj = permutation[j]; double s  = jacNorm[pj]; if (s != 0) { double sum = 0; for (int i = 0; i <= j; ++i) { sum += jacobian[i][pj] * residuals[i]; <BUGE> } maxCosine = Math.max(maxCosine, Math.abs(sum) / (s * cost)); } } } if (maxCosine <= orthoTolerance) { /* convergence has been reached*/ return current; }
/** * Set the desired threshold for QR ranking. * <p> * If the squared norm of a column vector is smaller or equal to this threshold * during QR decomposition, it is considered to be a zero vector and hence the * rank of the matrix is reduced. * </p> * @param threshold threshold for QR ranking */ public void setQRRankingThreshold(final double threshold) { this.qrRankingThreshold = threshold; }  /** {@inheritDoc} */ } <BUGS> maxCosine = Math.max(maxCosine, Math.abs(sum) / (s * cost)); <BUGE> } } } if (maxCosine <= orthoTolerance) { /* convergence has been reached*/ return current; }  /* rescale if necessary*/ for (int j = 0; j < cols; ++j) { diag[j] = Math.max(diag[j], jacNorm[j]); }  /* inner loop*/
/** * Set the desired threshold for QR ranking. * <p> * If the squared norm of a column vector is smaller or equal to this threshold * during QR decomposition, it is considered to be a zero vector and hence the * rank of the matrix is reduced. * </p> * @param threshold threshold for QR ranking */ public void setQRRankingThreshold(final double threshold) { this.qrRankingThreshold = threshold; }  /** {@inheritDoc} */ } <BUGS> if (maxCosine <= orthoTolerance) { <BUGE> /* convergence has been reached*/ return current; }  /* rescale if necessary*/ for (int j = 0; j < cols; ++j) { diag[j] = Math.max(diag[j], jacNorm[j]); }  /* inner loop*/ for (double ratio = 0; ratio < 1.0e-4;) {  /* save the state*/ for (int j = 0; j < solvedCols; ++j) {
/** * Set the desired threshold for QR ranking. * <p> * If the squared norm of a column vector is smaller or equal to this threshold * during QR decomposition, it is considered to be a zero vector and hence the * rank of the matrix is reduced. * </p> * @param threshold threshold for QR ranking */ public void setQRRankingThreshold(final double threshold) { this.qrRankingThreshold = threshold; }  /** {@inheritDoc} */ /* rescale if necessary*/ <BUGS> for (int j = 0; j < cols; ++j) { diag[j] = Math.max(diag[j], jacNorm[j]); <BUGE> }  /* inner loop*/ for (double ratio = 0; ratio < 1.0e-4;) {  /* save the state*/ for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; oldX[pj] = point[pj]; } double previousCost = cost; double[] tmpVec = residuals; residuals = oldRes;
/** * Set the desired threshold for QR ranking. * <p> * If the squared norm of a column vector is smaller or equal to this threshold * during QR decomposition, it is considered to be a zero vector and hence the * rank of the matrix is reduced. * </p> * @param threshold threshold for QR ranking */ public void setQRRankingThreshold(final double threshold) { this.qrRankingThreshold = threshold; }  /** {@inheritDoc} */ /* inner loop*/ <BUGS> for (double ratio = 0; ratio < 1.0e-4;) { <BUGE>  /* save the state*/ for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; oldX[pj] = point[pj]; } double previousCost = cost; double[] tmpVec = residuals; residuals = oldRes; oldRes    = tmpVec;  /* determine the Levenberg-Marquardt parameter*/ determineLMParameter(oldRes, delta, diag, work1, work2, work3);
* Set the desired threshold for QR ranking. * <p> * If the squared norm of a column vector is smaller or equal to this threshold * during QR decomposition, it is considered to be a zero vector and hence the * rank of the matrix is reduced. * </p> * @param threshold threshold for QR ranking */ public void setQRRankingThreshold(final double threshold) { this.qrRankingThreshold = threshold; }  /** {@inheritDoc} */ /* save the state*/ <BUGS> for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; oldX[pj] = point[pj]; <BUGE> } double previousCost = cost; double[] tmpVec = residuals; residuals = oldRes; oldRes    = tmpVec;  /* determine the Levenberg-Marquardt parameter*/ determineLMParameter(oldRes, delta, diag, work1, work2, work3);  /* compute the new point and the norm of the evolution direction*/ double lmNorm = 0; for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j];
* Set the desired threshold for QR ranking. * <p> * If the squared norm of a column vector is smaller or equal to this threshold * during QR decomposition, it is considered to be a zero vector and hence the * rank of the matrix is reduced. * </p> * @param threshold threshold for QR ranking */ public void setQRRankingThreshold(final double threshold) { this.qrRankingThreshold = threshold; }  /** {@inheritDoc} */ } <BUGS> double previousCost = cost; double[] tmpVec = residuals; residuals = oldRes; oldRes    = tmpVec; <BUGE>  /* determine the Levenberg-Marquardt parameter*/ determineLMParameter(oldRes, delta, diag, work1, work2, work3);  /* compute the new point and the norm of the evolution direction*/ double lmNorm = 0; for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; lmDir[pj] = -lmDir[pj]; point[pj] = oldX[pj] + lmDir[pj]; double s = diag[pj] * lmDir[pj]; lmNorm  += s * s;
/** * Set the desired threshold for QR ranking. * <p> * If the squared norm of a column vector is smaller or equal to this threshold * during QR decomposition, it is considered to be a zero vector and hence the * rank of the matrix is reduced. * </p> * @param threshold threshold for QR ranking */ public void setQRRankingThreshold(final double threshold) { this.qrRankingThreshold = threshold; }  /** {@inheritDoc} */ /* determine the Levenberg-Marquardt parameter*/ <BUGS> determineLMParameter(oldRes, delta, diag, work1, work2, work3); <BUGE>  /* compute the new point and the norm of the evolution direction*/ double lmNorm = 0; for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; lmDir[pj] = -lmDir[pj]; point[pj] = oldX[pj] + lmDir[pj]; double s = diag[pj] * lmDir[pj]; lmNorm  += s * s; } lmNorm = Math.sqrt(lmNorm); /* on the first iteration, adjust the initial step bound.*/ if (firstIteration) { delta = Math.min(delta, lmNorm);
* If the squared norm of a column vector is smaller or equal to this threshold * during QR decomposition, it is considered to be a zero vector and hence the * rank of the matrix is reduced. * </p> * @param threshold threshold for QR ranking */ public void setQRRankingThreshold(final double threshold) { this.qrRankingThreshold = threshold; }  /** {@inheritDoc} */ /* compute the new point and the norm of the evolution direction*/ <BUGS> double lmNorm = 0; for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; lmDir[pj] = -lmDir[pj]; point[pj] = oldX[pj] + lmDir[pj]; double s = diag[pj] * lmDir[pj]; lmNorm  += s * s; <BUGE> } lmNorm = Math.sqrt(lmNorm); /* on the first iteration, adjust the initial step bound.*/ if (firstIteration) { delta = Math.min(delta, lmNorm); }  /* evaluate the function at x + p and calculate its norm*/ updateResidualsAndCost(); current = new VectorialPointValuePair(point, objective);
/** * Set the desired threshold for QR ranking. * <p> * If the squared norm of a column vector is smaller or equal to this threshold * during QR decomposition, it is considered to be a zero vector and hence the * rank of the matrix is reduced. * </p> * @param threshold threshold for QR ranking */ public void setQRRankingThreshold(final double threshold) { this.qrRankingThreshold = threshold; }  /** {@inheritDoc} */ } <BUGS> lmNorm = Math.sqrt(lmNorm); <BUGE> /* on the first iteration, adjust the initial step bound.*/ if (firstIteration) { delta = Math.min(delta, lmNorm); }  /* evaluate the function at x + p and calculate its norm*/ updateResidualsAndCost(); current = new VectorialPointValuePair(point, objective);  /* compute the scaled actual reduction*/ double actRed = -1.0; if (0.1 * cost < previousCost) { double r = cost / previousCost; actRed = 1.0 - r * r;
/** * Set the desired threshold for QR ranking. * <p> * If the squared norm of a column vector is smaller or equal to this threshold * during QR decomposition, it is considered to be a zero vector and hence the * rank of the matrix is reduced. * </p> * @param threshold threshold for QR ranking */ public void setQRRankingThreshold(final double threshold) { this.qrRankingThreshold = threshold; }  /** {@inheritDoc} */ /* on the first iteration, adjust the initial step bound.*/ <BUGS> if (firstIteration) { delta = Math.min(delta, lmNorm); <BUGE> }  /* evaluate the function at x + p and calculate its norm*/ updateResidualsAndCost(); current = new VectorialPointValuePair(point, objective);  /* compute the scaled actual reduction*/ double actRed = -1.0; if (0.1 * cost < previousCost) { double r = cost / previousCost; actRed = 1.0 - r * r; }
/** * Set the desired threshold for QR ranking. * <p> * If the squared norm of a column vector is smaller or equal to this threshold * during QR decomposition, it is considered to be a zero vector and hence the * rank of the matrix is reduced. * </p> * @param threshold threshold for QR ranking */ public void setQRRankingThreshold(final double threshold) { this.qrRankingThreshold = threshold; }  /** {@inheritDoc} */ /* evaluate the function at x + p and calculate its norm*/ <BUGS> updateResidualsAndCost(); current = new VectorialPointValuePair(point, objective); <BUGE>  /* compute the scaled actual reduction*/ double actRed = -1.0; if (0.1 * cost < previousCost) { double r = cost / previousCost; actRed = 1.0 - r * r; }  /* compute the scaled predicted reduction*/ /* and the scaled directional derivative*/ for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; double dirJ = lmDir[pj];
* Set the desired threshold for QR ranking. * <p> * If the squared norm of a column vector is smaller or equal to this threshold * during QR decomposition, it is considered to be a zero vector and hence the * rank of the matrix is reduced. * </p> * @param threshold threshold for QR ranking */ public void setQRRankingThreshold(final double threshold) { this.qrRankingThreshold = threshold; }  /** {@inheritDoc} */ /* compute the scaled actual reduction*/ <BUGS> double actRed = -1.0; if (0.1 * cost < previousCost) { double r = cost / previousCost; actRed = 1.0 - r * r; <BUGE> }  /* compute the scaled predicted reduction*/ /* and the scaled directional derivative*/ for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; double dirJ = lmDir[pj]; work1[j] = 0; for (int i = 0; i <= j; ++i) { work1[i] += jacobian[i][pj] * dirJ; } }
* <p> * If the squared norm of a column vector is smaller or equal to this threshold * during QR decomposition, it is considered to be a zero vector and hence the * rank of the matrix is reduced. * </p> * @param threshold threshold for QR ranking */ public void setQRRankingThreshold(final double threshold) { this.qrRankingThreshold = threshold; }  /** {@inheritDoc} */ /* and the scaled directional derivative*/ <BUGS> for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; double dirJ = lmDir[pj]; work1[j] = 0; for (int i = 0; i <= j; ++i) { work1[i] += jacobian[i][pj] * dirJ; <BUGE> } } double coeff1 = 0; for (int j = 0; j < solvedCols; ++j) { coeff1 += work1[j] * work1[j]; } double pc2 = previousCost * previousCost; coeff1 = coeff1 / pc2; double coeff2 = lmPar * lmNorm * lmNorm / pc2; double preRed = coeff1 + 2 * coeff2; double dirDer = -(coeff1 + coeff2);
* Set the desired threshold for QR ranking. * <p> * If the squared norm of a column vector is smaller or equal to this threshold * during QR decomposition, it is considered to be a zero vector and hence the * rank of the matrix is reduced. * </p> * @param threshold threshold for QR ranking */ public void setQRRankingThreshold(final double threshold) { this.qrRankingThreshold = threshold; }  /** {@inheritDoc} */ } <BUGS> double coeff1 = 0; for (int j = 0; j < solvedCols; ++j) { coeff1 += work1[j] * work1[j]; <BUGE> } double pc2 = previousCost * previousCost; coeff1 = coeff1 / pc2; double coeff2 = lmPar * lmNorm * lmNorm / pc2; double preRed = coeff1 + 2 * coeff2; double dirDer = -(coeff1 + coeff2);  /* ratio of the actual to the predicted reduction*/ ratio = (preRed == 0) ? 0 : (actRed / preRed);  /* update the step bound*/ if (ratio <= 0.25) { double tmp =
* <p> * If the squared norm of a column vector is smaller or equal to this threshold * during QR decomposition, it is considered to be a zero vector and hence the * rank of the matrix is reduced. * </p> * @param threshold threshold for QR ranking */ public void setQRRankingThreshold(final double threshold) { this.qrRankingThreshold = threshold; }  /** {@inheritDoc} */ } <BUGS> double pc2 = previousCost * previousCost; coeff1 = coeff1 / pc2; double coeff2 = lmPar * lmNorm * lmNorm / pc2; double preRed = coeff1 + 2 * coeff2; double dirDer = -(coeff1 + coeff2); <BUGE>  /* ratio of the actual to the predicted reduction*/ ratio = (preRed == 0) ? 0 : (actRed / preRed);  /* update the step bound*/ if (ratio <= 0.25) { double tmp = (actRed < 0) ? (0.5 * dirDer / (dirDer + 0.5 * actRed)) : 0.5; if ((0.1 * cost >= previousCost) || (tmp < 0.1)) { tmp = 0.1; } delta = tmp * Math.min(delta, 10.0 * lmNorm);
/** * Set the desired threshold for QR ranking. * <p> * If the squared norm of a column vector is smaller or equal to this threshold * during QR decomposition, it is considered to be a zero vector and hence the * rank of the matrix is reduced. * </p> * @param threshold threshold for QR ranking */ public void setQRRankingThreshold(final double threshold) { this.qrRankingThreshold = threshold; }  /** {@inheritDoc} */ /* ratio of the actual to the predicted reduction*/ <BUGS> ratio = (preRed == 0) ? 0 : (actRed / preRed); <BUGE>  /* update the step bound*/ if (ratio <= 0.25) { double tmp = (actRed < 0) ? (0.5 * dirDer / (dirDer + 0.5 * actRed)) : 0.5; if ((0.1 * cost >= previousCost) || (tmp < 0.1)) { tmp = 0.1; } delta = tmp * Math.min(delta, 10.0 * lmNorm); lmPar /= tmp; } else if ((lmPar == 0) || (ratio >= 0.75)) { delta = 2 * lmNorm; lmPar *= 0.5; }
/** * Set the desired threshold for QR ranking. * <p> * If the squared norm of a column vector is smaller or equal to this threshold * during QR decomposition, it is considered to be a zero vector and hence the * rank of the matrix is reduced. * </p> * @param threshold threshold for QR ranking */ public void setQRRankingThreshold(final double threshold) { this.qrRankingThreshold = threshold; }  /** {@inheritDoc} */ /* update the step bound*/ <BUGS> if (ratio <= 0.25) { double tmp = <BUGE> (actRed < 0) ? (0.5 * dirDer / (dirDer + 0.5 * actRed)) : 0.5; if ((0.1 * cost >= previousCost) || (tmp < 0.1)) { tmp = 0.1; } delta = tmp * Math.min(delta, 10.0 * lmNorm); lmPar /= tmp; } else if ((lmPar == 0) || (ratio >= 0.75)) { delta = 2 * lmNorm; lmPar *= 0.5; }  /* test for successful iteration.*/ if (ratio >= 1.0e-4) {
/** * Set the desired threshold for QR ranking. * <p> * If the squared norm of a column vector is smaller or equal to this threshold * during QR decomposition, it is considered to be a zero vector and hence the * rank of the matrix is reduced. * </p> * @param threshold threshold for QR ranking */ public void setQRRankingThreshold(final double threshold) { this.qrRankingThreshold = threshold; }  /** {@inheritDoc} */ (actRed < 0) ? (0.5 * dirDer / (dirDer + 0.5 * actRed)) : 0.5; <BUGS> if ((0.1 * cost >= previousCost) || (tmp < 0.1)) { tmp = 0.1; <BUGE> } delta = tmp * Math.min(delta, 10.0 * lmNorm); lmPar /= tmp; } else if ((lmPar == 0) || (ratio >= 0.75)) { delta = 2 * lmNorm; lmPar *= 0.5; }  /* test for successful iteration.*/ if (ratio >= 1.0e-4) { /* successful iteration, update the norm*/ firstIteration = false; xNorm = 0;
* <p> * If the squared norm of a column vector is smaller or equal to this threshold * during QR decomposition, it is considered to be a zero vector and hence the * rank of the matrix is reduced. * </p> * @param threshold threshold for QR ranking */ public void setQRRankingThreshold(final double threshold) { this.qrRankingThreshold = threshold; }  /** {@inheritDoc} */ } <BUGS> delta = tmp * Math.min(delta, 10.0 * lmNorm); lmPar /= tmp; } else if ((lmPar == 0) || (ratio >= 0.75)) { delta = 2 * lmNorm; lmPar *= 0.5; <BUGE> }  /* test for successful iteration.*/ if (ratio >= 1.0e-4) { /* successful iteration, update the norm*/ firstIteration = false; xNorm = 0; for (int k = 0; k < cols; ++k) { double xK = diag[k] * point[k]; xNorm    += xK * xK; } xNorm = Math.sqrt(xNorm);
/** * Set the desired threshold for QR ranking. * <p> * If the squared norm of a column vector is smaller or equal to this threshold * during QR decomposition, it is considered to be a zero vector and hence the * rank of the matrix is reduced. * </p> * @param threshold threshold for QR ranking */ public void setQRRankingThreshold(final double threshold) { this.qrRankingThreshold = threshold; }  /** {@inheritDoc} */ /* test for successful iteration.*/ <BUGS> if (ratio >= 1.0e-4) { <BUGE> /* successful iteration, update the norm*/ firstIteration = false; xNorm = 0; for (int k = 0; k < cols; ++k) { double xK = diag[k] * point[k]; xNorm    += xK * xK; } xNorm = Math.sqrt(xNorm);  /* tests for convergence.*/ /* we use the vectorial convergence checker*/ } else { /* failed iteration, reset the previous values*/ cost = previousCost;
* <p> * If the squared norm of a column vector is smaller or equal to this threshold * during QR decomposition, it is considered to be a zero vector and hence the * rank of the matrix is reduced. * </p> * @param threshold threshold for QR ranking */ public void setQRRankingThreshold(final double threshold) { this.qrRankingThreshold = threshold; }  /** {@inheritDoc} */ /* successful iteration, update the norm*/ <BUGS> firstIteration = false; xNorm = 0; for (int k = 0; k < cols; ++k) { double xK = diag[k] * point[k]; xNorm    += xK * xK; <BUGE> } xNorm = Math.sqrt(xNorm);  /* tests for convergence.*/ /* we use the vectorial convergence checker*/ } else { /* failed iteration, reset the previous values*/ cost = previousCost; for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; point[pj] = oldX[pj]; }
/** * Set the desired threshold for QR ranking. * <p> * If the squared norm of a column vector is smaller or equal to this threshold * during QR decomposition, it is considered to be a zero vector and hence the * rank of the matrix is reduced. * </p> * @param threshold threshold for QR ranking */ public void setQRRankingThreshold(final double threshold) { this.qrRankingThreshold = threshold; }  /** {@inheritDoc} */ } <BUGS> xNorm = Math.sqrt(xNorm); <BUGE>  /* tests for convergence.*/ /* we use the vectorial convergence checker*/ } else { /* failed iteration, reset the previous values*/ cost = previousCost; for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; point[pj] = oldX[pj]; } tmpVec    = residuals; residuals = oldRes; oldRes    = tmpVec; }
* Set the desired threshold for QR ranking. * <p> * If the squared norm of a column vector is smaller or equal to this threshold * during QR decomposition, it is considered to be a zero vector and hence the * rank of the matrix is reduced. * </p> * @param threshold threshold for QR ranking */ public void setQRRankingThreshold(final double threshold) { this.qrRankingThreshold = threshold; }  /** {@inheritDoc} */ /* failed iteration, reset the previous values*/ <BUGS> cost = previousCost; for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; point[pj] = oldX[pj]; <BUGE> } tmpVec    = residuals; residuals = oldRes; oldRes    = tmpVec; } if (checker==null) { if (((Math.abs(actRed) <= costRelativeTolerance) && (preRed <= costRelativeTolerance) && (ratio <= 2.0)) || (delta <= parRelativeTolerance * xNorm)) { return current; }
* Set the desired threshold for QR ranking. * <p> * If the squared norm of a column vector is smaller or equal to this threshold * during QR decomposition, it is considered to be a zero vector and hence the * rank of the matrix is reduced. * </p> * @param threshold threshold for QR ranking */ public void setQRRankingThreshold(final double threshold) { this.qrRankingThreshold = threshold; }  /** {@inheritDoc} */ } <BUGS> tmpVec    = residuals; residuals = oldRes; oldRes    = tmpVec; <BUGE> } if (checker==null) { if (((Math.abs(actRed) <= costRelativeTolerance) && (preRed <= costRelativeTolerance) && (ratio <= 2.0)) || (delta <= parRelativeTolerance * xNorm)) { return current; } } else { if (checker.converged(getIterations(), previous, current)) { return current; } }
/** * Set the desired threshold for QR ranking. * <p> * If the squared norm of a column vector is smaller or equal to this threshold * during QR decomposition, it is considered to be a zero vector and hence the * rank of the matrix is reduced. * </p> * @param threshold threshold for QR ranking */ public void setQRRankingThreshold(final double threshold) { this.qrRankingThreshold = threshold; }  /** {@inheritDoc} */ } <BUGS> if (checker==null) { if (((Math.abs(actRed) <= costRelativeTolerance) && <BUGE> (preRed <= costRelativeTolerance) && (ratio <= 2.0)) || (delta <= parRelativeTolerance * xNorm)) { return current; } } else { if (checker.converged(getIterations(), previous, current)) { return current; } } /* tests for termination and stringent tolerances*/ /* (2.2204e-16 is the machine epsilon for IEEE754)*/ if ((Math.abs(actRed) <= 2.2204e-16) && (preRed <= 2.2204e-16) && (ratio <= 2.0)) {
/** * Set the desired threshold for QR ranking. * <p> * If the squared norm of a column vector is smaller or equal to this threshold * during QR decomposition, it is considered to be a zero vector and hence the * rank of the matrix is reduced. * </p> * @param threshold threshold for QR ranking */ public void setQRRankingThreshold(final double threshold) { this.qrRankingThreshold = threshold; }  /** {@inheritDoc} */ (delta <= parRelativeTolerance * xNorm)) { <BUGS> return current; <BUGE> } } else { if (checker.converged(getIterations(), previous, current)) { return current; } } /* tests for termination and stringent tolerances*/ /* (2.2204e-16 is the machine epsilon for IEEE754)*/ if ((Math.abs(actRed) <= 2.2204e-16) && (preRed <= 2.2204e-16) && (ratio <= 2.0)) { throw new OptimizationException(LocalizedFormats.TOO_SMALL_COST_RELATIVE_TOLERANCE, costRelativeTolerance); } else if (delta <= 2.2204e-16 * xNorm) { throw new OptimizationException(LocalizedFormats.TOO_SMALL_PARAMETERS_RELATIVE_TOLERANCE, parRelativeTolerance);
/** * Set the desired threshold for QR ranking. * <p> * If the squared norm of a column vector is smaller or equal to this threshold * during QR decomposition, it is considered to be a zero vector and hence the * rank of the matrix is reduced. * </p> * @param threshold threshold for QR ranking */ public void setQRRankingThreshold(final double threshold) { this.qrRankingThreshold = threshold; }  /** {@inheritDoc} */ /* (2.2204e-16 is the machine epsilon for IEEE754)*/ <BUGS> if ((Math.abs(actRed) <= 2.2204e-16) && (preRed <= 2.2204e-16) && (ratio <= 2.0)) { <BUGE> throw new OptimizationException(LocalizedFormats.TOO_SMALL_COST_RELATIVE_TOLERANCE, costRelativeTolerance); } else if (delta <= 2.2204e-16 * xNorm) { throw new OptimizationException(LocalizedFormats.TOO_SMALL_PARAMETERS_RELATIVE_TOLERANCE, parRelativeTolerance); } else if (maxCosine <= 2.2204e-16)  { throw new OptimizationException(LocalizedFormats.TOO_SMALL_ORTHOGONALITY_TOLERANCE, orthoTolerance); }  }  }
/** * Set the desired threshold for QR ranking. * <p> * If the squared norm of a column vector is smaller or equal to this threshold * during QR decomposition, it is considered to be a zero vector and hence the * rank of the matrix is reduced. * </p> * @param threshold threshold for QR ranking */ public void setQRRankingThreshold(final double threshold) { this.qrRankingThreshold = threshold; }  /** {@inheritDoc} */ costRelativeTolerance); <BUGS> } else if (delta <= 2.2204e-16 * xNorm) { <BUGE> throw new OptimizationException(LocalizedFormats.TOO_SMALL_PARAMETERS_RELATIVE_TOLERANCE, parRelativeTolerance); } else if (maxCosine <= 2.2204e-16)  { throw new OptimizationException(LocalizedFormats.TOO_SMALL_ORTHOGONALITY_TOLERANCE, orthoTolerance); }  }  }  }  /**
/** * Set the desired threshold for QR ranking. * <p> * If the squared norm of a column vector is smaller or equal to this threshold * during QR decomposition, it is considered to be a zero vector and hence the * rank of the matrix is reduced. * </p> * @param threshold threshold for QR ranking */ public void setQRRankingThreshold(final double threshold) { this.qrRankingThreshold = threshold; }  /** {@inheritDoc} */ parRelativeTolerance); <BUGS> } else if (maxCosine <= 2.2204e-16)  { <BUGE> throw new OptimizationException(LocalizedFormats.TOO_SMALL_ORTHOGONALITY_TOLERANCE, orthoTolerance); }  }  }  }  /** * Determine the Levenberg-Marquardt parameter. * <p>This implementation is a translation in Java of the MINPACK * <a href="http:/*www.netlib.org/minpack/lmpar.f">lmpar</a>*/
/** * Set the desired threshold for QR ranking. * <p> * If the squared norm of a column vector is smaller or equal to this threshold * during QR decomposition, it is considered to be a zero vector and hence the * rank of the matrix is reduced. * </p> * @param threshold threshold for QR ranking */ public void setQRRankingThreshold(final double threshold) { this.qrRankingThreshold = threshold; }  /** {@inheritDoc} */  <BUGS> } <BUGE>  }  }  /** * Determine the Levenberg-Marquardt parameter. * <p>This implementation is a translation in Java of the MINPACK * <a href="http:/*www.netlib.org/minpack/lmpar.f">lmpar</a>*/ * routine.</p> * <p>This method sets the lmPar and lmDir attributes.</p> * <p>The authors of the original fortran function are:</p> * <ul> *   <li>Argonne National Laboratory. MINPACK project. March 1980</li>
/** * Set the desired threshold for QR ranking. * <p> * If the squared norm of a column vector is smaller or equal to this threshold * during QR decomposition, it is considered to be a zero vector and hence the * rank of the matrix is reduced. * </p> * @param threshold threshold for QR ranking */ public void setQRRankingThreshold(final double threshold) { this.qrRankingThreshold = threshold; }  /** {@inheritDoc} */  <BUGS> } <BUGE>  }  /** * Determine the Levenberg-Marquardt parameter. * <p>This implementation is a translation in Java of the MINPACK * <a href="http:/*www.netlib.org/minpack/lmpar.f">lmpar</a>*/ * routine.</p> * <p>This method sets the lmPar and lmDir attributes.</p> * <p>The authors of the original fortran function are:</p> * <ul> *   <li>Argonne National Laboratory. MINPACK project. March 1980</li> *   <li>Burton  S. Garbow</li> *   <li>Kenneth E. Hillstrom</li>
*/ public double getChiSquare() { <BUGS> double chiSquare = 0; for (int i = 0; i < rows; ++i) { final double residual = residuals[i]; chiSquare += residual * residual / residualsWeights[i]; <BUGE> } return chiSquare; }
*/ public double getChiSquare() { double chiSquare = 0; for (int i = 0; i < rows; ++i) { final double residual = residuals[i]; chiSquare += residual * residual / residualsWeights[i]; } <BUGS> return chiSquare; <BUGE> }
/** {@inheritDoc} */
/** {@inheritDoc} */
@Override protected VectorialPointValuePair doOptimize() throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {  /* arrays shared with the other private methods*/ <BUGS> solvedCols  = Math.min(rows, cols); diagR       = new double[cols]; jacNorm     = new double[cols]; beta        = new double[cols]; permutation = new int[cols]; lmDir       = new double[cols]; <BUGE>  /* local point*/ double   delta   = 0; double   xNorm   = 0; double[] diag    = new double[cols]; double[] oldX    = new double[cols]; double[] oldRes  = new double[rows]; double[] work1   = new double[cols]; double[] work2   = new double[cols]; double[] work3   = new double[cols];  /* evaluate the function at the starting point and calculate its norm*/ updateResidualsAndCost();  /* outer loop*/ lmPar = 0; boolean firstIteration = true; while (true) {
@Override protected VectorialPointValuePair doOptimize() throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {  /* arrays shared with the other private methods*/ solvedCols  = Math.min(rows, cols); diagR       = new double[cols]; jacNorm     = new double[cols]; beta        = new double[cols]; permutation = new int[cols]; lmDir       = new double[cols];  /* local point*/ <BUGS> double   delta   = 0; double   xNorm   = 0; double[] diag    = new double[cols]; double[] oldX    = new double[cols]; double[] oldRes  = new double[rows]; double[] work1   = new double[cols]; double[] work2   = new double[cols]; double[] work3   = new double[cols]; <BUGE>  /* evaluate the function at the starting point and calculate its norm*/ updateResidualsAndCost();  /* outer loop*/ lmPar = 0; boolean firstIteration = true; while (true) {
@Override protected VectorialPointValuePair doOptimize() throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {  /* arrays shared with the other private methods*/ solvedCols  = Math.min(rows, cols); diagR       = new double[cols]; jacNorm     = new double[cols]; beta        = new double[cols]; permutation = new int[cols]; lmDir       = new double[cols];  /* local point*/ double   delta   = 0; double   xNorm   = 0; double[] diag    = new double[cols]; double[] oldX    = new double[cols]; double[] oldRes  = new double[rows]; double[] work1   = new double[cols]; double[] work2   = new double[cols]; double[] work3   = new double[cols];  /* evaluate the function at the starting point and calculate its norm*/ <BUGS> updateResidualsAndCost(); <BUGE>  /* outer loop*/ lmPar = 0; boolean firstIteration = true; while (true) {
@Override protected VectorialPointValuePair doOptimize() throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {  /* arrays shared with the other private methods*/ solvedCols  = Math.min(rows, cols); diagR       = new double[cols]; jacNorm     = new double[cols]; beta        = new double[cols]; permutation = new int[cols]; lmDir       = new double[cols];  /* local point*/ double   delta   = 0; double   xNorm   = 0; double[] diag    = new double[cols]; double[] oldX    = new double[cols]; double[] oldRes  = new double[rows]; double[] work1   = new double[cols]; double[] work2   = new double[cols]; double[] work3   = new double[cols];  /* evaluate the function at the starting point and calculate its norm*/ updateResidualsAndCost();  /* outer loop*/ <BUGS> lmPar = 0; boolean firstIteration = true; <BUGE> while (true) {
@Override protected VectorialPointValuePair doOptimize() throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {  /* arrays shared with the other private methods*/ solvedCols  = Math.min(rows, cols); diagR       = new double[cols]; jacNorm     = new double[cols]; beta        = new double[cols]; permutation = new int[cols]; lmDir       = new double[cols];  /* local point*/ double   delta   = 0; double   xNorm   = 0; double[] diag    = new double[cols]; double[] oldX    = new double[cols]; double[] oldRes  = new double[rows]; double[] work1   = new double[cols]; double[] work2   = new double[cols]; double[] work3   = new double[cols];  /* evaluate the function at the starting point and calculate its norm*/ updateResidualsAndCost();  /* outer loop*/ lmPar = 0; boolean firstIteration = true; while (true) {
}  /** * Set the desired max cosine on the orthogonality. * <p>This setting is always used, regardless of the {@link #setConvergenceChecker * vectorial convergence checker} being null or non-null.</p> * @param orthoTolerance desired max cosine on the orthogonality * between the function vector and the columns of the jacobian */ public void setOrthoTolerance(double orthoTolerance) { this.orthoTolerance = orthoTolerance; }  /** {@inheritDoc} */ /* compute the Q.R. decomposition of the jacobian matrix*/ <BUGS> updateJacobian(); qrDecomposition(); <BUGE>  /* compute Qt.res*/ qTy(residuals);  /* now we don't need Q anymore,*/ /* so let jacobian contain the R matrix with its diagonal elements*/ for (int k = 0; k < solvedCols; ++k) { int pk = permutation[k]; jacobian[k][pk] = diagR[pk]; }  if (firstIteration) {
}  /** * Set the desired max cosine on the orthogonality. * <p>This setting is always used, regardless of the {@link #setConvergenceChecker * vectorial convergence checker} being null or non-null.</p> * @param orthoTolerance desired max cosine on the orthogonality * between the function vector and the columns of the jacobian */ public void setOrthoTolerance(double orthoTolerance) { this.orthoTolerance = orthoTolerance; }  /** {@inheritDoc} */ /* compute Qt.res*/ <BUGS> qTy(residuals); <BUGE>  /* now we don't need Q anymore,*/ /* so let jacobian contain the R matrix with its diagonal elements*/ for (int k = 0; k < solvedCols; ++k) { int pk = permutation[k]; jacobian[k][pk] = diagR[pk]; }  if (firstIteration) {  /* scale the point according to the norms of the columns*/ /* of the initial jacobian*/ xNorm = 0; for (int k = 0; k < cols; ++k) {
/** * Set the desired max cosine on the orthogonality. * <p>This setting is always used, regardless of the {@link #setConvergenceChecker * vectorial convergence checker} being null or non-null.</p> * @param orthoTolerance desired max cosine on the orthogonality * between the function vector and the columns of the jacobian */ public void setOrthoTolerance(double orthoTolerance) { this.orthoTolerance = orthoTolerance; }  /** {@inheritDoc} */ /* so let jacobian contain the R matrix with its diagonal elements*/ <BUGS> for (int k = 0; k < solvedCols; ++k) { int pk = permutation[k]; jacobian[k][pk] = diagR[pk]; <BUGE> }  if (firstIteration) {  /* scale the point according to the norms of the columns*/ /* of the initial jacobian*/ xNorm = 0; for (int k = 0; k < cols; ++k) { double dk = jacNorm[k]; if (dk == 0) { dk = 1.0; } double xk = dk * point[k];
}  /** * Set the desired max cosine on the orthogonality. * <p>This setting is always used, regardless of the {@link #setConvergenceChecker * vectorial convergence checker} being null or non-null.</p> * @param orthoTolerance desired max cosine on the orthogonality * between the function vector and the columns of the jacobian */ public void setOrthoTolerance(double orthoTolerance) { this.orthoTolerance = orthoTolerance; }  /** {@inheritDoc} */  <BUGS> if (firstIteration) { <BUGE>  /* scale the point according to the norms of the columns*/ /* of the initial jacobian*/ xNorm = 0; for (int k = 0; k < cols; ++k) { double dk = jacNorm[k]; if (dk == 0) { dk = 1.0; } double xk = dk * point[k]; xNorm  += xk * xk; diag[k] = dk; } xNorm = Math.sqrt(xNorm);
/** * Set the desired max cosine on the orthogonality. * <p>This setting is always used, regardless of the {@link #setConvergenceChecker * vectorial convergence checker} being null or non-null.</p> * @param orthoTolerance desired max cosine on the orthogonality * between the function vector and the columns of the jacobian */ public void setOrthoTolerance(double orthoTolerance) { this.orthoTolerance = orthoTolerance; }  /** {@inheritDoc} */ /* of the initial jacobian*/ <BUGS> xNorm = 0; for (int k = 0; k < cols; ++k) { double dk = jacNorm[k]; if (dk == 0) { <BUGE> dk = 1.0; } double xk = dk * point[k]; xNorm  += xk * xk; diag[k] = dk; } xNorm = Math.sqrt(xNorm);  /* initialize the step bound delta*/ delta = (xNorm == 0) ? initialStepBoundFactor : (initialStepBoundFactor * xNorm);  }
/** * Set the desired max cosine on the orthogonality. * <p>This setting is always used, regardless of the {@link #setConvergenceChecker * vectorial convergence checker} being null or non-null.</p> * @param orthoTolerance desired max cosine on the orthogonality * between the function vector and the columns of the jacobian */ public void setOrthoTolerance(double orthoTolerance) { this.orthoTolerance = orthoTolerance; }  /** {@inheritDoc} */ } <BUGS> double xk = dk * point[k]; xNorm  += xk * xk; diag[k] = dk; <BUGE> } xNorm = Math.sqrt(xNorm);  /* initialize the step bound delta*/ delta = (xNorm == 0) ? initialStepBoundFactor : (initialStepBoundFactor * xNorm);  }  /* check orthogonality between function vector and jacobian columns*/ double maxCosine = 0; if (cost != 0) { for (int j = 0; j < solvedCols; ++j) { int    pj = permutation[j];
}  /** * Set the desired max cosine on the orthogonality. * <p>This setting is always used, regardless of the {@link #setConvergenceChecker * vectorial convergence checker} being null or non-null.</p> * @param orthoTolerance desired max cosine on the orthogonality * between the function vector and the columns of the jacobian */ public void setOrthoTolerance(double orthoTolerance) { this.orthoTolerance = orthoTolerance; }  /** {@inheritDoc} */ } <BUGS> xNorm = Math.sqrt(xNorm); <BUGE>  /* initialize the step bound delta*/ delta = (xNorm == 0) ? initialStepBoundFactor : (initialStepBoundFactor * xNorm);  }  /* check orthogonality between function vector and jacobian columns*/ double maxCosine = 0; if (cost != 0) { for (int j = 0; j < solvedCols; ++j) { int    pj = permutation[j]; double s  = jacNorm[pj]; if (s != 0) { double sum = 0;
}  /** * Set the desired max cosine on the orthogonality. * <p>This setting is always used, regardless of the {@link #setConvergenceChecker * vectorial convergence checker} being null or non-null.</p> * @param orthoTolerance desired max cosine on the orthogonality * between the function vector and the columns of the jacobian */ public void setOrthoTolerance(double orthoTolerance) { this.orthoTolerance = orthoTolerance; }  /** {@inheritDoc} */ /* initialize the step bound delta*/ <BUGS> delta = (xNorm == 0) ? initialStepBoundFactor : (initialStepBoundFactor * xNorm); <BUGE>  }  /* check orthogonality between function vector and jacobian columns*/ double maxCosine = 0; if (cost != 0) { for (int j = 0; j < solvedCols; ++j) { int    pj = permutation[j]; double s  = jacNorm[pj]; if (s != 0) { double sum = 0; for (int i = 0; i <= j; ++i) { sum += jacobian[i][pj] * residuals[i]; }
* <p>This setting is always used, regardless of the {@link #setConvergenceChecker * vectorial convergence checker} being null or non-null.</p> * @param orthoTolerance desired max cosine on the orthogonality * between the function vector and the columns of the jacobian */ public void setOrthoTolerance(double orthoTolerance) { this.orthoTolerance = orthoTolerance; }  /** {@inheritDoc} */ /* check orthogonality between function vector and jacobian columns*/ <BUGS> double maxCosine = 0; if (cost != 0) { for (int j = 0; j < solvedCols; ++j) { int    pj = permutation[j]; double s  = jacNorm[pj]; if (s != 0) { double sum = 0; for (int i = 0; i <= j; ++i) { sum += jacobian[i][pj] * residuals[i]; <BUGE> } maxCosine = Math.max(maxCosine, Math.abs(sum) / (s * cost)); } } } if (maxCosine <= orthoTolerance) { /* convergence has been reached*/ return new VectorialPointValuePair(point, objective); }
}  /** * Set the desired max cosine on the orthogonality. * <p>This setting is always used, regardless of the {@link #setConvergenceChecker * vectorial convergence checker} being null or non-null.</p> * @param orthoTolerance desired max cosine on the orthogonality * between the function vector and the columns of the jacobian */ public void setOrthoTolerance(double orthoTolerance) { this.orthoTolerance = orthoTolerance; }  /** {@inheritDoc} */ } <BUGS> maxCosine = Math.max(maxCosine, Math.abs(sum) / (s * cost)); <BUGE> } } } if (maxCosine <= orthoTolerance) { /* convergence has been reached*/ return new VectorialPointValuePair(point, objective); }  /* rescale if necessary*/ for (int j = 0; j < cols; ++j) { diag[j] = Math.max(diag[j], jacNorm[j]); }  /* inner loop*/
}  /** * Set the desired max cosine on the orthogonality. * <p>This setting is always used, regardless of the {@link #setConvergenceChecker * vectorial convergence checker} being null or non-null.</p> * @param orthoTolerance desired max cosine on the orthogonality * between the function vector and the columns of the jacobian */ public void setOrthoTolerance(double orthoTolerance) { this.orthoTolerance = orthoTolerance; }  /** {@inheritDoc} */ } <BUGS> if (maxCosine <= orthoTolerance) { <BUGE> /* convergence has been reached*/ return new VectorialPointValuePair(point, objective); }  /* rescale if necessary*/ for (int j = 0; j < cols; ++j) { diag[j] = Math.max(diag[j], jacNorm[j]); }  /* inner loop*/ for (double ratio = 0; ratio < 1.0e-4;) {  /* save the state*/ for (int j = 0; j < solvedCols; ++j) {
}  /** * Set the desired max cosine on the orthogonality. * <p>This setting is always used, regardless of the {@link #setConvergenceChecker * vectorial convergence checker} being null or non-null.</p> * @param orthoTolerance desired max cosine on the orthogonality * between the function vector and the columns of the jacobian */ public void setOrthoTolerance(double orthoTolerance) { this.orthoTolerance = orthoTolerance; }  /** {@inheritDoc} */ /* rescale if necessary*/ <BUGS> for (int j = 0; j < cols; ++j) { diag[j] = Math.max(diag[j], jacNorm[j]); <BUGE> }  /* inner loop*/ for (double ratio = 0; ratio < 1.0e-4;) {  /* save the state*/ for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; oldX[pj] = point[pj]; } double previousCost = cost; double[] tmpVec = residuals; residuals = oldRes;
}  /** * Set the desired max cosine on the orthogonality. * <p>This setting is always used, regardless of the {@link #setConvergenceChecker * vectorial convergence checker} being null or non-null.</p> * @param orthoTolerance desired max cosine on the orthogonality * between the function vector and the columns of the jacobian */ public void setOrthoTolerance(double orthoTolerance) { this.orthoTolerance = orthoTolerance; }  /** {@inheritDoc} */ /* inner loop*/ <BUGS> for (double ratio = 0; ratio < 1.0e-4;) { <BUGE>  /* save the state*/ for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; oldX[pj] = point[pj]; } double previousCost = cost; double[] tmpVec = residuals; residuals = oldRes; oldRes    = tmpVec;  /* determine the Levenberg-Marquardt parameter*/ determineLMParameter(oldRes, delta, diag, work1, work2, work3);
/** * Set the desired max cosine on the orthogonality. * <p>This setting is always used, regardless of the {@link #setConvergenceChecker * vectorial convergence checker} being null or non-null.</p> * @param orthoTolerance desired max cosine on the orthogonality * between the function vector and the columns of the jacobian */ public void setOrthoTolerance(double orthoTolerance) { this.orthoTolerance = orthoTolerance; }  /** {@inheritDoc} */ /* save the state*/ <BUGS> for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; oldX[pj] = point[pj]; <BUGE> } double previousCost = cost; double[] tmpVec = residuals; residuals = oldRes; oldRes    = tmpVec;  /* determine the Levenberg-Marquardt parameter*/ determineLMParameter(oldRes, delta, diag, work1, work2, work3);  /* compute the new point and the norm of the evolution direction*/ double lmNorm = 0; for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j];
/** * Set the desired max cosine on the orthogonality. * <p>This setting is always used, regardless of the {@link #setConvergenceChecker * vectorial convergence checker} being null or non-null.</p> * @param orthoTolerance desired max cosine on the orthogonality * between the function vector and the columns of the jacobian */ public void setOrthoTolerance(double orthoTolerance) { this.orthoTolerance = orthoTolerance; }  /** {@inheritDoc} */ } <BUGS> double previousCost = cost; double[] tmpVec = residuals; residuals = oldRes; oldRes    = tmpVec; <BUGE>  /* determine the Levenberg-Marquardt parameter*/ determineLMParameter(oldRes, delta, diag, work1, work2, work3);  /* compute the new point and the norm of the evolution direction*/ double lmNorm = 0; for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; lmDir[pj] = -lmDir[pj]; point[pj] = oldX[pj] + lmDir[pj]; double s = diag[pj] * lmDir[pj]; lmNorm  += s * s;
}  /** * Set the desired max cosine on the orthogonality. * <p>This setting is always used, regardless of the {@link #setConvergenceChecker * vectorial convergence checker} being null or non-null.</p> * @param orthoTolerance desired max cosine on the orthogonality * between the function vector and the columns of the jacobian */ public void setOrthoTolerance(double orthoTolerance) { this.orthoTolerance = orthoTolerance; }  /** {@inheritDoc} */ /* determine the Levenberg-Marquardt parameter*/ <BUGS> determineLMParameter(oldRes, delta, diag, work1, work2, work3); <BUGE>  /* compute the new point and the norm of the evolution direction*/ double lmNorm = 0; for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; lmDir[pj] = -lmDir[pj]; point[pj] = oldX[pj] + lmDir[pj]; double s = diag[pj] * lmDir[pj]; lmNorm  += s * s; } lmNorm = Math.sqrt(lmNorm);  /* on the first iteration, adjust the initial step bound.*/ if (firstIteration) {
* Set the desired max cosine on the orthogonality. * <p>This setting is always used, regardless of the {@link #setConvergenceChecker * vectorial convergence checker} being null or non-null.</p> * @param orthoTolerance desired max cosine on the orthogonality * between the function vector and the columns of the jacobian */ public void setOrthoTolerance(double orthoTolerance) { this.orthoTolerance = orthoTolerance; }  /** {@inheritDoc} */ /* compute the new point and the norm of the evolution direction*/ <BUGS> double lmNorm = 0; for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; lmDir[pj] = -lmDir[pj]; point[pj] = oldX[pj] + lmDir[pj]; double s = diag[pj] * lmDir[pj]; lmNorm  += s * s; <BUGE> } lmNorm = Math.sqrt(lmNorm);  /* on the first iteration, adjust the initial step bound.*/ if (firstIteration) { delta = Math.min(delta, lmNorm); }  /* evaluate the function at x + p and calculate its norm*/ updateResidualsAndCost();
}  /** * Set the desired max cosine on the orthogonality. * <p>This setting is always used, regardless of the {@link #setConvergenceChecker * vectorial convergence checker} being null or non-null.</p> * @param orthoTolerance desired max cosine on the orthogonality * between the function vector and the columns of the jacobian */ public void setOrthoTolerance(double orthoTolerance) { this.orthoTolerance = orthoTolerance; }  /** {@inheritDoc} */ } <BUGS> lmNorm = Math.sqrt(lmNorm); <BUGE>  /* on the first iteration, adjust the initial step bound.*/ if (firstIteration) { delta = Math.min(delta, lmNorm); }  /* evaluate the function at x + p and calculate its norm*/ updateResidualsAndCost();  /* compute the scaled actual reduction*/ double actRed = -1.0; if (0.1 * cost < previousCost) { double r = cost / previousCost; actRed = 1.0 - r * r;
}  /** * Set the desired max cosine on the orthogonality. * <p>This setting is always used, regardless of the {@link #setConvergenceChecker * vectorial convergence checker} being null or non-null.</p> * @param orthoTolerance desired max cosine on the orthogonality * between the function vector and the columns of the jacobian */ public void setOrthoTolerance(double orthoTolerance) { this.orthoTolerance = orthoTolerance; }  /** {@inheritDoc} */ /* on the first iteration, adjust the initial step bound.*/ <BUGS> if (firstIteration) { delta = Math.min(delta, lmNorm); <BUGE> }  /* evaluate the function at x + p and calculate its norm*/ updateResidualsAndCost();  /* compute the scaled actual reduction*/ double actRed = -1.0; if (0.1 * cost < previousCost) { double r = cost / previousCost; actRed = 1.0 - r * r; }  /* compute the scaled predicted reduction*/
}  /** * Set the desired max cosine on the orthogonality. * <p>This setting is always used, regardless of the {@link #setConvergenceChecker * vectorial convergence checker} being null or non-null.</p> * @param orthoTolerance desired max cosine on the orthogonality * between the function vector and the columns of the jacobian */ public void setOrthoTolerance(double orthoTolerance) { this.orthoTolerance = orthoTolerance; }  /** {@inheritDoc} */ /* evaluate the function at x + p and calculate its norm*/ <BUGS> updateResidualsAndCost(); <BUGE>  /* compute the scaled actual reduction*/ double actRed = -1.0; if (0.1 * cost < previousCost) { double r = cost / previousCost; actRed = 1.0 - r * r; }  /* compute the scaled predicted reduction*/ /* and the scaled directional derivative*/ for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; double dirJ = lmDir[pj]; work1[j] = 0;
/** * Set the desired max cosine on the orthogonality. * <p>This setting is always used, regardless of the {@link #setConvergenceChecker * vectorial convergence checker} being null or non-null.</p> * @param orthoTolerance desired max cosine on the orthogonality * between the function vector and the columns of the jacobian */ public void setOrthoTolerance(double orthoTolerance) { this.orthoTolerance = orthoTolerance; }  /** {@inheritDoc} */ /* compute the scaled actual reduction*/ <BUGS> double actRed = -1.0; if (0.1 * cost < previousCost) { double r = cost / previousCost; actRed = 1.0 - r * r; <BUGE> }  /* compute the scaled predicted reduction*/ /* and the scaled directional derivative*/ for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; double dirJ = lmDir[pj]; work1[j] = 0; for (int i = 0; i <= j; ++i) { work1[i] += jacobian[i][pj] * dirJ; } }
/** * Set the desired max cosine on the orthogonality. * <p>This setting is always used, regardless of the {@link #setConvergenceChecker * vectorial convergence checker} being null or non-null.</p> * @param orthoTolerance desired max cosine on the orthogonality * between the function vector and the columns of the jacobian */ public void setOrthoTolerance(double orthoTolerance) { this.orthoTolerance = orthoTolerance; }  /** {@inheritDoc} */ /* and the scaled directional derivative*/ <BUGS> for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; double dirJ = lmDir[pj]; work1[j] = 0; for (int i = 0; i <= j; ++i) { work1[i] += jacobian[i][pj] * dirJ; <BUGE> } } double coeff1 = 0; for (int j = 0; j < solvedCols; ++j) { coeff1 += work1[j] * work1[j]; } double pc2 = previousCost * previousCost; coeff1 = coeff1 / pc2; double coeff2 = lmPar * lmNorm * lmNorm / pc2; double preRed = coeff1 + 2 * coeff2; double dirDer = -(coeff1 + coeff2);
/** * Set the desired max cosine on the orthogonality. * <p>This setting is always used, regardless of the {@link #setConvergenceChecker * vectorial convergence checker} being null or non-null.</p> * @param orthoTolerance desired max cosine on the orthogonality * between the function vector and the columns of the jacobian */ public void setOrthoTolerance(double orthoTolerance) { this.orthoTolerance = orthoTolerance; }  /** {@inheritDoc} */ } <BUGS> double coeff1 = 0; for (int j = 0; j < solvedCols; ++j) { coeff1 += work1[j] * work1[j]; <BUGE> } double pc2 = previousCost * previousCost; coeff1 = coeff1 / pc2; double coeff2 = lmPar * lmNorm * lmNorm / pc2; double preRed = coeff1 + 2 * coeff2; double dirDer = -(coeff1 + coeff2);  /* ratio of the actual to the predicted reduction*/ ratio = (preRed == 0) ? 0 : (actRed / preRed);  /* update the step bound*/ if (ratio <= 0.25) { double tmp =
/** * Set the desired max cosine on the orthogonality. * <p>This setting is always used, regardless of the {@link #setConvergenceChecker * vectorial convergence checker} being null or non-null.</p> * @param orthoTolerance desired max cosine on the orthogonality * between the function vector and the columns of the jacobian */ public void setOrthoTolerance(double orthoTolerance) { this.orthoTolerance = orthoTolerance; }  /** {@inheritDoc} */ } <BUGS> double pc2 = previousCost * previousCost; coeff1 = coeff1 / pc2; double coeff2 = lmPar * lmNorm * lmNorm / pc2; double preRed = coeff1 + 2 * coeff2; double dirDer = -(coeff1 + coeff2); <BUGE>  /* ratio of the actual to the predicted reduction*/ ratio = (preRed == 0) ? 0 : (actRed / preRed);  /* update the step bound*/ if (ratio <= 0.25) { double tmp = (actRed < 0) ? (0.5 * dirDer / (dirDer + 0.5 * actRed)) : 0.5; if ((0.1 * cost >= previousCost) || (tmp < 0.1)) { tmp = 0.1; } delta = tmp * Math.min(delta, 10.0 * lmNorm);
}  /** * Set the desired max cosine on the orthogonality. * <p>This setting is always used, regardless of the {@link #setConvergenceChecker * vectorial convergence checker} being null or non-null.</p> * @param orthoTolerance desired max cosine on the orthogonality * between the function vector and the columns of the jacobian */ public void setOrthoTolerance(double orthoTolerance) { this.orthoTolerance = orthoTolerance; }  /** {@inheritDoc} */ /* ratio of the actual to the predicted reduction*/ <BUGS> ratio = (preRed == 0) ? 0 : (actRed / preRed); <BUGE>  /* update the step bound*/ if (ratio <= 0.25) { double tmp = (actRed < 0) ? (0.5 * dirDer / (dirDer + 0.5 * actRed)) : 0.5; if ((0.1 * cost >= previousCost) || (tmp < 0.1)) { tmp = 0.1; } delta = tmp * Math.min(delta, 10.0 * lmNorm); lmPar /= tmp; } else if ((lmPar == 0) || (ratio >= 0.75)) { delta = 2 * lmNorm; lmPar *= 0.5; }
}  /** * Set the desired max cosine on the orthogonality. * <p>This setting is always used, regardless of the {@link #setConvergenceChecker * vectorial convergence checker} being null or non-null.</p> * @param orthoTolerance desired max cosine on the orthogonality * between the function vector and the columns of the jacobian */ public void setOrthoTolerance(double orthoTolerance) { this.orthoTolerance = orthoTolerance; }  /** {@inheritDoc} */ /* update the step bound*/ <BUGS> if (ratio <= 0.25) { double tmp = <BUGE> (actRed < 0) ? (0.5 * dirDer / (dirDer + 0.5 * actRed)) : 0.5; if ((0.1 * cost >= previousCost) || (tmp < 0.1)) { tmp = 0.1; } delta = tmp * Math.min(delta, 10.0 * lmNorm); lmPar /= tmp; } else if ((lmPar == 0) || (ratio >= 0.75)) { delta = 2 * lmNorm; lmPar *= 0.5; }  /* test for successful iteration.*/ if (ratio >= 1.0e-4) {
}  /** * Set the desired max cosine on the orthogonality. * <p>This setting is always used, regardless of the {@link #setConvergenceChecker * vectorial convergence checker} being null or non-null.</p> * @param orthoTolerance desired max cosine on the orthogonality * between the function vector and the columns of the jacobian */ public void setOrthoTolerance(double orthoTolerance) { this.orthoTolerance = orthoTolerance; }  /** {@inheritDoc} */ (actRed < 0) ? (0.5 * dirDer / (dirDer + 0.5 * actRed)) : 0.5; <BUGS> if ((0.1 * cost >= previousCost) || (tmp < 0.1)) { tmp = 0.1; <BUGE> } delta = tmp * Math.min(delta, 10.0 * lmNorm); lmPar /= tmp; } else if ((lmPar == 0) || (ratio >= 0.75)) { delta = 2 * lmNorm; lmPar *= 0.5; }  /* test for successful iteration.*/ if (ratio >= 1.0e-4) { /* successful iteration, update the norm*/ firstIteration = false; xNorm = 0;
/** * Set the desired max cosine on the orthogonality. * <p>This setting is always used, regardless of the {@link #setConvergenceChecker * vectorial convergence checker} being null or non-null.</p> * @param orthoTolerance desired max cosine on the orthogonality * between the function vector and the columns of the jacobian */ public void setOrthoTolerance(double orthoTolerance) { this.orthoTolerance = orthoTolerance; }  /** {@inheritDoc} */ } <BUGS> delta = tmp * Math.min(delta, 10.0 * lmNorm); lmPar /= tmp; } else if ((lmPar == 0) || (ratio >= 0.75)) { delta = 2 * lmNorm; lmPar *= 0.5; <BUGE> }  /* test for successful iteration.*/ if (ratio >= 1.0e-4) { /* successful iteration, update the norm*/ firstIteration = false; xNorm = 0; for (int k = 0; k < cols; ++k) { double xK = diag[k] * point[k]; xNorm    += xK * xK; } xNorm = Math.sqrt(xNorm);
}  /** * Set the desired max cosine on the orthogonality. * <p>This setting is always used, regardless of the {@link #setConvergenceChecker * vectorial convergence checker} being null or non-null.</p> * @param orthoTolerance desired max cosine on the orthogonality * between the function vector and the columns of the jacobian */ public void setOrthoTolerance(double orthoTolerance) { this.orthoTolerance = orthoTolerance; }  /** {@inheritDoc} */ /* test for successful iteration.*/ <BUGS> if (ratio >= 1.0e-4) { <BUGE> /* successful iteration, update the norm*/ firstIteration = false; xNorm = 0; for (int k = 0; k < cols; ++k) { double xK = diag[k] * point[k]; xNorm    += xK * xK; } xNorm = Math.sqrt(xNorm); } else { /* failed iteration, reset the previous values*/ cost = previousCost; for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; point[pj] = oldX[pj];
/** * Set the desired max cosine on the orthogonality. * <p>This setting is always used, regardless of the {@link #setConvergenceChecker * vectorial convergence checker} being null or non-null.</p> * @param orthoTolerance desired max cosine on the orthogonality * between the function vector and the columns of the jacobian */ public void setOrthoTolerance(double orthoTolerance) { this.orthoTolerance = orthoTolerance; }  /** {@inheritDoc} */ /* successful iteration, update the norm*/ <BUGS> firstIteration = false; xNorm = 0; for (int k = 0; k < cols; ++k) { double xK = diag[k] * point[k]; xNorm    += xK * xK; <BUGE> } xNorm = Math.sqrt(xNorm); } else { /* failed iteration, reset the previous values*/ cost = previousCost; for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; point[pj] = oldX[pj]; } tmpVec    = residuals; residuals = oldRes; oldRes    = tmpVec;
}  /** * Set the desired max cosine on the orthogonality. * <p>This setting is always used, regardless of the {@link #setConvergenceChecker * vectorial convergence checker} being null or non-null.</p> * @param orthoTolerance desired max cosine on the orthogonality * between the function vector and the columns of the jacobian */ public void setOrthoTolerance(double orthoTolerance) { this.orthoTolerance = orthoTolerance; }  /** {@inheritDoc} */ } <BUGS> xNorm = Math.sqrt(xNorm); <BUGE> } else { /* failed iteration, reset the previous values*/ cost = previousCost; for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; point[pj] = oldX[pj]; } tmpVec    = residuals; residuals = oldRes; oldRes    = tmpVec; }  /* tests for convergence.*/ /* we use the vectorial convergence checker*/
/** * Set the desired max cosine on the orthogonality. * <p>This setting is always used, regardless of the {@link #setConvergenceChecker * vectorial convergence checker} being null or non-null.</p> * @param orthoTolerance desired max cosine on the orthogonality * between the function vector and the columns of the jacobian */ public void setOrthoTolerance(double orthoTolerance) { this.orthoTolerance = orthoTolerance; }  /** {@inheritDoc} */ /* failed iteration, reset the previous values*/ <BUGS> cost = previousCost; for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; point[pj] = oldX[pj]; <BUGE> } tmpVec    = residuals; residuals = oldRes; oldRes    = tmpVec; }  /* tests for convergence.*/ /* we use the vectorial convergence checker*/ /* we use the Levenberg-Marquardt specific convergence parameters*/ if (((Math.abs(actRed) <= costRelativeTolerance) && (preRed <= costRelativeTolerance) && (ratio <= 2.0)) ||
/** * Set the desired max cosine on the orthogonality. * <p>This setting is always used, regardless of the {@link #setConvergenceChecker * vectorial convergence checker} being null or non-null.</p> * @param orthoTolerance desired max cosine on the orthogonality * between the function vector and the columns of the jacobian */ public void setOrthoTolerance(double orthoTolerance) { this.orthoTolerance = orthoTolerance; }  /** {@inheritDoc} */ } <BUGS> tmpVec    = residuals; residuals = oldRes; oldRes    = tmpVec; <BUGE> }  /* tests for convergence.*/ /* we use the vectorial convergence checker*/ /* we use the Levenberg-Marquardt specific convergence parameters*/ if (((Math.abs(actRed) <= costRelativeTolerance) && (preRed <= costRelativeTolerance) && (ratio <= 2.0)) || (delta <= parRelativeTolerance * xNorm)) { return new VectorialPointValuePair(point, objective); }  /* tests for termination and stringent tolerances*/
}  /** * Set the desired max cosine on the orthogonality. * <p>This setting is always used, regardless of the {@link #setConvergenceChecker * vectorial convergence checker} being null or non-null.</p> * @param orthoTolerance desired max cosine on the orthogonality * between the function vector and the columns of the jacobian */ public void setOrthoTolerance(double orthoTolerance) { this.orthoTolerance = orthoTolerance; }  /** {@inheritDoc} */ /* we use the Levenberg-Marquardt specific convergence parameters*/ <BUGS> if (((Math.abs(actRed) <= costRelativeTolerance) && <BUGE> (preRed <= costRelativeTolerance) && (ratio <= 2.0)) || (delta <= parRelativeTolerance * xNorm)) { return new VectorialPointValuePair(point, objective); }  /* tests for termination and stringent tolerances*/ /* (2.2204e-16 is the machine epsilon for IEEE754)*/ if ((Math.abs(actRed) <= 2.2204e-16) && (preRed <= 2.2204e-16) && (ratio <= 2.0)) { throw new OptimizationException("cost relative tolerance is too small ({0})," + " no further reduction in the" + " sum of squares is possible", costRelativeTolerance); } else if (delta <= 2.2204e-16 * xNorm) {
}  /** * Set the desired max cosine on the orthogonality. * <p>This setting is always used, regardless of the {@link #setConvergenceChecker * vectorial convergence checker} being null or non-null.</p> * @param orthoTolerance desired max cosine on the orthogonality * between the function vector and the columns of the jacobian */ public void setOrthoTolerance(double orthoTolerance) { this.orthoTolerance = orthoTolerance; }  /** {@inheritDoc} */ (delta <= parRelativeTolerance * xNorm)) { <BUGS> return new VectorialPointValuePair(point, objective); <BUGE> }  /* tests for termination and stringent tolerances*/ /* (2.2204e-16 is the machine epsilon for IEEE754)*/ if ((Math.abs(actRed) <= 2.2204e-16) && (preRed <= 2.2204e-16) && (ratio <= 2.0)) { throw new OptimizationException("cost relative tolerance is too small ({0})," + " no further reduction in the" + " sum of squares is possible", costRelativeTolerance); } else if (delta <= 2.2204e-16 * xNorm) { throw new OptimizationException("parameters relative tolerance is too small" + " ({0}), no further improvement in" + " the approximate solution is possible", parRelativeTolerance);
}  /** * Set the desired max cosine on the orthogonality. * <p>This setting is always used, regardless of the {@link #setConvergenceChecker * vectorial convergence checker} being null or non-null.</p> * @param orthoTolerance desired max cosine on the orthogonality * between the function vector and the columns of the jacobian */ public void setOrthoTolerance(double orthoTolerance) { this.orthoTolerance = orthoTolerance; }  /** {@inheritDoc} */ /* (2.2204e-16 is the machine epsilon for IEEE754)*/ <BUGS> if ((Math.abs(actRed) <= 2.2204e-16) && (preRed <= 2.2204e-16) && (ratio <= 2.0)) { <BUGE> throw new OptimizationException("cost relative tolerance is too small ({0})," + " no further reduction in the" + " sum of squares is possible", costRelativeTolerance); } else if (delta <= 2.2204e-16 * xNorm) { throw new OptimizationException("parameters relative tolerance is too small" + " ({0}), no further improvement in" + " the approximate solution is possible", parRelativeTolerance); } else if (maxCosine <= 2.2204e-16)  { throw new OptimizationException("orthogonality tolerance is too small ({0})," + " solution is orthogonal to the jacobian", orthoTolerance); }
}  /** * Set the desired max cosine on the orthogonality. * <p>This setting is always used, regardless of the {@link #setConvergenceChecker * vectorial convergence checker} being null or non-null.</p> * @param orthoTolerance desired max cosine on the orthogonality * between the function vector and the columns of the jacobian */ public void setOrthoTolerance(double orthoTolerance) { this.orthoTolerance = orthoTolerance; }  /** {@inheritDoc} */ costRelativeTolerance); <BUGS> } else if (delta <= 2.2204e-16 * xNorm) { <BUGE> throw new OptimizationException("parameters relative tolerance is too small" + " ({0}), no further improvement in" + " the approximate solution is possible", parRelativeTolerance); } else if (maxCosine <= 2.2204e-16)  { throw new OptimizationException("orthogonality tolerance is too small ({0})," + " solution is orthogonal to the jacobian", orthoTolerance); }  }  }
}  /** * Set the desired max cosine on the orthogonality. * <p>This setting is always used, regardless of the {@link #setConvergenceChecker * vectorial convergence checker} being null or non-null.</p> * @param orthoTolerance desired max cosine on the orthogonality * between the function vector and the columns of the jacobian */ public void setOrthoTolerance(double orthoTolerance) { this.orthoTolerance = orthoTolerance; }  /** {@inheritDoc} */ parRelativeTolerance); <BUGS> } else if (maxCosine <= 2.2204e-16)  { <BUGE> throw new OptimizationException("orthogonality tolerance is too small ({0})," + " solution is orthogonal to the jacobian", orthoTolerance); }  }  }  }  /** * Determine the Levenberg-Marquardt parameter. * <p>This implementation is a translation in Java of the MINPACK
}  /** * Set the desired max cosine on the orthogonality. * <p>This setting is always used, regardless of the {@link #setConvergenceChecker * vectorial convergence checker} being null or non-null.</p> * @param orthoTolerance desired max cosine on the orthogonality * between the function vector and the columns of the jacobian */ public void setOrthoTolerance(double orthoTolerance) { this.orthoTolerance = orthoTolerance; }  /** {@inheritDoc} */  <BUGS> } <BUGE>  }  }  /** * Determine the Levenberg-Marquardt parameter. * <p>This implementation is a translation in Java of the MINPACK * <a href="http:/*www.netlib.org/minpack/lmpar.f">lmpar</a>*/ * routine.</p> * <p>This method sets the lmPar and lmDir attributes.</p> * <p>The authors of the original fortran function are:</p> * <ul> *   <li>Argonne National Laboratory. MINPACK project. March 1980</li>
}  /** * Set the desired max cosine on the orthogonality. * <p>This setting is always used, regardless of the {@link #setConvergenceChecker * vectorial convergence checker} being null or non-null.</p> * @param orthoTolerance desired max cosine on the orthogonality * between the function vector and the columns of the jacobian */ public void setOrthoTolerance(double orthoTolerance) { this.orthoTolerance = orthoTolerance; }  /** {@inheritDoc} */  <BUGS> } <BUGE>  }  /** * Determine the Levenberg-Marquardt parameter. * <p>This implementation is a translation in Java of the MINPACK * <a href="http:/*www.netlib.org/minpack/lmpar.f">lmpar</a>*/ * routine.</p> * <p>This method sets the lmPar and lmDir attributes.</p> * <p>The authors of the original fortran function are:</p> * <ul> *   <li>Argonne National Laboratory. MINPACK project. March 1980</li> *   <li>Burton  S. Garbow</li> *   <li>Kenneth E. Hillstrom</li>
*/ public PearsonsCorrelation(double[][] data) { <BUGS> this(new BlockRealMatrix(data)); } <BUGE>
/** {@inheritDoc} */
/** {@inheritDoc} */
/** {@inheritDoc} */
/** {@inheritDoc} */
/** {@inheritDoc} */
/** {@inheritDoc} */
/** {@inheritDoc} */
/** {@inheritDoc} */
/** {@inheritDoc} */
/** {@inheritDoc} */
/** {@inheritDoc} */
/** {@inheritDoc} */
/** {@inheritDoc} */
/** {@inheritDoc} */
/** {@inheritDoc} */
/** {@inheritDoc} */
/** {@inheritDoc} */
/** {@inheritDoc} */
/** {@inheritDoc} */
/** {@inheritDoc} */
/** {@inheritDoc} */
/** {@inheritDoc} */
/** {@inheritDoc} */
/** {@inheritDoc} */
/** {@inheritDoc} */
/** {@inheritDoc} */
/** {@inheritDoc} */
/** {@inheritDoc} */
/** {@inheritDoc} */
/** {@inheritDoc} */
/** {@inheritDoc} */
*/ public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial) throws MaxIterationsExceededException, FunctionEvaluationException {  <BUGS> clearResult(); verifySequence(min, initial, max); <BUGE>  /* return the initial guess if it is good enough*/ double yInitial = f.value(initial); if (Math.abs(yInitial) <= functionValueAccuracy) { setResult(initial, 0); return result; }  /* return the first endpoint if it is good enough*/ double yMin = f.value(min); if (Math.abs(yMin) <= functionValueAccuracy) { setResult(yMin, 0); return result; }  /* reduce interval if min and initial bracket the root*/ if (yInitial * yMin < 0) { return solve(f, min, yMin, initial, yInitial, min, yMin); }  /* return the second endpoint if it is good enough*/ double yMax = f.value(max); if (Math.abs(yMax) <= functionValueAccuracy) {
*/ public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial) throws MaxIterationsExceededException, FunctionEvaluationException {  clearResult(); verifySequence(min, initial, max);  /* return the initial guess if it is good enough*/ <BUGS> double yInitial = f.value(initial); if (Math.abs(yInitial) <= functionValueAccuracy) { <BUGE> setResult(initial, 0); return result; }  /* return the first endpoint if it is good enough*/ double yMin = f.value(min); if (Math.abs(yMin) <= functionValueAccuracy) { setResult(yMin, 0); return result; }  /* reduce interval if min and initial bracket the root*/ if (yInitial * yMin < 0) { return solve(f, min, yMin, initial, yInitial, min, yMin); }  /* return the second endpoint if it is good enough*/ double yMax = f.value(max); if (Math.abs(yMax) <= functionValueAccuracy) {
*/ public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial) throws MaxIterationsExceededException, FunctionEvaluationException {  clearResult(); verifySequence(min, initial, max);  /* return the initial guess if it is good enough*/ double yInitial = f.value(initial); if (Math.abs(yInitial) <= functionValueAccuracy) { setResult(initial, 0); return result; }  /* return the first endpoint if it is good enough*/ <BUGS> double yMin = f.value(min); if (Math.abs(yMin) <= functionValueAccuracy) { setResult(yMin, 0); return result; <BUGE> }  /* reduce interval if min and initial bracket the root*/ if (yInitial * yMin < 0) { return solve(f, min, yMin, initial, yInitial, min, yMin); }  /* return the second endpoint if it is good enough*/ double yMax = f.value(max); if (Math.abs(yMax) <= functionValueAccuracy) {
*/ protected void verifyInterval(final double lower, final double upper) { <BUGS> if (lower >= upper) { throw MathRuntimeException.createIllegalArgumentException( <BUGE> "endpoints do not specify an interval: [{0}, {1}]", lower, upper); } }
*/ protected void verifyInterval(final double lower, final double upper) { if (lower >= upper) { throw MathRuntimeException.createIllegalArgumentException( "endpoints do not specify an interval: [{0}, {1}]", lower, upper); } <BUGS> } <BUGE>
*/ protected double filterStep(final double h, final boolean forward, final boolean acceptSmall) throws IntegratorException {  <BUGS> double filteredH = h; if (Math.abs(h) < minStep) { <BUGE> if (acceptSmall) { filteredH = forward ? minStep : -minStep; } else { throw new IntegratorException( "minimal step size ({0,number,0.00E00}) reached, integration needs {1,number,0.00E00}", minStep, Math.abs(h)); } }  if (filteredH > maxStep) { filteredH = maxStep; } else if (filteredH < -maxStep) { filteredH = -maxStep; }  return filteredH;  }
*/ protected double filterStep(final double h, final boolean forward, final boolean acceptSmall) throws IntegratorException {  double filteredH = h; if (Math.abs(h) < minStep) { if (acceptSmall) { filteredH = forward ? minStep : -minStep; } else { throw new IntegratorException( "minimal step size ({0,number,0.00E00}) reached, integration needs {1,number,0.00E00}", minStep, Math.abs(h)); } }  <BUGS> if (filteredH > maxStep) { filteredH = maxStep; } else if (filteredH < -maxStep) { <BUGE> filteredH = -maxStep; }  return filteredH;  }
*/ protected double filterStep(final double h, final boolean forward, final boolean acceptSmall) throws IntegratorException {  double filteredH = h; if (Math.abs(h) < minStep) { if (acceptSmall) { filteredH = forward ? minStep : -minStep; } else { throw new IntegratorException( "minimal step size ({0,number,0.00E00}) reached, integration needs {1,number,0.00E00}", minStep, Math.abs(h)); } }  if (filteredH > maxStep) { filteredH = maxStep; } else if (filteredH < -maxStep) { filteredH = -maxStep; }  <BUGS> return filteredH; <BUGE>  }
@Deprecated public double getPct(Object v) { <BUGS> return getCumPct((Comparable<?>) v); <BUGE> }
*/ public SingularValueDecompositionImpl(final RealMatrix matrix, final int max) <BUGS> throws InvalidMatrixException { <BUGE>  m = matrix.getRowDimension(); n = matrix.getColumnDimension();  cachedU  = null; cachedS  = null; cachedV  = null; cachedVt = null;  /* transform the matrix to bidiagonal*/ transformer         = new BiDiagonalTransformer(matrix); mainBidiagonal      = transformer.getMainDiagonalRef(); secondaryBidiagonal = transformer.getSecondaryDiagonalRef();  /* compute Bt.B (if upper diagonal) or B.Bt (if lower diagonal)*/ mainTridiagonal      = new double[mainBidiagonal.length]; secondaryTridiagonal = new double[mainBidiagonal.length - 1]; double a = mainBidiagonal[0]; mainTridiagonal[0] = a * a; for (int i = 1; i < mainBidiagonal.length; ++i) { final double b  = secondaryBidiagonal[i - 1]; secondaryTridiagonal[i - 1] = a * b; a = mainBidiagonal[i]; mainTridiagonal[i] = a * a + b * b; }  /* compute singular values*/
*/ public SingularValueDecompositionImpl(final RealMatrix matrix, final int max) throws InvalidMatrixException {  <BUGS> m = matrix.getRowDimension(); n = matrix.getColumnDimension(); <BUGE>  cachedU  = null; cachedS  = null; cachedV  = null; cachedVt = null;  /* transform the matrix to bidiagonal*/ transformer         = new BiDiagonalTransformer(matrix); mainBidiagonal      = transformer.getMainDiagonalRef(); secondaryBidiagonal = transformer.getSecondaryDiagonalRef();  /* compute Bt.B (if upper diagonal) or B.Bt (if lower diagonal)*/ mainTridiagonal      = new double[mainBidiagonal.length]; secondaryTridiagonal = new double[mainBidiagonal.length - 1]; double a = mainBidiagonal[0]; mainTridiagonal[0] = a * a; for (int i = 1; i < mainBidiagonal.length; ++i) { final double b  = secondaryBidiagonal[i - 1]; secondaryTridiagonal[i - 1] = a * b; a = mainBidiagonal[i]; mainTridiagonal[i] = a * a + b * b; }  /* compute singular values*/
*/ public SingularValueDecompositionImpl(final RealMatrix matrix, final int max) throws InvalidMatrixException {  m = matrix.getRowDimension(); n = matrix.getColumnDimension();  <BUGS> cachedU  = null; cachedS  = null; cachedV  = null; cachedVt = null; <BUGE>  /* transform the matrix to bidiagonal*/ transformer         = new BiDiagonalTransformer(matrix); mainBidiagonal      = transformer.getMainDiagonalRef(); secondaryBidiagonal = transformer.getSecondaryDiagonalRef();  /* compute Bt.B (if upper diagonal) or B.Bt (if lower diagonal)*/ mainTridiagonal      = new double[mainBidiagonal.length]; secondaryTridiagonal = new double[mainBidiagonal.length - 1]; double a = mainBidiagonal[0]; mainTridiagonal[0] = a * a; for (int i = 1; i < mainBidiagonal.length; ++i) { final double b  = secondaryBidiagonal[i - 1]; secondaryTridiagonal[i - 1] = a * b; a = mainBidiagonal[i]; mainTridiagonal[i] = a * a + b * b; }  /* compute singular values*/
*/ public SingularValueDecompositionImpl(final RealMatrix matrix, final int max) throws InvalidMatrixException {  m = matrix.getRowDimension(); n = matrix.getColumnDimension();  cachedU  = null; cachedS  = null; cachedV  = null; cachedVt = null;  /* transform the matrix to bidiagonal*/ <BUGS> transformer         = new BiDiagonalTransformer(matrix); mainBidiagonal      = transformer.getMainDiagonalRef(); secondaryBidiagonal = transformer.getSecondaryDiagonalRef(); <BUGE>  /* compute Bt.B (if upper diagonal) or B.Bt (if lower diagonal)*/ mainTridiagonal      = new double[mainBidiagonal.length]; secondaryTridiagonal = new double[mainBidiagonal.length - 1]; double a = mainBidiagonal[0]; mainTridiagonal[0] = a * a; for (int i = 1; i < mainBidiagonal.length; ++i) { final double b  = secondaryBidiagonal[i - 1]; secondaryTridiagonal[i - 1] = a * b; a = mainBidiagonal[i]; mainTridiagonal[i] = a * a + b * b; }  /* compute singular values*/
*/ public SingularValueDecompositionImpl(final RealMatrix matrix, final int max) throws InvalidMatrixException {  m = matrix.getRowDimension(); n = matrix.getColumnDimension();  cachedU  = null; cachedS  = null; cachedV  = null; cachedVt = null;  /* transform the matrix to bidiagonal*/ transformer         = new BiDiagonalTransformer(matrix); mainBidiagonal      = transformer.getMainDiagonalRef(); secondaryBidiagonal = transformer.getSecondaryDiagonalRef();  /* compute Bt.B (if upper diagonal) or B.Bt (if lower diagonal)*/ <BUGS> mainTridiagonal      = new double[mainBidiagonal.length]; secondaryTridiagonal = new double[mainBidiagonal.length - 1]; double a = mainBidiagonal[0]; mainTridiagonal[0] = a * a; for (int i = 1; i < mainBidiagonal.length; ++i) { final double b  = secondaryBidiagonal[i - 1]; secondaryTridiagonal[i - 1] = a * b; a = mainBidiagonal[i]; mainTridiagonal[i] = a * a + b * b; <BUGE> }  /* compute singular values*/
*/ public SingularValueDecompositionImpl(final RealMatrix matrix, final int max) throws InvalidMatrixException {  m = matrix.getRowDimension(); n = matrix.getColumnDimension();  cachedU  = null; cachedS  = null; cachedV  = null; cachedVt = null;  /* transform the matrix to bidiagonal*/ transformer         = new BiDiagonalTransformer(matrix); mainBidiagonal      = transformer.getMainDiagonalRef(); secondaryBidiagonal = transformer.getSecondaryDiagonalRef();  /* compute Bt.B (if upper diagonal) or B.Bt (if lower diagonal)*/ mainTridiagonal      = new double[mainBidiagonal.length]; secondaryTridiagonal = new double[mainBidiagonal.length - 1]; double a = mainBidiagonal[0]; mainTridiagonal[0] = a * a; for (int i = 1; i < mainBidiagonal.length; ++i) { final double b  = secondaryBidiagonal[i - 1]; secondaryTridiagonal[i - 1] = a * b; a = mainBidiagonal[i]; mainTridiagonal[i] = a * a + b * b; }  /* compute singular values*/
* org.apache.commons.math.ConvergenceException} if algorithm fails to converge */ public SingularValueDecompositionImpl(final RealMatrix matrix) throws InvalidMatrixException { this(matrix, Math.min(matrix.getRowDimension(), matrix.getColumnDimension())); }  /** * Calculates the Singular Value Decomposition of the given matrix. * @param matrix The matrix to decompose. * @param max maximal number of singular values to compute * @exception InvalidMatrixException (wrapping a {@link * org.apache.commons.math.ConvergenceException} if algorithm fails to converge MathUtils.SAFE_MIN); <BUGS> final double[] eigenValues = eigenDecomposition.getRealEigenvalues(); int p = Math.min(max, eigenValues.length); while ((p > 0) && (eigenValues[p - 1] <= 0)) { --p; <BUGE> } singularValues = new double[p]; for (int i = 0; i < p; ++i) { singularValues[i] = Math.sqrt(eigenValues[i]); }  }  /** {@inheritDoc} */ public RealMatrix getU() throws InvalidMatrixException {
* org.apache.commons.math.ConvergenceException} if algorithm fails to converge */ public SingularValueDecompositionImpl(final RealMatrix matrix) throws InvalidMatrixException { this(matrix, Math.min(matrix.getRowDimension(), matrix.getColumnDimension())); }  /** * Calculates the Singular Value Decomposition of the given matrix. * @param matrix The matrix to decompose. * @param max maximal number of singular values to compute * @exception InvalidMatrixException (wrapping a {@link * org.apache.commons.math.ConvergenceException} if algorithm fails to converge } <BUGS> singularValues = new double[p]; for (int i = 0; i < p; ++i) { singularValues[i] = Math.sqrt(eigenValues[i]); <BUGE> }  }  /** {@inheritDoc} */ public RealMatrix getU() throws InvalidMatrixException {  if (cachedU == null) {  final int p = singularValues.length; if (m >= n) { /* the tridiagonal matrix is Bt.B, where B is upper bidiagonal*/
* @exception InvalidMatrixException (wrapping a {@link * org.apache.commons.math.ConvergenceException} if algorithm fails to converge */ public SingularValueDecompositionImpl(final RealMatrix matrix) throws InvalidMatrixException { this(matrix, Math.min(matrix.getRowDimension(), matrix.getColumnDimension())); }  /** * Calculates the Singular Value Decomposition of the given matrix. * @param matrix The matrix to decompose. * @param max maximal number of singular values to compute * @exception InvalidMatrixException (wrapping a {@link * org.apache.commons.math.ConvergenceException} if algorithm fails to converge  <BUGS> } <BUGE>  /** {@inheritDoc} */ public RealMatrix getU() throws InvalidMatrixException {  if (cachedU == null) {  final int p = singularValues.length; if (m >= n) { /* the tridiagonal matrix is Bt.B, where B is upper bidiagonal*/ final RealMatrix e = eigenDecomposition.getV().getSubMatrix(0, p - 1, 0, p - 1); final double[][] eData = e.getData(); final double[][] wData = new double[m][p];
/** {@inheritDoc} */
/** {@inheritDoc} */
*/ public double solve(final UnivariateRealFunction f, final double min, final double max) throws MaxIterationsExceededException, FunctionEvaluationException {  <BUGS> clearResult(); verifyInterval(min, max); <BUGE>  double ret = Double.NaN;  double yMin = f.value(min); double yMax = f.value(max);  /* Verify bracketing*/ double sign = yMin * yMax; if (sign > 0) { /* check if either value is close to a zero*/ if (Math.abs(yMin) <= functionValueAccuracy) { setResult(min, 0); ret = min; } else if (Math.abs(yMax) <= functionValueAccuracy) { setResult(max, 0); ret = max; } else { /* neither value is close to zero and min and max do not bracket root.*/ throw MathRuntimeException.createIllegalArgumentException( "function values at endpoints do not have different signs.  " + "Endpoints: [{0}, {1}], Values: [{2}, {3}]", min, max, yMin, yMax);
*/ public double solve(final UnivariateRealFunction f, final double min, final double max) throws MaxIterationsExceededException, FunctionEvaluationException {  clearResult(); verifyInterval(min, max);  <BUGS> double ret = Double.NaN; <BUGE>  double yMin = f.value(min); double yMax = f.value(max);  /* Verify bracketing*/ double sign = yMin * yMax; if (sign > 0) { /* check if either value is close to a zero*/ if (Math.abs(yMin) <= functionValueAccuracy) { setResult(min, 0); ret = min; } else if (Math.abs(yMax) <= functionValueAccuracy) { setResult(max, 0); ret = max; } else { /* neither value is close to zero and min and max do not bracket root.*/ throw MathRuntimeException.createIllegalArgumentException( "function values at endpoints do not have different signs.  " + "Endpoints: [{0}, {1}], Values: [{2}, {3}]", min, max, yMin, yMax);
*/ public double solve(final UnivariateRealFunction f, final double min, final double max) throws MaxIterationsExceededException, FunctionEvaluationException {  clearResult(); verifyInterval(min, max);  double ret = Double.NaN;  <BUGS> double yMin = f.value(min); double yMax = f.value(max); <BUGE>  /* Verify bracketing*/ double sign = yMin * yMax; if (sign > 0) { /* check if either value is close to a zero*/ if (Math.abs(yMin) <= functionValueAccuracy) { setResult(min, 0); ret = min; } else if (Math.abs(yMax) <= functionValueAccuracy) { setResult(max, 0); ret = max; } else { /* neither value is close to zero and min and max do not bracket root.*/ throw MathRuntimeException.createIllegalArgumentException( "function values at endpoints do not have different signs.  " + "Endpoints: [{0}, {1}], Values: [{2}, {3}]", min, max, yMin, yMax);
*/ public double solve(final UnivariateRealFunction f, final double min, final double max) throws MaxIterationsExceededException, FunctionEvaluationException {  clearResult(); verifyInterval(min, max);  double ret = Double.NaN;  double yMin = f.value(min); double yMax = f.value(max);  /* Verify bracketing*/ <BUGS> double sign = yMin * yMax; if (sign > 0) { <BUGE> /* check if either value is close to a zero*/ if (Math.abs(yMin) <= functionValueAccuracy) { setResult(min, 0); ret = min; } else if (Math.abs(yMax) <= functionValueAccuracy) { setResult(max, 0); ret = max; } else { /* neither value is close to zero and min and max do not bracket root.*/ throw MathRuntimeException.createIllegalArgumentException( "function values at endpoints do not have different signs.  " + "Endpoints: [{0}, {1}], Values: [{2}, {3}]", min, max, yMin, yMax);
*/ public double solve(final UnivariateRealFunction f, final double min, final double max) throws MaxIterationsExceededException, FunctionEvaluationException {  clearResult(); verifyInterval(min, max);  double ret = Double.NaN;  double yMin = f.value(min); double yMax = f.value(max);  /* Verify bracketing*/ double sign = yMin * yMax; if (sign > 0) { /* check if either value is close to a zero*/ <BUGS> if (Math.abs(yMin) <= functionValueAccuracy) { <BUGE> setResult(min, 0); ret = min; } else if (Math.abs(yMax) <= functionValueAccuracy) { setResult(max, 0); ret = max; } else { /* neither value is close to zero and min and max do not bracket root.*/ throw MathRuntimeException.createIllegalArgumentException( "function values at endpoints do not have different signs.  " + "Endpoints: [{0}, {1}], Values: [{2}, {3}]", min, max, yMin, yMax);
*/ public double solve(final UnivariateRealFunction f, final double min, final double max) throws MaxIterationsExceededException, FunctionEvaluationException {  clearResult(); verifyInterval(min, max);  double ret = Double.NaN;  double yMin = f.value(min); double yMax = f.value(max);  /* Verify bracketing*/ double sign = yMin * yMax; if (sign > 0) { /* check if either value is close to a zero*/ if (Math.abs(yMin) <= functionValueAccuracy) { setResult(min, 0); ret = min; <BUGS> } else if (Math.abs(yMax) <= functionValueAccuracy) { <BUGE> setResult(max, 0); ret = max; } else { /* neither value is close to zero and min and max do not bracket root.*/ throw MathRuntimeException.createIllegalArgumentException( "function values at endpoints do not have different signs.  " + "Endpoints: [{0}, {1}], Values: [{2}, {3}]", min, max, yMin, yMax);
*/ public double solve(final UnivariateRealFunction f, final double min, final double max) throws MaxIterationsExceededException, FunctionEvaluationException {  clearResult(); verifyInterval(min, max);  double ret = Double.NaN;  double yMin = f.value(min); double yMax = f.value(max);  /* Verify bracketing*/ double sign = yMin * yMax; if (sign > 0) { /* check if either value is close to a zero*/ if (Math.abs(yMin) <= functionValueAccuracy) { setResult(min, 0); ret = min; } else if (Math.abs(yMax) <= functionValueAccuracy) { setResult(max, 0); ret = max; } else { /* neither value is close to zero and min and max do not bracket root.*/ <BUGS> throw MathRuntimeException.createIllegalArgumentException( <BUGE> "function values at endpoints do not have different signs.  " + "Endpoints: [{0}, {1}], Values: [{2}, {3}]", min, max, yMin, yMax);
* <p> * Requires that the values of the function at the endpoints have opposite * signs. An <code>IllegalArgumentException</code> is thrown if this is not * the case.</p> * * @param f the function to solve * @param min the lower bound for the interval. * @param max the upper bound for the interval. * @return the value where the function is zero * @throws MaxIterationsExceededException if the maximum iteration count is exceeded * @throws FunctionEvaluationException if an error occurs evaluating the * function * @throws IllegalArgumentException if min is not less than max or the * signs of the values of the function at the endpoints are not opposites } <BUGS> } else if (sign < 0){ <BUGE> /* solve using only the first endpoint as initial guess*/ ret = solve(f, min, yMin, max, yMax, min, yMin); } else { /* either min or max is a root*/ if (yMin == 0.0) { ret = min; } else { ret = max; } }  return ret; }
* <p> * Requires that the values of the function at the endpoints have opposite * signs. An <code>IllegalArgumentException</code> is thrown if this is not * the case.</p> * * @param f the function to solve * @param min the lower bound for the interval. * @param max the upper bound for the interval. * @return the value where the function is zero * @throws MaxIterationsExceededException if the maximum iteration count is exceeded * @throws FunctionEvaluationException if an error occurs evaluating the * function * @throws IllegalArgumentException if min is not less than max or the * signs of the values of the function at the endpoints are not opposites /* solve using only the first endpoint as initial guess*/ <BUGS> ret = solve(f, min, yMin, max, yMax, min, yMin); <BUGE> } else { /* either min or max is a root*/ if (yMin == 0.0) { ret = min; } else { ret = max; } }  return ret; }  /** * Find a zero starting search according to the three provided points.
* <p> * Requires that the values of the function at the endpoints have opposite * signs. An <code>IllegalArgumentException</code> is thrown if this is not * the case.</p> * * @param f the function to solve * @param min the lower bound for the interval. * @param max the upper bound for the interval. * @return the value where the function is zero * @throws MaxIterationsExceededException if the maximum iteration count is exceeded * @throws FunctionEvaluationException if an error occurs evaluating the * function * @throws IllegalArgumentException if min is not less than max or the * signs of the values of the function at the endpoints are not opposites  <BUGS> return ret; <BUGE> }  /** * Find a zero starting search according to the three provided points. * @param f the function to solve * @param x0 old approximation for the root * @param y0 function value at the approximation for the root * @param x1 last calculated approximation for the root * @param y1 function value at the last calculated approximation * for the root * @param x2 bracket point (must be set to x0 if no bracket point is * known, this will force starting with linear interpolation) * @param y2 function value at the bracket point. * @return the value where the function is zero
*/ <BUGS> public KMeansPlusPlusClusterer(final Random random) { this.random = random; } <BUGE>
*/ private void processGeneralBlock(final int n) throws InvalidMatrixException {  /* check decomposed matrix data range*/ <BUGS> double sumOffDiag = 0; for (int i = 0; i < n - 1; ++i) { final int fourI = 4 * i; final double ei = work[fourI + 2]; sumOffDiag += ei; <BUGE> }  if (sumOffDiag == 0) { /* matrix is already diagonal*/ return; }  /* initial checks for splits (see Parlett & Marques section 3.3)*/ flipIfWarranted(n, 2);  /* two iterations with Li's test for initial splits*/ initialSplits(n);  /* initialize parameters used by goodStep*/ tType = 0; dMin1 = 0; dMin2 = 0; dN    = 0; dN1   = 0; dN2   = 0;
*/ private void processGeneralBlock(final int n) throws InvalidMatrixException {  /* check decomposed matrix data range*/ double sumOffDiag = 0; for (int i = 0; i < n - 1; ++i) { final int fourI = 4 * i; final double ei = work[fourI + 2]; sumOffDiag += ei; }  <BUGS> if (sumOffDiag == 0) { <BUGE> /* matrix is already diagonal*/ return; }  /* initial checks for splits (see Parlett & Marques section 3.3)*/ flipIfWarranted(n, 2);  /* two iterations with Li's test for initial splits*/ initialSplits(n);  /* initialize parameters used by goodStep*/ tType = 0; dMin1 = 0; dMin2 = 0; dN    = 0; dN1   = 0; dN2   = 0;
*/ private void processGeneralBlock(final int n) throws InvalidMatrixException {  /* check decomposed matrix data range*/ double sumOffDiag = 0; for (int i = 0; i < n - 1; ++i) { final int fourI = 4 * i; final double ei = work[fourI + 2]; sumOffDiag += ei; }  if (sumOffDiag == 0) { /* matrix is already diagonal*/ return; }  /* initial checks for splits (see Parlett & Marques section 3.3)*/ <BUGS> flipIfWarranted(n, 2); <BUGE>  /* two iterations with Li's test for initial splits*/ initialSplits(n);  /* initialize parameters used by goodStep*/ tType = 0; dMin1 = 0; dMin2 = 0; dN    = 0; dN1   = 0; dN2   = 0;
*/ private void processGeneralBlock(final int n) throws InvalidMatrixException {  /* check decomposed matrix data range*/ double sumOffDiag = 0; for (int i = 0; i < n - 1; ++i) { final int fourI = 4 * i; final double ei = work[fourI + 2]; sumOffDiag += ei; }  if (sumOffDiag == 0) { /* matrix is already diagonal*/ return; }  /* initial checks for splits (see Parlett & Marques section 3.3)*/ flipIfWarranted(n, 2);  /* two iterations with Li's test for initial splits*/ <BUGS> initialSplits(n); <BUGE>  /* initialize parameters used by goodStep*/ tType = 0; dMin1 = 0; dMin2 = 0; dN    = 0; dN1   = 0; dN2   = 0;
*/ private void processGeneralBlock(final int n) throws InvalidMatrixException {  /* check decomposed matrix data range*/ double sumOffDiag = 0; for (int i = 0; i < n - 1; ++i) { final int fourI = 4 * i; final double ei = work[fourI + 2]; sumOffDiag += ei; }  if (sumOffDiag == 0) { /* matrix is already diagonal*/ return; }  /* initial checks for splits (see Parlett & Marques section 3.3)*/ flipIfWarranted(n, 2);  /* two iterations with Li's test for initial splits*/ initialSplits(n);  /* initialize parameters used by goodStep*/ <BUGS> tType = 0; dMin1 = 0; dMin2 = 0; dN    = 0; dN1   = 0; dN2   = 0;
}  /** * Find realEigenvalues using dqd/dqds algorithms. * <p>This implementation is based on Beresford N. Parlett * and Osni A. Marques paper <a * href="http:/*www.netlib.org/lapack/lawnspdf/lawn155.pdf">An*/ * Implementation of the dqds Algorithm (Positive Case)</a> and on the * corresponding LAPACK routine DLASQ2.</p> * @param n number of rows of the block * @exception InvalidMatrixException if block cannot be diagonalized * after 30 * n iterations /* process split segments*/ <BUGS> int i0 = 0; int n0 = n; while (n0 > 0) { <BUGE>  /* retrieve shift that was temporarily stored as a negative off-diagonal element*/ sigma    = (n0 == n) ? 0 : -work[4 * n0 - 2]; sigmaLow = 0;  /* find start of a new split segment to process*/ double offDiagMin = (i0 == n0) ? 0 : work[4 * n0 - 6]; double offDiagMax = 0; double diagMax    = work[4 * n0 - 4]; double diagMin    = diagMax; i0 = 0; for (int i = 4 * (n0 - 2); i >= 0; i -= 4) { if (work[i + 2] <= 0) {
realEigenvalues[index + 2] = z2;  }  /** * Find realEigenvalues using dqd/dqds algorithms. * <p>This implementation is based on Beresford N. Parlett * and Osni A. Marques paper <a * href="http:/*www.netlib.org/lapack/lawnspdf/lawn155.pdf">An*/ * Implementation of the dqds Algorithm (Positive Case)</a> and on the * corresponding LAPACK routine DLASQ2.</p> * @param n number of rows of the block * @exception InvalidMatrixException if block cannot be diagonalized * after 30 * n iterations /* retrieve shift that was temporarily stored as a negative off-diagonal element*/ <BUGS> sigma    = (n0 == n) ? 0 : -work[4 * n0 - 2]; sigmaLow = 0; <BUGE>  /* find start of a new split segment to process*/ double offDiagMin = (i0 == n0) ? 0 : work[4 * n0 - 6]; double offDiagMax = 0; double diagMax    = work[4 * n0 - 4]; double diagMin    = diagMax; i0 = 0; for (int i = 4 * (n0 - 2); i >= 0; i -= 4) { if (work[i + 2] <= 0) { i0 = 1 + i / 4; break; } if (diagMin >= 4 * offDiagMax) {
/** * Find realEigenvalues using dqd/dqds algorithms. * <p>This implementation is based on Beresford N. Parlett * and Osni A. Marques paper <a * href="http:/*www.netlib.org/lapack/lawnspdf/lawn155.pdf">An*/ * Implementation of the dqds Algorithm (Positive Case)</a> and on the * corresponding LAPACK routine DLASQ2.</p> * @param n number of rows of the block * @exception InvalidMatrixException if block cannot be diagonalized * after 30 * n iterations /* find start of a new split segment to process*/ <BUGS> double offDiagMin = (i0 == n0) ? 0 : work[4 * n0 - 6]; double offDiagMax = 0; double diagMax    = work[4 * n0 - 4]; double diagMin    = diagMax; i0 = 0; for (int i = 4 * (n0 - 2); i >= 0; i -= 4) { if (work[i + 2] <= 0) { i0 = 1 + i / 4; break; <BUGE> } if (diagMin >= 4 * offDiagMax) { diagMin    = Math.min(diagMin, work[i + 4]); offDiagMax = Math.max(offDiagMax, work[i + 2]); } diagMax    = Math.max(diagMax, work[i] + work[i + 2]); offDiagMin = Math.min(offDiagMin, work[i + 2]); } work[4 * n0 - 2] = offDiagMin;
}  /** * Find realEigenvalues using dqd/dqds algorithms. * <p>This implementation is based on Beresford N. Parlett * and Osni A. Marques paper <a * href="http:/*www.netlib.org/lapack/lawnspdf/lawn155.pdf">An*/ * Implementation of the dqds Algorithm (Positive Case)</a> and on the * corresponding LAPACK routine DLASQ2.</p> * @param n number of rows of the block * @exception InvalidMatrixException if block cannot be diagonalized * after 30 * n iterations } <BUGS> if (diagMin >= 4 * offDiagMax) { diagMin    = Math.min(diagMin, work[i + 4]); offDiagMax = Math.max(offDiagMax, work[i + 2]); <BUGE> } diagMax    = Math.max(diagMax, work[i] + work[i + 2]); offDiagMin = Math.min(offDiagMin, work[i + 2]); } work[4 * n0 - 2] = offDiagMin;  /* lower bound of Gershgorin disk*/ dMin = -Math.max(0, diagMin - 2 * Math.sqrt(diagMin * offDiagMax));  pingPong = 0; int maxIter = 30 * (n0 - i0); for (int k = 0; i0 < n0; ++k) { if (k >= maxIter) {
realEigenvalues[index + 2] = z2;  }  /** * Find realEigenvalues using dqd/dqds algorithms. * <p>This implementation is based on Beresford N. Parlett * and Osni A. Marques paper <a * href="http:/*www.netlib.org/lapack/lawnspdf/lawn155.pdf">An*/ * Implementation of the dqds Algorithm (Positive Case)</a> and on the * corresponding LAPACK routine DLASQ2.</p> * @param n number of rows of the block * @exception InvalidMatrixException if block cannot be diagonalized * after 30 * n iterations } <BUGS> diagMax    = Math.max(diagMax, work[i] + work[i + 2]); offDiagMin = Math.min(offDiagMin, work[i + 2]); <BUGE> } work[4 * n0 - 2] = offDiagMin;  /* lower bound of Gershgorin disk*/ dMin = -Math.max(0, diagMin - 2 * Math.sqrt(diagMin * offDiagMax));  pingPong = 0; int maxIter = 30 * (n0 - i0); for (int k = 0; i0 < n0; ++k) { if (k >= maxIter) { throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter)); }
realEigenvalues[index + 2] = z2;  }  /** * Find realEigenvalues using dqd/dqds algorithms. * <p>This implementation is based on Beresford N. Parlett * and Osni A. Marques paper <a * href="http:/*www.netlib.org/lapack/lawnspdf/lawn155.pdf">An*/ * Implementation of the dqds Algorithm (Positive Case)</a> and on the * corresponding LAPACK routine DLASQ2.</p> * @param n number of rows of the block * @exception InvalidMatrixException if block cannot be diagonalized * after 30 * n iterations } <BUGS> work[4 * n0 - 2] = offDiagMin; <BUGE>  /* lower bound of Gershgorin disk*/ dMin = -Math.max(0, diagMin - 2 * Math.sqrt(diagMin * offDiagMax));  pingPong = 0; int maxIter = 30 * (n0 - i0); for (int k = 0; i0 < n0; ++k) { if (k >= maxIter) { throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter)); }  /* perform one step*/ n0 = goodStep(i0, n0); pingPong = 1 - pingPong;
realEigenvalues[index + 2] = z2;  }  /** * Find realEigenvalues using dqd/dqds algorithms. * <p>This implementation is based on Beresford N. Parlett * and Osni A. Marques paper <a * href="http:/*www.netlib.org/lapack/lawnspdf/lawn155.pdf">An*/ * Implementation of the dqds Algorithm (Positive Case)</a> and on the * corresponding LAPACK routine DLASQ2.</p> * @param n number of rows of the block * @exception InvalidMatrixException if block cannot be diagonalized * after 30 * n iterations /* lower bound of Gershgorin disk*/ <BUGS> dMin = -Math.max(0, diagMin - 2 * Math.sqrt(diagMin * offDiagMax)); <BUGE>  pingPong = 0; int maxIter = 30 * (n0 - i0); for (int k = 0; i0 < n0; ++k) { if (k >= maxIter) { throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter)); }  /* perform one step*/ n0 = goodStep(i0, n0); pingPong = 1 - pingPong;  /* check for new splits after "ping" steps*/ /* when the last elements of qd array are very small*/
}  /** * Find realEigenvalues using dqd/dqds algorithms. * <p>This implementation is based on Beresford N. Parlett * and Osni A. Marques paper <a * href="http:/*www.netlib.org/lapack/lawnspdf/lawn155.pdf">An*/ * Implementation of the dqds Algorithm (Positive Case)</a> and on the * corresponding LAPACK routine DLASQ2.</p> * @param n number of rows of the block * @exception InvalidMatrixException if block cannot be diagonalized * after 30 * n iterations  <BUGS> pingPong = 0; int maxIter = 30 * (n0 - i0); for (int k = 0; i0 < n0; ++k) { if (k >= maxIter) { <BUGE> throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter)); }  /* perform one step*/ n0 = goodStep(i0, n0); pingPong = 1 - pingPong;  /* check for new splits after "ping" steps*/ /* when the last elements of qd array are very small*/ if ((pingPong == 0) && (n0 - i0 > 3) && (work[4 * n0 - 1] <= TOLERANCE_2 * diagMax) && (work[4 * n0 - 2] <= TOLERANCE_2 * sigma)) {
realEigenvalues[index + 2] = z2;  }  /** * Find realEigenvalues using dqd/dqds algorithms. * <p>This implementation is based on Beresford N. Parlett * and Osni A. Marques paper <a * href="http:/*www.netlib.org/lapack/lawnspdf/lawn155.pdf">An*/ * Implementation of the dqds Algorithm (Positive Case)</a> and on the * corresponding LAPACK routine DLASQ2.</p> * @param n number of rows of the block * @exception InvalidMatrixException if block cannot be diagonalized * after 30 * n iterations /* perform one step*/ <BUGS> n0 = goodStep(i0, n0); pingPong = 1 - pingPong; <BUGE>  /* check for new splits after "ping" steps*/ /* when the last elements of qd array are very small*/ if ((pingPong == 0) && (n0 - i0 > 3) && (work[4 * n0 - 1] <= TOLERANCE_2 * diagMax) && (work[4 * n0 - 2] <= TOLERANCE_2 * sigma)) { int split  = i0 - 1; diagMax    = work[4 * i0]; offDiagMin = work[4 * i0 + 2]; double previousEMin = work[4 * i0 + 3]; for (int i = 4 * i0; i < 4 * n0 - 16; i += 4) { if ((work[i + 3] <= TOLERANCE_2 * work[i]) || (work[i + 2] <= TOLERANCE_2 * sigma)) {
realEigenvalues[index + 2] = z2;  }  /** * Find realEigenvalues using dqd/dqds algorithms. * <p>This implementation is based on Beresford N. Parlett * and Osni A. Marques paper <a * href="http:/*www.netlib.org/lapack/lawnspdf/lawn155.pdf">An*/ * Implementation of the dqds Algorithm (Positive Case)</a> and on the * corresponding LAPACK routine DLASQ2.</p> * @param n number of rows of the block * @exception InvalidMatrixException if block cannot be diagonalized * after 30 * n iterations /* when the last elements of qd array are very small*/ <BUGS> if ((pingPong == 0) && (n0 - i0 > 3) && <BUGE> (work[4 * n0 - 1] <= TOLERANCE_2 * diagMax) && (work[4 * n0 - 2] <= TOLERANCE_2 * sigma)) { int split  = i0 - 1; diagMax    = work[4 * i0]; offDiagMin = work[4 * i0 + 2]; double previousEMin = work[4 * i0 + 3]; for (int i = 4 * i0; i < 4 * n0 - 16; i += 4) { if ((work[i + 3] <= TOLERANCE_2 * work[i]) || (work[i + 2] <= TOLERANCE_2 * sigma)) { /* insert a split*/ work[i + 2]  = -sigma; split        = i / 4; diagMax      = 0; offDiagMin   = work[i + 6];
realEigenvalues[index + 2] = z2;  }  /** * Find realEigenvalues using dqd/dqds algorithms. * <p>This implementation is based on Beresford N. Parlett * and Osni A. Marques paper <a * href="http:/*www.netlib.org/lapack/lawnspdf/lawn155.pdf">An*/ * Implementation of the dqds Algorithm (Positive Case)</a> and on the * corresponding LAPACK routine DLASQ2.</p> * @param n number of rows of the block * @exception InvalidMatrixException if block cannot be diagonalized * after 30 * n iterations  <BUGS> } <BUGE>  }  /** * Perform two iterations with Li's tests for initial splits. * @param n number of rows of the matrix to process */ private void initialSplits(final int n) {  pingPong = 0; for (int k = 0; k < 2; ++k) {  /* apply Li's reverse test*/ double d = work[4 * (n - 1) + pingPong];
realEigenvalues[index + 2] = z2;  }  /** * Find realEigenvalues using dqd/dqds algorithms. * <p>This implementation is based on Beresford N. Parlett * and Osni A. Marques paper <a * href="http:/*www.netlib.org/lapack/lawnspdf/lawn155.pdf">An*/ * Implementation of the dqds Algorithm (Positive Case)</a> and on the * corresponding LAPACK routine DLASQ2.</p> * @param n number of rows of the block * @exception InvalidMatrixException if block cannot be diagonalized * after 30 * n iterations  <BUGS> } <BUGE>  /** * Perform two iterations with Li's tests for initial splits. * @param n number of rows of the matrix to process */ private void initialSplits(final int n) {  pingPong = 0; for (int k = 0; k < 2; ++k) {  /* apply Li's reverse test*/ double d = work[4 * (n - 1) + pingPong]; for (int i = 4 * (n - 2) + pingPong; i >= 0; i -= 4) { if (work[i + 2] <= TOLERANCE_2 * d) {
*/ private void computeShiftIncrement(final int start, final int end, final int deflated) {  <BUGS> final double cnst1 = 0.563; final double cnst2 = 1.010; final double cnst3 = 1.05; <BUGE>  /* a negative dMin forces the shift to take that absolute value*/ /* tType records the type of shift.*/ if (dMin <= 0.0) { tau = -dMin; tType = -1; return; }  int nn = 4 * end + pingPong - 1; switch (deflated) {  case 0 : /* no realEigenvalues deflated.*/ if (dMin == dN || dMin == dN1) {  double b1 = Math.sqrt(work[nn - 3]) * Math.sqrt(work[nn - 5]); double b2 = Math.sqrt(work[nn - 7]) * Math.sqrt(work[nn - 9]); double a2 = work[nn - 7] + work[nn - 5];  if (dMin == dN && dMin1 == dN1) { /* cases 2 and 3.*/ final double gap2 = dMin2 - a2 - dMin2 * 0.25; final double gap1 = a2 - dN - ((gap2 > 0.0 && gap2 > b2) ? (b2 / gap2) * b2 : (b1 + b2)); if (gap1 > 0.0 && gap1 > b1) {
*/ private void computeShiftIncrement(final int start, final int end, final int deflated) {  final double cnst1 = 0.563; final double cnst2 = 1.010; final double cnst3 = 1.05;  /* a negative dMin forces the shift to take that absolute value*/ /* tType records the type of shift.*/ <BUGS> if (dMin <= 0.0) { <BUGE> tau = -dMin; tType = -1; return; }  int nn = 4 * end + pingPong - 1; switch (deflated) {  case 0 : /* no realEigenvalues deflated.*/ if (dMin == dN || dMin == dN1) {  double b1 = Math.sqrt(work[nn - 3]) * Math.sqrt(work[nn - 5]); double b2 = Math.sqrt(work[nn - 7]) * Math.sqrt(work[nn - 9]); double a2 = work[nn - 7] + work[nn - 5];  if (dMin == dN && dMin1 == dN1) { /* cases 2 and 3.*/ final double gap2 = dMin2 - a2 - dMin2 * 0.25; final double gap1 = a2 - dN - ((gap2 > 0.0 && gap2 > b2) ? (b2 / gap2) * b2 : (b1 + b2)); if (gap1 > 0.0 && gap1 > b1) {
*/ private void computeShiftIncrement(final int start, final int end, final int deflated) {  final double cnst1 = 0.563; final double cnst2 = 1.010; final double cnst3 = 1.05;  /* a negative dMin forces the shift to take that absolute value*/ /* tType records the type of shift.*/ if (dMin <= 0.0) { tau = -dMin; tType = -1; return; }  <BUGS> int nn = 4 * end + pingPong - 1; switch (deflated) { <BUGE>  case 0 : /* no realEigenvalues deflated.*/ if (dMin == dN || dMin == dN1) {  double b1 = Math.sqrt(work[nn - 3]) * Math.sqrt(work[nn - 5]); double b2 = Math.sqrt(work[nn - 7]) * Math.sqrt(work[nn - 9]); double a2 = work[nn - 7] + work[nn - 5];  if (dMin == dN && dMin1 == dN1) { /* cases 2 and 3.*/ final double gap2 = dMin2 - a2 - dMin2 * 0.25; final double gap1 = a2 - dN - ((gap2 > 0.0 && gap2 > b2) ? (b2 / gap2) * b2 : (b1 + b2)); if (gap1 > 0.0 && gap1 > b1) {
*/ private void computeShiftIncrement(final int start, final int end, final int deflated) {  final double cnst1 = 0.563; final double cnst2 = 1.010; final double cnst3 = 1.05;  /* a negative dMin forces the shift to take that absolute value*/ /* tType records the type of shift.*/ if (dMin <= 0.0) { tau = -dMin; tType = -1; return; }  int nn = 4 * end + pingPong - 1; switch (deflated) {  case 0 : /* no realEigenvalues deflated.*/ <BUGS> if (dMin == dN || dMin == dN1) { <BUGE>  double b1 = Math.sqrt(work[nn - 3]) * Math.sqrt(work[nn - 5]); double b2 = Math.sqrt(work[nn - 7]) * Math.sqrt(work[nn - 9]); double a2 = work[nn - 7] + work[nn - 5];  if (dMin == dN && dMin1 == dN1) { /* cases 2 and 3.*/ final double gap2 = dMin2 - a2 - dMin2 * 0.25; final double gap1 = a2 - dN - ((gap2 > 0.0 && gap2 > b2) ? (b2 / gap2) * b2 : (b1 + b2)); if (gap1 > 0.0 && gap1 > b1) {
*/ private void computeShiftIncrement(final int start, final int end, final int deflated) {  final double cnst1 = 0.563; final double cnst2 = 1.010; final double cnst3 = 1.05;  /* a negative dMin forces the shift to take that absolute value*/ /* tType records the type of shift.*/ if (dMin <= 0.0) { tau = -dMin; tType = -1; return; }  int nn = 4 * end + pingPong - 1; switch (deflated) {  case 0 : /* no realEigenvalues deflated.*/ if (dMin == dN || dMin == dN1) {  <BUGS> double b1 = Math.sqrt(work[nn - 3]) * Math.sqrt(work[nn - 5]); double b2 = Math.sqrt(work[nn - 7]) * Math.sqrt(work[nn - 9]); double a2 = work[nn - 7] + work[nn - 5]; <BUGE>  if (dMin == dN && dMin1 == dN1) { /* cases 2 and 3.*/ final double gap2 = dMin2 - a2 - dMin2 * 0.25; final double gap1 = a2 - dN - ((gap2 > 0.0 && gap2 > b2) ? (b2 / gap2) * b2 : (b1 + b2)); if (gap1 > 0.0 && gap1 > b1) {
*/ private void computeShiftIncrement(final int start, final int end, final int deflated) {  final double cnst1 = 0.563; final double cnst2 = 1.010; final double cnst3 = 1.05;  /* a negative dMin forces the shift to take that absolute value*/ /* tType records the type of shift.*/ if (dMin <= 0.0) { tau = -dMin; tType = -1; return; }  int nn = 4 * end + pingPong - 1; switch (deflated) {  case 0 : /* no realEigenvalues deflated.*/ if (dMin == dN || dMin == dN1) {  double b1 = Math.sqrt(work[nn - 3]) * Math.sqrt(work[nn - 5]); double b2 = Math.sqrt(work[nn - 7]) * Math.sqrt(work[nn - 9]); double a2 = work[nn - 7] + work[nn - 5];  <BUGS> if (dMin == dN && dMin1 == dN1) { <BUGE> /* cases 2 and 3.*/ final double gap2 = dMin2 - a2 - dMin2 * 0.25; final double gap1 = a2 - dN - ((gap2 > 0.0 && gap2 > b2) ? (b2 / gap2) * b2 : (b1 + b2)); if (gap1 > 0.0 && gap1 > b1) {
work[j4 + 2] = dN; work[4 * end - pingPong - 1] = eMin;  }  /** * Compute the shift increment as an estimate of the smallest eigenvalue. * <p>This implementation is a translation of the LAPACK routine DLAZQ4.</p> * @param start start index * @param end end index * @param deflated number of realEigenvalues just deflated /* cases 2 and 3.*/ <BUGS> final double gap2 = dMin2 - a2 - dMin2 * 0.25; final double gap1 = a2 - dN - ((gap2 > 0.0 && gap2 > b2) ? (b2 / gap2) * b2 : (b1 + b2)); if (gap1 > 0.0 && gap1 > b1) { tau   = Math.max(dN - (b1 / gap1) * b1, 0.5 * dMin); tType = -2; <BUGE> } else { double s = 0.0; if (dN > b1) { s = dN - b1; } if (a2 > (b1 + b2)) { s = Math.min(s, a2 - (b1 + b2)); } tau   = Math.max(s, 0.333 * dMin); tType = -3; } } else {
} dMin = Math.min(dMin, dN);  work[j4 + 2] = dN; work[4 * end - pingPong - 1] = eMin;  }  /** * Compute the shift increment as an estimate of the smallest eigenvalue. * <p>This implementation is a translation of the LAPACK routine DLAZQ4.</p> * @param start start index * @param end end index * @param deflated number of realEigenvalues just deflated } <BUGS> } else { <BUGE> /* case 4.*/ tType = -4; double s = 0.25 * dMin; double gam; int np; if (dMin == dN) { gam = dN; a2 = 0.0; if (work[nn - 5]  >  work[nn - 7]) { return; } b2 = work[nn - 5] / work[nn - 7]; np = nn - 9; } else {
} dMin = Math.min(dMin, dN);  work[j4 + 2] = dN; work[4 * end - pingPong - 1] = eMin;  }  /** * Compute the shift increment as an estimate of the smallest eigenvalue. * <p>This implementation is a translation of the LAPACK routine DLAZQ4.</p> * @param start start index * @param end end index * @param deflated number of realEigenvalues just deflated /* case 4.*/ <BUGS> tType = -4; double s = 0.25 * dMin; <BUGE> double gam; int np; if (dMin == dN) { gam = dN; a2 = 0.0; if (work[nn - 5]  >  work[nn - 7]) { return; } b2 = work[nn - 5] / work[nn - 7]; np = nn - 9; } else { np = nn - 2 * pingPong; b2 = work[np - 2];
dMin = Math.min(dMin, dN);  work[j4 + 2] = dN; work[4 * end - pingPong - 1] = eMin;  }  /** * Compute the shift increment as an estimate of the smallest eigenvalue. * <p>This implementation is a translation of the LAPACK routine DLAZQ4.</p> * @param start start index * @param end end index * @param deflated number of realEigenvalues just deflated int np; <BUGS> if (dMin == dN) { gam = dN; a2 = 0.0; if (work[nn - 5]  >  work[nn - 7]) { <BUGE> return; } b2 = work[nn - 5] / work[nn - 7]; np = nn - 9; } else { np = nn - 2 * pingPong; b2 = work[np - 2]; gam = dN1; if (work[np - 4]  >  work[np - 2]) { return; } a2 = work[np - 4] / work[np - 2];
} dMin = Math.min(dMin, dN);  work[j4 + 2] = dN; work[4 * end - pingPong - 1] = eMin;  }  /** * Compute the shift increment as an estimate of the smallest eigenvalue. * <p>This implementation is a translation of the LAPACK routine DLAZQ4.</p> * @param start start index * @param end end index * @param deflated number of realEigenvalues just deflated } <BUGS> b2 = work[nn - 5] / work[nn - 7]; np = nn - 9; <BUGE> } else { np = nn - 2 * pingPong; b2 = work[np - 2]; gam = dN1; if (work[np - 4]  >  work[np - 2]) { return; } a2 = work[np - 4] / work[np - 2]; if (work[nn - 9]  >  work[nn - 11]) { return; } b2 = work[nn - 9] / work[nn - 11]; np = nn - 13;
dMin = Math.min(dMin, dN);  work[j4 + 2] = dN; work[4 * end - pingPong - 1] = eMin;  }  /** * Compute the shift increment as an estimate of the smallest eigenvalue. * <p>This implementation is a translation of the LAPACK routine DLAZQ4.</p> * @param start start index * @param end end index * @param deflated number of realEigenvalues just deflated /* approximate contribution to norm squared from i < nn-1.*/ <BUGS> a2 = a2 + b2; for (int i4 = np; i4 >= 4 * start + 2 + pingPong; i4 -= 4) { if(b2 == 0.0) { <BUGE> break; } b1 = b2; if (work[i4]  >  work[i4 - 2]) { return; } b2 = b2 * (work[i4] / work[i4 - 2]); a2 = a2 + b2; if (100 * Math.max(b2, b1) < a2 || cnst1 < a2) { break; } } a2 = cnst3 * a2;
dMin = Math.min(dMin, dN);  work[j4 + 2] = dN; work[4 * end - pingPong - 1] = eMin;  }  /** * Compute the shift increment as an estimate of the smallest eigenvalue. * <p>This implementation is a translation of the LAPACK routine DLAZQ4.</p> * @param start start index * @param end end index * @param deflated number of realEigenvalues just deflated } <BUGS> b1 = b2; if (work[i4]  >  work[i4 - 2]) { return; <BUGE> } b2 = b2 * (work[i4] / work[i4 - 2]); a2 = a2 + b2; if (100 * Math.max(b2, b1) < a2 || cnst1 < a2) { break; } } a2 = cnst3 * a2;  /* rayleigh quotient residual bound.*/ if (a2 < cnst1) { s = gam * (1 - Math.sqrt(a2)) / (1 + a2); }
dMin = Math.min(dMin, dN);  work[j4 + 2] = dN; work[4 * end - pingPong - 1] = eMin;  }  /** * Compute the shift increment as an estimate of the smallest eigenvalue. * <p>This implementation is a translation of the LAPACK routine DLAZQ4.</p> * @param start start index * @param end end index * @param deflated number of realEigenvalues just deflated } <BUGS> b2 = b2 * (work[i4] / work[i4 - 2]); a2 = a2 + b2; if (100 * Math.max(b2, b1) < a2 || cnst1 < a2) { <BUGE> break; } } a2 = cnst3 * a2;  /* rayleigh quotient residual bound.*/ if (a2 < cnst1) { s = gam * (1 - Math.sqrt(a2)) / (1 + a2); } tau = s;  } } else if (dMin == dN2) {
} dMin = Math.min(dMin, dN);  work[j4 + 2] = dN; work[4 * end - pingPong - 1] = eMin;  }  /** * Compute the shift increment as an estimate of the smallest eigenvalue. * <p>This implementation is a translation of the LAPACK routine DLAZQ4.</p> * @param start start index * @param end end index * @param deflated number of realEigenvalues just deflated } <BUGS> a2 = cnst3 * a2; <BUGE>  /* rayleigh quotient residual bound.*/ if (a2 < cnst1) { s = gam * (1 - Math.sqrt(a2)) / (1 + a2); } tau = s;  } } else if (dMin == dN2) {  /* case 5.*/ tType = -5; double s = 0.25 * dMin;
} dMin = Math.min(dMin, dN);  work[j4 + 2] = dN; work[4 * end - pingPong - 1] = eMin;  }  /** * Compute the shift increment as an estimate of the smallest eigenvalue. * <p>This implementation is a translation of the LAPACK routine DLAZQ4.</p> * @param start start index * @param end end index * @param deflated number of realEigenvalues just deflated /* rayleigh quotient residual bound.*/ <BUGS> if (a2 < cnst1) { s = gam * (1 - Math.sqrt(a2)) / (1 + a2); <BUGE> } tau = s;  } } else if (dMin == dN2) {  /* case 5.*/ tType = -5; double s = 0.25 * dMin;  /* compute contribution to norm squared from i > nn-2.*/ final int np = nn - 2 * pingPong; double b1 = work[np - 2];
} dMin = Math.min(dMin, dN);  work[j4 + 2] = dN; work[4 * end - pingPong - 1] = eMin;  }  /** * Compute the shift increment as an estimate of the smallest eigenvalue. * <p>This implementation is a translation of the LAPACK routine DLAZQ4.</p> * @param start start index * @param end end index * @param deflated number of realEigenvalues just deflated } <BUGS> tau = s; <BUGE>  } } else if (dMin == dN2) {  /* case 5.*/ tType = -5; double s = 0.25 * dMin;  /* compute contribution to norm squared from i > nn-2.*/ final int np = nn - 2 * pingPong; double b1 = work[np - 2]; double b2 = work[np - 6]; final double gam = dN2; if (work[np - 8] > b2 || work[np - 4] > b1) {
} dMin = Math.min(dMin, dN);  work[j4 + 2] = dN; work[4 * end - pingPong - 1] = eMin;  }  /** * Compute the shift increment as an estimate of the smallest eigenvalue. * <p>This implementation is a translation of the LAPACK routine DLAZQ4.</p> * @param start start index * @param end end index * @param deflated number of realEigenvalues just deflated } <BUGS> } else if (dMin == dN2) { <BUGE>  /* case 5.*/ tType = -5; double s = 0.25 * dMin;  /* compute contribution to norm squared from i > nn-2.*/ final int np = nn - 2 * pingPong; double b1 = work[np - 2]; double b2 = work[np - 6]; final double gam = dN2; if (work[np - 8] > b2 || work[np - 4] > b1) { return; } double a2 = (work[np - 8] / b2) * (1 + work[np - 4] / b1);
} dMin = Math.min(dMin, dN);  work[j4 + 2] = dN; work[4 * end - pingPong - 1] = eMin;  }  /** * Compute the shift increment as an estimate of the smallest eigenvalue. * <p>This implementation is a translation of the LAPACK routine DLAZQ4.</p> * @param start start index * @param end end index * @param deflated number of realEigenvalues just deflated /* case 5.*/ <BUGS> tType = -5; double s = 0.25 * dMin; <BUGE>  /* compute contribution to norm squared from i > nn-2.*/ final int np = nn - 2 * pingPong; double b1 = work[np - 2]; double b2 = work[np - 6]; final double gam = dN2; if (work[np - 8] > b2 || work[np - 4] > b1) { return; } double a2 = (work[np - 8] / b2) * (1 + work[np - 4] / b1);  /* approximate contribution to norm squared from i < nn-2.*/ if (end - start > 2) {
work[j4 + 2] = dN; work[4 * end - pingPong - 1] = eMin;  }  /** * Compute the shift increment as an estimate of the smallest eigenvalue. * <p>This implementation is a translation of the LAPACK routine DLAZQ4.</p> * @param start start index * @param end end index * @param deflated number of realEigenvalues just deflated /* compute contribution to norm squared from i > nn-2.*/ <BUGS> final int np = nn - 2 * pingPong; double b1 = work[np - 2]; double b2 = work[np - 6]; final double gam = dN2; if (work[np - 8] > b2 || work[np - 4] > b1) { <BUGE> return; } double a2 = (work[np - 8] / b2) * (1 + work[np - 4] / b1);  /* approximate contribution to norm squared from i < nn-2.*/ if (end - start > 2) { b2 = work[nn - 13] / work[nn - 15]; a2 = a2 + b2; for (int i4 = nn - 17; i4 >= 4 * start + 2 + pingPong; i4 -= 4) { if (b2 == 0.0) { break; }
} dMin = Math.min(dMin, dN);  work[j4 + 2] = dN; work[4 * end - pingPong - 1] = eMin;  }  /** * Compute the shift increment as an estimate of the smallest eigenvalue. * <p>This implementation is a translation of the LAPACK routine DLAZQ4.</p> * @param start start index * @param end end index * @param deflated number of realEigenvalues just deflated } <BUGS> double a2 = (work[np - 8] / b2) * (1 + work[np - 4] / b1); <BUGE>  /* approximate contribution to norm squared from i < nn-2.*/ if (end - start > 2) { b2 = work[nn - 13] / work[nn - 15]; a2 = a2 + b2; for (int i4 = nn - 17; i4 >= 4 * start + 2 + pingPong; i4 -= 4) { if (b2 == 0.0) { break; } b1 = b2; if (work[i4]  >  work[i4 - 2]) { return; } b2 = b2 * (work[i4] / work[i4 - 2]);
} dMin = Math.min(dMin, dN);  work[j4 + 2] = dN; work[4 * end - pingPong - 1] = eMin;  }  /** * Compute the shift increment as an estimate of the smallest eigenvalue. * <p>This implementation is a translation of the LAPACK routine DLAZQ4.</p> * @param start start index * @param end end index * @param deflated number of realEigenvalues just deflated /* approximate contribution to norm squared from i < nn-2.*/ <BUGS> if (end - start > 2) { b2 = work[nn - 13] / work[nn - 15]; <BUGE> a2 = a2 + b2; for (int i4 = nn - 17; i4 >= 4 * start + 2 + pingPong; i4 -= 4) { if (b2 == 0.0) { break; } b1 = b2; if (work[i4]  >  work[i4 - 2]) { return; } b2 = b2 * (work[i4] / work[i4 - 2]); a2 = a2 + b2; if (100 * Math.max(b2, b1) < a2 || cnst1 < a2)  { break;
} dMin = Math.min(dMin, dN);  work[j4 + 2] = dN; work[4 * end - pingPong - 1] = eMin;  }  /** * Compute the shift increment as an estimate of the smallest eigenvalue. * <p>This implementation is a translation of the LAPACK routine DLAZQ4.</p> * @param start start index * @param end end index * @param deflated number of realEigenvalues just deflated case 1 : /* one eigenvalue just deflated. use dMin1, dN1 for dMin and dN.*/ <BUGS> if (dMin1 == dN1 && dMin2 == dN2) { <BUGE>  /* cases 7 and 8.*/ tType = -7; double s = 0.333 * dMin1; if (work[nn - 5] > work[nn - 7]) { return; } double b1 = work[nn - 5] / work[nn - 7]; double b2 = b1; if (b2 != 0.0) { for (int i4 = 4 * end - 10 + pingPong; i4 >= 4 * start + 2 + pingPong; i4 -= 4) { final double oldB1 = b1; if (work[i4] > work[i4 - 2]) { return;
} dMin = Math.min(dMin, dN);  work[j4 + 2] = dN; work[4 * end - pingPong - 1] = eMin;  }  /** * Compute the shift increment as an estimate of the smallest eigenvalue. * <p>This implementation is a translation of the LAPACK routine DLAZQ4.</p> * @param start start index * @param end end index * @param deflated number of realEigenvalues just deflated /* case 9.*/ <BUGS> tau = 0.25 * dMin1; if (dMin1 == dN1) { <BUGE> tau = 0.5 * dMin1; } tType = -9; } break;  case 2 : /* two realEigenvalues deflated. use dMin2, dN2 for dMin and dN.*/  /* cases 10 and 11.*/ if (dMin2 == dN2 && 2 * work[nn - 5] < work[nn - 7]) { tType = -10; final double s = 0.333 * dMin2; if (work[nn - 5] > work[nn - 7]) {
} dMin = Math.min(dMin, dN);  work[j4 + 2] = dN; work[4 * end - pingPong - 1] = eMin;  }  /** * Compute the shift increment as an estimate of the smallest eigenvalue. * <p>This implementation is a translation of the LAPACK routine DLAZQ4.</p> * @param start start index * @param end end index * @param deflated number of realEigenvalues just deflated } <BUGS> tType = -9; <BUGE> } break;  case 2 : /* two realEigenvalues deflated. use dMin2, dN2 for dMin and dN.*/  /* cases 10 and 11.*/ if (dMin2 == dN2 && 2 * work[nn - 5] < work[nn - 7]) { tType = -10; final double s = 0.333 * dMin2; if (work[nn - 5] > work[nn - 7]) { return; } double b1 = work[nn - 5] / work[nn - 7]; double b2 = b1;
} dMin = Math.min(dMin, dN);  work[j4 + 2] = dN; work[4 * end - pingPong - 1] = eMin;  }  /** * Compute the shift increment as an estimate of the smallest eigenvalue. * <p>This implementation is a translation of the LAPACK routine DLAZQ4.</p> * @param start start index * @param end end index * @param deflated number of realEigenvalues just deflated } <BUGS> break; <BUGE>  case 2 : /* two realEigenvalues deflated. use dMin2, dN2 for dMin and dN.*/  /* cases 10 and 11.*/ if (dMin2 == dN2 && 2 * work[nn - 5] < work[nn - 7]) { tType = -10; final double s = 0.333 * dMin2; if (work[nn - 5] > work[nn - 7]) { return; } double b1 = work[nn - 5] / work[nn - 7]; double b2 = b1; if (b2 != 0.0){ for (int i4 = 4 * end - 9 + pingPong; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {
} dMin = Math.min(dMin, dN);  work[j4 + 2] = dN; work[4 * end - pingPong - 1] = eMin;  }  /** * Compute the shift increment as an estimate of the smallest eigenvalue. * <p>This implementation is a translation of the LAPACK routine DLAZQ4.</p> * @param start start index * @param end end index * @param deflated number of realEigenvalues just deflated  <BUGS> } <BUGE>  /** * Update sigma. * @param shift shift to apply to sigma */ private void updateSigma(final double shift) { /* BEWARE: do NOT attempt to simplify the following statements*/ /* the expressions below take care to accumulate the part of sigma*/ /* that does not fit within a double variable into sigmaLow*/ if (shift < sigma) { sigmaLow += shift; final double t = sigma + sigmaLow; sigmaLow -= t - sigma; sigma = t;
*/ protected void solvePhase1(final SimplexTableau tableau) throws OptimizationException { /* make sure we're in Phase 1*/ <BUGS> if (tableau.getNumArtificialVariables() == 0) { return; <BUGE> }  while (!isPhase1Solved(tableau)) { doIteration(tableau); }  /* if W is not zero then we have no feasible solution*/ if (!MathUtils.equals(tableau.getEntry(0, tableau.getRhsOffset()), 0, epsilon)) { throw new NoFeasibleSolutionException(); } }
*/ protected RealPointValuePair getSolution() { <BUGS> double[] coefficients = new double[getOriginalNumDecisionVariables()]; Integer negativeVarBasicRow = getBasicRow(getNegativeDecisionVariableOffset()); double mostNegative = negativeVarBasicRow == null ? 0 : getEntry(negativeVarBasicRow, getRhsOffset()); Set<Integer> basicRows = new HashSet<Integer>(); for (int i = 0; i < coefficients.length; i++) { Integer basicRow = getBasicRow(getNumObjectiveFunctions() + i); if (basicRows.contains(basicRow)) { <BUGE> /* if multiple variables can take a given value */ /* then we choose the first and set the rest equal to 0*/ coefficients[i] = 0; } else { basicRows.add(basicRow); coefficients[i] = (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) - (restrictToNonNegative ? 0 : mostNegative); } } return new RealPointValuePair(coefficients, f.getValue(coefficients)); }
*/ protected RealPointValuePair getSolution() { double[] coefficients = new double[getOriginalNumDecisionVariables()]; Integer negativeVarBasicRow = getBasicRow(getNegativeDecisionVariableOffset()); double mostNegative = negativeVarBasicRow == null ? 0 : getEntry(negativeVarBasicRow, getRhsOffset()); Set<Integer> basicRows = new HashSet<Integer>(); for (int i = 0; i < coefficients.length; i++) { Integer basicRow = getBasicRow(getNumObjectiveFunctions() + i); if (basicRows.contains(basicRow)) { /* if multiple variables can take a given value */ /* then we choose the first and set the rest equal to 0*/ <BUGS> coefficients[i] = 0; <BUGE> } else { basicRows.add(basicRow); coefficients[i] = (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) - (restrictToNonNegative ? 0 : mostNegative); } } return new RealPointValuePair(coefficients, f.getValue(coefficients)); }
*/ protected RealPointValuePair getSolution() { double[] coefficients = new double[getOriginalNumDecisionVariables()]; Integer negativeVarBasicRow = getBasicRow(getNegativeDecisionVariableOffset()); double mostNegative = negativeVarBasicRow == null ? 0 : getEntry(negativeVarBasicRow, getRhsOffset()); Set<Integer> basicRows = new HashSet<Integer>(); for (int i = 0; i < coefficients.length; i++) { Integer basicRow = getBasicRow(getNumObjectiveFunctions() + i); if (basicRows.contains(basicRow)) { /* if multiple variables can take a given value */ /* then we choose the first and set the rest equal to 0*/ coefficients[i] = 0; } else { <BUGS> basicRows.add(basicRow); coefficients[i] = <BUGE> (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) - (restrictToNonNegative ? 0 : mostNegative); } } return new RealPointValuePair(coefficients, f.getValue(coefficients)); }
*/ protected RealPointValuePair getSolution() { double[] coefficients = new double[getOriginalNumDecisionVariables()]; Integer negativeVarBasicRow = getBasicRow(getNegativeDecisionVariableOffset()); double mostNegative = negativeVarBasicRow == null ? 0 : getEntry(negativeVarBasicRow, getRhsOffset()); Set<Integer> basicRows = new HashSet<Integer>(); for (int i = 0; i < coefficients.length; i++) { Integer basicRow = getBasicRow(getNumObjectiveFunctions() + i); if (basicRows.contains(basicRow)) { /* if multiple variables can take a given value */ /* then we choose the first and set the rest equal to 0*/ coefficients[i] = 0; } else { basicRows.add(basicRow); coefficients[i] = (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) - (restrictToNonNegative ? 0 : mostNegative); } } <BUGS> return new RealPointValuePair(coefficients, f.getValue(coefficients)); <BUGE> }
*/ public void setStartConfiguration(final double[] steps) throws IllegalArgumentException { /* only the relative position of the n final vertices with respect*/ /* to the first one are stored*/ <BUGS> final int n = steps.length; startConfiguration = new double[n][n]; for (int i = 0; i < n; ++i) { final double[] vertexI = startConfiguration[i]; for (int j = 0; j < i + 1; ++j) { if (steps[j] == 0.0) { <BUGE> throw MathRuntimeException.createIllegalArgumentException( "equals vertices {0} and {1} in simplex configuration", j, j + 1); } System.arraycopy(steps, 0, vertexI, 0, j + 1); } } }
*/ public void setStartConfiguration(final double[] steps) throws IllegalArgumentException { /* only the relative position of the n final vertices with respect*/ /* to the first one are stored*/ final int n = steps.length; startConfiguration = new double[n][n]; for (int i = 0; i < n; ++i) { final double[] vertexI = startConfiguration[i]; for (int j = 0; j < i + 1; ++j) { if (steps[j] == 0.0) { throw MathRuntimeException.createIllegalArgumentException( "equals vertices {0} and {1} in simplex configuration", j, j + 1); } <BUGS> System.arraycopy(steps, 0, vertexI, 0, j + 1); <BUGE> } } }
*/ public void setStartConfiguration(final double[] steps) throws IllegalArgumentException { /* only the relative position of the n final vertices with respect*/ /* to the first one are stored*/ final int n = steps.length; startConfiguration = new double[n][n]; for (int i = 0; i < n; ++i) { final double[] vertexI = startConfiguration[i]; for (int j = 0; j < i + 1; ++j) { if (steps[j] == 0.0) { throw MathRuntimeException.createIllegalArgumentException( "equals vertices {0} and {1} in simplex configuration", j, j + 1); } System.arraycopy(steps, 0, vertexI, 0, j + 1); } } <BUGS> } <BUGE>
public SimpleRelocator(String patt, String shadedPattern, List excludes) <BUGS> { this.pattern = patt.replace('.', '/'); <BUGE>  if ( shadedPattern != null ) { this.shadedPattern = shadedPattern.replace('.', '/'); } else { this.shadedPattern = "hidden/" + this.pattern; }  if (excludes != null) { this.excludes = new ArrayList();  for (Iterator i = excludes.iterator(); i.hasNext();) { String e = (String) i.next();  this.excludes.add(e.replace('.', '/')); } } }
public SimpleRelocator(String patt, String shadedPattern, List excludes) { this.pattern = patt.replace('.', '/');  <BUGS> if ( shadedPattern != null ) <BUGE> { this.shadedPattern = shadedPattern.replace('.', '/'); } else { this.shadedPattern = "hidden/" + this.pattern; }  if (excludes != null) { this.excludes = new ArrayList();  for (Iterator i = excludes.iterator(); i.hasNext();) { String e = (String) i.next();  this.excludes.add(e.replace('.', '/')); } } }
public SimpleRelocator(String patt, String shadedPattern, List excludes) { this.pattern = patt.replace('.', '/');  if ( shadedPattern != null ) { this.shadedPattern = shadedPattern.replace('.', '/'); } else { <BUGS> this.shadedPattern = "hidden/" + this.pattern; <BUGE> }  if (excludes != null) { this.excludes = new ArrayList();  for (Iterator i = excludes.iterator(); i.hasNext();) { String e = (String) i.next();  this.excludes.add(e.replace('.', '/')); } } }
public SimpleRelocator(String patt, String shadedPattern, List excludes) { this.pattern = patt.replace('.', '/');  if ( shadedPattern != null ) { this.shadedPattern = shadedPattern.replace('.', '/'); } else { this.shadedPattern = "hidden/" + this.pattern; }  <BUGS> if (excludes != null) <BUGE> { this.excludes = new ArrayList();  for (Iterator i = excludes.iterator(); i.hasNext();) { String e = (String) i.next();  this.excludes.add(e.replace('.', '/')); } } }
public SimpleRelocator(String patt, String shadedPattern, List excludes) { this.pattern = patt.replace('.', '/');  if ( shadedPattern != null ) { this.shadedPattern = shadedPattern.replace('.', '/'); } else { this.shadedPattern = "hidden/" + this.pattern; }  if (excludes != null) { this.excludes = new ArrayList();  for (Iterator i = excludes.iterator(); i.hasNext();) { String e = (String) i.next();  this.excludes.add(e.replace('.', '/')); } } <BUGS> } <BUGE>
public SimpleRelocator(String patt, String shadedPattern, List excludes) <BUGS> { this.pattern = patt; this.pathPattern = patt.replace('.', '/'); <BUGE>  if ( shadedPattern != null ) { this.shadedPattern = shadedPattern; this.shadedPathPattern = shadedPattern.replace('.', '/'); } else { this.shadedPattern = "hidden." + this.pattern; this.shadedPathPattern = "hidden/" + this.pathPattern; }  if ( excludes != null && !excludes.isEmpty() ) { this.excludes = new ArrayList();  for (Iterator i = excludes.iterator(); i.hasNext();) { String e = (String) i.next();  String classExclude = e.replace( '.', '/' );  this.excludes.add(classExclude); } } }
public SimpleRelocator(String patt, String shadedPattern, List excludes) { this.pattern = patt; this.pathPattern = patt.replace('.', '/');  <BUGS> if ( shadedPattern != null ) <BUGE> { this.shadedPattern = shadedPattern; this.shadedPathPattern = shadedPattern.replace('.', '/'); } else { this.shadedPattern = "hidden." + this.pattern; this.shadedPathPattern = "hidden/" + this.pathPattern; }  if ( excludes != null && !excludes.isEmpty() ) { this.excludes = new ArrayList();  for (Iterator i = excludes.iterator(); i.hasNext();) { String e = (String) i.next();  String classExclude = e.replace( '.', '/' );  this.excludes.add(classExclude); } } }
public SimpleRelocator(String patt, String shadedPattern, List excludes) { this.pattern = patt; this.pathPattern = patt.replace('.', '/');  if ( shadedPattern != null ) { this.shadedPattern = shadedPattern; this.shadedPathPattern = shadedPattern.replace('.', '/'); } else { <BUGS> this.shadedPattern = "hidden." + this.pattern; this.shadedPathPattern = "hidden/" + this.pathPattern; <BUGE> }  if ( excludes != null && !excludes.isEmpty() ) { this.excludes = new ArrayList();  for (Iterator i = excludes.iterator(); i.hasNext();) { String e = (String) i.next();  String classExclude = e.replace( '.', '/' );  this.excludes.add(classExclude); } } }
public SimpleRelocator(String patt, String shadedPattern, List excludes) { this.pattern = patt; this.pathPattern = patt.replace('.', '/');  if ( shadedPattern != null ) { this.shadedPattern = shadedPattern; this.shadedPathPattern = shadedPattern.replace('.', '/'); } else { this.shadedPattern = "hidden." + this.pattern; this.shadedPathPattern = "hidden/" + this.pathPattern; }  <BUGS> if ( excludes != null && !excludes.isEmpty() ) <BUGE> { this.excludes = new ArrayList();  for (Iterator i = excludes.iterator(); i.hasNext();) { String e = (String) i.next();  String classExclude = e.replace( '.', '/' );  this.excludes.add(classExclude); } } }
public SimpleRelocator(String patt, String shadedPattern, List excludes) { this.pattern = patt; this.pathPattern = patt.replace('.', '/');  if ( shadedPattern != null ) { this.shadedPattern = shadedPattern; this.shadedPathPattern = shadedPattern.replace('.', '/'); } else { this.shadedPattern = "hidden." + this.pattern; this.shadedPathPattern = "hidden/" + this.pathPattern; }  if ( excludes != null && !excludes.isEmpty() ) { <BUGS> this.excludes = new ArrayList(); <BUGE>  for (Iterator i = excludes.iterator(); i.hasNext();) { String e = (String) i.next();  String classExclude = e.replace( '.', '/' );  this.excludes.add(classExclude); } } }
public SimpleRelocator(String patt, String shadedPattern, List excludes) { this.pattern = patt; this.pathPattern = patt.replace('.', '/');  if ( shadedPattern != null ) { this.shadedPattern = shadedPattern; this.shadedPathPattern = shadedPattern.replace('.', '/'); } else { this.shadedPattern = "hidden." + this.pattern; this.shadedPathPattern = "hidden/" + this.pathPattern; }  if ( excludes != null && !excludes.isEmpty() ) { this.excludes = new ArrayList();  <BUGS> for (Iterator i = excludes.iterator(); i.hasNext();) <BUGE> { String e = (String) i.next();  String classExclude = e.replace( '.', '/' );  this.excludes.add(classExclude); } } }
public SimpleRelocator(String patt, String shadedPattern, List excludes) { this.pattern = patt; this.pathPattern = patt.replace('.', '/');  if ( shadedPattern != null ) { this.shadedPattern = shadedPattern; this.shadedPathPattern = shadedPattern.replace('.', '/'); } else { this.shadedPattern = "hidden." + this.pattern; this.shadedPathPattern = "hidden/" + this.pathPattern; }  if ( excludes != null && !excludes.isEmpty() ) { this.excludes = new ArrayList();  for (Iterator i = excludes.iterator(); i.hasNext();) { <BUGS> String e = (String) i.next(); <BUGE>  String classExclude = e.replace( '.', '/' );  this.excludes.add(classExclude); } } }
public SimpleRelocator(String patt, String shadedPattern, List excludes) { this.pattern = patt; this.pathPattern = patt.replace('.', '/');  if ( shadedPattern != null ) { this.shadedPattern = shadedPattern; this.shadedPathPattern = shadedPattern.replace('.', '/'); } else { this.shadedPattern = "hidden." + this.pattern; this.shadedPathPattern = "hidden/" + this.pathPattern; }  if ( excludes != null && !excludes.isEmpty() ) { this.excludes = new ArrayList();  for (Iterator i = excludes.iterator(); i.hasNext();) { String e = (String) i.next();  <BUGS> String classExclude = e.replace( '.', '/' ); <BUGE>  this.excludes.add(classExclude); } } }
public SimpleRelocator(String patt, String shadedPattern, List excludes) { this.pattern = patt; this.pathPattern = patt.replace('.', '/');  if ( shadedPattern != null ) { this.shadedPattern = shadedPattern; this.shadedPathPattern = shadedPattern.replace('.', '/'); } else { this.shadedPattern = "hidden." + this.pattern; this.shadedPathPattern = "hidden/" + this.pathPattern; }  if ( excludes != null && !excludes.isEmpty() ) { this.excludes = new ArrayList();  for (Iterator i = excludes.iterator(); i.hasNext();) { String e = (String) i.next();  String classExclude = e.replace( '.', '/' );  <BUGS> this.excludes.add(classExclude); } <BUGE> } }
public SimpleRelocator(String patt, String shadedPattern, List excludes) { this.pattern = patt; this.pathPattern = patt.replace('.', '/');  if ( shadedPattern != null ) { this.shadedPattern = shadedPattern; this.shadedPathPattern = shadedPattern.replace('.', '/'); } else { this.shadedPattern = "hidden." + this.pattern; this.shadedPathPattern = "hidden/" + this.pathPattern; }  if ( excludes != null && !excludes.isEmpty() ) { this.excludes = new ArrayList();  for (Iterator i = excludes.iterator(); i.hasNext();) { String e = (String) i.next();  String classExclude = e.replace( '.', '/' );  this.excludes.add(classExclude); } } <BUGS> } <BUGE>
public SimpleFilter( Set jars, Set includes, Set excludes ) <BUGS> { this.jars = new HashSet( jars ); <BUGE> this.includes = normalizePatterns( includes ); this.excludes = normalizePatterns( excludes ); }
public void processResource( String resource, InputStream is, List relocators ) throws IOException { <BUGS> if ( entries.isEmpty() ) <BUGE> { String year = new SimpleDateFormat( "yyyy" ).format( new Date() ); if ( !inceptionYear.equals( year ) ) { year = inceptionYear + "-" + year; }   /*add headers*/ if ( addHeader ) { entries.add( preamble1 + projectName + preamble2 ); } else { entries.add( "" ); } /*fake second entry, we'll look for a real one later*/ entries.add( projectName + "\nCopyright " + year + " " + organizationName + "\n" ); entries.add( preamble3 + organizationName + " (" + organizationURL + ").\n" ); }   BufferedReader reader; if ( StringUtils.isNotEmpty( encoding ) )
public void processResource( String resource, InputStream is, List relocators ) throws IOException { if ( entries.isEmpty() ) { <BUGS> String year = new SimpleDateFormat( "yyyy" ).format( new Date() ); if ( !inceptionYear.equals( year ) ) <BUGE> { year = inceptionYear + "-" + year; }   /*add headers*/ if ( addHeader ) { entries.add( preamble1 + projectName + preamble2 ); } else { entries.add( "" ); } /*fake second entry, we'll look for a real one later*/ entries.add( projectName + "\nCopyright " + year + " " + organizationName + "\n" ); entries.add( preamble3 + organizationName + " (" + organizationURL + ").\n" ); }   BufferedReader reader; if ( StringUtils.isNotEmpty( encoding ) )
public void processResource( String resource, InputStream is, List relocators ) throws IOException { if ( entries.isEmpty() ) { String year = new SimpleDateFormat( "yyyy" ).format( new Date() ); if ( !inceptionYear.equals( year ) ) { <BUGS> year = inceptionYear + "-" + year; <BUGE> }   /*add headers*/ if ( addHeader ) { entries.add( preamble1 + projectName + preamble2 ); } else { entries.add( "" ); } /*fake second entry, we'll look for a real one later*/ entries.add( projectName + "\nCopyright " + year + " " + organizationName + "\n" ); entries.add( preamble3 + organizationName + " (" + organizationURL + ").\n" ); }   BufferedReader reader; if ( StringUtils.isNotEmpty( encoding ) )
public void processResource( String resource, InputStream is, List relocators ) throws IOException { if ( entries.isEmpty() ) { String year = new SimpleDateFormat( "yyyy" ).format( new Date() ); if ( !inceptionYear.equals( year ) ) { year = inceptionYear + "-" + year; }   /*add headers*/ <BUGS> if ( addHeader ) <BUGE> { entries.add( preamble1 + projectName + preamble2 ); } else { entries.add( "" ); } /*fake second entry, we'll look for a real one later*/ entries.add( projectName + "\nCopyright " + year + " " + organizationName + "\n" ); entries.add( preamble3 + organizationName + " (" + organizationURL + ").\n" ); }   BufferedReader reader; if ( StringUtils.isNotEmpty( encoding ) )
public void processResource( String resource, InputStream is, List relocators ) throws IOException { if ( entries.isEmpty() ) { String year = new SimpleDateFormat( "yyyy" ).format( new Date() ); if ( !inceptionYear.equals( year ) ) { year = inceptionYear + "-" + year; }   /*add headers*/ if ( addHeader ) { <BUGS> entries.add( preamble1 + projectName + preamble2 ); <BUGE> } else { entries.add( "" ); } /*fake second entry, we'll look for a real one later*/ entries.add( projectName + "\nCopyright " + year + " " + organizationName + "\n" ); entries.add( preamble3 + organizationName + " (" + organizationURL + ").\n" ); }   BufferedReader reader; if ( StringUtils.isNotEmpty( encoding ) )
public void processResource( String resource, InputStream is, List relocators ) throws IOException { if ( entries.isEmpty() ) { String year = new SimpleDateFormat( "yyyy" ).format( new Date() ); if ( !inceptionYear.equals( year ) ) { year = inceptionYear + "-" + year; }   /*add headers*/ if ( addHeader ) { entries.add( preamble1 + projectName + preamble2 ); } else { entries.add( "" ); } /*fake second entry, we'll look for a real one later*/ <BUGS> entries.add( projectName + "\nCopyright " + year + " " + organizationName + "\n" ); entries.add( preamble3 + organizationName + " (" + organizationURL + ").\n" ); <BUGE> }   BufferedReader reader; if ( StringUtils.isNotEmpty( encoding ) )
public void processResource( String resource, InputStream is, List relocators ) throws IOException { if ( entries.isEmpty() ) { String year = new SimpleDateFormat( "yyyy" ).format( new Date() ); if ( !inceptionYear.equals( year ) ) { year = inceptionYear + "-" + year; }   /*add headers*/ if ( addHeader ) { entries.add( preamble1 + projectName + preamble2 ); } else { entries.add( "" ); } /*fake second entry, we'll look for a real one later*/ entries.add( projectName + "\nCopyright " + year + " " + organizationName + "\n" ); entries.add( preamble3 + organizationName + " (" + organizationURL + ").\n" ); }   BufferedReader reader; <BUGS> if ( StringUtils.isNotEmpty( encoding ) ) <BUGE>
private static final String NOTICE_PATH = "META-INF/NOTICE";  private static final String NOTICE_TXT_PATH = "META-INF/NOTICE.txt";  public boolean canTransformResource( String resource ) { if ( NOTICE_PATH.equalsIgnoreCase( resource ) || NOTICE_TXT_PATH.equalsIgnoreCase( resource ) ) { return true; }  return false; } { <BUGS> reader = new BufferedReader( new InputStreamReader( is ) ); <BUGE> }  String line = reader.readLine(); StringBuffer sb = new StringBuffer(); Set currentOrg = null; int lineCount = 0; while ( line != null ) { String trimedLine = line.trim();  if ( !trimedLine.startsWith( "/*" ) )*/ { if ( trimedLine.length() > 0 ) {
private static final String NOTICE_TXT_PATH = "META-INF/NOTICE.txt";  public boolean canTransformResource( String resource ) { if ( NOTICE_PATH.equalsIgnoreCase( resource ) || NOTICE_TXT_PATH.equalsIgnoreCase( resource ) ) { return true; }  return false; }  <BUGS> String line = reader.readLine(); StringBuffer sb = new StringBuffer(); Set currentOrg = null; int lineCount = 0; while ( line != null ) <BUGE> { String trimedLine = line.trim();  if ( !trimedLine.startsWith( "/*" ) )*/ { if ( trimedLine.length() > 0 ) { if ( trimedLine.startsWith( "- " ) ) { /*resource-bundle 1.3 mode*/ if ( lineCount == 1 && sb.toString().indexOf( "This product includes/uses software(s) developed by" ) != -1 )
private static final String NOTICE_PATH = "META-INF/NOTICE";  private static final String NOTICE_TXT_PATH = "META-INF/NOTICE.txt";  public boolean canTransformResource( String resource ) { if ( NOTICE_PATH.equalsIgnoreCase( resource ) || NOTICE_TXT_PATH.equalsIgnoreCase( resource ) ) { return true; }  return false; } { <BUGS> String trimedLine = line.trim(); <BUGE>  if ( !trimedLine.startsWith( "/*" ) )*/ { if ( trimedLine.length() > 0 ) { if ( trimedLine.startsWith( "- " ) ) { /*resource-bundle 1.3 mode*/ if ( lineCount == 1 && sb.toString().indexOf( "This product includes/uses software(s) developed by" ) != -1 ) { currentOrg = (Set) organizationEntries.get( sb.toString().trim() ); if ( currentOrg == null ) {
private static final String NOTICE_PATH = "META-INF/NOTICE";  private static final String NOTICE_TXT_PATH = "META-INF/NOTICE.txt";  public boolean canTransformResource( String resource ) { if ( NOTICE_PATH.equalsIgnoreCase( resource ) || NOTICE_TXT_PATH.equalsIgnoreCase( resource ) ) { return true; }  return false; }  <BUGS> if ( !trimedLine.startsWith( "/*" ) ) <BUGE>*/ { if ( trimedLine.length() > 0 ) { if ( trimedLine.startsWith( "- " ) ) { /*resource-bundle 1.3 mode*/ if ( lineCount == 1 && sb.toString().indexOf( "This product includes/uses software(s) developed by" ) != -1 ) { currentOrg = (Set) organizationEntries.get( sb.toString().trim() ); if ( currentOrg == null ) { currentOrg = new TreeSet(); organizationEntries.put( sb.toString().trim(), currentOrg );
private static final String NOTICE_PATH = "META-INF/NOTICE";  private static final String NOTICE_TXT_PATH = "META-INF/NOTICE.txt";  public boolean canTransformResource( String resource ) { if ( NOTICE_PATH.equalsIgnoreCase( resource ) || NOTICE_TXT_PATH.equalsIgnoreCase( resource ) ) { return true; }  return false; } { <BUGS> if ( trimedLine.length() > 0 ) <BUGE> { if ( trimedLine.startsWith( "- " ) ) { /*resource-bundle 1.3 mode*/ if ( lineCount == 1 && sb.toString().indexOf( "This product includes/uses software(s) developed by" ) != -1 ) { currentOrg = (Set) organizationEntries.get( sb.toString().trim() ); if ( currentOrg == null ) { currentOrg = new TreeSet(); organizationEntries.put( sb.toString().trim(), currentOrg ); } sb = new StringBuffer();
private static final String NOTICE_PATH = "META-INF/NOTICE";  private static final String NOTICE_TXT_PATH = "META-INF/NOTICE.txt";  public boolean canTransformResource( String resource ) { if ( NOTICE_PATH.equalsIgnoreCase( resource ) || NOTICE_TXT_PATH.equalsIgnoreCase( resource ) ) { return true; }  return false; } { <BUGS> String ent = sb.toString(); if ( ent.startsWith( projectName ) <BUGE> && ent.indexOf( "Copyright " ) != -1 ) { copyright = ent; } if ( currentOrg == null ) { entries.add( ent ); } else { currentOrg.add( ent ); } sb = new StringBuffer();
public SimpleRelocator( String patt, String shadedPattern, List includes, List excludes ) { <BUGS> this( patt, shadedPattern, includes, excludes, false ); <BUGE> }
@Override protected Object processParsedValue(Object value, Format formatter) {  /* Parsed value will be Long if it fits in a long and is not fractional*/ <BUGS> if (value instanceof Long) { <BUGE> return value; } return Long.valueOf(((Number)value).longValue());  }
@Override protected Object processParsedValue(Object value, Format formatter) {  /* Parsed value will be Long if it fits in a long and is not fractional*/ if (value instanceof Long) { return value; } <BUGS> return Long.valueOf(((Number)value).longValue()); <BUGE>  }
*/ protected boolean isValidPath(String path) { <BUGS> if (path == null) { <BUGE> return false; }  if (!PATH_PATTERN.matcher(path).matches()) { return false; }  try { // Don't omit host otherwise leading path may be taken as host if it starts with /**/ URI uri = new URI(null,null,path,null); String norm = uri.normalize().getPath(); if (norm.startsWith("/../") /* Trying to go via the parent dir */ || norm.equals("/..")) {   /* Trying to go to the parent dir*/ return false; } } catch (URISyntaxException e) { return false; }  int slash2Count = countToken("/*", path);*/ if (isOff(ALLOW_2_SLASHES) && (slash2Count > 0)) { return false; }  return true; }
*/ protected boolean isValidPath(String path) { if (path == null) { return false; }  <BUGS> if (!PATH_PATTERN.matcher(path).matches()) { <BUGE> return false; }  try { // Don't omit host otherwise leading path may be taken as host if it starts with /**/ URI uri = new URI(null,null,path,null); String norm = uri.normalize().getPath(); if (norm.startsWith("/../") /* Trying to go via the parent dir */ || norm.equals("/..")) {   /* Trying to go to the parent dir*/ return false; } } catch (URISyntaxException e) { return false; }  int slash2Count = countToken("/*", path);*/ if (isOff(ALLOW_2_SLASHES) && (slash2Count > 0)) { return false; }  return true; }
*/ protected boolean isValidPath(String path) { if (path == null) { return false; }  if (!PATH_PATTERN.matcher(path).matches()) { return false; }  try { // Don't omit host otherwise leading path may be taken as host if it starts with /**/ <BUGS> URI uri = new URI(null,null,path,null); String norm = uri.normalize().getPath(); if (norm.startsWith("/../") /* Trying to go via the parent dir */ || norm.equals("/..")) {   /* Trying to go to the parent dir <BUGE>*/ return false; } } catch (URISyntaxException e) { return false; }  int slash2Count = countToken("/*", path);*/ if (isOff(ALLOW_2_SLASHES) && (slash2Count > 0)) { return false; }  return true; }
*/ protected boolean isValidPath(String path) { if (path == null) { return false; }  if (!PATH_PATTERN.matcher(path).matches()) { return false; }  try { // Don't omit host otherwise leading path may be taken as host if it starts with /**/ URI uri = new URI(null,null,path,null); String norm = uri.normalize().getPath(); if (norm.startsWith("/../") /* Trying to go via the parent dir */ || norm.equals("/..")) {   /* Trying to go to the parent dir*/ return false; } <BUGS> } catch (URISyntaxException e) { return false; } <BUGE>  int slash2Count = countToken("/*", path);*/ if (isOff(ALLOW_2_SLASHES) && (slash2Count > 0)) { return false; }  return true; }
*/ protected boolean isValidPath(String path) { if (path == null) { return false; }  if (!PATH_PATTERN.matcher(path).matches()) { return false; }  try { // Don't omit host otherwise leading path may be taken as host if it starts with /**/ URI uri = new URI(null,null,path,null); String norm = uri.normalize().getPath(); if (norm.startsWith("/../") /* Trying to go via the parent dir */ || norm.equals("/..")) {   /* Trying to go to the parent dir*/ return false; } } catch (URISyntaxException e) { return false; }  <BUGS> int slash2Count = countToken("/*", path);*/ if (isOff(ALLOW_2_SLASHES) && (slash2Count > 0)) { <BUGE> return false; }  return true; }
*/ protected boolean isValidPath(String path) { if (path == null) { return false; }  if (!PATH_PATTERN.matcher(path).matches()) { return false; }  try { // Don't omit host otherwise leading path may be taken as host if it starts with /**/ URI uri = new URI(null,null,path,null); String norm = uri.normalize().getPath(); if (norm.startsWith("/../") /* Trying to go via the parent dir */ || norm.equals("/..")) {   /* Trying to go to the parent dir*/ return false; } } catch (URISyntaxException e) { return false; }  int slash2Count = countToken("/*", path);*/ if (isOff(ALLOW_2_SLASHES) && (slash2Count > 0)) { return false; }  <BUGS> return true; <BUGE> }
*/ public boolean isValid(String email) { <BUGS> if (email == null) { <BUGE> return false; }  if (email.endsWith(".")) { /* check this first - it's cheap!*/ return false; }  /* Check the whole email address structure*/ Matcher emailMatcher = EMAIL_PATTERN.matcher(email); if (!emailMatcher.matches()) { return false; }  if (!isValidUser(emailMatcher.group(1))) { return false; }  if (!isValidDomain(emailMatcher.group(2))) { return false; }  return true; }
*/ public boolean isValid(String email) { if (email == null) { return false; }  <BUGS> if (email.endsWith(".")) { /* check this first - it's cheap! <BUGE>*/ return false; }  /* Check the whole email address structure*/ Matcher emailMatcher = EMAIL_PATTERN.matcher(email); if (!emailMatcher.matches()) { return false; }  if (!isValidUser(emailMatcher.group(1))) { return false; }  if (!isValidDomain(emailMatcher.group(2))) { return false; }  return true; }
*/ public boolean isValid(String email) { if (email == null) { return false; }  if (email.endsWith(".")) { /* check this first - it's cheap!*/ return false; }  /* Check the whole email address structure*/ <BUGS> Matcher emailMatcher = EMAIL_PATTERN.matcher(email); if (!emailMatcher.matches()) { <BUGE> return false; }  if (!isValidUser(emailMatcher.group(1))) { return false; }  if (!isValidDomain(emailMatcher.group(2))) { return false; }  return true; }
*/ public boolean isValid(String email) { if (email == null) { return false; }  if (email.endsWith(".")) { /* check this first - it's cheap!*/ return false; }  /* Check the whole email address structure*/ Matcher emailMatcher = EMAIL_PATTERN.matcher(email); if (!emailMatcher.matches()) { return false; }  <BUGS> if (!isValidUser(emailMatcher.group(1))) { return false; <BUGE> }  if (!isValidDomain(emailMatcher.group(2))) { return false; }  return true; }
*/ public boolean isValid(String email) { if (email == null) { return false; }  if (email.endsWith(".")) { /* check this first - it's cheap!*/ return false; }  /* Check the whole email address structure*/ Matcher emailMatcher = EMAIL_PATTERN.matcher(email); if (!emailMatcher.matches()) { return false; }  if (!isValidUser(emailMatcher.group(1))) { return false; }  <BUGS> if (!isValidDomain(emailMatcher.group(2))) { return false; <BUGE> }  return true; }
*/ public boolean isValid(String email) { if (email == null) { return false; }  if (email.endsWith(".")) { /* check this first - it's cheap!*/ return false; }  /* Check the whole email address structure*/ Matcher emailMatcher = EMAIL_PATTERN.matcher(email); if (!emailMatcher.matches()) { return false; }  if (!isValidUser(emailMatcher.group(1))) { return false; }  if (!isValidDomain(emailMatcher.group(2))) { return false; }  <BUGS> return true; <BUGE> }
*/ public boolean isValid(String value) { <BUGS> if (value == null) { <BUGE> return false; } for (int i = 0; i < patterns.length; i++) { if (patterns[i].matcher(value).matches()) { return true; } } return false; }
*/ public boolean isValid(String value) { if (value == null) { return false; } <BUGS> for (int i = 0; i < patterns.length; i++) { if (patterns[i].matcher(value).matches()) { return true; <BUGE> } } return false; }
*/ public boolean isValid(String value) { if (value == null) { return false; } for (int i = 0; i < patterns.length; i++) { if (patterns[i].matcher(value).matches()) { return true; } } <BUGS> return false; <BUGE> }
*/ public static DomainValidator getInstance(boolean allowLocal) { <BUGS> if(allowLocal) { return DOMAIN_VALIDATOR_WITH_LOCAL; <BUGE> } return DOMAIN_VALIDATOR; }
*/ public static DomainValidator getInstance(boolean allowLocal) { if(allowLocal) { return DOMAIN_VALIDATOR_WITH_LOCAL; } <BUGS> return DOMAIN_VALIDATOR; <BUGE> }
*/ public boolean isValid(String value) { <BUGS> if (value == null) { <BUGE> return false; }  if (!ASCII_PATTERN.matcher(value).matches()) { return false; }  /* Check the whole url address structure*/ Matcher urlMatcher = URL_PATTERN.matcher(value); if (!urlMatcher.matches()) { return false; }  if (!isValidScheme(urlMatcher.group(PARSE_URL_SCHEME))) { return false; }  /* Special case - file: allows an empty authority*/ /* Validate the authority*/ if (!isValidAuthority(urlMatcher.group(PARSE_URL_AUTHORITY))) { return false; }  if (!isValidPath(urlMatcher.group(PARSE_URL_PATH))) { return false; }
*/ public boolean isValid(String value) { if (value == null) { return false; }  <BUGS> if (!ASCII_PATTERN.matcher(value).matches()) { <BUGE> return false; }  /* Check the whole url address structure*/ Matcher urlMatcher = URL_PATTERN.matcher(value); if (!urlMatcher.matches()) { return false; }  if (!isValidScheme(urlMatcher.group(PARSE_URL_SCHEME))) { return false; }  /* Special case - file: allows an empty authority*/ /* Validate the authority*/ if (!isValidAuthority(urlMatcher.group(PARSE_URL_AUTHORITY))) { return false; }  if (!isValidPath(urlMatcher.group(PARSE_URL_PATH))) { return false; }
*/ public boolean isValid(String value) { if (value == null) { return false; }  if (!ASCII_PATTERN.matcher(value).matches()) { return false; }  /* Check the whole url address structure*/ <BUGS> Matcher urlMatcher = URL_PATTERN.matcher(value); if (!urlMatcher.matches()) { <BUGE> return false; }  if (!isValidScheme(urlMatcher.group(PARSE_URL_SCHEME))) { return false; }  /* Special case - file: allows an empty authority*/ /* Validate the authority*/ if (!isValidAuthority(urlMatcher.group(PARSE_URL_AUTHORITY))) { return false; }  if (!isValidPath(urlMatcher.group(PARSE_URL_PATH))) { return false; }
*/ public boolean isValid(String value) { if (value == null) { return false; }  if (!ASCII_PATTERN.matcher(value).matches()) { return false; }  /* Check the whole url address structure*/ Matcher urlMatcher = URL_PATTERN.matcher(value); if (!urlMatcher.matches()) { return false; }  <BUGS> if (!isValidScheme(urlMatcher.group(PARSE_URL_SCHEME))) { return false; <BUGE> }  /* Special case - file: allows an empty authority*/ /* Validate the authority*/ if (!isValidAuthority(urlMatcher.group(PARSE_URL_AUTHORITY))) { return false; }  if (!isValidPath(urlMatcher.group(PARSE_URL_PATH))) { return false; }
*/ public boolean isValid(String value) { if (value == null) { return false; }  if (!ASCII_PATTERN.matcher(value).matches()) { return false; }  /* Check the whole url address structure*/ Matcher urlMatcher = URL_PATTERN.matcher(value); if (!urlMatcher.matches()) { return false; }  if (!isValidScheme(urlMatcher.group(PARSE_URL_SCHEME))) { return false; }  /* Special case - file: allows an empty authority*/ /* Validate the authority*/ <BUGS> if (!isValidAuthority(urlMatcher.group(PARSE_URL_AUTHORITY))) { return false; <BUGE> }  if (!isValidPath(urlMatcher.group(PARSE_URL_PATH))) { return false; }
*/ public boolean isValid(String value) { if (value == null) { return false; }  if (!ASCII_PATTERN.matcher(value).matches()) { return false; }  /* Check the whole url address structure*/ Matcher urlMatcher = URL_PATTERN.matcher(value); if (!urlMatcher.matches()) { return false; }  if (!isValidScheme(urlMatcher.group(PARSE_URL_SCHEME))) { return false; }  /* Special case - file: allows an empty authority*/ /* Validate the authority*/ if (!isValidAuthority(urlMatcher.group(PARSE_URL_AUTHORITY))) { return false; }  <BUGS> if (!isValidPath(urlMatcher.group(PARSE_URL_PATH))) { <BUGE> return false; }
*/ public boolean isValid(String value) { if (value == null) { return false; }  if (!ASCII_PATTERN.matcher(value).matches()) { return false; }  /* Check the whole url address structure*/ Matcher urlMatcher = URL_PATTERN.matcher(value); if (!urlMatcher.matches()) { return false; }  if (!isValidScheme(urlMatcher.group(PARSE_URL_SCHEME))) { return false; }  /* Special case - file: allows an empty authority*/ /* Validate the authority*/ if (!isValidAuthority(urlMatcher.group(PARSE_URL_AUTHORITY))) { return false; }  if (!isValidPath(urlMatcher.group(PARSE_URL_PATH))) { return false; }
this.allowedSchemes = new HashSet(); this.allowedSchemes.addAll(Arrays.asList(schemes)); }  this.authorityValidator = authorityValidator;  }  /** * <p>Checks if a field has a valid url address.</p> * * @param value The value validation is being performed on.  A <code>null</code> * value is considered invalid. * @return true if the url is valid.  <BUGS> if (!isValidFragment(urlMatcher.group(PARSE_URL_FRAGMENT))) { <BUGE> return false; }  return true; }  /** * Validate scheme. If schemes[] was initialized to a non null, * then only those scheme's are allowed.  Note this is slightly different * than for the constructor. * @param scheme The scheme to validate.  A <code>null</code> value is considered * invalid. * @return true if valid. */
this.allowedSchemes = new HashSet(); this.allowedSchemes.addAll(Arrays.asList(schemes)); }  this.authorityValidator = authorityValidator;  }  /** * <p>Checks if a field has a valid url address.</p> * * @param value The value validation is being performed on.  A <code>null</code> * value is considered invalid. * @return true if the url is valid.  <BUGS> return true; <BUGE> }  /** * Validate scheme. If schemes[] was initialized to a non null, * then only those scheme's are allowed.  Note this is slightly different * than for the constructor. * @param scheme The scheme to validate.  A <code>null</code> value is considered * invalid. * @return true if valid. */ protected boolean isValidScheme(String scheme) { if (scheme == null) { return false; }
*/ protected boolean isValidAuthority(String authority) { <BUGS> if (authority == null) { <BUGE> return false; }  /* check manual authority validation if specified*/ if (authorityValidator != null && authorityValidator.isValid(authority)) { return true; } /* convert to ASCII if possible*/ final String authorityASCII = DomainValidator.unicodeToASCII(authority);  Matcher authorityMatcher = AUTHORITY_PATTERN.matcher(authorityASCII); if (!authorityMatcher.matches()) { return false; }  /* We have to process IPV6 separately because that is parsed in a different group*/ String ipv6 = authorityMatcher.group(PARSE_AUTHORITY_IPV6); if (ipv6 != null) { InetAddressValidator inetAddressValidator = InetAddressValidator.getInstance(); if (!inetAddressValidator.isValidInet6Address(ipv6)) { return false; } } else { String hostLocation = authorityMatcher.group(PARSE_AUTHORITY_HOST_IP); /* check if authority is hostname or IP address:*/ /* try a hostname first since that's much more likely*/ DomainValidator domainValidator = DomainValidator.getInstance(isOn(ALLOW_LOCAL_URLS));
*/ protected boolean isValidAuthority(String authority) { if (authority == null) { return false; }  /* check manual authority validation if specified*/ <BUGS> if (authorityValidator != null && authorityValidator.isValid(authority)) { <BUGE> return true; } /* convert to ASCII if possible*/ final String authorityASCII = DomainValidator.unicodeToASCII(authority);  Matcher authorityMatcher = AUTHORITY_PATTERN.matcher(authorityASCII); if (!authorityMatcher.matches()) { return false; }  /* We have to process IPV6 separately because that is parsed in a different group*/ String ipv6 = authorityMatcher.group(PARSE_AUTHORITY_IPV6); if (ipv6 != null) { InetAddressValidator inetAddressValidator = InetAddressValidator.getInstance(); if (!inetAddressValidator.isValidInet6Address(ipv6)) { return false; } } else { String hostLocation = authorityMatcher.group(PARSE_AUTHORITY_HOST_IP); /* check if authority is hostname or IP address:*/ /* try a hostname first since that's much more likely*/ DomainValidator domainValidator = DomainValidator.getInstance(isOn(ALLOW_LOCAL_URLS));
*/ protected boolean isValidAuthority(String authority) { if (authority == null) { return false; }  /* check manual authority validation if specified*/ if (authorityValidator != null && authorityValidator.isValid(authority)) { return true; } /* convert to ASCII if possible*/ <BUGS> final String authorityASCII = DomainValidator.unicodeToASCII(authority); <BUGE>  Matcher authorityMatcher = AUTHORITY_PATTERN.matcher(authorityASCII); if (!authorityMatcher.matches()) { return false; }  /* We have to process IPV6 separately because that is parsed in a different group*/ String ipv6 = authorityMatcher.group(PARSE_AUTHORITY_IPV6); if (ipv6 != null) { InetAddressValidator inetAddressValidator = InetAddressValidator.getInstance(); if (!inetAddressValidator.isValidInet6Address(ipv6)) { return false; } } else { String hostLocation = authorityMatcher.group(PARSE_AUTHORITY_HOST_IP); /* check if authority is hostname or IP address:*/ /* try a hostname first since that's much more likely*/ DomainValidator domainValidator = DomainValidator.getInstance(isOn(ALLOW_LOCAL_URLS));
*/ protected boolean isValidAuthority(String authority) { if (authority == null) { return false; }  /* check manual authority validation if specified*/ if (authorityValidator != null && authorityValidator.isValid(authority)) { return true; } /* convert to ASCII if possible*/ final String authorityASCII = DomainValidator.unicodeToASCII(authority);  <BUGS> Matcher authorityMatcher = AUTHORITY_PATTERN.matcher(authorityASCII); if (!authorityMatcher.matches()) { <BUGE> return false; }  /* We have to process IPV6 separately because that is parsed in a different group*/ String ipv6 = authorityMatcher.group(PARSE_AUTHORITY_IPV6); if (ipv6 != null) { InetAddressValidator inetAddressValidator = InetAddressValidator.getInstance(); if (!inetAddressValidator.isValidInet6Address(ipv6)) { return false; } } else { String hostLocation = authorityMatcher.group(PARSE_AUTHORITY_HOST_IP); /* check if authority is hostname or IP address:*/ /* try a hostname first since that's much more likely*/ DomainValidator domainValidator = DomainValidator.getInstance(isOn(ALLOW_LOCAL_URLS));
*/ protected boolean isValidAuthority(String authority) { if (authority == null) { return false; }  /* check manual authority validation if specified*/ if (authorityValidator != null && authorityValidator.isValid(authority)) { return true; } /* convert to ASCII if possible*/ final String authorityASCII = DomainValidator.unicodeToASCII(authority);  Matcher authorityMatcher = AUTHORITY_PATTERN.matcher(authorityASCII); if (!authorityMatcher.matches()) { return false; }  /* We have to process IPV6 separately because that is parsed in a different group*/ <BUGS> String ipv6 = authorityMatcher.group(PARSE_AUTHORITY_IPV6); if (ipv6 != null) { <BUGE> InetAddressValidator inetAddressValidator = InetAddressValidator.getInstance(); if (!inetAddressValidator.isValidInet6Address(ipv6)) { return false; } } else { String hostLocation = authorityMatcher.group(PARSE_AUTHORITY_HOST_IP); /* check if authority is hostname or IP address:*/ /* try a hostname first since that's much more likely*/ DomainValidator domainValidator = DomainValidator.getInstance(isOn(ALLOW_LOCAL_URLS));
*/ protected boolean isValidAuthority(String authority) { if (authority == null) { return false; }  /* check manual authority validation if specified*/ if (authorityValidator != null && authorityValidator.isValid(authority)) { return true; } /* convert to ASCII if possible*/ final String authorityASCII = DomainValidator.unicodeToASCII(authority);  Matcher authorityMatcher = AUTHORITY_PATTERN.matcher(authorityASCII); if (!authorityMatcher.matches()) { return false; }  /* We have to process IPV6 separately because that is parsed in a different group*/ String ipv6 = authorityMatcher.group(PARSE_AUTHORITY_IPV6); if (ipv6 != null) { InetAddressValidator inetAddressValidator = InetAddressValidator.getInstance(); if (!inetAddressValidator.isValidInet6Address(ipv6)) { return false; } } else { <BUGS> String hostLocation = authorityMatcher.group(PARSE_AUTHORITY_HOST_IP); <BUGE> /* check if authority is hostname or IP address:*/ /* try a hostname first since that's much more likely*/ DomainValidator domainValidator = DomainValidator.getInstance(isOn(ALLOW_LOCAL_URLS));
*/ protected boolean isValidAuthority(String authority) { if (authority == null) { return false; }  /* check manual authority validation if specified*/ if (authorityValidator != null && authorityValidator.isValid(authority)) { return true; } /* convert to ASCII if possible*/ final String authorityASCII = DomainValidator.unicodeToASCII(authority);  Matcher authorityMatcher = AUTHORITY_PATTERN.matcher(authorityASCII); if (!authorityMatcher.matches()) { return false; }  /* We have to process IPV6 separately because that is parsed in a different group*/ String ipv6 = authorityMatcher.group(PARSE_AUTHORITY_IPV6); if (ipv6 != null) { InetAddressValidator inetAddressValidator = InetAddressValidator.getInstance(); if (!inetAddressValidator.isValidInet6Address(ipv6)) { return false; } } else { String hostLocation = authorityMatcher.group(PARSE_AUTHORITY_HOST_IP); /* check if authority is hostname or IP address:*/ /* try a hostname first since that's much more likely*/ <BUGS> DomainValidator domainValidator = DomainValidator.getInstance(isOn(ALLOW_LOCAL_URLS));
}  return true; }  /** * Returns true if the authority is properly formatted.  An authority is the combination * of hostname and port.  A <code>null</code> authority value is considered invalid. * Note: this implementation validates the domain unless a RegexValidator was provided. * If a RegexValidator was supplied and it matches, then the authority is regarded * as valid with no further checks, otherwise the method checks against the * AUTHORITY_PATTERN and the DomainValidator (ALLOW_LOCAL_URLS) * @param authority Authority value to validate, alllows IDN * @return true if authority (hostname and port) is valid. /* try an IPv4 address*/ <BUGS> InetAddressValidator inetAddressValidator = InetAddressValidator.getInstance(); if (!inetAddressValidator.isValidInet4Address(hostLocation)) { <BUGE> /* isn't IPv4, so the URL is invalid*/ return false; } } }  String port = authorityMatcher.group(PARSE_AUTHORITY_PORT); if (port != null && !PORT_PATTERN.matcher(port).matches()) { return false; }  String extra = authorityMatcher.group(PARSE_AUTHORITY_EXTRA); if (extra != null && extra.trim().length() > 0){
}  return true; }  /** * Returns true if the authority is properly formatted.  An authority is the combination * of hostname and port.  A <code>null</code> authority value is considered invalid. * Note: this implementation validates the domain unless a RegexValidator was provided. * If a RegexValidator was supplied and it matches, then the authority is regarded * as valid with no further checks, otherwise the method checks against the * AUTHORITY_PATTERN and the DomainValidator (ALLOW_LOCAL_URLS) * @param authority Authority value to validate, alllows IDN * @return true if authority (hostname and port) is valid. /* isn't IPv4, so the URL is invalid*/ <BUGS> return false; <BUGE> } } }  String port = authorityMatcher.group(PARSE_AUTHORITY_PORT); if (port != null && !PORT_PATTERN.matcher(port).matches()) { return false; }  String extra = authorityMatcher.group(PARSE_AUTHORITY_EXTRA); if (extra != null && extra.trim().length() > 0){ return false; }
}  return true; }  /** * Returns true if the authority is properly formatted.  An authority is the combination * of hostname and port.  A <code>null</code> authority value is considered invalid. * Note: this implementation validates the domain unless a RegexValidator was provided. * If a RegexValidator was supplied and it matches, then the authority is regarded * as valid with no further checks, otherwise the method checks against the * AUTHORITY_PATTERN and the DomainValidator (ALLOW_LOCAL_URLS) * @param authority Authority value to validate, alllows IDN * @return true if authority (hostname and port) is valid.  <BUGS> String port = authorityMatcher.group(PARSE_AUTHORITY_PORT); if (port != null && !PORT_PATTERN.matcher(port).matches()) { <BUGE> return false; }  String extra = authorityMatcher.group(PARSE_AUTHORITY_EXTRA); if (extra != null && extra.trim().length() > 0){ return false; }  return true; }  /** * Returns true if the path is valid.  A <code>null</code> value is considered invalid.
}  return true; }  /** * Returns true if the authority is properly formatted.  An authority is the combination * of hostname and port.  A <code>null</code> authority value is considered invalid. * Note: this implementation validates the domain unless a RegexValidator was provided. * If a RegexValidator was supplied and it matches, then the authority is regarded * as valid with no further checks, otherwise the method checks against the * AUTHORITY_PATTERN and the DomainValidator (ALLOW_LOCAL_URLS) * @param authority Authority value to validate, alllows IDN * @return true if authority (hostname and port) is valid.  <BUGS> String extra = authorityMatcher.group(PARSE_AUTHORITY_EXTRA); if (extra != null && extra.trim().length() > 0){ <BUGE> return false; }  return true; }  /** * Returns true if the path is valid.  A <code>null</code> value is considered invalid. * @param path Path value to validate. * @return true if path is valid. */ protected boolean isValidPath(String path) { if (path == null) {
}  return true; }  /** * Returns true if the authority is properly formatted.  An authority is the combination * of hostname and port.  A <code>null</code> authority value is considered invalid. * Note: this implementation validates the domain unless a RegexValidator was provided. * If a RegexValidator was supplied and it matches, then the authority is regarded * as valid with no further checks, otherwise the method checks against the * AUTHORITY_PATTERN and the DomainValidator (ALLOW_LOCAL_URLS) * @param authority Authority value to validate, alllows IDN * @return true if authority (hostname and port) is valid.  <BUGS> return true; <BUGE> }  /** * Returns true if the path is valid.  A <code>null</code> value is considered invalid. * @param path Path value to validate. * @return true if path is valid. */ protected boolean isValidPath(String path) { if (path == null) { return false; }  if (!PATH_PATTERN.matcher(path).matches()) { return false;
*/ public boolean isValid(String code) { <BUGS> if (code == null || code.length() < 5) { <BUGE> return false; } try { int modulusResult = calculateModulus(code); return (modulusResult == 1); } catch (CheckDigitException  ex) { return false; } }
*/ public boolean isValid(String code) { if (code == null || code.length() < 5) { return false; } try { <BUGS> int modulusResult = calculateModulus(code); return (modulusResult == 1); } catch (CheckDigitException  ex) { return false; <BUGE> } }
*/ protected boolean isValidPath(String path) { <BUGS> if (path == null) { <BUGE> return false; }  if (!PATH_PATTERN.matcher(path).matches()) { return false; }   int slash2Count = countToken("/*", path);*/ if (isOff(ALLOW_2_SLASHES) && (slash2Count > 0)) { return false; }  int slashCount = countToken("/", path); int dot2Count = countToken("..", path); if (dot2Count > 0 && (slashCount - slash2Count - 1) <= dot2Count) { return false; } return true; }
*/ protected boolean isValidPath(String path) { if (path == null) { return false; }  <BUGS> if (!PATH_PATTERN.matcher(path).matches()) { <BUGE> return false; }   int slash2Count = countToken("/*", path);*/ if (isOff(ALLOW_2_SLASHES) && (slash2Count > 0)) { return false; }  int slashCount = countToken("/", path); int dot2Count = countToken("..", path); if (dot2Count > 0 && (slashCount - slash2Count - 1) <= dot2Count) { return false; } return true; }
*/ protected boolean isValidPath(String path) { if (path == null) { return false; }  if (!PATH_PATTERN.matcher(path).matches()) { return false; }   <BUGS> int slash2Count = countToken("/*", path);*/ if (isOff(ALLOW_2_SLASHES) && (slash2Count > 0)) { <BUGE> return false; }  int slashCount = countToken("/", path); int dot2Count = countToken("..", path); if (dot2Count > 0 && (slashCount - slash2Count - 1) <= dot2Count) { return false; } return true; }
*/ protected boolean isValidPath(String path) { if (path == null) { return false; }  if (!PATH_PATTERN.matcher(path).matches()) { return false; }   int slash2Count = countToken("/*", path);*/ if (isOff(ALLOW_2_SLASHES) && (slash2Count > 0)) { return false; }  <BUGS> int slashCount = countToken("/", path); int dot2Count = countToken("..", path); if (dot2Count > 0 && (slashCount - slash2Count - 1) <= dot2Count) { return false; <BUGE> } return true; }
*/ protected boolean isValidPath(String path) { if (path == null) { return false; }  if (!PATH_PATTERN.matcher(path).matches()) { return false; }   int slash2Count = countToken("/*", path);*/ if (isOff(ALLOW_2_SLASHES) && (slash2Count > 0)) { return false; }  int slashCount = countToken("/", path); int dot2Count = countToken("..", path); if (dot2Count > 0 && (slashCount - slash2Count - 1) <= dot2Count) { return false; } <BUGS> return true; <BUGE> }
*/ protected boolean isValidUser(String user) {  <BUGS> if (user == null || user.length() > 64) { return false; <BUGE> }  return USER_PATTERN.matcher(user).matches(); }
*/ protected boolean isValidUser(String user) {  if (user == null || user.length() > 64) { return false; }  <BUGS> return USER_PATTERN.matcher(user).matches(); <BUGE> }
*/ public static synchronized DomainValidator getInstance() { <BUGS> inUse = true; return DOMAIN_VALIDATOR; <BUGE> }
private String chompLeadingDot(String str) { <BUGS> if (str.startsWith(".")) { return str.substring(1); <BUGE> } return str; }
*/ public boolean isValid(String email) { <BUGS> if (email == null) { <BUGE> return false; }  if (email.endsWith(".")) { /* check this first - it's cheap!*/ return false; }  /* Check the whole email address structure*/ Matcher emailMatcher = EMAIL_PATTERN.matcher(email); if (!emailMatcher.matches()) { return false; }  if (!isValidUser(emailMatcher.group(1))) { return false; }  if (!isValidDomain(emailMatcher.group(2))) { return false; }  return true; }
*/ public boolean isValid(String email) { if (email == null) { return false; }  <BUGS> if (email.endsWith(".")) { /* check this first - it's cheap! <BUGE>*/ return false; }  /* Check the whole email address structure*/ Matcher emailMatcher = EMAIL_PATTERN.matcher(email); if (!emailMatcher.matches()) { return false; }  if (!isValidUser(emailMatcher.group(1))) { return false; }  if (!isValidDomain(emailMatcher.group(2))) { return false; }  return true; }
*/ public boolean isValid(String email) { if (email == null) { return false; }  if (email.endsWith(".")) { /* check this first - it's cheap!*/ return false; }  /* Check the whole email address structure*/ <BUGS> Matcher emailMatcher = EMAIL_PATTERN.matcher(email); if (!emailMatcher.matches()) { <BUGE> return false; }  if (!isValidUser(emailMatcher.group(1))) { return false; }  if (!isValidDomain(emailMatcher.group(2))) { return false; }  return true; }
*/ public boolean isValid(String email) { if (email == null) { return false; }  if (email.endsWith(".")) { /* check this first - it's cheap!*/ return false; }  /* Check the whole email address structure*/ Matcher emailMatcher = EMAIL_PATTERN.matcher(email); if (!emailMatcher.matches()) { return false; }  <BUGS> if (!isValidUser(emailMatcher.group(1))) { return false; <BUGE> }  if (!isValidDomain(emailMatcher.group(2))) { return false; }  return true; }
*/ public boolean isValid(String email) { if (email == null) { return false; }  if (email.endsWith(".")) { /* check this first - it's cheap!*/ return false; }  /* Check the whole email address structure*/ Matcher emailMatcher = EMAIL_PATTERN.matcher(email); if (!emailMatcher.matches()) { return false; }  if (!isValidUser(emailMatcher.group(1))) { return false; }  <BUGS> if (!isValidDomain(emailMatcher.group(2))) { <BUGE> return false; }  return true; }
*/ public boolean isValid(String email) { if (email == null) { return false; }  if (email.endsWith(".")) { /* check this first - it's cheap!*/ return false; }  /* Check the whole email address structure*/ Matcher emailMatcher = EMAIL_PATTERN.matcher(email); if (!emailMatcher.matches()) { return false; }  if (!isValidUser(emailMatcher.group(1))) { return false; }  if (!isValidDomain(emailMatcher.group(2))) { return false; }  <BUGS> return true; <BUGE> }
*/ public boolean isValid(String value) { <BUGS> if (value == null) { <BUGE> return false; }  /* Check the whole url address structure*/ Matcher urlMatcher = URL_PATTERN.matcher(value); if (!urlMatcher.matches()) { return false; }  String scheme = urlMatcher.group(PARSE_URL_SCHEME); if (!isValidScheme(scheme)) { return false; }  String authority = urlMatcher.group(PARSE_URL_AUTHORITY); if ("file".equals(scheme)) {/* Special case - file: allows an empty authority*/ if (!"".equals(authority)) { if (authority.contains(":")) { /* but cannot allow trailing :*/ return false; } } /* drop through to continue validation*/ } else { /* not file:*/ /* Validate the authority*/ if (!isValidAuthority(authority)) { return false; }
*/ public boolean isValid(String value) { if (value == null) { return false; }  /* Check the whole url address structure*/ <BUGS> Matcher urlMatcher = URL_PATTERN.matcher(value); if (!urlMatcher.matches()) { <BUGE> return false; }  String scheme = urlMatcher.group(PARSE_URL_SCHEME); if (!isValidScheme(scheme)) { return false; }  String authority = urlMatcher.group(PARSE_URL_AUTHORITY); if ("file".equals(scheme)) {/* Special case - file: allows an empty authority*/ if (!"".equals(authority)) { if (authority.contains(":")) { /* but cannot allow trailing :*/ return false; } } /* drop through to continue validation*/ } else { /* not file:*/ /* Validate the authority*/ if (!isValidAuthority(authority)) { return false; }
*/ public boolean isValid(String value) { if (value == null) { return false; }  /* Check the whole url address structure*/ Matcher urlMatcher = URL_PATTERN.matcher(value); if (!urlMatcher.matches()) { return false; }  <BUGS> String scheme = urlMatcher.group(PARSE_URL_SCHEME); if (!isValidScheme(scheme)) { <BUGE> return false; }  String authority = urlMatcher.group(PARSE_URL_AUTHORITY); if ("file".equals(scheme)) {/* Special case - file: allows an empty authority*/ if (!"".equals(authority)) { if (authority.contains(":")) { /* but cannot allow trailing :*/ return false; } } /* drop through to continue validation*/ } else { /* not file:*/ /* Validate the authority*/ if (!isValidAuthority(authority)) { return false; }
*/ public boolean isValid(String value) { if (value == null) { return false; }  /* Check the whole url address structure*/ Matcher urlMatcher = URL_PATTERN.matcher(value); if (!urlMatcher.matches()) { return false; }  String scheme = urlMatcher.group(PARSE_URL_SCHEME); if (!isValidScheme(scheme)) { return false; }  <BUGS> String authority = urlMatcher.group(PARSE_URL_AUTHORITY); if ("file".equals(scheme)) {/* Special case - file: allows an empty authority*/ if (!"".equals(authority)) { if (authority.contains(":")) { /* but cannot allow trailing : <BUGE>*/ return false; } } /* drop through to continue validation*/ } else { /* not file:*/ /* Validate the authority*/ if (!isValidAuthority(authority)) { return false; }
*/ public boolean isValid(String code) { <BUGS> Validator formatValidator = getValidator(code); if (formatValidator == null || code.length() != formatValidator.lengthOfIBAN || !formatValidator.validator.isValid(code)) { <BUGE> return false; } return IBANCheckDigit.IBAN_CHECK_DIGIT.isValid(code); }
*/ public boolean isValid(String code) { Validator formatValidator = getValidator(code); if (formatValidator == null || code.length() != formatValidator.lengthOfIBAN || !formatValidator.validator.isValid(code)) { return false; } <BUGS> return IBANCheckDigit.IBAN_CHECK_DIGIT.isValid(code); <BUGE> }
*/ public boolean isValid(String code) { <BUGS> Validator formatValidator = getValidator(code); if (formatValidator == null || code.length() != formatValidator.lengthOfIBAN || !formatValidator.validator.isValid(code)) { return false; <BUGE> } return IBANCheckDigit.IBAN_CHECK_DIGIT.isValid(code); }
*/ public boolean isValid(String code) { Validator formatValidator = getValidator(code); if (formatValidator == null || code.length() != formatValidator.lengthOfIBAN || !formatValidator.validator.isValid(code)) { return false; } <BUGS> return IBANCheckDigit.IBAN_CHECK_DIGIT.isValid(code); <BUGE> }
*/ protected boolean isValidAuthority(String authority) { <BUGS> if (authority == null) { <BUGE> return false; }  /* check manual authority validation if specified*/ if (authorityValidator != null && authorityValidator.isValid(authority)) { return true; } /* convert to ASCII if possible*/ final String authorityASCII = DomainValidator.unicodeToASCII(authority);  Matcher authorityMatcher = AUTHORITY_PATTERN.matcher(authorityASCII); if (!authorityMatcher.matches()) { return false; }  /* We have to process IPV6 separately because that is parsed in a different group*/ String ipv6 = authorityMatcher.group(PARSE_AUTHORITY_IPV6); if (ipv6 != null) { InetAddressValidator inetAddressValidator = InetAddressValidator.getInstance(); if (!inetAddressValidator.isValidInet6Address(ipv6)) { return false; } } else { String hostLocation = authorityMatcher.group(PARSE_AUTHORITY_HOST_IP); /* check if authority is hostname or IP address:*/ /* try a hostname first since that's much more likely*/ DomainValidator domainValidator = DomainValidator.getInstance(isOn(ALLOW_LOCAL_URLS));
*/ protected boolean isValidAuthority(String authority) { if (authority == null) { return false; }  /* check manual authority validation if specified*/ <BUGS> if (authorityValidator != null && authorityValidator.isValid(authority)) { <BUGE> return true; } /* convert to ASCII if possible*/ final String authorityASCII = DomainValidator.unicodeToASCII(authority);  Matcher authorityMatcher = AUTHORITY_PATTERN.matcher(authorityASCII); if (!authorityMatcher.matches()) { return false; }  /* We have to process IPV6 separately because that is parsed in a different group*/ String ipv6 = authorityMatcher.group(PARSE_AUTHORITY_IPV6); if (ipv6 != null) { InetAddressValidator inetAddressValidator = InetAddressValidator.getInstance(); if (!inetAddressValidator.isValidInet6Address(ipv6)) { return false; } } else { String hostLocation = authorityMatcher.group(PARSE_AUTHORITY_HOST_IP); /* check if authority is hostname or IP address:*/ /* try a hostname first since that's much more likely*/ DomainValidator domainValidator = DomainValidator.getInstance(isOn(ALLOW_LOCAL_URLS));
*/ protected boolean isValidAuthority(String authority) { if (authority == null) { return false; }  /* check manual authority validation if specified*/ if (authorityValidator != null && authorityValidator.isValid(authority)) { return true; } /* convert to ASCII if possible*/ <BUGS> final String authorityASCII = DomainValidator.unicodeToASCII(authority); <BUGE>  Matcher authorityMatcher = AUTHORITY_PATTERN.matcher(authorityASCII); if (!authorityMatcher.matches()) { return false; }  /* We have to process IPV6 separately because that is parsed in a different group*/ String ipv6 = authorityMatcher.group(PARSE_AUTHORITY_IPV6); if (ipv6 != null) { InetAddressValidator inetAddressValidator = InetAddressValidator.getInstance(); if (!inetAddressValidator.isValidInet6Address(ipv6)) { return false; } } else { String hostLocation = authorityMatcher.group(PARSE_AUTHORITY_HOST_IP); /* check if authority is hostname or IP address:*/ /* try a hostname first since that's much more likely*/ DomainValidator domainValidator = DomainValidator.getInstance(isOn(ALLOW_LOCAL_URLS));
*/ protected boolean isValidAuthority(String authority) { if (authority == null) { return false; }  /* check manual authority validation if specified*/ if (authorityValidator != null && authorityValidator.isValid(authority)) { return true; } /* convert to ASCII if possible*/ final String authorityASCII = DomainValidator.unicodeToASCII(authority);  <BUGS> Matcher authorityMatcher = AUTHORITY_PATTERN.matcher(authorityASCII); if (!authorityMatcher.matches()) { <BUGE> return false; }  /* We have to process IPV6 separately because that is parsed in a different group*/ String ipv6 = authorityMatcher.group(PARSE_AUTHORITY_IPV6); if (ipv6 != null) { InetAddressValidator inetAddressValidator = InetAddressValidator.getInstance(); if (!inetAddressValidator.isValidInet6Address(ipv6)) { return false; } } else { String hostLocation = authorityMatcher.group(PARSE_AUTHORITY_HOST_IP); /* check if authority is hostname or IP address:*/ /* try a hostname first since that's much more likely*/ DomainValidator domainValidator = DomainValidator.getInstance(isOn(ALLOW_LOCAL_URLS));
*/ protected boolean isValidAuthority(String authority) { if (authority == null) { return false; }  /* check manual authority validation if specified*/ if (authorityValidator != null && authorityValidator.isValid(authority)) { return true; } /* convert to ASCII if possible*/ final String authorityASCII = DomainValidator.unicodeToASCII(authority);  Matcher authorityMatcher = AUTHORITY_PATTERN.matcher(authorityASCII); if (!authorityMatcher.matches()) { return false; }  /* We have to process IPV6 separately because that is parsed in a different group*/ <BUGS> String ipv6 = authorityMatcher.group(PARSE_AUTHORITY_IPV6); if (ipv6 != null) { <BUGE> InetAddressValidator inetAddressValidator = InetAddressValidator.getInstance(); if (!inetAddressValidator.isValidInet6Address(ipv6)) { return false; } } else { String hostLocation = authorityMatcher.group(PARSE_AUTHORITY_HOST_IP); /* check if authority is hostname or IP address:*/ /* try a hostname first since that's much more likely*/ DomainValidator domainValidator = DomainValidator.getInstance(isOn(ALLOW_LOCAL_URLS));
*/ protected boolean isValidAuthority(String authority) { if (authority == null) { return false; }  /* check manual authority validation if specified*/ if (authorityValidator != null && authorityValidator.isValid(authority)) { return true; } /* convert to ASCII if possible*/ final String authorityASCII = DomainValidator.unicodeToASCII(authority);  Matcher authorityMatcher = AUTHORITY_PATTERN.matcher(authorityASCII); if (!authorityMatcher.matches()) { return false; }  /* We have to process IPV6 separately because that is parsed in a different group*/ String ipv6 = authorityMatcher.group(PARSE_AUTHORITY_IPV6); if (ipv6 != null) { InetAddressValidator inetAddressValidator = InetAddressValidator.getInstance(); if (!inetAddressValidator.isValidInet6Address(ipv6)) { return false; } } else { <BUGS> String hostLocation = authorityMatcher.group(PARSE_AUTHORITY_HOST_IP); <BUGE> /* check if authority is hostname or IP address:*/ /* try a hostname first since that's much more likely*/ DomainValidator domainValidator = DomainValidator.getInstance(isOn(ALLOW_LOCAL_URLS));
*/ protected boolean isValidAuthority(String authority) { if (authority == null) { return false; }  /* check manual authority validation if specified*/ if (authorityValidator != null && authorityValidator.isValid(authority)) { return true; } /* convert to ASCII if possible*/ final String authorityASCII = DomainValidator.unicodeToASCII(authority);  Matcher authorityMatcher = AUTHORITY_PATTERN.matcher(authorityASCII); if (!authorityMatcher.matches()) { return false; }  /* We have to process IPV6 separately because that is parsed in a different group*/ String ipv6 = authorityMatcher.group(PARSE_AUTHORITY_IPV6); if (ipv6 != null) { InetAddressValidator inetAddressValidator = InetAddressValidator.getInstance(); if (!inetAddressValidator.isValidInet6Address(ipv6)) { return false; } } else { String hostLocation = authorityMatcher.group(PARSE_AUTHORITY_HOST_IP); /* check if authority is hostname or IP address:*/ /* try a hostname first since that's much more likely*/ <BUGS> DomainValidator domainValidator = DomainValidator.getInstance(isOn(ALLOW_LOCAL_URLS));
}  return true; }  /** * Returns true if the authority is properly formatted.  An authority is the combination * of hostname and port.  A <code>null</code> authority value is considered invalid. * Note: this implementation validates the domain unless a RegexValidator was provided. * If a RegexValidator was supplied and it matches, then the authority is regarded * as valid with no further checks, otherwise the method checks against the * AUTHORITY_PATTERN and the DomainValidator (ALLOW_LOCAL_URLS) * @param authority Authority value to validate, alllows IDN * @return true if authority (hostname and port) is valid. } <BUGS> String port = authorityMatcher.group(PARSE_AUTHORITY_PORT); if (port != null && port.length() > 0) { <BUGE> try { long iPort = Integer.parseInt(port); if (iPort < 0 || iPort > 0xFFFF) { return false; } } catch (NumberFormatException nfe) { return false; /* this can happen for big numbers*/ } } }  String extra = authorityMatcher.group(PARSE_AUTHORITY_EXTRA); if (extra != null && extra.trim().length() > 0){
}  return true; }  /** * Returns true if the authority is properly formatted.  An authority is the combination * of hostname and port.  A <code>null</code> authority value is considered invalid. * Note: this implementation validates the domain unless a RegexValidator was provided. * If a RegexValidator was supplied and it matches, then the authority is regarded * as valid with no further checks, otherwise the method checks against the * AUTHORITY_PATTERN and the DomainValidator (ALLOW_LOCAL_URLS) * @param authority Authority value to validate, alllows IDN * @return true if authority (hostname and port) is valid. try { <BUGS> long iPort = Integer.parseInt(port); <BUGE> if (iPort < 0 || iPort > 0xFFFF) { return false; } } catch (NumberFormatException nfe) { return false; /* this can happen for big numbers*/ } } }  String extra = authorityMatcher.group(PARSE_AUTHORITY_EXTRA); if (extra != null && extra.trim().length() > 0){ return false; }
}  return true; }  /** * Returns true if the authority is properly formatted.  An authority is the combination * of hostname and port.  A <code>null</code> authority value is considered invalid. * Note: this implementation validates the domain unless a RegexValidator was provided. * If a RegexValidator was supplied and it matches, then the authority is regarded * as valid with no further checks, otherwise the method checks against the * AUTHORITY_PATTERN and the DomainValidator (ALLOW_LOCAL_URLS) * @param authority Authority value to validate, alllows IDN * @return true if authority (hostname and port) is valid. } <BUGS> } catch (NumberFormatException nfe) { return false; /* this can happen for big numbers <BUGE>*/ } } }  String extra = authorityMatcher.group(PARSE_AUTHORITY_EXTRA); if (extra != null && extra.trim().length() > 0){ return false; }  return true; }  /**
}  return true; }  /** * Returns true if the authority is properly formatted.  An authority is the combination * of hostname and port.  A <code>null</code> authority value is considered invalid. * Note: this implementation validates the domain unless a RegexValidator was provided. * If a RegexValidator was supplied and it matches, then the authority is regarded * as valid with no further checks, otherwise the method checks against the * AUTHORITY_PATTERN and the DomainValidator (ALLOW_LOCAL_URLS) * @param authority Authority value to validate, alllows IDN * @return true if authority (hostname and port) is valid.  <BUGS> String extra = authorityMatcher.group(PARSE_AUTHORITY_EXTRA); if (extra != null && extra.trim().length() > 0){ <BUGE> return false; }  return true; }  /** * Returns true if the path is valid.  A <code>null</code> value is considered invalid. * @param path Path value to validate. * @return true if path is valid. */ protected boolean isValidPath(String path) { if (path == null) {
}  return true; }  /** * Returns true if the authority is properly formatted.  An authority is the combination * of hostname and port.  A <code>null</code> authority value is considered invalid. * Note: this implementation validates the domain unless a RegexValidator was provided. * If a RegexValidator was supplied and it matches, then the authority is regarded * as valid with no further checks, otherwise the method checks against the * AUTHORITY_PATTERN and the DomainValidator (ALLOW_LOCAL_URLS) * @param authority Authority value to validate, alllows IDN * @return true if authority (hostname and port) is valid.  <BUGS> return true; <BUGE> }  /** * Returns true if the path is valid.  A <code>null</code> value is considered invalid. * @param path Path value to validate. * @return true if path is valid. */ protected boolean isValidPath(String path) { if (path == null) { return false; }  if (!PATH_PATTERN.matcher(path).matches()) { return false;
*/ protected boolean isValidAuthority(String authority) { <BUGS> if (authority == null) { <BUGE> return false; }  /* check manual authority validation if specified*/ if (authorityValidator != null && authorityValidator.isValid(authority)) { return true; } /* convert to ASCII if possible*/ final String authorityASCII = DomainValidator.unicodeToASCII(authority);  Matcher authorityMatcher = AUTHORITY_PATTERN.matcher(authorityASCII); if (!authorityMatcher.matches()) { return false; }  /* We have to process IPV6 separately because that is parsed in a different group*/ String ipv6 = authorityMatcher.group(PARSE_AUTHORITY_IPV6); if (ipv6 != null) { InetAddressValidator inetAddressValidator = InetAddressValidator.getInstance(); if (!inetAddressValidator.isValidInet6Address(ipv6)) { return false; } } else { String hostLocation = authorityMatcher.group(PARSE_AUTHORITY_HOST_IP); /* check if authority is hostname or IP address:*/ /* try a hostname first since that's much more likely*/ DomainValidator domainValidator = DomainValidator.getInstance(isOn(ALLOW_LOCAL_URLS));
*/ protected boolean isValidAuthority(String authority) { if (authority == null) { return false; }  /* check manual authority validation if specified*/ <BUGS> if (authorityValidator != null && authorityValidator.isValid(authority)) { <BUGE> return true; } /* convert to ASCII if possible*/ final String authorityASCII = DomainValidator.unicodeToASCII(authority);  Matcher authorityMatcher = AUTHORITY_PATTERN.matcher(authorityASCII); if (!authorityMatcher.matches()) { return false; }  /* We have to process IPV6 separately because that is parsed in a different group*/ String ipv6 = authorityMatcher.group(PARSE_AUTHORITY_IPV6); if (ipv6 != null) { InetAddressValidator inetAddressValidator = InetAddressValidator.getInstance(); if (!inetAddressValidator.isValidInet6Address(ipv6)) { return false; } } else { String hostLocation = authorityMatcher.group(PARSE_AUTHORITY_HOST_IP); /* check if authority is hostname or IP address:*/ /* try a hostname first since that's much more likely*/ DomainValidator domainValidator = DomainValidator.getInstance(isOn(ALLOW_LOCAL_URLS));
*/ protected boolean isValidAuthority(String authority) { if (authority == null) { return false; }  /* check manual authority validation if specified*/ if (authorityValidator != null && authorityValidator.isValid(authority)) { return true; } /* convert to ASCII if possible*/ <BUGS> final String authorityASCII = DomainValidator.unicodeToASCII(authority); <BUGE>  Matcher authorityMatcher = AUTHORITY_PATTERN.matcher(authorityASCII); if (!authorityMatcher.matches()) { return false; }  /* We have to process IPV6 separately because that is parsed in a different group*/ String ipv6 = authorityMatcher.group(PARSE_AUTHORITY_IPV6); if (ipv6 != null) { InetAddressValidator inetAddressValidator = InetAddressValidator.getInstance(); if (!inetAddressValidator.isValidInet6Address(ipv6)) { return false; } } else { String hostLocation = authorityMatcher.group(PARSE_AUTHORITY_HOST_IP); /* check if authority is hostname or IP address:*/ /* try a hostname first since that's much more likely*/ DomainValidator domainValidator = DomainValidator.getInstance(isOn(ALLOW_LOCAL_URLS));
*/ protected boolean isValidAuthority(String authority) { if (authority == null) { return false; }  /* check manual authority validation if specified*/ if (authorityValidator != null && authorityValidator.isValid(authority)) { return true; } /* convert to ASCII if possible*/ final String authorityASCII = DomainValidator.unicodeToASCII(authority);  <BUGS> Matcher authorityMatcher = AUTHORITY_PATTERN.matcher(authorityASCII); if (!authorityMatcher.matches()) { <BUGE> return false; }  /* We have to process IPV6 separately because that is parsed in a different group*/ String ipv6 = authorityMatcher.group(PARSE_AUTHORITY_IPV6); if (ipv6 != null) { InetAddressValidator inetAddressValidator = InetAddressValidator.getInstance(); if (!inetAddressValidator.isValidInet6Address(ipv6)) { return false; } } else { String hostLocation = authorityMatcher.group(PARSE_AUTHORITY_HOST_IP); /* check if authority is hostname or IP address:*/ /* try a hostname first since that's much more likely*/ DomainValidator domainValidator = DomainValidator.getInstance(isOn(ALLOW_LOCAL_URLS));
*/ protected boolean isValidAuthority(String authority) { if (authority == null) { return false; }  /* check manual authority validation if specified*/ if (authorityValidator != null && authorityValidator.isValid(authority)) { return true; } /* convert to ASCII if possible*/ final String authorityASCII = DomainValidator.unicodeToASCII(authority);  Matcher authorityMatcher = AUTHORITY_PATTERN.matcher(authorityASCII); if (!authorityMatcher.matches()) { return false; }  /* We have to process IPV6 separately because that is parsed in a different group*/ <BUGS> String ipv6 = authorityMatcher.group(PARSE_AUTHORITY_IPV6); if (ipv6 != null) { <BUGE> InetAddressValidator inetAddressValidator = InetAddressValidator.getInstance(); if (!inetAddressValidator.isValidInet6Address(ipv6)) { return false; } } else { String hostLocation = authorityMatcher.group(PARSE_AUTHORITY_HOST_IP); /* check if authority is hostname or IP address:*/ /* try a hostname first since that's much more likely*/ DomainValidator domainValidator = DomainValidator.getInstance(isOn(ALLOW_LOCAL_URLS));
*/ protected boolean isValidAuthority(String authority) { if (authority == null) { return false; }  /* check manual authority validation if specified*/ if (authorityValidator != null && authorityValidator.isValid(authority)) { return true; } /* convert to ASCII if possible*/ final String authorityASCII = DomainValidator.unicodeToASCII(authority);  Matcher authorityMatcher = AUTHORITY_PATTERN.matcher(authorityASCII); if (!authorityMatcher.matches()) { return false; }  /* We have to process IPV6 separately because that is parsed in a different group*/ String ipv6 = authorityMatcher.group(PARSE_AUTHORITY_IPV6); if (ipv6 != null) { InetAddressValidator inetAddressValidator = InetAddressValidator.getInstance(); if (!inetAddressValidator.isValidInet6Address(ipv6)) { return false; } } else { <BUGS> String hostLocation = authorityMatcher.group(PARSE_AUTHORITY_HOST_IP); <BUGE> /* check if authority is hostname or IP address:*/ /* try a hostname first since that's much more likely*/ DomainValidator domainValidator = DomainValidator.getInstance(isOn(ALLOW_LOCAL_URLS));
*/ protected boolean isValidAuthority(String authority) { if (authority == null) { return false; }  /* check manual authority validation if specified*/ if (authorityValidator != null && authorityValidator.isValid(authority)) { return true; } /* convert to ASCII if possible*/ final String authorityASCII = DomainValidator.unicodeToASCII(authority);  Matcher authorityMatcher = AUTHORITY_PATTERN.matcher(authorityASCII); if (!authorityMatcher.matches()) { return false; }  /* We have to process IPV6 separately because that is parsed in a different group*/ String ipv6 = authorityMatcher.group(PARSE_AUTHORITY_IPV6); if (ipv6 != null) { InetAddressValidator inetAddressValidator = InetAddressValidator.getInstance(); if (!inetAddressValidator.isValidInet6Address(ipv6)) { return false; } } else { String hostLocation = authorityMatcher.group(PARSE_AUTHORITY_HOST_IP); /* check if authority is hostname or IP address:*/ /* try a hostname first since that's much more likely*/ <BUGS> DomainValidator domainValidator = DomainValidator.getInstance(isOn(ALLOW_LOCAL_URLS));
}  return true; }  /** * Returns true if the authority is properly formatted.  An authority is the combination * of hostname and port.  A <code>null</code> authority value is considered invalid. * Note: this implementation validates the domain unless a RegexValidator was provided. * If a RegexValidator was supplied and it matches, then the authority is regarded * as valid with no further checks, otherwise the method checks against the * AUTHORITY_PATTERN and the DomainValidator (ALLOW_LOCAL_URLS) * @param authority Authority value to validate, alllows IDN * @return true if authority (hostname and port) is valid. /* try an IPv4 address*/ <BUGS> InetAddressValidator inetAddressValidator = InetAddressValidator.getInstance(); if (!inetAddressValidator.isValidInet4Address(hostLocation)) { <BUGE> /* isn't IPv4, so the URL is invalid*/ return false; } } String port = authorityMatcher.group(PARSE_AUTHORITY_PORT); if (port != null && port.length() > 0) { try { int iPort = Integer.parseInt(port); if (iPort < 0 || iPort > MAX_UNSIGNED_16_BIT_INT) { return false; } } catch (NumberFormatException nfe) { return false; /* this can happen for big numbers*/
}  return true; }  /** * Returns true if the authority is properly formatted.  An authority is the combination * of hostname and port.  A <code>null</code> authority value is considered invalid. * Note: this implementation validates the domain unless a RegexValidator was provided. * If a RegexValidator was supplied and it matches, then the authority is regarded * as valid with no further checks, otherwise the method checks against the * AUTHORITY_PATTERN and the DomainValidator (ALLOW_LOCAL_URLS) * @param authority Authority value to validate, alllows IDN * @return true if authority (hostname and port) is valid. /* isn't IPv4, so the URL is invalid*/ <BUGS> return false; <BUGE> } } String port = authorityMatcher.group(PARSE_AUTHORITY_PORT); if (port != null && port.length() > 0) { try { int iPort = Integer.parseInt(port); if (iPort < 0 || iPort > MAX_UNSIGNED_16_BIT_INT) { return false; } } catch (NumberFormatException nfe) { return false; /* this can happen for big numbers*/ } } }
}  return true; }  /** * Returns true if the authority is properly formatted.  An authority is the combination * of hostname and port.  A <code>null</code> authority value is considered invalid. * Note: this implementation validates the domain unless a RegexValidator was provided. * If a RegexValidator was supplied and it matches, then the authority is regarded * as valid with no further checks, otherwise the method checks against the * AUTHORITY_PATTERN and the DomainValidator (ALLOW_LOCAL_URLS) * @param authority Authority value to validate, alllows IDN * @return true if authority (hostname and port) is valid. } <BUGS> String port = authorityMatcher.group(PARSE_AUTHORITY_PORT); if (port != null && port.length() > 0) { <BUGE> try { int iPort = Integer.parseInt(port); if (iPort < 0 || iPort > MAX_UNSIGNED_16_BIT_INT) { return false; } } catch (NumberFormatException nfe) { return false; /* this can happen for big numbers*/ } } }  String extra = authorityMatcher.group(PARSE_AUTHORITY_EXTRA); if (extra != null && extra.trim().length() > 0){
}  return true; }  /** * Returns true if the authority is properly formatted.  An authority is the combination * of hostname and port.  A <code>null</code> authority value is considered invalid. * Note: this implementation validates the domain unless a RegexValidator was provided. * If a RegexValidator was supplied and it matches, then the authority is regarded * as valid with no further checks, otherwise the method checks against the * AUTHORITY_PATTERN and the DomainValidator (ALLOW_LOCAL_URLS) * @param authority Authority value to validate, alllows IDN * @return true if authority (hostname and port) is valid. try { <BUGS> int iPort = Integer.parseInt(port); if (iPort < 0 || iPort > MAX_UNSIGNED_16_BIT_INT) { <BUGE> return false; } } catch (NumberFormatException nfe) { return false; /* this can happen for big numbers*/ } } }  String extra = authorityMatcher.group(PARSE_AUTHORITY_EXTRA); if (extra != null && extra.trim().length() > 0){ return false; }
}  return true; }  /** * Returns true if the authority is properly formatted.  An authority is the combination * of hostname and port.  A <code>null</code> authority value is considered invalid. * Note: this implementation validates the domain unless a RegexValidator was provided. * If a RegexValidator was supplied and it matches, then the authority is regarded * as valid with no further checks, otherwise the method checks against the * AUTHORITY_PATTERN and the DomainValidator (ALLOW_LOCAL_URLS) * @param authority Authority value to validate, alllows IDN * @return true if authority (hostname and port) is valid. return false; /* this can happen for big numbers*/ <BUGS> } <BUGE> } }  String extra = authorityMatcher.group(PARSE_AUTHORITY_EXTRA); if (extra != null && extra.trim().length() > 0){ return false; }  return true; }  /** * Returns true if the path is valid.  A <code>null</code> value is considered invalid. * @param path Path value to validate.
}  return true; }  /** * Returns true if the authority is properly formatted.  An authority is the combination * of hostname and port.  A <code>null</code> authority value is considered invalid. * Note: this implementation validates the domain unless a RegexValidator was provided. * If a RegexValidator was supplied and it matches, then the authority is regarded * as valid with no further checks, otherwise the method checks against the * AUTHORITY_PATTERN and the DomainValidator (ALLOW_LOCAL_URLS) * @param authority Authority value to validate, alllows IDN * @return true if authority (hostname and port) is valid.  <BUGS> String extra = authorityMatcher.group(PARSE_AUTHORITY_EXTRA); if (extra != null && extra.trim().length() > 0){ <BUGE> return false; }  return true; }  /** * Returns true if the path is valid.  A <code>null</code> value is considered invalid. * @param path Path value to validate. * @return true if path is valid. */ protected boolean isValidPath(String path) { if (path == null) {
}  return true; }  /** * Returns true if the authority is properly formatted.  An authority is the combination * of hostname and port.  A <code>null</code> authority value is considered invalid. * Note: this implementation validates the domain unless a RegexValidator was provided. * If a RegexValidator was supplied and it matches, then the authority is regarded * as valid with no further checks, otherwise the method checks against the * AUTHORITY_PATTERN and the DomainValidator (ALLOW_LOCAL_URLS) * @param authority Authority value to validate, alllows IDN * @return true if authority (hostname and port) is valid.  <BUGS> return true; <BUGE> }  /** * Returns true if the path is valid.  A <code>null</code> value is considered invalid. * @param path Path value to validate. * @return true if path is valid. */ protected boolean isValidPath(String path) { if (path == null) { return false; }  if (!PATH_PATTERN.matcher(path).matches()) { return false;
*/ public boolean isValidInet6Address(String inet6Address) { <BUGS> boolean containsCompressedZeroes = inet6Address.contains("::"); if (containsCompressedZeroes && (inet6Address.indexOf("::") != inet6Address.lastIndexOf("::"))) { <BUGE> return false; } if ((inet6Address.startsWith(":") && !inet6Address.startsWith("::")) || (inet6Address.endsWith(":") && !inet6Address.endsWith("::"))) { return false; } String[] octets = inet6Address.split(":"); if (containsCompressedZeroes) { List<String> octetList = new ArrayList<String>(Arrays.asList(octets)); if (inet6Address.endsWith("::")) { /* String.split() drops ending empty segments*/ octetList.add(""); } else if (inet6Address.startsWith("::") && !octetList.isEmpty()) { octetList.remove(0); } octets = octetList.toArray(new String[octetList.size()]); } if (octets.length > IPV6_MAX_HEX_GROUPS) { return false; } int validOctets = 0; int emptyOctets = 0; /* consecutive empty chunks*/ for (int index = 0; index < octets.length; index++) { String octet = octets[index]; if (octet.length() == 0) { emptyOctets++;
*/ public boolean isValidInet6Address(String inet6Address) { boolean containsCompressedZeroes = inet6Address.contains("::"); if (containsCompressedZeroes && (inet6Address.indexOf("::") != inet6Address.lastIndexOf("::"))) { return false; } <BUGS> if ((inet6Address.startsWith(":") && !inet6Address.startsWith("::")) <BUGE> || (inet6Address.endsWith(":") && !inet6Address.endsWith("::"))) { return false; } String[] octets = inet6Address.split(":"); if (containsCompressedZeroes) { List<String> octetList = new ArrayList<String>(Arrays.asList(octets)); if (inet6Address.endsWith("::")) { /* String.split() drops ending empty segments*/ octetList.add(""); } else if (inet6Address.startsWith("::") && !octetList.isEmpty()) { octetList.remove(0); } octets = octetList.toArray(new String[octetList.size()]); } if (octets.length > IPV6_MAX_HEX_GROUPS) { return false; } int validOctets = 0; int emptyOctets = 0; /* consecutive empty chunks*/ for (int index = 0; index < octets.length; index++) { String octet = octets[index]; if (octet.length() == 0) { emptyOctets++;
*/ public boolean isValidInet6Address(String inet6Address) { boolean containsCompressedZeroes = inet6Address.contains("::"); if (containsCompressedZeroes && (inet6Address.indexOf("::") != inet6Address.lastIndexOf("::"))) { return false; } if ((inet6Address.startsWith(":") && !inet6Address.startsWith("::")) || (inet6Address.endsWith(":") && !inet6Address.endsWith("::"))) { return false; } <BUGS> String[] octets = inet6Address.split(":"); if (containsCompressedZeroes) { List<String> octetList = new ArrayList<String>(Arrays.asList(octets)); if (inet6Address.endsWith("::")) { <BUGE> /* String.split() drops ending empty segments*/ octetList.add(""); } else if (inet6Address.startsWith("::") && !octetList.isEmpty()) { octetList.remove(0); } octets = octetList.toArray(new String[octetList.size()]); } if (octets.length > IPV6_MAX_HEX_GROUPS) { return false; } int validOctets = 0; int emptyOctets = 0; /* consecutive empty chunks*/ for (int index = 0; index < octets.length; index++) { String octet = octets[index]; if (octet.length() == 0) { emptyOctets++;
*/ public boolean isValidInet6Address(String inet6Address) { boolean containsCompressedZeroes = inet6Address.contains("::"); if (containsCompressedZeroes && (inet6Address.indexOf("::") != inet6Address.lastIndexOf("::"))) { return false; } if ((inet6Address.startsWith(":") && !inet6Address.startsWith("::")) || (inet6Address.endsWith(":") && !inet6Address.endsWith("::"))) { return false; } String[] octets = inet6Address.split(":"); if (containsCompressedZeroes) { List<String> octetList = new ArrayList<String>(Arrays.asList(octets)); if (inet6Address.endsWith("::")) { /* String.split() drops ending empty segments*/ octetList.add(""); <BUGS> } else if (inet6Address.startsWith("::") && !octetList.isEmpty()) { octetList.remove(0); <BUGE> } octets = octetList.toArray(new String[octetList.size()]); } if (octets.length > IPV6_MAX_HEX_GROUPS) { return false; } int validOctets = 0; int emptyOctets = 0; /* consecutive empty chunks*/ for (int index = 0; index < octets.length; index++) { String octet = octets[index]; if (octet.length() == 0) { emptyOctets++;
*/ public boolean isValidInet6Address(String inet6Address) { boolean containsCompressedZeroes = inet6Address.contains("::"); if (containsCompressedZeroes && (inet6Address.indexOf("::") != inet6Address.lastIndexOf("::"))) { return false; } if ((inet6Address.startsWith(":") && !inet6Address.startsWith("::")) || (inet6Address.endsWith(":") && !inet6Address.endsWith("::"))) { return false; } String[] octets = inet6Address.split(":"); if (containsCompressedZeroes) { List<String> octetList = new ArrayList<String>(Arrays.asList(octets)); if (inet6Address.endsWith("::")) { /* String.split() drops ending empty segments*/ octetList.add(""); } else if (inet6Address.startsWith("::") && !octetList.isEmpty()) { octetList.remove(0); } <BUGS> octets = octetList.toArray(new String[octetList.size()]); <BUGE> } if (octets.length > IPV6_MAX_HEX_GROUPS) { return false; } int validOctets = 0; int emptyOctets = 0; /* consecutive empty chunks*/ for (int index = 0; index < octets.length; index++) { String octet = octets[index]; if (octet.length() == 0) { emptyOctets++;
*/ public boolean isValidInet6Address(String inet6Address) { boolean containsCompressedZeroes = inet6Address.contains("::"); if (containsCompressedZeroes && (inet6Address.indexOf("::") != inet6Address.lastIndexOf("::"))) { return false; } if ((inet6Address.startsWith(":") && !inet6Address.startsWith("::")) || (inet6Address.endsWith(":") && !inet6Address.endsWith("::"))) { return false; } String[] octets = inet6Address.split(":"); if (containsCompressedZeroes) { List<String> octetList = new ArrayList<String>(Arrays.asList(octets)); if (inet6Address.endsWith("::")) { /* String.split() drops ending empty segments*/ octetList.add(""); } else if (inet6Address.startsWith("::") && !octetList.isEmpty()) { octetList.remove(0); } octets = octetList.toArray(new String[octetList.size()]); } <BUGS> if (octets.length > IPV6_MAX_HEX_GROUPS) { <BUGE> return false; } int validOctets = 0; int emptyOctets = 0; /* consecutive empty chunks*/ for (int index = 0; index < octets.length; index++) { String octet = octets[index]; if (octet.length() == 0) { emptyOctets++;
*/ public boolean isValidInet6Address(String inet6Address) { boolean containsCompressedZeroes = inet6Address.contains("::"); if (containsCompressedZeroes && (inet6Address.indexOf("::") != inet6Address.lastIndexOf("::"))) { return false; } if ((inet6Address.startsWith(":") && !inet6Address.startsWith("::")) || (inet6Address.endsWith(":") && !inet6Address.endsWith("::"))) { return false; } String[] octets = inet6Address.split(":"); if (containsCompressedZeroes) { List<String> octetList = new ArrayList<String>(Arrays.asList(octets)); if (inet6Address.endsWith("::")) { /* String.split() drops ending empty segments*/ octetList.add(""); } else if (inet6Address.startsWith("::") && !octetList.isEmpty()) { octetList.remove(0); } octets = octetList.toArray(new String[octetList.size()]); } if (octets.length > IPV6_MAX_HEX_GROUPS) { return false; } <BUGS> int validOctets = 0; int emptyOctets = 0; /* consecutive empty chunks*/ for (int index = 0; index < octets.length; index++) { String octet = octets[index]; if (octet.length() == 0) { emptyOctets++;
return false; }  }  return true; }  /** * Validates an IPv6 address. Returns true if valid. * @param inet6Address the IPv6 address to validate * @return true if the argument contains a valid IPv6 address * * @since 1.4.1 } else { <BUGS> emptyOctets = 0; <BUGE> /* Is last chunk an IPv4 address?*/ if (octet.contains(".")) { /* contains is Java 1.5+*/ if (!inet6Address.endsWith(octet)) { return false; } if (index > octets.length - 1 || index > 6) {  /* CHECKSTYLE IGNORE MagicNumber*/ return false; } if (!isValidInet4Address(octet)) { return false; } validOctets += 2; continue; }
return false; }  }  return true; }  /** * Validates an IPv6 address. Returns true if valid. * @param inet6Address the IPv6 address to validate * @return true if the argument contains a valid IPv6 address * * @since 1.4.1 /* Is last chunk an IPv4 address?*/ <BUGS> if (octet.contains(".")) { /* contains is Java 1.5+*/ if (!inet6Address.endsWith(octet)) { <BUGE> return false; } if (index > octets.length - 1 || index > 6) {  /* CHECKSTYLE IGNORE MagicNumber*/ return false; } if (!isValidInet4Address(octet)) { return false; } validOctets += 2; continue; } if (octet.length() > IPV6_MAX_HEX_DIGITS_PER_GROUP) { return false;
return false; }  }  return true; }  /** * Validates an IPv6 address. Returns true if valid. * @param inet6Address the IPv6 address to validate * @return true if the argument contains a valid IPv6 address * * @since 1.4.1 } <BUGS> if (index > octets.length - 1 || index > 6) {  /* CHECKSTYLE IGNORE MagicNumber <BUGE>*/ return false; } if (!isValidInet4Address(octet)) { return false; } validOctets += 2; continue; } if (octet.length() > IPV6_MAX_HEX_DIGITS_PER_GROUP) { return false; } int octetInt = 0; try { octetInt = Integer.valueOf(octet, BASE_16).intValue();
return false; }  }  return true; }  /** * Validates an IPv6 address. Returns true if valid. * @param inet6Address the IPv6 address to validate * @return true if the argument contains a valid IPv6 address * * @since 1.4.1 } <BUGS> if (!isValidInet4Address(octet)) { <BUGE> return false; } validOctets += 2; continue; } if (octet.length() > IPV6_MAX_HEX_DIGITS_PER_GROUP) { return false; } int octetInt = 0; try { octetInt = Integer.valueOf(octet, BASE_16).intValue(); } catch (NumberFormatException e) { return false; }
return false; }  }  return true; }  /** * Validates an IPv6 address. Returns true if valid. * @param inet6Address the IPv6 address to validate * @return true if the argument contains a valid IPv6 address * * @since 1.4.1 } <BUGS> validOctets += 2; continue; <BUGE> } if (octet.length() > IPV6_MAX_HEX_DIGITS_PER_GROUP) { return false; } int octetInt = 0; try { octetInt = Integer.valueOf(octet, BASE_16).intValue(); } catch (NumberFormatException e) { return false; } if (octetInt < 0 || octetInt > MAX_UNSIGNED_SHORT) { return false; }
return false; }  }  return true; }  /** * Validates an IPv6 address. Returns true if valid. * @param inet6Address the IPv6 address to validate * @return true if the argument contains a valid IPv6 address * * @since 1.4.1 } <BUGS> if (octet.length() > IPV6_MAX_HEX_DIGITS_PER_GROUP) { <BUGE> return false; } int octetInt = 0; try { octetInt = Integer.valueOf(octet, BASE_16).intValue(); } catch (NumberFormatException e) { return false; } if (octetInt < 0 || octetInt > MAX_UNSIGNED_SHORT) { return false; } } validOctets++; }
return false; }  }  return true; }  /** * Validates an IPv6 address. Returns true if valid. * @param inet6Address the IPv6 address to validate * @return true if the argument contains a valid IPv6 address * * @since 1.4.1 } <BUGS> int octetInt = 0; <BUGE> try { octetInt = Integer.valueOf(octet, BASE_16).intValue(); } catch (NumberFormatException e) { return false; } if (octetInt < 0 || octetInt > MAX_UNSIGNED_SHORT) { return false; } } validOctets++; } if (validOctets < IPV6_MAX_HEX_GROUPS && !containsCompressedZeroes) { return false; }
return false; }  }  return true; }  /** * Validates an IPv6 address. Returns true if valid. * @param inet6Address the IPv6 address to validate * @return true if the argument contains a valid IPv6 address * * @since 1.4.1 try { <BUGS> octetInt = Integer.valueOf(octet, BASE_16).intValue(); <BUGE> } catch (NumberFormatException e) { return false; } if (octetInt < 0 || octetInt > MAX_UNSIGNED_SHORT) { return false; } } validOctets++; } if (validOctets < IPV6_MAX_HEX_GROUPS && !containsCompressedZeroes) { return false; } return true; }
return false; }  }  return true; }  /** * Validates an IPv6 address. Returns true if valid. * @param inet6Address the IPv6 address to validate * @return true if the argument contains a valid IPv6 address * * @since 1.4.1 return false; <BUGS> } if (octetInt < 0 || octetInt > MAX_UNSIGNED_SHORT) { <BUGE> return false; } } validOctets++; } if (validOctets < IPV6_MAX_HEX_GROUPS && !containsCompressedZeroes) { return false; } return true; } }
return false; }  }  return true; }  /** * Validates an IPv6 address. Returns true if valid. * @param inet6Address the IPv6 address to validate * @return true if the argument contains a valid IPv6 address * * @since 1.4.1 } <BUGS> validOctets++; <BUGE> } if (validOctets < IPV6_MAX_HEX_GROUPS && !containsCompressedZeroes) { return false; } return true; } }
return false; }  }  return true; }  /** * Validates an IPv6 address. Returns true if valid. * @param inet6Address the IPv6 address to validate * @return true if the argument contains a valid IPv6 address * * @since 1.4.1 } <BUGS> if (validOctets < IPV6_MAX_HEX_GROUPS && !containsCompressedZeroes) { <BUGE> return false; } return true; } }
return false; }  }  return true; }  /** * Validates an IPv6 address. Returns true if valid. * @param inet6Address the IPv6 address to validate * @return true if the argument contains a valid IPv6 address * * @since 1.4.1 } <BUGS> return true; <BUGE> } }
*/ protected boolean isValidQuery(String query) { <BUGS> if (query == null) { <BUGE> return true; }  return QUERY_PATTERN.matcher(query).matches(); }
*/ protected boolean isValidQuery(String query) { if (query == null) { return true; }  <BUGS> return QUERY_PATTERN.matcher(query).matches(); <BUGE> }
@Override public void invalidateObject(T obj) throws Exception { <BUGS> PooledObject<T> p = allObjects.get(obj); if (p == null) { if (isAbandonedConfig()) { <BUGE> return; } else { throw new IllegalStateException( "Returned object not currently part of this pool"); } } destroy(p); }
@Override public void invalidateObject(T obj) throws Exception { PooledObject<T> p = allObjects.get(obj); if (p == null) { if (isAbandonedConfig()) { return; } else { <BUGS> throw new IllegalStateException( <BUGE> "Returned object not currently part of this pool"); } } destroy(p); }
@Override public void invalidateObject(T obj) throws Exception { PooledObject<T> p = allObjects.get(obj); if (p == null) { if (isAbandonedConfig()) { return; } else { throw new IllegalStateException( "Returned object not currently part of this pool"); } } <BUGS> destroy(p); } <BUGE>
*/ private PooledObject<T> create(K key) throws Exception { <BUGS> int maxTotalPerKeySave = getMaxTotalPerKey(); /* Per key*/ int maxTotal = getMaxTotal();   /* All keys <BUGE>*/  /* Check against the overall limit*/ boolean loop = true;  while (loop) { int newNumTotal = numTotal.incrementAndGet(); if (maxTotal > -1 && newNumTotal > maxTotal) { numTotal.decrementAndGet(); if (getNumIdle() == 0) { return null; } else { clearOldest(); } } else { loop = false; } }  ObjectDeque<T> objectDeque = poolMap.get(key); long newCreateCount = objectDeque.getCreateCount().incrementAndGet();  /* Check against the per key limit*/ if (maxTotalPerKeySave > -1 && newCreateCount > maxTotalPerKeySave || newCreateCount > Integer.MAX_VALUE) { numTotal.decrementAndGet(); objectDeque.getCreateCount().decrementAndGet();
*/ private PooledObject<T> create(K key) throws Exception { int maxTotalPerKeySave = getMaxTotalPerKey(); /* Per key*/ int maxTotal = getMaxTotal();   /* All keys*/  /* Check against the overall limit*/ <BUGS> boolean loop = true; <BUGE>  while (loop) { int newNumTotal = numTotal.incrementAndGet(); if (maxTotal > -1 && newNumTotal > maxTotal) { numTotal.decrementAndGet(); if (getNumIdle() == 0) { return null; } else { clearOldest(); } } else { loop = false; } }  ObjectDeque<T> objectDeque = poolMap.get(key); long newCreateCount = objectDeque.getCreateCount().incrementAndGet();  /* Check against the per key limit*/ if (maxTotalPerKeySave > -1 && newCreateCount > maxTotalPerKeySave || newCreateCount > Integer.MAX_VALUE) { numTotal.decrementAndGet(); objectDeque.getCreateCount().decrementAndGet();
*/ private PooledObject<T> create(K key) throws Exception { int maxTotalPerKeySave = getMaxTotalPerKey(); /* Per key*/ int maxTotal = getMaxTotal();   /* All keys*/  /* Check against the overall limit*/ boolean loop = true;  <BUGS> while (loop) { int newNumTotal = numTotal.incrementAndGet(); if (maxTotal > -1 && newNumTotal > maxTotal) { <BUGE> numTotal.decrementAndGet(); if (getNumIdle() == 0) { return null; } else { clearOldest(); } } else { loop = false; } }  ObjectDeque<T> objectDeque = poolMap.get(key); long newCreateCount = objectDeque.getCreateCount().incrementAndGet();  /* Check against the per key limit*/ if (maxTotalPerKeySave > -1 && newCreateCount > maxTotalPerKeySave || newCreateCount > Integer.MAX_VALUE) { numTotal.decrementAndGet(); objectDeque.getCreateCount().decrementAndGet();
*/ private PooledObject<T> create(K key) throws Exception { int maxTotalPerKeySave = getMaxTotalPerKey(); /* Per key*/ int maxTotal = getMaxTotal();   /* All keys*/  /* Check against the overall limit*/ boolean loop = true;  while (loop) { int newNumTotal = numTotal.incrementAndGet(); if (maxTotal > -1 && newNumTotal > maxTotal) { numTotal.decrementAndGet(); if (getNumIdle() == 0) { return null; } else { clearOldest(); } } else { <BUGS> loop = false; <BUGE> } }  ObjectDeque<T> objectDeque = poolMap.get(key); long newCreateCount = objectDeque.getCreateCount().incrementAndGet();  /* Check against the per key limit*/ if (maxTotalPerKeySave > -1 && newCreateCount > maxTotalPerKeySave || newCreateCount > Integer.MAX_VALUE) { numTotal.decrementAndGet(); objectDeque.getCreateCount().decrementAndGet();
*/ private PooledObject<T> create(K key) throws Exception { int maxTotalPerKeySave = getMaxTotalPerKey(); /* Per key*/ int maxTotal = getMaxTotal();   /* All keys*/  /* Check against the overall limit*/ boolean loop = true;  while (loop) { int newNumTotal = numTotal.incrementAndGet(); if (maxTotal > -1 && newNumTotal > maxTotal) { numTotal.decrementAndGet(); if (getNumIdle() == 0) { return null; } else { clearOldest(); } } else { loop = false; } <BUGS> } <BUGE>  ObjectDeque<T> objectDeque = poolMap.get(key); long newCreateCount = objectDeque.getCreateCount().incrementAndGet();  /* Check against the per key limit*/ if (maxTotalPerKeySave > -1 && newCreateCount > maxTotalPerKeySave || newCreateCount > Integer.MAX_VALUE) { numTotal.decrementAndGet(); objectDeque.getCreateCount().decrementAndGet();
*/ private PooledObject<T> create(K key) throws Exception { int maxTotalPerKeySave = getMaxTotalPerKey(); /* Per key*/ int maxTotal = getMaxTotal();   /* All keys*/  /* Check against the overall limit*/ boolean loop = true;  while (loop) { int newNumTotal = numTotal.incrementAndGet(); if (maxTotal > -1 && newNumTotal > maxTotal) { numTotal.decrementAndGet(); if (getNumIdle() == 0) { return null; } else { clearOldest(); } } else { loop = false; } }  <BUGS> ObjectDeque<T> objectDeque = poolMap.get(key); long newCreateCount = objectDeque.getCreateCount().incrementAndGet(); <BUGE>  /* Check against the per key limit*/ if (maxTotalPerKeySave > -1 && newCreateCount > maxTotalPerKeySave || newCreateCount > Integer.MAX_VALUE) { numTotal.decrementAndGet(); objectDeque.getCreateCount().decrementAndGet();
*/ private PooledObject<T> create(K key) throws Exception { int maxTotalPerKeySave = getMaxTotalPerKey(); /* Per key*/ int maxTotal = getMaxTotal();   /* All keys*/  /* Check against the overall limit*/ boolean loop = true;  while (loop) { int newNumTotal = numTotal.incrementAndGet(); if (maxTotal > -1 && newNumTotal > maxTotal) { numTotal.decrementAndGet(); if (getNumIdle() == 0) { return null; } else { clearOldest(); } } else { loop = false; } }  ObjectDeque<T> objectDeque = poolMap.get(key); long newCreateCount = objectDeque.getCreateCount().incrementAndGet();  /* Check against the per key limit*/ <BUGS> if (maxTotalPerKeySave > -1 && newCreateCount > maxTotalPerKeySave || <BUGE> newCreateCount > Integer.MAX_VALUE) { numTotal.decrementAndGet(); objectDeque.getCreateCount().decrementAndGet();
*/ private PooledObject<T> create(K key) throws Exception { int maxTotalPerKeySave = getMaxTotalPerKey(); /* Per key*/ int maxTotal = getMaxTotal();   /* All keys*/  /* Check against the overall limit*/ boolean loop = true;  while (loop) { int newNumTotal = numTotal.incrementAndGet(); if (maxTotal > -1 && newNumTotal > maxTotal) { numTotal.decrementAndGet(); if (getNumIdle() == 0) { return null; } else { clearOldest(); } } else { loop = false; } }  ObjectDeque<T> objectDeque = poolMap.get(key); long newCreateCount = objectDeque.getCreateCount().incrementAndGet();  /* Check against the per key limit*/ if (maxTotalPerKeySave > -1 && newCreateCount > maxTotalPerKeySave || newCreateCount > Integer.MAX_VALUE) { <BUGS> numTotal.decrementAndGet(); objectDeque.getCreateCount().decrementAndGet();
} } } } }  /** * Create a new pooled object. * * @param key Key associated with new pooled object * * @return The new, wrapped pooled object * * @throws Exception If the objection creation fails  <BUGS> PooledObject<T> p = null; <BUGE> try { p = factory.makeObject(key); } catch (Exception e) { numTotal.decrementAndGet(); throw e; }  createdCount.incrementAndGet(); objectDeque.getAllObjects().put(p.getObject(), p); return p; }  /** * Destroy the wrapped, pooled object.
} } } }  /** * Create a new pooled object. * * @param key Key associated with new pooled object * * @return The new, wrapped pooled object * * @throws Exception If the objection creation fails try { <BUGS> p = factory.makeObject(key); } catch (Exception e) { numTotal.decrementAndGet(); throw e; <BUGE> }  createdCount.incrementAndGet(); objectDeque.getAllObjects().put(p.getObject(), p); return p; }  /** * Destroy the wrapped, pooled object. * * @param key The key associated with the object to destroy. * @param toDestroy The wrapped object to be destroyed
@Override public synchronized void markReturning() { <BUGS> state = PooledObjectState.RETURNING; } <BUGE>
*/ public final long getMaxBorrowWaitTimeMillis() { <BUGS> return maxBorrowWaitTimeMillis; <BUGE> }
*/ public void setMinEvictableIdleTimeMillis(long minEvictableIdleTimeMillis) { <BUGS> this.minEvictableIdleTimeMillis = minEvictableIdleTimeMillis; } <BUGE>
*/ public E takeFirst() throws InterruptedException { <BUGS> lock.lock(); <BUGE> try { E x; while ( (x = unlinkFirst()) == null) { notEmpty.await(); } return x; } finally { lock.unlock(); } }
*/ public E takeFirst() throws InterruptedException { lock.lock(); try { E x; <BUGS> while ( (x = unlinkFirst()) == null) { notEmpty.await(); <BUGE> } return x; } finally { lock.unlock(); } }
*/ public E takeFirst() throws InterruptedException { lock.lock(); try { E x; while ( (x = unlinkFirst()) == null) { notEmpty.await(); } <BUGS> return x; <BUGE> } finally { lock.unlock(); } }
*/ public E takeFirst() throws InterruptedException { lock.lock(); try { E x; while ( (x = unlinkFirst()) == null) { notEmpty.await(); } return x; } finally { <BUGS> lock.unlock(); <BUGE> } }
@Override public synchronized boolean allocate() { <BUGS> if (state == PooledObjectState.IDLE) { state = PooledObjectState.ALLOCATED; lastBorrowTime = System.currentTimeMillis(); lastUseTime = lastBorrowTime; borrowedCount++; if (logAbandoned) { <BUGE> borrowedBy = new AbandonedObjectCreatedException(); } return true; } else if (state == PooledObjectState.EVICTION) { /* TODO Allocate anyway and ignore eviction test*/ state = PooledObjectState.EVICTION_RETURN_TO_HEAD; return false; } /* TODO if validating and testOnBorrow == true then pre-allocate for*/ /* performance*/ return false; }
@Override public synchronized boolean allocate() { if (state == PooledObjectState.IDLE) { state = PooledObjectState.ALLOCATED; lastBorrowTime = System.currentTimeMillis(); lastUseTime = lastBorrowTime; borrowedCount++; if (logAbandoned) { borrowedBy = new AbandonedObjectCreatedException(); } <BUGS> return true; } else if (state == PooledObjectState.EVICTION) { <BUGE> /* TODO Allocate anyway and ignore eviction test*/ state = PooledObjectState.EVICTION_RETURN_TO_HEAD; return false; } /* TODO if validating and testOnBorrow == true then pre-allocate for*/ /* performance*/ return false; }
@Override public synchronized boolean allocate() { if (state == PooledObjectState.IDLE) { state = PooledObjectState.ALLOCATED; lastBorrowTime = System.currentTimeMillis(); lastUseTime = lastBorrowTime; borrowedCount++; if (logAbandoned) { borrowedBy = new AbandonedObjectCreatedException(); } return true; } else if (state == PooledObjectState.EVICTION) { /* TODO Allocate anyway and ignore eviction test*/ state = PooledObjectState.EVICTION_RETURN_TO_HEAD; return false; } /* TODO if validating and testOnBorrow == true then pre-allocate for*/ /* performance*/ <BUGS> return false; <BUGE> }
*/ private void removeAbandoned(AbandonedConfig ac) { /* Generate a list of abandoned objects to remove*/ <BUGS> final long now = System.currentTimeMillis(); final long timeout = now - (ac.getRemoveAbandonedTimeout() * 1000L); ArrayList<PooledObject<T>> remove = new ArrayList<PooledObject<T>>(); Iterator<PooledObject<T>> it = allObjects.values().iterator(); while (it.hasNext()) { PooledObject<T> pooledObject = it.next(); synchronized (pooledObject) { if (pooledObject.getState() == PooledObjectState.ALLOCATED && pooledObject.getLastUsedTime() <= timeout) { pooledObject.markAbandoned(); remove.add(pooledObject); <BUGE> } } }  /* Now remove the abandoned objects*/ Iterator<PooledObject<T>> itr = remove.iterator(); while (itr.hasNext()) { PooledObject<T> pooledObject = itr.next(); if (ac.getLogAbandoned()) { pooledObject.printStackTrace(ac.getLogWriter()); } try { invalidateObject(pooledObject.getObject()); } catch (Exception e) { e.printStackTrace();
*/ private void removeAbandoned(AbandonedConfig ac) { /* Generate a list of abandoned objects to remove*/ final long now = System.currentTimeMillis(); final long timeout = now - (ac.getRemoveAbandonedTimeout() * 1000L); ArrayList<PooledObject<T>> remove = new ArrayList<PooledObject<T>>(); Iterator<PooledObject<T>> it = allObjects.values().iterator(); while (it.hasNext()) { PooledObject<T> pooledObject = it.next(); synchronized (pooledObject) { if (pooledObject.getState() == PooledObjectState.ALLOCATED && pooledObject.getLastUsedTime() <= timeout) { pooledObject.markAbandoned(); remove.add(pooledObject); } <BUGS> } } <BUGE>  /* Now remove the abandoned objects*/ Iterator<PooledObject<T>> itr = remove.iterator(); while (itr.hasNext()) { PooledObject<T> pooledObject = itr.next(); if (ac.getLogAbandoned()) { pooledObject.printStackTrace(ac.getLogWriter()); } try { invalidateObject(pooledObject.getObject()); } catch (Exception e) { e.printStackTrace();
*/ private void removeAbandoned(AbandonedConfig ac) { /* Generate a list of abandoned objects to remove*/ final long now = System.currentTimeMillis(); final long timeout = now - (ac.getRemoveAbandonedTimeout() * 1000L); ArrayList<PooledObject<T>> remove = new ArrayList<PooledObject<T>>(); Iterator<PooledObject<T>> it = allObjects.values().iterator(); while (it.hasNext()) { PooledObject<T> pooledObject = it.next(); synchronized (pooledObject) { if (pooledObject.getState() == PooledObjectState.ALLOCATED && pooledObject.getLastUsedTime() <= timeout) { pooledObject.markAbandoned(); remove.add(pooledObject); } } }  /* Now remove the abandoned objects*/ <BUGS> Iterator<PooledObject<T>> itr = remove.iterator(); while (itr.hasNext()) { PooledObject<T> pooledObject = itr.next(); if (ac.getLogAbandoned()) { pooledObject.printStackTrace(ac.getLogWriter()); <BUGE> } try { invalidateObject(pooledObject.getObject()); } catch (Exception e) { e.printStackTrace();
*/ private void removeAbandoned(AbandonedConfig ac) { /* Generate a list of abandoned objects to remove*/ final long now = System.currentTimeMillis(); final long timeout = now - (ac.getRemoveAbandonedTimeout() * 1000L); ArrayList<PooledObject<T>> remove = new ArrayList<PooledObject<T>>(); Iterator<PooledObject<T>> it = allObjects.values().iterator(); while (it.hasNext()) { PooledObject<T> pooledObject = it.next(); synchronized (pooledObject) { if (pooledObject.getState() == PooledObjectState.ALLOCATED && pooledObject.getLastUsedTime() <= timeout) { pooledObject.markAbandoned(); remove.add(pooledObject); } } }  /* Now remove the abandoned objects*/ Iterator<PooledObject<T>> itr = remove.iterator(); while (itr.hasNext()) { PooledObject<T> pooledObject = itr.next(); if (ac.getLogAbandoned()) { pooledObject.printStackTrace(ac.getLogWriter()); } try { <BUGS> invalidateObject(pooledObject.getObject()); <BUGE> } catch (Exception e) { e.printStackTrace();
if (numTestsPerEvictionRun >= 0) { return Math.min(numTestsPerEvictionRun, idleObjects.size()); } else { return (int) (Math.ceil(idleObjects.size() / Math.abs((double) numTestsPerEvictionRun))); } }  /** * Recover abandoned objects which have been checked out but * not used since longer than the removeAbandonedTimeout. * * @param ac The configuration to use to identify abandoned objects e.printStackTrace(); <BUGS> } } } <BUGE>   /*--- Usage tracking support -----------------------------------------------*/  @Override public void use(T pooledObject) { AbandonedConfig ac = this.abandonedConfig; if (ac != null && ac.getUseUsageTracking()) { PooledObject<T> wrapper = allObjects.get(new IdentityWrapper<T>(pooledObject)); wrapper.use(); } }
*/ private PooledObject<T> create() throws Exception { <BUGS> final int localMaxTotal = getMaxTotal(); final long newCreateCount = createCount.incrementAndGet(); if (localMaxTotal > -1 && newCreateCount > localMaxTotal || <BUGE> newCreateCount > Integer.MAX_VALUE) { createCount.decrementAndGet(); return null; }  final PooledObject<T> p; try { p = factory.makeObject(); } catch (final Exception e) { createCount.decrementAndGet(); throw e; }  final AbandonedConfig ac = this.abandonedConfig; if (ac != null && ac.getLogAbandoned()) { p.setLogAbandoned(true); }  createdCount.incrementAndGet(); allObjects.put(new IdentityWrapper<T>(p.getObject()), p); return p; }
*/ private PooledObject<T> create() throws Exception { final int localMaxTotal = getMaxTotal(); final long newCreateCount = createCount.incrementAndGet(); if (localMaxTotal > -1 && newCreateCount > localMaxTotal || newCreateCount > Integer.MAX_VALUE) { <BUGS> createCount.decrementAndGet(); return null; <BUGE> }  final PooledObject<T> p; try { p = factory.makeObject(); } catch (final Exception e) { createCount.decrementAndGet(); throw e; }  final AbandonedConfig ac = this.abandonedConfig; if (ac != null && ac.getLogAbandoned()) { p.setLogAbandoned(true); }  createdCount.incrementAndGet(); allObjects.put(new IdentityWrapper<T>(p.getObject()), p); return p; }
*/ private PooledObject<T> create() throws Exception { final int localMaxTotal = getMaxTotal(); final long newCreateCount = createCount.incrementAndGet(); if (localMaxTotal > -1 && newCreateCount > localMaxTotal || newCreateCount > Integer.MAX_VALUE) { createCount.decrementAndGet(); return null; }  final PooledObject<T> p; try { <BUGS> p = factory.makeObject(); } catch (final Exception e) { createCount.decrementAndGet(); throw e; <BUGE> }  final AbandonedConfig ac = this.abandonedConfig; if (ac != null && ac.getLogAbandoned()) { p.setLogAbandoned(true); }  createdCount.incrementAndGet(); allObjects.put(new IdentityWrapper<T>(p.getObject()), p); return p; }
*/ public void interruptWaiters(final Condition condition) { <BUGS> final Collection<Thread> threads = getWaitingThreads(condition); for (final Thread thread : threads) { thread.interrupt(); } } <BUGE>
*/ private PooledObject<T> create() throws Exception { <BUGS> int localMaxTotal = getMaxTotal(); <BUGE> /* This simplifies the code later in this method*/ if (localMaxTotal < 0) { localMaxTotal = Integer.MAX_VALUE; }   /* Flag that indicates if create should:*/ /* - TRUE:  call the factory to create an object*/ /* - FALSE: return null*/ /* - null:  loop and re-test the condition that determines whether to*/ /*          call the factory*/ Boolean create = null; while (create == null) { synchronized (makeObjectCountLock) { final long newCreateCount = createCount.incrementAndGet(); if (newCreateCount > localMaxTotal) { /* The pool is currently at capacity or in the process of*/ /* making enough new objects to take it to capacity.*/ createCount.decrementAndGet(); if (makeObjectCount == 0) { /* There are no makeObject() calls in progress so the*/ /* pool is at capacity. Do not attempt to create a new*/ /* object. Return and wait for an object to be returned*/ create = Boolean.FALSE; } else { /* There are makeObject() calls in progress that might*/ /* bring the pool to capacity. Those calls might also*/
*/ private PooledObject<T> create() throws Exception { int localMaxTotal = getMaxTotal(); /* This simplifies the code later in this method*/ <BUGS> if (localMaxTotal < 0) { <BUGE> localMaxTotal = Integer.MAX_VALUE; }   /* Flag that indicates if create should:*/ /* - TRUE:  call the factory to create an object*/ /* - FALSE: return null*/ /* - null:  loop and re-test the condition that determines whether to*/ /*          call the factory*/ Boolean create = null; while (create == null) { synchronized (makeObjectCountLock) { final long newCreateCount = createCount.incrementAndGet(); if (newCreateCount > localMaxTotal) { /* The pool is currently at capacity or in the process of*/ /* making enough new objects to take it to capacity.*/ createCount.decrementAndGet(); if (makeObjectCount == 0) { /* There are no makeObject() calls in progress so the*/ /* pool is at capacity. Do not attempt to create a new*/ /* object. Return and wait for an object to be returned*/ create = Boolean.FALSE; } else { /* There are makeObject() calls in progress that might*/ /* bring the pool to capacity. Those calls might also*/
*/ private PooledObject<T> create() throws Exception { int localMaxTotal = getMaxTotal(); /* This simplifies the code later in this method*/ if (localMaxTotal < 0) { localMaxTotal = Integer.MAX_VALUE; }   /* Flag that indicates if create should:*/ /* - TRUE:  call the factory to create an object*/ /* - FALSE: return null*/ /* - null:  loop and re-test the condition that determines whether to*/ /*          call the factory*/ <BUGS> Boolean create = null; while (create == null) { synchronized (makeObjectCountLock) { final long newCreateCount = createCount.incrementAndGet(); if (newCreateCount > localMaxTotal) { <BUGE> /* The pool is currently at capacity or in the process of*/ /* making enough new objects to take it to capacity.*/ createCount.decrementAndGet(); if (makeObjectCount == 0) { /* There are no makeObject() calls in progress so the*/ /* pool is at capacity. Do not attempt to create a new*/ /* object. Return and wait for an object to be returned*/ create = Boolean.FALSE; } else { /* There are makeObject() calls in progress that might*/ /* bring the pool to capacity. Those calls might also*/
*/ private PooledObject<T> create() throws Exception { int localMaxTotal = getMaxTotal(); /* This simplifies the code later in this method*/ if (localMaxTotal < 0) { localMaxTotal = Integer.MAX_VALUE; }   /* Flag that indicates if create should:*/ /* - TRUE:  call the factory to create an object*/ /* - FALSE: return null*/ /* - null:  loop and re-test the condition that determines whether to*/ /*          call the factory*/ Boolean create = null; while (create == null) { synchronized (makeObjectCountLock) { final long newCreateCount = createCount.incrementAndGet(); if (newCreateCount > localMaxTotal) { /* The pool is currently at capacity or in the process of*/ /* making enough new objects to take it to capacity.*/ <BUGS> createCount.decrementAndGet(); if (makeObjectCount == 0) { <BUGE> /* There are no makeObject() calls in progress so the*/ /* pool is at capacity. Do not attempt to create a new*/ /* object. Return and wait for an object to be returned*/ create = Boolean.FALSE; } else { /* There are makeObject() calls in progress that might*/ /* bring the pool to capacity. Those calls might also*/
return; } ensureMinIdle(); }  /** * Attempts to create a new wrapped pooled object. * <p> * If there are {@link #getMaxTotal()} objects already in circulation * or in process of being created, this method returns null. * * @return The new wrapped pooled object * * @throws Exception if the object factory's {@code makeObject} fails /* the pool is at capacity or not.*/ <BUGS> makeObjectCountLock.wait(); <BUGE> } } else { /* The pool is not at capacity. Create a new object.*/ makeObjectCount++; create = Boolean.TRUE; } }  /* Do not block more if maxWaitTimeMillis is set.*/ }  if (!create.booleanValue()) { return null; }
return; } ensureMinIdle(); }  /** * Attempts to create a new wrapped pooled object. * <p> * If there are {@link #getMaxTotal()} objects already in circulation * or in process of being created, this method returns null. * * @return The new wrapped pooled object * * @throws Exception if the object factory's {@code makeObject} fails /* The pool is not at capacity. Create a new object.*/ <BUGS> makeObjectCount++; create = Boolean.TRUE; <BUGE> } }  /* Do not block more if maxWaitTimeMillis is set.*/ }  if (!create.booleanValue()) { return null; }  final PooledObject<T> p; try { p = factory.makeObject();
return; } ensureMinIdle(); }  /** * Attempts to create a new wrapped pooled object. * <p> * If there are {@link #getMaxTotal()} objects already in circulation * or in process of being created, this method returns null. * * @return The new wrapped pooled object * * @throws Exception if the object factory's {@code makeObject} fails } <BUGS> } <BUGE>  /* Do not block more if maxWaitTimeMillis is set.*/ }  if (!create.booleanValue()) { return null; }  final PooledObject<T> p; try { p = factory.makeObject(); } catch (final Throwable e) { createCount.decrementAndGet(); throw e;
return; } ensureMinIdle(); }  /** * Attempts to create a new wrapped pooled object. * <p> * If there are {@link #getMaxTotal()} objects already in circulation * or in process of being created, this method returns null. * * @return The new wrapped pooled object * * @throws Exception if the object factory's {@code makeObject} fails  <BUGS> if (!create.booleanValue()) { <BUGE> return null; }  final PooledObject<T> p; try { p = factory.makeObject(); } catch (final Throwable e) { createCount.decrementAndGet(); throw e; } finally { synchronized (makeObjectCountLock) { makeObjectCount--; makeObjectCountLock.notifyAll(); }
return; } ensureMinIdle(); }  /** * Attempts to create a new wrapped pooled object. * <p> * If there are {@link #getMaxTotal()} objects already in circulation * or in process of being created, this method returns null. * * @return The new wrapped pooled object * * @throws Exception if the object factory's {@code makeObject} fails try { <BUGS> p = factory.makeObject(); <BUGE> } catch (final Throwable e) { createCount.decrementAndGet(); throw e; } finally { synchronized (makeObjectCountLock) { makeObjectCount--; makeObjectCountLock.notifyAll(); } }  final AbandonedConfig ac = this.abandonedConfig; if (ac != null && ac.getLogAbandoned()) { p.setLogAbandoned(true); /* TODO: in 3.0, this can use the method defined on PooledObject*/
*/ public void interruptWaiters(final Condition condition) { <BUGS> final Collection<Thread> threads = getWaitingThreads(condition); for (final Thread thread : threads) { thread.interrupt(); } } <BUGE>
@Override public void returnObject(final K key, final T obj) {  <BUGS> final ObjectDeque<T> objectDeque = poolMap.get(key); <BUGE>   final PooledObject<T> p = objectDeque.getAllObjects().get(new IdentityWrapper<>(obj));  if (p == null) { throw new IllegalStateException( "Returned object not currently part of this pool"); }  markReturningState(p);  final long activeTime = p.getActiveTimeMillis();  try { if (getTestOnReturn() && !factory.validateObject(key, p)) { try { destroy(key, p, true); } catch (final Exception e) { swallowException(e); } whenWaitersAddObject(key, objectDeque.idleObjects); return; }  try { factory.passivateObject(key, p);
@Override public void returnObject(final K key, final T obj) {  final ObjectDeque<T> objectDeque = poolMap.get(key);   <BUGS> final PooledObject<T> p = objectDeque.getAllObjects().get(new IdentityWrapper<>(obj)); <BUGE>  if (p == null) { throw new IllegalStateException( "Returned object not currently part of this pool"); }  markReturningState(p);  final long activeTime = p.getActiveTimeMillis();  try { if (getTestOnReturn() && !factory.validateObject(key, p)) { try { destroy(key, p, true); } catch (final Exception e) { swallowException(e); } whenWaitersAddObject(key, objectDeque.idleObjects); return; }  try { factory.passivateObject(key, p);
*/ <BUGS> public DefaultPooledObject(final T object) { <BUGE> this.object = object; }
*/ private FTPFile parseFileList(String entry) { <BUGS> if (matches(entry)) { FTPFile file = new FTPFile(); file.setRawListing(entry); String name = group(2); String dsorg = group(1); file.setName(name); <BUGE>  /* DSORG*/ if ("PS".equals(dsorg)) { file.setType(FTPFile.FILE_TYPE); } else if ("PO".equals(dsorg) || "PO-E".equals(dsorg)) { /* regex already ruled out anything other than PO or PO-E*/ file.setType(FTPFile.DIRECTORY_TYPE); } else { return null; }  return file; }  return null; }
*/ private FTPFile parseFileList(String entry) { if (matches(entry)) { FTPFile file = new FTPFile(); file.setRawListing(entry); String name = group(2); String dsorg = group(1); file.setName(name);  /* DSORG*/ <BUGS> if ("PS".equals(dsorg)) { file.setType(FTPFile.FILE_TYPE); <BUGE> } else if ("PO".equals(dsorg) || "PO-E".equals(dsorg)) { /* regex already ruled out anything other than PO or PO-E*/ file.setType(FTPFile.DIRECTORY_TYPE); } else { return null; }  return file; }  return null; }
*/ private FTPFile parseFileList(String entry) { if (matches(entry)) { FTPFile file = new FTPFile(); file.setRawListing(entry); String name = group(2); String dsorg = group(1); file.setName(name);  /* DSORG*/ if ("PS".equals(dsorg)) { file.setType(FTPFile.FILE_TYPE); } <BUGS> else if ("PO".equals(dsorg) || "PO-E".equals(dsorg)) { <BUGE> /* regex already ruled out anything other than PO or PO-E*/ file.setType(FTPFile.DIRECTORY_TYPE); } else { return null; }  return file; }  return null; }
*/ private FTPFile parseFileList(String entry) { if (matches(entry)) { FTPFile file = new FTPFile(); file.setRawListing(entry); String name = group(2); String dsorg = group(1); file.setName(name);  /* DSORG*/ if ("PS".equals(dsorg)) { file.setType(FTPFile.FILE_TYPE); } else if ("PO".equals(dsorg) || "PO-E".equals(dsorg)) { /* regex already ruled out anything other than PO or PO-E*/ <BUGS> file.setType(FTPFile.DIRECTORY_TYPE); <BUGE> } else { return null; }  return file; }  return null; }
*/ private FTPFile parseFileList(String entry) { if (matches(entry)) { FTPFile file = new FTPFile(); file.setRawListing(entry); String name = group(2); String dsorg = group(1); file.setName(name);  /* DSORG*/ if ("PS".equals(dsorg)) { file.setType(FTPFile.FILE_TYPE); } else if ("PO".equals(dsorg) || "PO-E".equals(dsorg)) { /* regex already ruled out anything other than PO or PO-E*/ file.setType(FTPFile.DIRECTORY_TYPE); } else { return null; }  <BUGS> return file; <BUGE> }  return null; }
*/ private FTPFile parseFileList(String entry) { if (matches(entry)) { FTPFile file = new FTPFile(); file.setRawListing(entry); String name = group(2); String dsorg = group(1); file.setName(name);  /* DSORG*/ if ("PS".equals(dsorg)) { file.setType(FTPFile.FILE_TYPE); } else if ("PO".equals(dsorg) || "PO-E".equals(dsorg)) { /* regex already ruled out anything other than PO or PO-E*/ file.setType(FTPFile.DIRECTORY_TYPE); } else { return null; }  return file; }  <BUGS> return null; <BUGE> }
*/ public boolean isInRange(String address) { <BUGS> return isInRange(toInteger(address)); <BUGE> }
@Override public int compareTo( GpgVersion other ) { <BUGS> Pattern p = Pattern.compile( "([.\\d]+)$" ); <BUGE>  String[] thisSegments; Matcher m = p.matcher( rawVersion ); if ( m.find() ) { thisSegments  = m.group( 1 ).split( "\\." ); } else { throw new IllegalArgumentException( "Can't parse version of " + this.rawVersion ); }  String[] otherSegments; m = p.matcher( other.rawVersion ); if ( m.find() ) { otherSegments  = m.group( 1 ).split( "\\." ); } else { throw new IllegalArgumentException( "Can't parse version of " + other.rawVersion ); }  int minSegments = Math.min( thisSegments.length, otherSegments.length );  for ( int index = 0; index < minSegments; index++ )
@Override public int compareTo( GpgVersion other ) { Pattern p = Pattern.compile( "([.\\d]+)$" );  String[] thisSegments; <BUGS> Matcher m = p.matcher( rawVersion ); if ( m.find() ) <BUGE> { thisSegments  = m.group( 1 ).split( "\\." ); } else { throw new IllegalArgumentException( "Can't parse version of " + this.rawVersion ); }  String[] otherSegments; m = p.matcher( other.rawVersion ); if ( m.find() ) { otherSegments  = m.group( 1 ).split( "\\." ); } else { throw new IllegalArgumentException( "Can't parse version of " + other.rawVersion ); }  int minSegments = Math.min( thisSegments.length, otherSegments.length );  for ( int index = 0; index < minSegments; index++ )
@Override public int compareTo( GpgVersion other ) { Pattern p = Pattern.compile( "([.\\d]+)$" );  String[] thisSegments; Matcher m = p.matcher( rawVersion ); if ( m.find() ) { <BUGS> thisSegments  = m.group( 1 ).split( "\\." ); <BUGE> } else { throw new IllegalArgumentException( "Can't parse version of " + this.rawVersion ); }  String[] otherSegments; m = p.matcher( other.rawVersion ); if ( m.find() ) { otherSegments  = m.group( 1 ).split( "\\." ); } else { throw new IllegalArgumentException( "Can't parse version of " + other.rawVersion ); }  int minSegments = Math.min( thisSegments.length, otherSegments.length );  for ( int index = 0; index < minSegments; index++ )
@Override public int compareTo( GpgVersion other ) { Pattern p = Pattern.compile( "([.\\d]+)$" );  String[] thisSegments; Matcher m = p.matcher( rawVersion ); if ( m.find() ) { thisSegments  = m.group( 1 ).split( "\\." ); } else { <BUGS> throw new IllegalArgumentException( "Can't parse version of " + this.rawVersion ); <BUGE> }  String[] otherSegments; m = p.matcher( other.rawVersion ); if ( m.find() ) { otherSegments  = m.group( 1 ).split( "\\." ); } else { throw new IllegalArgumentException( "Can't parse version of " + other.rawVersion ); }  int minSegments = Math.min( thisSegments.length, otherSegments.length );  for ( int index = 0; index < minSegments; index++ )
@Override public int compareTo( GpgVersion other ) { Pattern p = Pattern.compile( "([.\\d]+)$" );  String[] thisSegments; Matcher m = p.matcher( rawVersion ); if ( m.find() ) { thisSegments  = m.group( 1 ).split( "\\." ); } else { throw new IllegalArgumentException( "Can't parse version of " + this.rawVersion ); }  String[] otherSegments; <BUGS> m = p.matcher( other.rawVersion ); if ( m.find() ) <BUGE> { otherSegments  = m.group( 1 ).split( "\\." ); } else { throw new IllegalArgumentException( "Can't parse version of " + other.rawVersion ); }  int minSegments = Math.min( thisSegments.length, otherSegments.length );  for ( int index = 0; index < minSegments; index++ )
@Override public int compareTo( GpgVersion other ) { Pattern p = Pattern.compile( "([.\\d]+)$" );  String[] thisSegments; Matcher m = p.matcher( rawVersion ); if ( m.find() ) { thisSegments  = m.group( 1 ).split( "\\." ); } else { throw new IllegalArgumentException( "Can't parse version of " + this.rawVersion ); }  String[] otherSegments; m = p.matcher( other.rawVersion ); if ( m.find() ) { <BUGS> otherSegments  = m.group( 1 ).split( "\\." ); <BUGE> } else { throw new IllegalArgumentException( "Can't parse version of " + other.rawVersion ); }  int minSegments = Math.min( thisSegments.length, otherSegments.length );  for ( int index = 0; index < minSegments; index++ )
@Override public int compareTo( GpgVersion other ) { Pattern p = Pattern.compile( "([.\\d]+)$" );  String[] thisSegments; Matcher m = p.matcher( rawVersion ); if ( m.find() ) { thisSegments  = m.group( 1 ).split( "\\." ); } else { throw new IllegalArgumentException( "Can't parse version of " + this.rawVersion ); }  String[] otherSegments; m = p.matcher( other.rawVersion ); if ( m.find() ) { otherSegments  = m.group( 1 ).split( "\\." ); } else { throw new IllegalArgumentException( "Can't parse version of " + other.rawVersion ); }  <BUGS> int minSegments = Math.min( thisSegments.length, otherSegments.length ); <BUGE>  for ( int index = 0; index < minSegments; index++ )
@Override public int compareTo( GpgVersion other ) { Pattern p = Pattern.compile( "([.\\d]+)$" );  String[] thisSegments; Matcher m = p.matcher( rawVersion ); if ( m.find() ) { thisSegments  = m.group( 1 ).split( "\\." ); } else { throw new IllegalArgumentException( "Can't parse version of " + this.rawVersion ); }  String[] otherSegments; m = p.matcher( other.rawVersion ); if ( m.find() ) { otherSegments  = m.group( 1 ).split( "\\." ); } else { throw new IllegalArgumentException( "Can't parse version of " + other.rawVersion ); }  int minSegments = Math.min( thisSegments.length, otherSegments.length );  <BUGS> for ( int index = 0; index < minSegments; index++ ) <BUGE>
public class GpgVersion implements Comparable<GpgVersion> { private final String rawVersion;  private GpgVersion( String rawVersion ) { this.rawVersion = rawVersion; }  public static GpgVersion parse( String rawVersion ) { return new GpgVersion( rawVersion ); }  { <BUGS> int thisValue = Integer.parseInt( thisSegments[index] ); <BUGE>  int otherValue = Integer.parseInt( otherSegments[index] );  int compareValue = Integer.compare( thisValue, otherValue );  if ( compareValue != 0 ) { return compareValue; } }  return ( thisSegments.length - otherSegments.length ); }
public class GpgVersion implements Comparable<GpgVersion> { private final String rawVersion;  private GpgVersion( String rawVersion ) { this.rawVersion = rawVersion; }  public static GpgVersion parse( String rawVersion ) { return new GpgVersion( rawVersion ); }   <BUGS> int otherValue = Integer.parseInt( otherSegments[index] ); <BUGE>  int compareValue = Integer.compare( thisValue, otherValue );  if ( compareValue != 0 ) { return compareValue; } }  return ( thisSegments.length - otherSegments.length ); }  /** * Verify if this version is before some other version
public class GpgVersion implements Comparable<GpgVersion> { private final String rawVersion;  private GpgVersion( String rawVersion ) { this.rawVersion = rawVersion; }  public static GpgVersion parse( String rawVersion ) { return new GpgVersion( rawVersion ); }   <BUGS> int compareValue = Integer.compare( thisValue, otherValue ); <BUGE>  if ( compareValue != 0 ) { return compareValue; } }  return ( thisSegments.length - otherSegments.length ); }  /** * Verify if this version is before some other version * * @param other the version to compare with
public class GpgVersion implements Comparable<GpgVersion> { private final String rawVersion;  private GpgVersion( String rawVersion ) { this.rawVersion = rawVersion; }  public static GpgVersion parse( String rawVersion ) { return new GpgVersion( rawVersion ); }   <BUGS> if ( compareValue != 0 ) <BUGE> { return compareValue; } }  return ( thisSegments.length - otherSegments.length ); }  /** * Verify if this version is before some other version * * @param other the version to compare with * @return {@code true} is this is less than {@code other}, otherwise {@code false} */
public class GpgVersion implements Comparable<GpgVersion> { private final String rawVersion;  private GpgVersion( String rawVersion ) { this.rawVersion = rawVersion; }  public static GpgVersion parse( String rawVersion ) { return new GpgVersion( rawVersion ); }  { <BUGS> return compareValue; <BUGE> } }  return ( thisSegments.length - otherSegments.length ); }  /** * Verify if this version is before some other version * * @param other the version to compare with * @return {@code true} is this is less than {@code other}, otherwise {@code false} */ public boolean isBefore( GpgVersion other ) {
public class GpgVersion implements Comparable<GpgVersion> { private final String rawVersion;  private GpgVersion( String rawVersion ) { this.rawVersion = rawVersion; }  public static GpgVersion parse( String rawVersion ) { return new GpgVersion( rawVersion ); }   <BUGS> return ( thisSegments.length - otherSegments.length ); <BUGE> }  /** * Verify if this version is before some other version * * @param other the version to compare with * @return {@code true} is this is less than {@code other}, otherwise {@code false} */ public boolean isBefore( GpgVersion other ) { return this.compareTo( other ) < 0; }  /**
@Override public Double apply(final CharSequence left, final CharSequence right) { <BUGS> final double defaultScalingFactor = 0.1; final double percentageRoundValue = 100.0; <BUGE>  if (left == null || right == null) { throw new IllegalArgumentException("Strings must not be null"); }  int[] mtp = matches(left, right); double m = mtp[0]; if (m == 0) { return 0D; } double j = ((m / left.length() + m / right.length() + (m - mtp[1]) / m)) / 3; double jw = j < 0.7D ? j : j + Math.min(defaultScalingFactor, 1D / mtp[3]) * mtp[2] * (1D - j); return Math.round(jw * percentageRoundValue) / percentageRoundValue; }
@Override public Double apply(final CharSequence left, final CharSequence right) { final double defaultScalingFactor = 0.1; final double percentageRoundValue = 100.0;  <BUGS> if (left == null || right == null) { <BUGE> throw new IllegalArgumentException("Strings must not be null"); }  int[] mtp = matches(left, right); double m = mtp[0]; if (m == 0) { return 0D; } double j = ((m / left.length() + m / right.length() + (m - mtp[1]) / m)) / 3; double jw = j < 0.7D ? j : j + Math.min(defaultScalingFactor, 1D / mtp[3]) * mtp[2] * (1D - j); return Math.round(jw * percentageRoundValue) / percentageRoundValue; }
@Override public Double apply(final CharSequence left, final CharSequence right) { final double defaultScalingFactor = 0.1; final double percentageRoundValue = 100.0;  if (left == null || right == null) { throw new IllegalArgumentException("Strings must not be null"); }  <BUGS> int[] mtp = matches(left, right); double m = mtp[0]; if (m == 0) { <BUGE> return 0D; } double j = ((m / left.length() + m / right.length() + (m - mtp[1]) / m)) / 3; double jw = j < 0.7D ? j : j + Math.min(defaultScalingFactor, 1D / mtp[3]) * mtp[2] * (1D - j); return Math.round(jw * percentageRoundValue) / percentageRoundValue; }
@Override public Double apply(final CharSequence left, final CharSequence right) { final double defaultScalingFactor = 0.1; final double percentageRoundValue = 100.0;  if (left == null || right == null) { throw new IllegalArgumentException("Strings must not be null"); }  int[] mtp = matches(left, right); double m = mtp[0]; if (m == 0) { return 0D; } <BUGS> double j = ((m / left.length() + m / right.length() + (m - mtp[1]) / m)) / 3; double jw = j < 0.7D ? j : j + Math.min(defaultScalingFactor, 1D / mtp[3]) * mtp[2] * (1D - j); return Math.round(jw * percentageRoundValue) / percentageRoundValue; <BUGE> }
*/ public static String capitalizeFully(String str, final char... delimiters) { <BUGS> final int delimLen = delimiters == null ? -1 : delimiters.length; if (StringUtils.isEmpty(str) || delimLen == 0) { return str; <BUGE> } str = str.toLowerCase(); return capitalize(str, delimiters); }
*/ public static final String unescapeJson(final String input) { <BUGS> return UNESCAPE_JSON.translate(input); <BUGE> }
*/ private String parseFormatDescription(final String pattern, final ParsePosition pos) { <BUGS> final int start = pos.getIndex(); seekNonWs(pattern, pos); final int text = pos.getIndex(); int depth = 1; for (; pos.getIndex() < pattern.length(); next(pos)) { switch (pattern.charAt(pos.getIndex())) { <BUGE> case START_FE: depth++; break; case END_FE: depth--; if (depth == 0) { return pattern.substring(text, pos.getIndex()); } break; case QUOTE: getQuotedString(pattern, pos); break; default: break; } } throw new IllegalArgumentException( "Unterminated format element at position " + start); }
*/ private String parseFormatDescription(final String pattern, final ParsePosition pos) { final int start = pos.getIndex(); seekNonWs(pattern, pos); final int text = pos.getIndex(); int depth = 1; for (; pos.getIndex() < pattern.length(); next(pos)) { switch (pattern.charAt(pos.getIndex())) { case START_FE: depth++; break; case END_FE: depth--; if (depth == 0) { return pattern.substring(text, pos.getIndex()); } break; case QUOTE: <BUGS> getQuotedString(pattern, pos); break; <BUGE> default: break; } } throw new IllegalArgumentException( "Unterminated format element at position " + start); }
*/ private String parseFormatDescription(final String pattern, final ParsePosition pos) { final int start = pos.getIndex(); seekNonWs(pattern, pos); final int text = pos.getIndex(); int depth = 1; for (; pos.getIndex() < pattern.length(); next(pos)) { switch (pattern.charAt(pos.getIndex())) { case START_FE: depth++; break; case END_FE: depth--; if (depth == 0) { return pattern.substring(text, pos.getIndex()); } break; case QUOTE: getQuotedString(pattern, pos); break; default: break; } } <BUGS> throw new IllegalArgumentException( <BUGE> "Unterminated format element at position " + start); }
*/ public void addSourceDirectory( File sourceDirectory ) { <BUGS> this.sourceDirectories.add( sourceDirectory ); } <BUGE>
protected StringBuilder _appendClassSignature(StringBuilder sb) { <BUGS> sb.append('L'); sb = _appendClassName(sb); int count = _typeBindings.size(); if (count > 0) { sb.append('<'); for (int i = 0; i < count; ++i) { sb = _typeBindings.getBoundType(i).appendErasedSignature(sb); <BUGE> } sb.append('>'); } sb.append(';'); return sb; }
protected StringBuilder _appendClassSignature(StringBuilder sb) { sb.append('L'); sb = _appendClassName(sb); int count = _typeBindings.size(); if (count > 0) { sb.append('<'); for (int i = 0; i < count; ++i) { sb = _typeBindings.getBoundType(i).appendErasedSignature(sb); } <BUGS> sb.append('>'); <BUGE> } sb.append(';'); return sb; }
protected StringBuilder _appendClassSignature(StringBuilder sb) { sb.append('L'); sb = _appendClassName(sb); int count = _typeBindings.size(); if (count > 0) { sb.append('<'); for (int i = 0; i < count; ++i) { sb = _typeBindings.getBoundType(i).appendErasedSignature(sb); } sb.append('>'); } <BUGS> sb.append(';'); return sb; <BUGE> }
protected JsonSchema propertySchema(BeanProperty prop) throws JsonMappingException { <BUGS> if (prop == null) { <BUGE> throw new IllegalArgumentException("Null property"); }  /* check if we've seen this argument's sub-schema already and return a reference-schema if we have*/ String seenSchemaUri = visitorContext.getSeenSchemaUri(prop.getType()); if (seenSchemaUri != null) { return new ReferenceSchema(seenSchemaUri); }  SchemaFactoryWrapper visitor = wrapperFactory.getWrapper(getProvider(), visitorContext); JsonSerializer<Object> ser = getSer(prop); if (ser != null) { JavaType type = prop.getType(); if (type == null) { throw new IllegalStateException("Missing type for property '"+prop.getName()+"'"); } ser.acceptJsonFormatVisitor(visitor, type); } return visitor.finalSchema(); }
protected JsonSchema propertySchema(BeanProperty prop) throws JsonMappingException { if (prop == null) { throw new IllegalArgumentException("Null property"); }  /* check if we've seen this argument's sub-schema already and return a reference-schema if we have*/ <BUGS> String seenSchemaUri = visitorContext.getSeenSchemaUri(prop.getType()); if (seenSchemaUri != null) { return new ReferenceSchema(seenSchemaUri); <BUGE> }  SchemaFactoryWrapper visitor = wrapperFactory.getWrapper(getProvider(), visitorContext); JsonSerializer<Object> ser = getSer(prop); if (ser != null) { JavaType type = prop.getType(); if (type == null) { throw new IllegalStateException("Missing type for property '"+prop.getName()+"'"); } ser.acceptJsonFormatVisitor(visitor, type); } return visitor.finalSchema(); }
protected JsonSchema propertySchema(BeanProperty prop) throws JsonMappingException { if (prop == null) { throw new IllegalArgumentException("Null property"); }  /* check if we've seen this argument's sub-schema already and return a reference-schema if we have*/ String seenSchemaUri = visitorContext.getSeenSchemaUri(prop.getType()); if (seenSchemaUri != null) { return new ReferenceSchema(seenSchemaUri); }  <BUGS> SchemaFactoryWrapper visitor = wrapperFactory.getWrapper(getProvider(), visitorContext); JsonSerializer<Object> ser = getSer(prop); if (ser != null) { JavaType type = prop.getType(); if (type == null) { <BUGE> throw new IllegalStateException("Missing type for property '"+prop.getName()+"'"); } ser.acceptJsonFormatVisitor(visitor, type); } return visitor.finalSchema(); }
protected JsonSchema propertySchema(BeanProperty prop) throws JsonMappingException { if (prop == null) { throw new IllegalArgumentException("Null property"); }  /* check if we've seen this argument's sub-schema already and return a reference-schema if we have*/ String seenSchemaUri = visitorContext.getSeenSchemaUri(prop.getType()); if (seenSchemaUri != null) { return new ReferenceSchema(seenSchemaUri); }  SchemaFactoryWrapper visitor = wrapperFactory.getWrapper(getProvider(), visitorContext); JsonSerializer<Object> ser = getSer(prop); if (ser != null) { JavaType type = prop.getType(); if (type == null) { throw new IllegalStateException("Missing type for property '"+prop.getName()+"'"); } <BUGS> ser.acceptJsonFormatVisitor(visitor, type); <BUGE> } return visitor.finalSchema(); }
protected JsonSchema propertySchema(BeanProperty prop) throws JsonMappingException { if (prop == null) { throw new IllegalArgumentException("Null property"); }  /* check if we've seen this argument's sub-schema already and return a reference-schema if we have*/ String seenSchemaUri = visitorContext.getSeenSchemaUri(prop.getType()); if (seenSchemaUri != null) { return new ReferenceSchema(seenSchemaUri); }  SchemaFactoryWrapper visitor = wrapperFactory.getWrapper(getProvider(), visitorContext); JsonSerializer<Object> ser = getSer(prop); if (ser != null) { JavaType type = prop.getType(); if (type == null) { throw new IllegalStateException("Missing type for property '"+prop.getName()+"'"); } ser.acceptJsonFormatVisitor(visitor, type); } <BUGS> return visitor.finalSchema(); <BUGE> }
@Override public ReadableDateTime deserialize(JsonParser p, DeserializationContext ctxt) throws IOException { <BUGS> JsonToken t = p.getCurrentToken(); <BUGE>  DateTimeZone tz = _format.isTimezoneExplicit() ? _format.getTimeZone() : DateTimeZone.forTimeZone(ctxt.getTimeZone());  if (t == JsonToken.VALUE_NUMBER_INT) { return new DateTime(p.getLongValue(), tz); } if (t == JsonToken.VALUE_STRING) { String str = p.getText().trim(); if (str.length() == 0) { /* [JACKSON-360]*/ return null; } /* 08-Jul-2015, tatu: as per [datatype-joda#44], optional TimeZone inclusion*/ /* NOTE: on/off feature only for serialization; on deser should accept both*/ int ix = str.indexOf('['); if (ix > 0) { int ix2 = str.lastIndexOf(']'); String tzId = (ix2 < ix) ? str.substring(ix+1) : str.substring(ix+1, ix2); try { tz = DateTimeZone.forID(tzId); } catch (IllegalArgumentException e) { throw ctxt.mappingException(String.format("Unknown DateTimeZone id '%s'", tzId)); } str = str.substring(0, ix);
@Override public ReadableDateTime deserialize(JsonParser p, DeserializationContext ctxt) throws IOException { JsonToken t = p.getCurrentToken();  <BUGS> DateTimeZone tz = _format.isTimezoneExplicit() ? _format.getTimeZone() : DateTimeZone.forTimeZone(ctxt.getTimeZone()); <BUGE>  if (t == JsonToken.VALUE_NUMBER_INT) { return new DateTime(p.getLongValue(), tz); } if (t == JsonToken.VALUE_STRING) { String str = p.getText().trim(); if (str.length() == 0) { /* [JACKSON-360]*/ return null; } /* 08-Jul-2015, tatu: as per [datatype-joda#44], optional TimeZone inclusion*/ /* NOTE: on/off feature only for serialization; on deser should accept both*/ int ix = str.indexOf('['); if (ix > 0) { int ix2 = str.lastIndexOf(']'); String tzId = (ix2 < ix) ? str.substring(ix+1) : str.substring(ix+1, ix2); try { tz = DateTimeZone.forID(tzId); } catch (IllegalArgumentException e) { throw ctxt.mappingException(String.format("Unknown DateTimeZone id '%s'", tzId)); } str = str.substring(0, ix);
@Override public ReadableDateTime deserialize(JsonParser p, DeserializationContext ctxt) throws IOException { JsonToken t = p.getCurrentToken();  DateTimeZone tz = _format.isTimezoneExplicit() ? _format.getTimeZone() : DateTimeZone.forTimeZone(ctxt.getTimeZone());  <BUGS> if (t == JsonToken.VALUE_NUMBER_INT) { <BUGE> return new DateTime(p.getLongValue(), tz); } if (t == JsonToken.VALUE_STRING) { String str = p.getText().trim(); if (str.length() == 0) { /* [JACKSON-360]*/ return null; } /* 08-Jul-2015, tatu: as per [datatype-joda#44], optional TimeZone inclusion*/ /* NOTE: on/off feature only for serialization; on deser should accept both*/ int ix = str.indexOf('['); if (ix > 0) { int ix2 = str.lastIndexOf(']'); String tzId = (ix2 < ix) ? str.substring(ix+1) : str.substring(ix+1, ix2); try { tz = DateTimeZone.forID(tzId); } catch (IllegalArgumentException e) { throw ctxt.mappingException(String.format("Unknown DateTimeZone id '%s'", tzId)); } str = str.substring(0, ix);
@Override public ReadableDateTime deserialize(JsonParser p, DeserializationContext ctxt) throws IOException { JsonToken t = p.getCurrentToken();  DateTimeZone tz = _format.isTimezoneExplicit() ? _format.getTimeZone() : DateTimeZone.forTimeZone(ctxt.getTimeZone());  if (t == JsonToken.VALUE_NUMBER_INT) { return new DateTime(p.getLongValue(), tz); } <BUGS> if (t == JsonToken.VALUE_STRING) { String str = p.getText().trim(); if (str.length() == 0) { /* [JACKSON-360] <BUGE>*/ return null; } /* 08-Jul-2015, tatu: as per [datatype-joda#44], optional TimeZone inclusion*/ /* NOTE: on/off feature only for serialization; on deser should accept both*/ int ix = str.indexOf('['); if (ix > 0) { int ix2 = str.lastIndexOf(']'); String tzId = (ix2 < ix) ? str.substring(ix+1) : str.substring(ix+1, ix2); try { tz = DateTimeZone.forID(tzId); } catch (IllegalArgumentException e) { throw ctxt.mappingException(String.format("Unknown DateTimeZone id '%s'", tzId)); } str = str.substring(0, ix);
@Override public ReadableDateTime deserialize(JsonParser p, DeserializationContext ctxt) throws IOException { JsonToken t = p.getCurrentToken();  DateTimeZone tz = _format.isTimezoneExplicit() ? _format.getTimeZone() : DateTimeZone.forTimeZone(ctxt.getTimeZone());  if (t == JsonToken.VALUE_NUMBER_INT) { return new DateTime(p.getLongValue(), tz); } if (t == JsonToken.VALUE_STRING) { String str = p.getText().trim(); if (str.length() == 0) { /* [JACKSON-360]*/ return null; } /* 08-Jul-2015, tatu: as per [datatype-joda#44], optional TimeZone inclusion*/ /* NOTE: on/off feature only for serialization; on deser should accept both*/ <BUGS> int ix = str.indexOf('['); if (ix > 0) { <BUGE> int ix2 = str.lastIndexOf(']'); String tzId = (ix2 < ix) ? str.substring(ix+1) : str.substring(ix+1, ix2); try { tz = DateTimeZone.forID(tzId); } catch (IllegalArgumentException e) { throw ctxt.mappingException(String.format("Unknown DateTimeZone id '%s'", tzId)); } str = str.substring(0, ix);
}  @SuppressWarnings("unchecked") public static <T extends ReadableInstant> JsonDeserializer<T> forType(Class<T> cls) { return (JsonDeserializer<T>) new DateTimeDeserializer(cls, FormatConfig.DEFAULT_DATETIME_FORMAT); }  @Override public JodaDateDeserializerBase<?> withFormat(JacksonJodaDateFormat format) { return new DateTimeDeserializer(_valueClass, format); }  /* Not sure if it should use timezone or not...*/ <BUGS> return _format.createParser(ctxt).parseDateTime(str); <BUGE> } throw ctxt.mappingException(handledType()); } }
@Override public LocalDate deserialize(JsonParser parser, DeserializationContext context) throws IOException { <BUGS> switch(parser.getCurrentTokenId()) <BUGE> { case JsonTokenId.ID_START_ARRAY: if(parser.nextToken() == JsonToken.END_ARRAY) { return null; } int year = parser.getIntValue();  parser.nextToken(); int month = parser.getIntValue();  parser.nextToken(); int day = parser.getIntValue();  if (parser.nextToken() != JsonToken.END_ARRAY) { throw context.wrongTokenException(parser, JsonToken.END_ARRAY, "Expected array to end."); } return LocalDate.of(year, month, day);  case JsonTokenId.ID_STRING: String string = parser.getText().trim(); if(string.length() == 0) { return null; }   return LocalDate.parse(string, _formatter);
@Override public LocalDate deserialize(JsonParser parser, DeserializationContext context) throws IOException { switch(parser.getCurrentTokenId()) { case JsonTokenId.ID_START_ARRAY: if(parser.nextToken() == JsonToken.END_ARRAY) { return null; } int year = parser.getIntValue();  parser.nextToken(); int month = parser.getIntValue();  parser.nextToken(); int day = parser.getIntValue();  if (parser.nextToken() != JsonToken.END_ARRAY) { throw context.wrongTokenException(parser, JsonToken.END_ARRAY, "Expected array to end."); } return LocalDate.of(year, month, day);  case JsonTokenId.ID_STRING: <BUGS> String string = parser.getText().trim(); if(string.length() == 0) { <BUGE> return null; }   return LocalDate.parse(string, _formatter);
@Override public LocalDate deserialize(JsonParser parser, DeserializationContext context) throws IOException { switch(parser.getCurrentTokenId()) { case JsonTokenId.ID_START_ARRAY: if(parser.nextToken() == JsonToken.END_ARRAY) { return null; } int year = parser.getIntValue();  parser.nextToken(); int month = parser.getIntValue();  parser.nextToken(); int day = parser.getIntValue();  if (parser.nextToken() != JsonToken.END_ARRAY) { throw context.wrongTokenException(parser, JsonToken.END_ARRAY, "Expected array to end."); } return LocalDate.of(year, month, day);  case JsonTokenId.ID_STRING: String string = parser.getText().trim(); if(string.length() == 0) { return null; }   <BUGS> return LocalDate.parse(string, _formatter); <BUGE>
@Override public void serialize(T value, JsonGenerator generator, SerializerProvider provider) throws IOException { <BUGS> if (useTimestamp(provider)) { <BUGE> if (provider.isEnabled(SerializationFeature.WRITE_DATE_TIMESTAMPS_AS_NANOSECONDS)) { generator.writeNumber(DecimalUtils.toDecimal( getEpochSeconds.applyAsLong(value), getNanoseconds.applyAsInt(value) )); } else { generator.writeNumber(getEpochMillis.applyAsLong(value)); } } else { String str;  if (_formatter != null) { str = _formatter.format(value);; } else if (defaultFormat != null) { str = defaultFormat.format(value);; } else { str = value.toString(); } generator.writeString(str); } }
@Override public void serialize(T value, JsonGenerator generator, SerializerProvider provider) throws IOException { if (useTimestamp(provider)) { if (provider.isEnabled(SerializationFeature.WRITE_DATE_TIMESTAMPS_AS_NANOSECONDS)) { generator.writeNumber(DecimalUtils.toDecimal( getEpochSeconds.applyAsLong(value), getNanoseconds.applyAsInt(value) )); } else { generator.writeNumber(getEpochMillis.applyAsLong(value)); } } else { String str;  <BUGS> if (_formatter != null) { <BUGE> str = _formatter.format(value);; } else if (defaultFormat != null) { str = defaultFormat.format(value);; } else { str = value.toString(); } generator.writeString(str); } }
@Override public void serialize(T value, JsonGenerator generator, SerializerProvider provider) throws IOException { if (useTimestamp(provider)) { if (provider.isEnabled(SerializationFeature.WRITE_DATE_TIMESTAMPS_AS_NANOSECONDS)) { generator.writeNumber(DecimalUtils.toDecimal( getEpochSeconds.applyAsLong(value), getNanoseconds.applyAsInt(value) )); } else { generator.writeNumber(getEpochMillis.applyAsLong(value)); } } else { String str;  if (_formatter != null) { str = _formatter.format(value);; <BUGS> } else if (defaultFormat != null) { str = defaultFormat.format(value);; <BUGE> } else { str = value.toString(); } generator.writeString(str); } }
@Override public void serialize(T value, JsonGenerator generator, SerializerProvider provider) throws IOException { if (useTimestamp(provider)) { if (provider.isEnabled(SerializationFeature.WRITE_DATE_TIMESTAMPS_AS_NANOSECONDS)) { generator.writeNumber(DecimalUtils.toDecimal( getEpochSeconds.applyAsLong(value), getNanoseconds.applyAsInt(value) )); } else { generator.writeNumber(getEpochMillis.applyAsLong(value)); } } else { String str;  if (_formatter != null) { str = _formatter.format(value);; } else if (defaultFormat != null) { str = defaultFormat.format(value);; } else { str = value.toString(); } <BUGS> generator.writeString(str); <BUGE> } }
@Override public void serialize(T value, JsonGenerator generator, SerializerProvider provider) throws IOException { if (useTimestamp(provider)) { if (provider.isEnabled(SerializationFeature.WRITE_DATE_TIMESTAMPS_AS_NANOSECONDS)) { generator.writeNumber(DecimalUtils.toDecimal( getEpochSeconds.applyAsLong(value), getNanoseconds.applyAsInt(value) )); } else { generator.writeNumber(getEpochMillis.applyAsLong(value)); } } else { String str;  if (_formatter != null) { str = _formatter.format(value);; } else if (defaultFormat != null) { str = defaultFormat.format(value);; } else { str = value.toString(); } generator.writeString(str); } <BUGS> } <BUGE>
@Override public LocalDate deserialize(JsonParser parser, DeserializationContext context) throws IOException { <BUGS> if (parser.hasToken(JsonToken.VALUE_STRING)) { String string = parser.getText().trim(); if (string.length() == 0) { <BUGE> return null; } /* as per [datatype-jsr310#37], only check for optional (and, incorrect...) time marker 'T'*/ /* if we are using default formatter*/ DateTimeFormatter format = _formatter; if (format == DEFAULT_FORMATTER) { /* JavaScript by default includes time in JSON serialized Dates (UTC/ISO instant format).*/ if (string.contains("T")) { return LocalDate.parse(string, DateTimeFormatter.ISO_LOCAL_DATE_TIME); } } return LocalDate.parse(string, format); } if (parser.isExpectedStartArrayToken()) { if (parser.nextToken() == JsonToken.END_ARRAY) { return null; } int year = parser.getIntValue();  parser.nextToken(); int month = parser.getIntValue();  parser.nextToken(); int day = parser.getIntValue();
@Override public LocalDate deserialize(JsonParser parser, DeserializationContext context) throws IOException { if (parser.hasToken(JsonToken.VALUE_STRING)) { String string = parser.getText().trim(); if (string.length() == 0) { return null; } /* as per [datatype-jsr310#37], only check for optional (and, incorrect...) time marker 'T'*/ /* if we are using default formatter*/ <BUGS> DateTimeFormatter format = _formatter; if (format == DEFAULT_FORMATTER) { <BUGE> /* JavaScript by default includes time in JSON serialized Dates (UTC/ISO instant format).*/ if (string.contains("T")) { return LocalDate.parse(string, DateTimeFormatter.ISO_LOCAL_DATE_TIME); } } return LocalDate.parse(string, format); } if (parser.isExpectedStartArrayToken()) { if (parser.nextToken() == JsonToken.END_ARRAY) { return null; } int year = parser.getIntValue();  parser.nextToken(); int month = parser.getIntValue();  parser.nextToken(); int day = parser.getIntValue();
@Override public LocalDate deserialize(JsonParser parser, DeserializationContext context) throws IOException { if (parser.hasToken(JsonToken.VALUE_STRING)) { String string = parser.getText().trim(); if (string.length() == 0) { return null; } /* as per [datatype-jsr310#37], only check for optional (and, incorrect...) time marker 'T'*/ /* if we are using default formatter*/ DateTimeFormatter format = _formatter; if (format == DEFAULT_FORMATTER) { /* JavaScript by default includes time in JSON serialized Dates (UTC/ISO instant format).*/ <BUGS> if (string.contains("T")) { return LocalDate.parse(string, DateTimeFormatter.ISO_LOCAL_DATE_TIME); <BUGE> } } return LocalDate.parse(string, format); } if (parser.isExpectedStartArrayToken()) { if (parser.nextToken() == JsonToken.END_ARRAY) { return null; } int year = parser.getIntValue();  parser.nextToken(); int month = parser.getIntValue();  parser.nextToken(); int day = parser.getIntValue();
protected InstantSerializer(InstantSerializer base, Boolean useTimestamp, DateTimeFormatter formatter) { <BUGS> super(base, useTimestamp, formatter); } <BUGE>
@Override public void resolve(DeserializationContext ctxt) throws JsonMappingException { <BUGS> super.resolve(ctxt); <BUGE> /* Ok, now; need to find actual property instances to go with order * defined based on property names. */ /* 20-Sep-2014, tatu: As per [Afterburner#43], use of `JsonTypeInfo.As.EXTERNAL_PROPERTY` *   will "hide" matching property, leading to no match below. *   But since we don't use optimized path if that case, let's just bail out. */ /* should we assign empty array or... ?*/  int len = _orderedPropertyNames.length; ArrayList<SettableBeanProperty> props = new ArrayList<SettableBeanProperty>(len); int i = 0;  for (; i < len; ++i) { SettableBeanProperty prop = _beanProperties.find(_orderedPropertyNames[i].toString()); if (prop == null) { break; } props.add(prop); } /* should usually get at least one property; let's for now consider it an error if not*/ /* (may need to revisit in future)*/ if (i == 0) { throw new IllegalStateException("Afterburner internal error: BeanDeserializer for " +_beanType+" has no properties that match expected ordering -- can not create optimized deserializer");
@Override public void resolve(DeserializationContext ctxt) throws JsonMappingException { super.resolve(ctxt); /* Ok, now; need to find actual property instances to go with order * defined based on property names. */ /* 20-Sep-2014, tatu: As per [Afterburner#43], use of `JsonTypeInfo.As.EXTERNAL_PROPERTY` *   will "hide" matching property, leading to no match below. *   But since we don't use optimized path if that case, let's just bail out. */ /* should we assign empty array or... ?*/  <BUGS> int len = _orderedPropertyNames.length; ArrayList<SettableBeanProperty> props = new ArrayList<SettableBeanProperty>(len); int i = 0; <BUGE>  for (; i < len; ++i) { SettableBeanProperty prop = _beanProperties.find(_orderedPropertyNames[i].toString()); if (prop == null) { break; } props.add(prop); } /* should usually get at least one property; let's for now consider it an error if not*/ /* (may need to revisit in future)*/ if (i == 0) { throw new IllegalStateException("Afterburner internal error: BeanDeserializer for " +_beanType+" has no properties that match expected ordering -- can not create optimized deserializer");
@Override public void resolve(DeserializationContext ctxt) throws JsonMappingException { super.resolve(ctxt); /* Ok, now; need to find actual property instances to go with order * defined based on property names. */ /* 20-Sep-2014, tatu: As per [Afterburner#43], use of `JsonTypeInfo.As.EXTERNAL_PROPERTY` *   will "hide" matching property, leading to no match below. *   But since we don't use optimized path if that case, let's just bail out. */ /* should we assign empty array or... ?*/  int len = _orderedPropertyNames.length; ArrayList<SettableBeanProperty> props = new ArrayList<SettableBeanProperty>(len); int i = 0;  <BUGS> for (; i < len; ++i) { SettableBeanProperty prop = _beanProperties.find(_orderedPropertyNames[i].toString()); if (prop == null) { break; <BUGE> } props.add(prop); } /* should usually get at least one property; let's for now consider it an error if not*/ /* (may need to revisit in future)*/ if (i == 0) { throw new IllegalStateException("Afterburner internal error: BeanDeserializer for " +_beanType+" has no properties that match expected ordering -- can not create optimized deserializer");
@Override public void resolve(DeserializationContext ctxt) throws JsonMappingException { super.resolve(ctxt); /* Ok, now; need to find actual property instances to go with order * defined based on property names. */ /* 20-Sep-2014, tatu: As per [Afterburner#43], use of `JsonTypeInfo.As.EXTERNAL_PROPERTY` *   will "hide" matching property, leading to no match below. *   But since we don't use optimized path if that case, let's just bail out. */ /* should we assign empty array or... ?*/  int len = _orderedPropertyNames.length; ArrayList<SettableBeanProperty> props = new ArrayList<SettableBeanProperty>(len); int i = 0;  for (; i < len; ++i) { SettableBeanProperty prop = _beanProperties.find(_orderedPropertyNames[i].toString()); if (prop == null) { break; } props.add(prop); } /* should usually get at least one property; let's for now consider it an error if not*/ /* (may need to revisit in future)*/ <BUGS> if (i == 0) { throw new IllegalStateException("Afterburner internal error: BeanDeserializer for " <BUGE> +_beanType+" has no properties that match expected ordering -- can not create optimized deserializer");
@Override public final void serializeAsField(Object bean, JsonGenerator gen, SerializerProvider prov) throws Exception { <BUGS> if (broken) { <BUGE> fallbackWriter.serializeAsField(bean, gen, prov); return; } String value; try { value = _propertyAccessor.stringField(bean, _propertyIndex); } catch (Throwable t) { _handleProblem(bean, gen, prov, t, false); return; } /* Null (etc) handling; copied from super-class impl*/ if (value == null) { if (!_suppressNulls) { gen.writeFieldName(_fastName); prov.defaultSerializeNull(gen); } return; } if (_suppressableValue != null) { if (MARKER_FOR_EMPTY == _suppressableValue) { if (value.length() == 0) { return; } } else if (_suppressableValue.equals(value)) { return; }
@Override public final void serializeAsField(Object bean, JsonGenerator gen, SerializerProvider prov) throws Exception { if (broken) { fallbackWriter.serializeAsField(bean, gen, prov); return; } String value; try { <BUGS> value = _propertyAccessor.stringField(bean, _propertyIndex); <BUGE> } catch (Throwable t) { _handleProblem(bean, gen, prov, t, false); return; } /* Null (etc) handling; copied from super-class impl*/ if (value == null) { if (!_suppressNulls) { gen.writeFieldName(_fastName); prov.defaultSerializeNull(gen); } return; } if (_suppressableValue != null) { if (MARKER_FOR_EMPTY == _suppressableValue) { if (value.length() == 0) { return; } } else if (_suppressableValue.equals(value)) { return; }
@Override public final void serializeAsField(Object bean, JsonGenerator gen, SerializerProvider prov) throws Exception { if (broken) { fallbackWriter.serializeAsField(bean, gen, prov); return; } String value; try { value = _propertyAccessor.stringField(bean, _propertyIndex); } catch (Throwable t) { _handleProblem(bean, gen, prov, t, false); return; <BUGS> } <BUGE> /* Null (etc) handling; copied from super-class impl*/ if (value == null) { if (!_suppressNulls) { gen.writeFieldName(_fastName); prov.defaultSerializeNull(gen); } return; } if (_suppressableValue != null) { if (MARKER_FOR_EMPTY == _suppressableValue) { if (value.length() == 0) { return; } } else if (_suppressableValue.equals(value)) { return; }
@Override public final void serializeAsField(Object bean, JsonGenerator gen, SerializerProvider prov) throws Exception { if (broken) { fallbackWriter.serializeAsField(bean, gen, prov); return; } String value; try { value = _propertyAccessor.stringField(bean, _propertyIndex); } catch (Throwable t) { _handleProblem(bean, gen, prov, t, false); return; } /* Null (etc) handling; copied from super-class impl*/ <BUGS> if (value == null) { if (!_suppressNulls) { <BUGE> gen.writeFieldName(_fastName); prov.defaultSerializeNull(gen); } return; } if (_suppressableValue != null) { if (MARKER_FOR_EMPTY == _suppressableValue) { if (value.length() == 0) { return; } } else if (_suppressableValue.equals(value)) { return; }
@Override public final void serializeAsField(Object bean, JsonGenerator gen, SerializerProvider prov) throws Exception { if (broken) { fallbackWriter.serializeAsField(bean, gen, prov); return; } String value; try { value = _propertyAccessor.stringField(bean, _propertyIndex); } catch (Throwable t) { _handleProblem(bean, gen, prov, t, false); return; } /* Null (etc) handling; copied from super-class impl*/ if (value == null) { if (!_suppressNulls) { gen.writeFieldName(_fastName); prov.defaultSerializeNull(gen); } <BUGS> return; <BUGE> } if (_suppressableValue != null) { if (MARKER_FOR_EMPTY == _suppressableValue) { if (value.length() == 0) { return; } } else if (_suppressableValue.equals(value)) { return; }
protected PropertyAccessorCollector findProperties(Class<?> beanClass, SerializationConfig config, List<BeanPropertyWriter> beanProperties) { <BUGS> PropertyAccessorCollector collector = new PropertyAccessorCollector(beanClass); ListIterator<BeanPropertyWriter> it = beanProperties.listIterator(); while (it.hasNext()) { BeanPropertyWriter bpw = it.next(); Class<?> type = bpw.getPropertyType(); AnnotatedMember member = bpw.getMember(); <BUGE>  /* 11-Sep-2015, tatu: Let's skip virtual members (related to #57)*/ /* We can't access private fields or methods, skip:*/ if (Modifier.isPrivate(member.getMember().getModifiers())) { continue; } /* (although, interestingly enough, can seem to access private classes...)*/  /* 30-Jul-2012, tatu: [Issue-6]: Needs to skip custom serializers, if any.*/ if (bpw.hasSerializer()) { if (!isDefaultSerializer(config, bpw.getSerializer())) { continue; } } /* [#9]: also skip unwrapping stuff...*/ if (bpw.isUnwrapping()) { continue; } /* [#51]: and any sub-classes as well*/ /* 04-Mar-2015, tatu: This might be too restrictive, as core databind has some
protected PropertyAccessorCollector findProperties(Class<?> beanClass, SerializationConfig config, List<BeanPropertyWriter> beanProperties) { PropertyAccessorCollector collector = new PropertyAccessorCollector(beanClass); ListIterator<BeanPropertyWriter> it = beanProperties.listIterator(); while (it.hasNext()) { BeanPropertyWriter bpw = it.next(); Class<?> type = bpw.getPropertyType(); AnnotatedMember member = bpw.getMember();  /* 11-Sep-2015, tatu: Let's skip virtual members (related to #57)*/ /* We can't access private fields or methods, skip:*/ <BUGS> if (Modifier.isPrivate(member.getMember().getModifiers())) { <BUGE> continue; } /* (although, interestingly enough, can seem to access private classes...)*/  /* 30-Jul-2012, tatu: [Issue-6]: Needs to skip custom serializers, if any.*/ if (bpw.hasSerializer()) { if (!isDefaultSerializer(config, bpw.getSerializer())) { continue; } } /* [#9]: also skip unwrapping stuff...*/ if (bpw.isUnwrapping()) { continue; } /* [#51]: and any sub-classes as well*/ /* 04-Mar-2015, tatu: This might be too restrictive, as core databind has some
protected PropertyAccessorCollector findProperties(Class<?> beanClass, SerializationConfig config, List<BeanPropertyWriter> beanProperties) { PropertyAccessorCollector collector = new PropertyAccessorCollector(beanClass); ListIterator<BeanPropertyWriter> it = beanProperties.listIterator(); while (it.hasNext()) { BeanPropertyWriter bpw = it.next(); Class<?> type = bpw.getPropertyType(); AnnotatedMember member = bpw.getMember();  /* 11-Sep-2015, tatu: Let's skip virtual members (related to #57)*/ /* We can't access private fields or methods, skip:*/ if (Modifier.isPrivate(member.getMember().getModifiers())) { continue; } /* (although, interestingly enough, can seem to access private classes...)*/  /* 30-Jul-2012, tatu: [Issue-6]: Needs to skip custom serializers, if any.*/ <BUGS> if (bpw.hasSerializer()) { <BUGE> if (!isDefaultSerializer(config, bpw.getSerializer())) { continue; } } /* [#9]: also skip unwrapping stuff...*/ if (bpw.isUnwrapping()) { continue; } /* [#51]: and any sub-classes as well*/ /* 04-Mar-2015, tatu: This might be too restrictive, as core databind has some
protected PropertyAccessorCollector findProperties(Class<?> beanClass, SerializationConfig config, List<BeanPropertyWriter> beanProperties) { PropertyAccessorCollector collector = new PropertyAccessorCollector(beanClass); ListIterator<BeanPropertyWriter> it = beanProperties.listIterator(); while (it.hasNext()) { BeanPropertyWriter bpw = it.next(); Class<?> type = bpw.getPropertyType(); AnnotatedMember member = bpw.getMember();  /* 11-Sep-2015, tatu: Let's skip virtual members (related to #57)*/ /* We can't access private fields or methods, skip:*/ if (Modifier.isPrivate(member.getMember().getModifiers())) { continue; } /* (although, interestingly enough, can seem to access private classes...)*/  /* 30-Jul-2012, tatu: [Issue-6]: Needs to skip custom serializers, if any.*/ if (bpw.hasSerializer()) { if (!isDefaultSerializer(config, bpw.getSerializer())) { continue; } } /* [#9]: also skip unwrapping stuff...*/ <BUGS> if (bpw.isUnwrapping()) { <BUGE> continue; } /* [#51]: and any sub-classes as well*/ /* 04-Mar-2015, tatu: This might be too restrictive, as core databind has some
/* and then link accessors to bean property writers:*/ ListIterator<BeanPropertyWriter> it = beanProperties.listIterator(); while (it.hasNext()) { BeanPropertyWriter bpw = it.next(); if (bpw instanceof OptimizedBeanPropertyWriter<?>) { if (acc == null) { acc = collector.findAccessor(_classLoader); } it.set(((OptimizedBeanPropertyWriter<?>) bpw).withAccessor(acc)); } } return beanProperties; } */ <BUGS> if (bpw.getClass() != BeanPropertyWriter.class) { <BUGE> continue; }  boolean isMethod = (member instanceof AnnotatedMethod); if (type.isPrimitive()) { if (type == Integer.TYPE) {  if (isMethod) { it.set(collector.addIntGetter(bpw)); } else { it.set(collector.addIntField(bpw)); } } else if (type == Long.TYPE) { if (isMethod) {
/* and then link accessors to bean property writers:*/ ListIterator<BeanPropertyWriter> it = beanProperties.listIterator(); while (it.hasNext()) { BeanPropertyWriter bpw = it.next(); if (bpw instanceof OptimizedBeanPropertyWriter<?>) { if (acc == null) { acc = collector.findAccessor(_classLoader); } it.set(((OptimizedBeanPropertyWriter<?>) bpw).withAccessor(acc)); } } return beanProperties; }  <BUGS> boolean isMethod = (member instanceof AnnotatedMethod); if (type.isPrimitive()) { <BUGE> if (type == Integer.TYPE) {  if (isMethod) { it.set(collector.addIntGetter(bpw)); } else { it.set(collector.addIntField(bpw)); } } else if (type == Long.TYPE) { if (isMethod) { it.set(collector.addLongGetter(bpw)); } else { it.set(collector.addLongField(bpw)); }
/* and then link accessors to bean property writers:*/ ListIterator<BeanPropertyWriter> it = beanProperties.listIterator(); while (it.hasNext()) { BeanPropertyWriter bpw = it.next(); if (bpw instanceof OptimizedBeanPropertyWriter<?>) { if (acc == null) { acc = collector.findAccessor(_classLoader); } it.set(((OptimizedBeanPropertyWriter<?>) bpw).withAccessor(acc)); } } return beanProperties; } } else { <BUGS> if (type == String.class) { if (isMethod) { <BUGE> it.set(collector.addStringGetter(bpw)); } else { it.set(collector.addStringField(bpw)); } } else { /* any other Object types; we can at least call accessor*/ if (isMethod) { it.set(collector.addObjectGetter(bpw)); } else { it.set(collector.addObjectField(bpw)); } } } }
/* and then link accessors to bean property writers:*/ ListIterator<BeanPropertyWriter> it = beanProperties.listIterator(); while (it.hasNext()) { BeanPropertyWriter bpw = it.next(); if (bpw instanceof OptimizedBeanPropertyWriter<?>) { if (acc == null) { acc = collector.findAccessor(_classLoader); } it.set(((OptimizedBeanPropertyWriter<?>) bpw).withAccessor(acc)); } } return beanProperties; } } else { <BUGS> it.set(collector.addStringField(bpw)); <BUGE> } } else { /* any other Object types; we can at least call accessor*/ if (isMethod) { it.set(collector.addObjectGetter(bpw)); } else { it.set(collector.addObjectField(bpw)); } } } } return collector; }  /**
/* and then link accessors to bean property writers:*/ ListIterator<BeanPropertyWriter> it = beanProperties.listIterator(); while (it.hasNext()) { BeanPropertyWriter bpw = it.next(); if (bpw instanceof OptimizedBeanPropertyWriter<?>) { if (acc == null) { acc = collector.findAccessor(_classLoader); } it.set(((OptimizedBeanPropertyWriter<?>) bpw).withAccessor(acc)); } } return beanProperties; } } <BUGS> } <BUGE> return collector; }  /** * Helper method used to check whether given serializer is the default * serializer implementation: this is necessary to avoid overriding other * kinds of serializers. */ protected boolean isDefaultSerializer(SerializationConfig config, JsonSerializer<?> ser) { return ClassUtil.isJacksonStdImpl(ser); } }
public static boolean convertToBoolean(String prop, Object value) { <BUGS> if (value == null) { <BUGE> return false; } if (value instanceof Boolean) { return ((Boolean) value).booleanValue(); } if (value instanceof String) { String str = (String) value; if (str.equalsIgnoreCase("false")) { return false; } if (str.equalsIgnoreCase("true")) { return true; } throw new IllegalArgumentException("Invalid String value for property '"+prop+"': expected Boolean value."); } throw new IllegalArgumentException("Invalid value type ("+value.getClass()+") for property '"+prop+"': expected Boolean value."); }
public static boolean convertToBoolean(String prop, Object value) { if (value == null) { return false; } <BUGS> if (value instanceof Boolean) { return ((Boolean) value).booleanValue(); <BUGE> } if (value instanceof String) { String str = (String) value; if (str.equalsIgnoreCase("false")) { return false; } if (str.equalsIgnoreCase("true")) { return true; } throw new IllegalArgumentException("Invalid String value for property '"+prop+"': expected Boolean value."); } throw new IllegalArgumentException("Invalid value type ("+value.getClass()+") for property '"+prop+"': expected Boolean value."); }
@Override public XMLStreamReader createXMLStreamReader(Reader r) throws XMLStreamException { /* false for auto-close, since caller has access to the reader*/ <BUGS> return createSR(null, r, false, false); <BUGE> }
@SuppressWarnings("resource") private XMLStreamWriter2 createSW(Result res) throws XMLStreamException { <BUGS> OutputStream out = null; Writer w = null; String encoding = null; <BUGE> boolean requireAutoClose; String sysId = null;  if (res instanceof Stax2Result) { Stax2Result sr = (Stax2Result) res; try { out = sr.constructOutputStream(); if (out == null) { w = sr.constructWriter(); } } catch (IOException ioe) { throw new WstxIOException(ioe); } /* yes, it's required since caller has no access to stream/writer:*/ requireAutoClose = true; } else if (res instanceof StreamResult) { StreamResult sr = (StreamResult) res; out = sr.getOutputStream(); sysId = sr.getSystemId(); if (out == null) { w = sr.getWriter(); } /* Caller owns it, only auto-close if requested to do so:
@SuppressWarnings("resource") private XMLStreamWriter2 createSW(Result res) throws XMLStreamException { OutputStream out = null; Writer w = null; String encoding = null; boolean requireAutoClose; <BUGS> String sysId = null; <BUGE>  if (res instanceof Stax2Result) { Stax2Result sr = (Stax2Result) res; try { out = sr.constructOutputStream(); if (out == null) { w = sr.constructWriter(); } } catch (IOException ioe) { throw new WstxIOException(ioe); } /* yes, it's required since caller has no access to stream/writer:*/ requireAutoClose = true; } else if (res instanceof StreamResult) { StreamResult sr = (StreamResult) res; out = sr.getOutputStream(); sysId = sr.getSystemId(); if (out == null) { w = sr.getWriter(); } /* Caller owns it, only auto-close if requested to do so:
@SuppressWarnings("resource") private XMLStreamWriter2 createSW(Result res) throws XMLStreamException { OutputStream out = null; Writer w = null; String encoding = null; boolean requireAutoClose; String sysId = null;  <BUGS> if (res instanceof Stax2Result) { <BUGE> Stax2Result sr = (Stax2Result) res; try { out = sr.constructOutputStream(); if (out == null) { w = sr.constructWriter(); } } catch (IOException ioe) { throw new WstxIOException(ioe); } /* yes, it's required since caller has no access to stream/writer:*/ requireAutoClose = true; } else if (res instanceof StreamResult) { StreamResult sr = (StreamResult) res; out = sr.getOutputStream(); sysId = sr.getSystemId(); if (out == null) { w = sr.getWriter(); } /* Caller owns it, only auto-close if requested to do so:
@SuppressWarnings("resource") private XMLStreamWriter2 createSW(Result res) throws XMLStreamException { OutputStream out = null; Writer w = null; String encoding = null; boolean requireAutoClose; String sysId = null;  if (res instanceof Stax2Result) { Stax2Result sr = (Stax2Result) res; try { out = sr.constructOutputStream(); if (out == null) { w = sr.constructWriter(); } } catch (IOException ioe) { throw new WstxIOException(ioe); } /* yes, it's required since caller has no access to stream/writer:*/ requireAutoClose = true; <BUGS> } else if (res instanceof StreamResult) { <BUGE> StreamResult sr = (StreamResult) res; out = sr.getOutputStream(); sysId = sr.getSystemId(); if (out == null) { w = sr.getWriter(); } /* Caller owns it, only auto-close if requested to do so:
/** * Called by {code createSW(OutputStream, Writer, String, boolean)} after all of the * necessary configuration logic is complete. */ protected XMLStreamWriter2 createSW(String enc, WriterConfig cfg, XmlWriter xw) { if (cfg.willSupportNamespaces()) { if (cfg.automaticNamespacesEnabled()) { return new RepairingNsStreamWriter(xw, enc, cfg); } return new SimpleNsStreamWriter(xw, enc, cfg); } return new NonNsStreamWriter(xw, enc, cfg); }  requireAutoClose = false; <BUGS> } else if (res instanceof SAXResult) { <BUGE> SAXResult sr = (SAXResult) res; sysId = sr.getSystemId(); if (sysId == null || sysId.length() == 0) { throw new XMLStreamException("Can not create a stream writer for a SAXResult that does not have System Id (support for using SAX input source not implemented)"); } requireAutoClose = true; } else if (res instanceof DOMResult) { return WstxDOMWrappingWriter.createFrom(mConfig.createNonShared(), (DOMResult) res); } else { throw new IllegalArgumentException("Can not instantiate a writer for XML result type "+res.getClass()+" (unrecognized type)"); }  if (out != null) { return createSW(out, null, encoding, requireAutoClose);
/** * Called by {code createSW(OutputStream, Writer, String, boolean)} after all of the * necessary configuration logic is complete. */ protected XMLStreamWriter2 createSW(String enc, WriterConfig cfg, XmlWriter xw) { if (cfg.willSupportNamespaces()) { if (cfg.automaticNamespacesEnabled()) { return new RepairingNsStreamWriter(xw, enc, cfg); } return new SimpleNsStreamWriter(xw, enc, cfg); } return new NonNsStreamWriter(xw, enc, cfg); }  requireAutoClose = true; <BUGS> } else if (res instanceof DOMResult) { return WstxDOMWrappingWriter.createFrom(mConfig.createNonShared(), (DOMResult) res); <BUGE> } else { throw new IllegalArgumentException("Can not instantiate a writer for XML result type "+res.getClass()+" (unrecognized type)"); }  if (out != null) { return createSW(out, null, encoding, requireAutoClose); } if (w != null) { return createSW(null, w, encoding, requireAutoClose); } if (sysId != null && sysId.length() > 0) { /* 26-Dec-2008, TSa: If we must construct URL from system id, *   it means caller will not have access to resulting
@SuppressWarnings("resource") private XMLStreamWriter2 createSW(Result res) throws XMLStreamException { <BUGS> OutputStream out = null; Writer w = null; String encoding = null; <BUGE> boolean requireAutoClose; String sysId = null;  if (res instanceof Stax2Result) { Stax2Result sr = (Stax2Result) res; try { out = sr.constructOutputStream(); if (out == null) { w = sr.constructWriter(); } } catch (IOException ioe) { throw new WstxIOException(ioe); } /* yes, it's required since caller has no access to stream/writer:*/ requireAutoClose = true; } else if (res instanceof StreamResult) { StreamResult sr = (StreamResult) res; out = sr.getOutputStream(); sysId = sr.getSystemId(); if (out == null) { w = sr.getWriter(); } /* Caller owns it, only auto-close if requested to do so:
@SuppressWarnings("resource") private XMLStreamWriter2 createSW(Result res) throws XMLStreamException { OutputStream out = null; Writer w = null; String encoding = null; boolean requireAutoClose; <BUGS> String sysId = null; <BUGE>  if (res instanceof Stax2Result) { Stax2Result sr = (Stax2Result) res; try { out = sr.constructOutputStream(); if (out == null) { w = sr.constructWriter(); } } catch (IOException ioe) { throw new WstxIOException(ioe); } /* yes, it's required since caller has no access to stream/writer:*/ requireAutoClose = true; } else if (res instanceof StreamResult) { StreamResult sr = (StreamResult) res; out = sr.getOutputStream(); sysId = sr.getSystemId(); if (out == null) { w = sr.getWriter(); } /* Caller owns it, only auto-close if requested to do so:
@SuppressWarnings("resource") private XMLStreamWriter2 createSW(Result res) throws XMLStreamException { OutputStream out = null; Writer w = null; String encoding = null; boolean requireAutoClose; String sysId = null;  <BUGS> if (res instanceof Stax2Result) { <BUGE> Stax2Result sr = (Stax2Result) res; try { out = sr.constructOutputStream(); if (out == null) { w = sr.constructWriter(); } } catch (IOException ioe) { throw new WstxIOException(ioe); } /* yes, it's required since caller has no access to stream/writer:*/ requireAutoClose = true; } else if (res instanceof StreamResult) { StreamResult sr = (StreamResult) res; out = sr.getOutputStream(); sysId = sr.getSystemId(); if (out == null) { w = sr.getWriter(); } /* Caller owns it, only auto-close if requested to do so:
@SuppressWarnings("resource") private XMLStreamWriter2 createSW(Result res) throws XMLStreamException { OutputStream out = null; Writer w = null; String encoding = null; boolean requireAutoClose; String sysId = null;  if (res instanceof Stax2Result) { Stax2Result sr = (Stax2Result) res; try { out = sr.constructOutputStream(); if (out == null) { w = sr.constructWriter(); } } catch (IOException ioe) { throw new WstxIOException(ioe); } /* yes, it's required since caller has no access to stream/writer:*/ requireAutoClose = true; <BUGS> } else if (res instanceof StreamResult) { <BUGE> StreamResult sr = (StreamResult) res; out = sr.getOutputStream(); sysId = sr.getSystemId(); if (out == null) { w = sr.getWriter(); } /* Caller owns it, only auto-close if requested to do so:
/** * Called by {code createSW(OutputStream, Writer, String, boolean)} after all of the * necessary configuration logic is complete. */ protected XMLStreamWriter2 createSW(String enc, WriterConfig cfg, XmlWriter xw) { if (cfg.willSupportNamespaces()) { if (cfg.automaticNamespacesEnabled()) { return new RepairingNsStreamWriter(xw, enc, cfg); } return new SimpleNsStreamWriter(xw, enc, cfg); } return new NonNsStreamWriter(xw, enc, cfg); }  requireAutoClose = false; <BUGS> } else if (res instanceof SAXResult) { <BUGE> SAXResult sr = (SAXResult) res; sysId = sr.getSystemId(); if (sysId == null || sysId.length() == 0) { throw new XMLStreamException("Can not create a stream writer for a SAXResult that does not have System Id (support for using SAX input source not implemented)"); } requireAutoClose = true; } else if (res instanceof DOMResult) { return WstxDOMWrappingWriter.createFrom(mConfig.createNonShared(), (DOMResult) res); } else { throw new IllegalArgumentException("Can not instantiate a writer for XML result type "+res.getClass()+" (unrecognized type)"); }  if (out != null) { return createSW(out, null, encoding, requireAutoClose);
/** * Called by {code createSW(OutputStream, Writer, String, boolean)} after all of the * necessary configuration logic is complete. */ protected XMLStreamWriter2 createSW(String enc, WriterConfig cfg, XmlWriter xw) { if (cfg.willSupportNamespaces()) { if (cfg.automaticNamespacesEnabled()) { return new RepairingNsStreamWriter(xw, enc, cfg); } return new SimpleNsStreamWriter(xw, enc, cfg); } return new NonNsStreamWriter(xw, enc, cfg); }  requireAutoClose = true; <BUGS> } else if (res instanceof DOMResult) { return WstxDOMWrappingWriter.createFrom(mConfig.createNonShared(), (DOMResult) res); <BUGE> } else { throw new IllegalArgumentException("Can not instantiate a writer for XML result type "+res.getClass()+" (unrecognized type)"); }  if (out != null) { return createSW(out, null, encoding, requireAutoClose); } if (w != null) { return createSW(null, w, encoding, requireAutoClose); } if (sysId != null && sysId.length() > 0) { /* 26-Dec-2008, TSa: If we must construct URL from system id, *   it means caller will not have access to resulting
*/ public static DotName createComponentized(DotName prefix, String localName) { <BUGS> if (localName.indexOf('.') != -1) <BUGE> throw new IllegalArgumentException("A componentized DotName can not contain '.' characters in a local name");  return new DotName(prefix, localName, true); }
*/ public static DotName createComponentized(DotName prefix, String localName) { if (localName.indexOf('.') != -1) throw new IllegalArgumentException("A componentized DotName can not contain '.' characters in a local name");  <BUGS> return new DotName(prefix, localName, true); <BUGE> }
*/ public static DotName createComponentized(DotName prefix, String localName) { <BUGS> if (localName.indexOf('.') != -1) <BUGE> throw new IllegalArgumentException("A componentized DotName can not contain '.' characters in a local name");  return new DotName(prefix, localName, true); }
*/ public static DotName createComponentized(DotName prefix, String localName) { if (localName.indexOf('.') != -1) throw new IllegalArgumentException("A componentized DotName can not contain '.' characters in a local name");  <BUGS> return new DotName(prefix, localName, true); <BUGE> }
*/ public final short flags() { <BUGS> return flags; <BUGE> }
*/ public final short flags() { <BUGS> return flags; <BUGE> }
*/ public static DotName createComponentized(DotName prefix, String localName, boolean innerClass) { <BUGS> if (localName.indexOf('.') != -1) <BUGE> throw new IllegalArgumentException("A componentized DotName can not contain '.' characters in a local name");  return new DotName(prefix, localName, true, innerClass); }
*/ public static DotName createComponentized(DotName prefix, String localName, boolean innerClass) { if (localName.indexOf('.') != -1) throw new IllegalArgumentException("A componentized DotName can not contain '.' characters in a local name");  <BUGS> return new DotName(prefix, localName, true, innerClass); <BUGE> }
public String getSourceSetter( OgnlContext context, Object target, Object index ) { try {  <BUGS> String methodName = index.toString().replaceAll( "\"", "" ); Method m = OgnlRuntime.getWriteMethod( target.getClass(), methodName ); <BUGE>  if ( m == null && context.getCurrentObject() != null && context.getCurrentObject().toString() != null ) { m = OgnlRuntime.getWriteMethod( target.getClass(), context.getCurrentObject().toString().replaceAll( "\"", "" ) ); }  if ( m == null || m.getParameterTypes() == null || m.getParameterTypes().length <= 0 ) throw new UnsupportedCompilationException( "Unable to determine setting expression on " + context.getCurrentObject() + " with index of " + index );  Class parm = m.getParameterTypes()[0]; String conversion;  if ( m.getParameterTypes().length > 1 ) throw new UnsupportedCompilationException( "Object property accessors can only support single parameter setters." );  if ( parm.isPrimitive() ) { Class wrapClass = OgnlRuntime.getPrimitiveWrapperClass( parm );
public String getSourceSetter( OgnlContext context, Object target, Object index ) { try {  String methodName = index.toString().replaceAll( "\"", "" ); Method m = OgnlRuntime.getWriteMethod( target.getClass(), methodName );  <BUGS> if ( m == null && context.getCurrentObject() != null && context.getCurrentObject().toString() != null ) <BUGE> { m = OgnlRuntime.getWriteMethod( target.getClass(), context.getCurrentObject().toString().replaceAll( "\"", "" ) ); }  if ( m == null || m.getParameterTypes() == null || m.getParameterTypes().length <= 0 ) throw new UnsupportedCompilationException( "Unable to determine setting expression on " + context.getCurrentObject() + " with index of " + index );  Class parm = m.getParameterTypes()[0]; String conversion;  if ( m.getParameterTypes().length > 1 ) throw new UnsupportedCompilationException( "Object property accessors can only support single parameter setters." );  if ( parm.isPrimitive() ) { Class wrapClass = OgnlRuntime.getPrimitiveWrapperClass( parm );
public String getSourceSetter( OgnlContext context, Object target, Object index ) { try {  String methodName = index.toString().replaceAll( "\"", "" ); Method m = OgnlRuntime.getWriteMethod( target.getClass(), methodName );  if ( m == null && context.getCurrentObject() != null && context.getCurrentObject().toString() != null ) { <BUGS> m = OgnlRuntime.getWriteMethod( target.getClass(), context.getCurrentObject().toString().replaceAll( "\"", "" ) ); <BUGE> }  if ( m == null || m.getParameterTypes() == null || m.getParameterTypes().length <= 0 ) throw new UnsupportedCompilationException( "Unable to determine setting expression on " + context.getCurrentObject() + " with index of " + index );  Class parm = m.getParameterTypes()[0]; String conversion;  if ( m.getParameterTypes().length > 1 ) throw new UnsupportedCompilationException( "Object property accessors can only support single parameter setters." );  if ( parm.isPrimitive() ) { Class wrapClass = OgnlRuntime.getPrimitiveWrapperClass( parm );
public String getSourceSetter( OgnlContext context, Object target, Object index ) { try {  String methodName = index.toString().replaceAll( "\"", "" ); Method m = OgnlRuntime.getWriteMethod( target.getClass(), methodName );  if ( m == null && context.getCurrentObject() != null && context.getCurrentObject().toString() != null ) { m = OgnlRuntime.getWriteMethod( target.getClass(), context.getCurrentObject().toString().replaceAll( "\"", "" ) ); }  <BUGS> if ( m == null || m.getParameterTypes() == null || m.getParameterTypes().length <= 0 ) throw new UnsupportedCompilationException( "Unable to determine setting expression on " + context.getCurrentObject() + " with index of " + index ); <BUGE>  Class parm = m.getParameterTypes()[0]; String conversion;  if ( m.getParameterTypes().length > 1 ) throw new UnsupportedCompilationException( "Object property accessors can only support single parameter setters." );  if ( parm.isPrimitive() ) { Class wrapClass = OgnlRuntime.getPrimitiveWrapperClass( parm );
public String getSourceSetter( OgnlContext context, Object target, Object index ) { try {  String methodName = index.toString().replaceAll( "\"", "" ); Method m = OgnlRuntime.getWriteMethod( target.getClass(), methodName );  if ( m == null && context.getCurrentObject() != null && context.getCurrentObject().toString() != null ) { m = OgnlRuntime.getWriteMethod( target.getClass(), context.getCurrentObject().toString().replaceAll( "\"", "" ) ); }  if ( m == null || m.getParameterTypes() == null || m.getParameterTypes().length <= 0 ) throw new UnsupportedCompilationException( "Unable to determine setting expression on " + context.getCurrentObject() + " with index of " + index );  <BUGS> Class parm = m.getParameterTypes()[0]; <BUGE> String conversion;  if ( m.getParameterTypes().length > 1 ) throw new UnsupportedCompilationException( "Object property accessors can only support single parameter setters." );  if ( parm.isPrimitive() ) { Class wrapClass = OgnlRuntime.getPrimitiveWrapperClass( parm );
public String getSourceSetter( OgnlContext context, Object target, Object index ) { try {  String methodName = index.toString().replaceAll( "\"", "" ); Method m = OgnlRuntime.getWriteMethod( target.getClass(), methodName );  if ( m == null && context.getCurrentObject() != null && context.getCurrentObject().toString() != null ) { m = OgnlRuntime.getWriteMethod( target.getClass(), context.getCurrentObject().toString().replaceAll( "\"", "" ) ); }  if ( m == null || m.getParameterTypes() == null || m.getParameterTypes().length <= 0 ) throw new UnsupportedCompilationException( "Unable to determine setting expression on " + context.getCurrentObject() + " with index of " + index );  Class parm = m.getParameterTypes()[0]; String conversion;  <BUGS> if ( m.getParameterTypes().length > 1 ) <BUGE> throw new UnsupportedCompilationException( "Object property accessors can only support single parameter setters." );  if ( parm.isPrimitive() ) { Class wrapClass = OgnlRuntime.getPrimitiveWrapperClass( parm );
public String getSourceSetter( OgnlContext context, Object target, Object index ) { try {  String methodName = index.toString().replaceAll( "\"", "" ); Method m = OgnlRuntime.getWriteMethod( target.getClass(), methodName );  if ( m == null && context.getCurrentObject() != null && context.getCurrentObject().toString() != null ) { m = OgnlRuntime.getWriteMethod( target.getClass(), context.getCurrentObject().toString().replaceAll( "\"", "" ) ); }  if ( m == null || m.getParameterTypes() == null || m.getParameterTypes().length <= 0 ) throw new UnsupportedCompilationException( "Unable to determine setting expression on " + context.getCurrentObject() + " with index of " + index );  Class parm = m.getParameterTypes()[0]; String conversion;  if ( m.getParameterTypes().length > 1 ) throw new UnsupportedCompilationException( "Object property accessors can only support single parameter setters." );  <BUGS> if ( parm.isPrimitive() ) <BUGE> { Class wrapClass = OgnlRuntime.getPrimitiveWrapperClass( parm );
public String getSourceSetter( OgnlContext context, Object target, Object index ) { try {  String methodName = index.toString().replaceAll( "\"", "" ); Method m = OgnlRuntime.getWriteMethod( target.getClass(), methodName );  if ( m == null && context.getCurrentObject() != null && context.getCurrentObject().toString() != null ) { m = OgnlRuntime.getWriteMethod( target.getClass(), context.getCurrentObject().toString().replaceAll( "\"", "" ) ); }  if ( m == null || m.getParameterTypes() == null || m.getParameterTypes().length <= 0 ) throw new UnsupportedCompilationException( "Unable to determine setting expression on " + context.getCurrentObject() + " with index of " + index );  Class parm = m.getParameterTypes()[0]; String conversion;  if ( m.getParameterTypes().length > 1 ) throw new UnsupportedCompilationException( "Object property accessors can only support single parameter setters." );  if ( parm.isPrimitive() ) { <BUGS> Class wrapClass = OgnlRuntime.getPrimitiveWrapperClass( parm ); <BUGE>
return ""; }  context.setCurrentType( m.getReturnType() ); context.setCurrentAccessor( OgnlRuntime.getCompiler().getSuperOrInterfaceClass( m, m.getDeclaringClass() ) );  return "." + m.getName() + "()";  } catch ( Throwable t ) { throw OgnlOps.castToRuntime( t ); } } conversion = <BUGS> OgnlRuntime.getCompiler().createLocalReference( context, <BUGE> "((" + wrapClass.getName() + ")org.apache.commons.ognl.OgnlOps#convertValue($3," + wrapClass.getName() + ".class, true))." + OgnlRuntime.getNumericValueGetter( wrapClass ), parm );  } else if ( parm.isArray() ) { conversion = OgnlRuntime.getCompiler().createLocalReference( context, "(" + ExpressionCompiler.getCastString( parm )
return ""; }  context.setCurrentType( m.getReturnType() ); context.setCurrentAccessor( OgnlRuntime.getCompiler().getSuperOrInterfaceClass( m, m.getDeclaringClass() ) );  return "." + m.getName() + "()";  } catch ( Throwable t ) { throw OgnlOps.castToRuntime( t ); } } "((" <BUGS> + wrapClass.getName() <BUGE> + ")org.apache.commons.ognl.OgnlOps#convertValue($3," + wrapClass.getName() + ".class, true))." + OgnlRuntime.getNumericValueGetter( wrapClass ), parm );  } else if ( parm.isArray() ) { conversion = OgnlRuntime.getCompiler().createLocalReference( context, "(" + ExpressionCompiler.getCastString( parm ) + ")org.apache.commons.ognl.OgnlOps#toArray($3," + parm.getComponentType().getName() + ".class)",
return ""; }  context.setCurrentType( m.getReturnType() ); context.setCurrentAccessor( OgnlRuntime.getCompiler().getSuperOrInterfaceClass( m, m.getDeclaringClass() ) );  return "." + m.getName() + "()";  } catch ( Throwable t ) { throw OgnlOps.castToRuntime( t ); } } + ")org.apache.commons.ognl.OgnlOps#convertValue($3," <BUGS> + wrapClass.getName() + ".class, true))." + OgnlRuntime.getNumericValueGetter( wrapClass ), <BUGE> parm );  } else if ( parm.isArray() ) { conversion = OgnlRuntime.getCompiler().createLocalReference( context, "(" + ExpressionCompiler.getCastString( parm ) + ")org.apache.commons.ognl.OgnlOps#toArray($3," + parm.getComponentType().getName() + ".class)", parm );
return ""; }  context.setCurrentType( m.getReturnType() ); context.setCurrentAccessor( OgnlRuntime.getCompiler().getSuperOrInterfaceClass( m, m.getDeclaringClass() ) );  return "." + m.getName() + "()";  } catch ( Throwable t ) { throw OgnlOps.castToRuntime( t ); } }  <BUGS> } else if ( parm.isArray() ) <BUGE> { conversion = OgnlRuntime.getCompiler().createLocalReference( context, "(" + ExpressionCompiler.getCastString( parm ) + ")org.apache.commons.ognl.OgnlOps#toArray($3," + parm.getComponentType().getName() + ".class)", parm );  } else { conversion =
return ""; }  context.setCurrentType( m.getReturnType() ); context.setCurrentAccessor( OgnlRuntime.getCompiler().getSuperOrInterfaceClass( m, m.getDeclaringClass() ) );  return "." + m.getName() + "()";  } catch ( Throwable t ) { throw OgnlOps.castToRuntime( t ); } } conversion = <BUGS> OgnlRuntime.getCompiler().createLocalReference( context, <BUGE> "(" + parm.getName() + ")org.apache.commons.ognl.OgnlOps#convertValue($3," + parm.getName() + ".class)", parm ); }  context.setCurrentType( m.getReturnType() ); context.setCurrentAccessor( OgnlRuntime.getCompiler().getSuperOrInterfaceClass( m, m.getDeclaringClass() ) );  return "." + m.getName() + "(" + conversion + ")";  } catch ( Throwable t ) {
return ""; }  context.setCurrentType( m.getReturnType() ); context.setCurrentAccessor( OgnlRuntime.getCompiler().getSuperOrInterfaceClass( m, m.getDeclaringClass() ) );  return "." + m.getName() + "()";  } catch ( Throwable t ) { throw OgnlOps.castToRuntime( t ); } } "(" <BUGS> + parm.getName() <BUGE> + ")org.apache.commons.ognl.OgnlOps#convertValue($3," + parm.getName() + ".class)", parm ); }  context.setCurrentType( m.getReturnType() ); context.setCurrentAccessor( OgnlRuntime.getCompiler().getSuperOrInterfaceClass( m, m.getDeclaringClass() ) );  return "." + m.getName() + "(" + conversion + ")";  } catch ( Throwable t ) { throw OgnlOps.castToRuntime( t ); }
return ""; }  context.setCurrentType( m.getReturnType() ); context.setCurrentAccessor( OgnlRuntime.getCompiler().getSuperOrInterfaceClass( m, m.getDeclaringClass() ) );  return "." + m.getName() + "()";  } catch ( Throwable t ) { throw OgnlOps.castToRuntime( t ); } } + ")org.apache.commons.ognl.OgnlOps#convertValue($3," <BUGS> + parm.getName() + ".class)", parm ); <BUGE> }  context.setCurrentType( m.getReturnType() ); context.setCurrentAccessor( OgnlRuntime.getCompiler().getSuperOrInterfaceClass( m, m.getDeclaringClass() ) );  return "." + m.getName() + "(" + conversion + ")";  } catch ( Throwable t ) { throw OgnlOps.castToRuntime( t ); } } }
return ""; }  context.setCurrentType( m.getReturnType() ); context.setCurrentAccessor( OgnlRuntime.getCompiler().getSuperOrInterfaceClass( m, m.getDeclaringClass() ) );  return "." + m.getName() + "()";  } catch ( Throwable t ) { throw OgnlOps.castToRuntime( t ); } }  <BUGS> context.setCurrentType( m.getReturnType() ); context.setCurrentAccessor( OgnlRuntime.getCompiler().getSuperOrInterfaceClass( m, m.getDeclaringClass() ) ); <BUGE>  return "." + m.getName() + "(" + conversion + ")";  } catch ( Throwable t ) { throw OgnlOps.castToRuntime( t ); } } }
return ""; }  context.setCurrentType( m.getReturnType() ); context.setCurrentAccessor( OgnlRuntime.getCompiler().getSuperOrInterfaceClass( m, m.getDeclaringClass() ) );  return "." + m.getName() + "()";  } catch ( Throwable t ) { throw OgnlOps.castToRuntime( t ); } }  <BUGS> return "." + m.getName() + "(" + conversion + ")"; <BUGE>  } catch ( Throwable t ) { throw OgnlOps.castToRuntime( t ); } } }
return ""; }  context.setCurrentType( m.getReturnType() ); context.setCurrentAccessor( OgnlRuntime.getCompiler().getSuperOrInterfaceClass( m, m.getDeclaringClass() ) );  return "." + m.getName() + "()";  } catch ( Throwable t ) { throw OgnlOps.castToRuntime( t ); } } } <BUGS> catch ( Throwable t ) <BUGE> { throw OgnlOps.castToRuntime( t ); } } }
return ""; }  context.setCurrentType( m.getReturnType() ); context.setCurrentAccessor( OgnlRuntime.getCompiler().getSuperOrInterfaceClass( m, m.getDeclaringClass() ) );  return "." + m.getName() + "()";  } catch ( Throwable t ) { throw OgnlOps.castToRuntime( t ); } } { <BUGS> throw OgnlOps.castToRuntime( t ); <BUGE> } } }
public boolean remove(@Nonnull Map<String, Object> properties, @Nonnull Validator<?> validator, ServiceReference<Validator<?>> serviceReference) { String validatorId = getValidatorIdFromServiceProperties(properties, validator.getClass(), serviceReference); return remove(validatorId, serviceReference); }
public boolean remove(@Nonnull Map<String, Object> properties, @Nonnull Validator<?> validator, ServiceReference<Validator<?>> serviceReference) { String validatorId = getValidatorIdFromServiceProperties(properties, validator.getClass(), serviceReference); return remove(validatorId, serviceReference); }
public boolean remove(@Nonnull Map<String, Object> properties, @Nonnull Validator<?> validator, ServiceReference<Validator<?>> serviceReference) { String validatorId = getValidatorIdFromServiceProperties(properties, validator.getClass(), serviceReference); return remove(validatorId, serviceReference); }
public boolean remove(@Nonnull Map<String, Object> properties, @Nonnull Validator<?> validator, ServiceReference<Validator<?>> serviceReference) { String validatorId = getValidatorIdFromServiceProperties(properties, validator.getClass(), serviceReference); return remove(validatorId, serviceReference); }
public static Properties getBundleIDtoFeaturesMap(Feature app) { <BUGS> Map<ArtifactId, Set<ArtifactId>> map = new HashMap<>(); <BUGE>  for (Artifact bundle : app.getBundles()) { map.compute(bundle.getId(), (id, features) -> { if (features == null) { features = new HashSet<>(); } features.addAll(Arrays.asList(bundle.getFeatureOrigins())); return features; }); }  Properties result = new Properties();  for (Map.Entry<ArtifactId, Set<ArtifactId>> entry : map.entrySet()) { result.setProperty(entry.getKey().toMvnId(), entry.getValue().stream().map(ArtifactId::toMvnId).collect(Collectors.joining(","))); }  return result; }
public static Properties getBundleIDtoFeaturesMap(Feature app) { Map<ArtifactId, Set<ArtifactId>> map = new HashMap<>();  <BUGS> for (Artifact bundle : app.getBundles()) <BUGE> { map.compute(bundle.getId(), (id, features) -> { if (features == null) { features = new HashSet<>(); } features.addAll(Arrays.asList(bundle.getFeatureOrigins())); return features; }); }  Properties result = new Properties();  for (Map.Entry<ArtifactId, Set<ArtifactId>> entry : map.entrySet()) { result.setProperty(entry.getKey().toMvnId(), entry.getValue().stream().map(ArtifactId::toMvnId).collect(Collectors.joining(","))); }  return result; }
public static Properties getBundleIDtoFeaturesMap(Feature app) { Map<ArtifactId, Set<ArtifactId>> map = new HashMap<>();  for (Artifact bundle : app.getBundles()) { <BUGS> map.compute(bundle.getId(), (id, features) -> <BUGE> { if (features == null) { features = new HashSet<>(); } features.addAll(Arrays.asList(bundle.getFeatureOrigins())); return features; }); }  Properties result = new Properties();  for (Map.Entry<ArtifactId, Set<ArtifactId>> entry : map.entrySet()) { result.setProperty(entry.getKey().toMvnId(), entry.getValue().stream().map(ArtifactId::toMvnId).collect(Collectors.joining(","))); }  return result; }
public static Properties getBundleIDtoFeaturesMap(Feature app) { Map<ArtifactId, Set<ArtifactId>> map = new HashMap<>();  for (Artifact bundle : app.getBundles()) { map.compute(bundle.getId(), (id, features) -> { if (features == null) { features = new HashSet<>(); } features.addAll(Arrays.asList(bundle.getFeatureOrigins())); return features; }); <BUGS> } <BUGE>  Properties result = new Properties();  for (Map.Entry<ArtifactId, Set<ArtifactId>> entry : map.entrySet()) { result.setProperty(entry.getKey().toMvnId(), entry.getValue().stream().map(ArtifactId::toMvnId).collect(Collectors.joining(","))); }  return result; }
public static Properties getBundleIDtoFeaturesMap(Feature app) { Map<ArtifactId, Set<ArtifactId>> map = new HashMap<>();  for (Artifact bundle : app.getBundles()) { map.compute(bundle.getId(), (id, features) -> { if (features == null) { features = new HashSet<>(); } features.addAll(Arrays.asList(bundle.getFeatureOrigins())); return features; }); }  <BUGS> Properties result = new Properties(); <BUGE>  for (Map.Entry<ArtifactId, Set<ArtifactId>> entry : map.entrySet()) { result.setProperty(entry.getKey().toMvnId(), entry.getValue().stream().map(ArtifactId::toMvnId).collect(Collectors.joining(","))); }  return result; }
public static Properties getBundleIDtoFeaturesMap(Feature app) { Map<ArtifactId, Set<ArtifactId>> map = new HashMap<>();  for (Artifact bundle : app.getBundles()) { map.compute(bundle.getId(), (id, features) -> { if (features == null) { features = new HashSet<>(); } features.addAll(Arrays.asList(bundle.getFeatureOrigins())); return features; }); }  Properties result = new Properties();  <BUGS> for (Map.Entry<ArtifactId, Set<ArtifactId>> entry : map.entrySet()) { result.setProperty(entry.getKey().toMvnId(), entry.getValue().stream().map(ArtifactId::toMvnId).collect(Collectors.joining(","))); } <BUGE>  return result; }
public static Properties getBundleIDtoFeaturesMap(Feature app) { Map<ArtifactId, Set<ArtifactId>> map = new HashMap<>();  for (Artifact bundle : app.getBundles()) { map.compute(bundle.getId(), (id, features) -> { if (features == null) { features = new HashSet<>(); } features.addAll(Arrays.asList(bundle.getFeatureOrigins())); return features; }); }  Properties result = new Properties();  for (Map.Entry<ArtifactId, Set<ArtifactId>> entry : map.entrySet()) { result.setProperty(entry.getKey().toMvnId(), entry.getValue().stream().map(ArtifactId::toMvnId).collect(Collectors.joining(","))); }  <BUGS> return result; <BUGE> }
public File createPackage(File outputDirectory) throws IOException { /* generate the Vault properties XML file*/  <BUGS> File xmlProperties = new File(storingDirectory, VAULT_PROPERTIES_FILE); xmlProperties.getParentFile().mkdirs(); <BUGE>  try (FileOutputStream fos = new FileOutputStream(xmlProperties)) { properties.storeToXML(fos, null); }  /* generate the Vault filter XML file*/ File xmlFilter = new File(storingDirectory, VAULT_FILTER_FILE); try (InputStream input = filter.getSource(); FileOutputStream output = new FileOutputStream(xmlFilter)) { IOUtils.copy(input, output); }  /* copy the required resources*/  for (String resource : INCLUDE_RESOURCES) { try (InputStream input = getClass().getResourceAsStream(resource)) { addEntry(META_INF_VAULT_DIRECTORY + resource, input); } }  /* create the target archiver*/  Archiver archiver = new JarArchiver(); archiver.setIncludeEmptyDirs(true);
public File createPackage(File outputDirectory) throws IOException { /* generate the Vault properties XML file*/  File xmlProperties = new File(storingDirectory, VAULT_PROPERTIES_FILE); xmlProperties.getParentFile().mkdirs();  <BUGS> try (FileOutputStream fos = new FileOutputStream(xmlProperties)) { properties.storeToXML(fos, null); } <BUGE>  /* generate the Vault filter XML file*/ File xmlFilter = new File(storingDirectory, VAULT_FILTER_FILE); try (InputStream input = filter.getSource(); FileOutputStream output = new FileOutputStream(xmlFilter)) { IOUtils.copy(input, output); }  /* copy the required resources*/  for (String resource : INCLUDE_RESOURCES) { try (InputStream input = getClass().getResourceAsStream(resource)) { addEntry(META_INF_VAULT_DIRECTORY + resource, input); } }  /* create the target archiver*/  Archiver archiver = new JarArchiver(); archiver.setIncludeEmptyDirs(true);
public File createPackage(File outputDirectory) throws IOException { /* generate the Vault properties XML file*/  File xmlProperties = new File(storingDirectory, VAULT_PROPERTIES_FILE); xmlProperties.getParentFile().mkdirs();  try (FileOutputStream fos = new FileOutputStream(xmlProperties)) { properties.storeToXML(fos, null); }  /* generate the Vault filter XML file*/ <BUGS> File xmlFilter = new File(storingDirectory, VAULT_FILTER_FILE); try (InputStream input = filter.getSource(); FileOutputStream output = new FileOutputStream(xmlFilter)) { IOUtils.copy(input, output); } <BUGE>  /* copy the required resources*/  for (String resource : INCLUDE_RESOURCES) { try (InputStream input = getClass().getResourceAsStream(resource)) { addEntry(META_INF_VAULT_DIRECTORY + resource, input); } }  /* create the target archiver*/  Archiver archiver = new JarArchiver(); archiver.setIncludeEmptyDirs(true);
public File createPackage(File outputDirectory) throws IOException { /* generate the Vault properties XML file*/  File xmlProperties = new File(storingDirectory, VAULT_PROPERTIES_FILE); xmlProperties.getParentFile().mkdirs();  try (FileOutputStream fos = new FileOutputStream(xmlProperties)) { properties.storeToXML(fos, null); }  /* generate the Vault filter XML file*/ File xmlFilter = new File(storingDirectory, VAULT_FILTER_FILE); try (InputStream input = filter.getSource(); FileOutputStream output = new FileOutputStream(xmlFilter)) { IOUtils.copy(input, output); }  /* copy the required resources*/  <BUGS> for (String resource : INCLUDE_RESOURCES) { try (InputStream input = getClass().getResourceAsStream(resource)) { addEntry(META_INF_VAULT_DIRECTORY + resource, input); } <BUGE> }  /* create the target archiver*/  Archiver archiver = new JarArchiver(); archiver.setIncludeEmptyDirs(true);
public File createPackage(File outputDirectory) throws IOException { /* generate the Vault properties XML file*/  File xmlProperties = new File(storingDirectory, VAULT_PROPERTIES_FILE); xmlProperties.getParentFile().mkdirs();  try (FileOutputStream fos = new FileOutputStream(xmlProperties)) { properties.storeToXML(fos, null); }  /* generate the Vault filter XML file*/ File xmlFilter = new File(storingDirectory, VAULT_FILTER_FILE); try (InputStream input = filter.getSource(); FileOutputStream output = new FileOutputStream(xmlFilter)) { IOUtils.copy(input, output); }  /* copy the required resources*/  for (String resource : INCLUDE_RESOURCES) { try (InputStream input = getClass().getResourceAsStream(resource)) { addEntry(META_INF_VAULT_DIRECTORY + resource, input); } }  /* create the target archiver*/  <BUGS> Archiver archiver = new JarArchiver(); archiver.setIncludeEmptyDirs(true); <BUGE>
public void addEntry(String path, InputStream input) throws IOException { File target = new File(storingDirectory, path);  target.getParentFile().mkdirs();  try (OutputStream output = new FileOutputStream(target)) { IOUtils.copy(input, output); } }  public File createPackage() throws IOException { return createPackage(TMP_DIR); }  <BUGS> String destFileName = storingDirectory.getName().substring(0, storingDirectory.getName().lastIndexOf('-')); File destFile = new File(TMP_DIR, destFileName); <BUGE>  archiver.setDestFile(destFile); archiver.addFileSet(new DefaultFileSet(storingDirectory)); archiver.createArchive();  return destFile; }  }
public void addEntry(String path, InputStream input) throws IOException { File target = new File(storingDirectory, path);  target.getParentFile().mkdirs();  try (OutputStream output = new FileOutputStream(target)) { IOUtils.copy(input, output); } }  public File createPackage() throws IOException { return createPackage(TMP_DIR); }  <BUGS> archiver.setDestFile(destFile); archiver.addFileSet(new DefaultFileSet(storingDirectory)); archiver.createArchive(); <BUGE>  return destFile; }  }
public void addEntry(String path, InputStream input) throws IOException { File target = new File(storingDirectory, path);  target.getParentFile().mkdirs();  try (OutputStream output = new FileOutputStream(target)) { IOUtils.copy(input, output); } }  public File createPackage() throws IOException { return createPackage(TMP_DIR); }  <BUGS> return destFile; <BUGE> }  }
@Override public final void handle(String path, Archive archive, Entry entry, ContentPackage2FeatureModelConverter converter) throws Exception { <BUGS> String pid = entry.getName().substring(0, entry.getName().lastIndexOf('.')); <BUGE>  String id; int n = pid.indexOf('~'); if (n == -1) { n = pid.indexOf('-'); } if (n > 0) { id = pid.substring(0, n).concat("~").concat(pid.substring(n + 1)); } else { id = pid; }  logger.info("Processing configuration '{}'.", id);  Dictionary<String, Object> configurationProperties; try (InputStream input = archive.openInputStream(entry)) { configurationProperties = parseConfiguration(id, input); }  if (configurationProperties == null) { logger.info("{} entry does not contain a valid OSGi configuration, treating it as a regular resource", path); converter.getMainPackageAssembler().addEntry(path, archive, entry); return; }  if (configurationProperties.isEmpty()) { logger.info("No configuration properties found for configuration {}", path);
@Override public final void handle(String path, Archive archive, Entry entry, ContentPackage2FeatureModelConverter converter) throws Exception { String pid = entry.getName().substring(0, entry.getName().lastIndexOf('.'));  String id; <BUGS> int n = pid.indexOf('~'); if (n == -1) { <BUGE> n = pid.indexOf('-'); } if (n > 0) { id = pid.substring(0, n).concat("~").concat(pid.substring(n + 1)); } else { id = pid; }  logger.info("Processing configuration '{}'.", id);  Dictionary<String, Object> configurationProperties; try (InputStream input = archive.openInputStream(entry)) { configurationProperties = parseConfiguration(id, input); }  if (configurationProperties == null) { logger.info("{} entry does not contain a valid OSGi configuration, treating it as a regular resource", path); converter.getMainPackageAssembler().addEntry(path, archive, entry); return; }  if (configurationProperties.isEmpty()) { logger.info("No configuration properties found for configuration {}", path);
@Override public final void handle(String path, Archive archive, Entry entry, ContentPackage2FeatureModelConverter converter) throws Exception { String pid = entry.getName().substring(0, entry.getName().lastIndexOf('.'));  String id; int n = pid.indexOf('~'); if (n == -1) { n = pid.indexOf('-'); } <BUGS> if (n > 0) { id = pid.substring(0, n).concat("~").concat(pid.substring(n + 1)); <BUGE> } else { id = pid; }  logger.info("Processing configuration '{}'.", id);  Dictionary<String, Object> configurationProperties; try (InputStream input = archive.openInputStream(entry)) { configurationProperties = parseConfiguration(id, input); }  if (configurationProperties == null) { logger.info("{} entry does not contain a valid OSGi configuration, treating it as a regular resource", path); converter.getMainPackageAssembler().addEntry(path, archive, entry); return; }  if (configurationProperties.isEmpty()) { logger.info("No configuration properties found for configuration {}", path);
@Override public final void handle(String path, Archive archive, Entry entry, ContentPackage2FeatureModelConverter converter) throws Exception { String pid = entry.getName().substring(0, entry.getName().lastIndexOf('.'));  String id; int n = pid.indexOf('~'); if (n == -1) { n = pid.indexOf('-'); } if (n > 0) { id = pid.substring(0, n).concat("~").concat(pid.substring(n + 1)); } else { id = pid; }  <BUGS> logger.info("Processing configuration '{}'.", id); <BUGE>  Dictionary<String, Object> configurationProperties; try (InputStream input = archive.openInputStream(entry)) { configurationProperties = parseConfiguration(id, input); }  if (configurationProperties == null) { logger.info("{} entry does not contain a valid OSGi configuration, treating it as a regular resource", path); converter.getMainPackageAssembler().addEntry(path, archive, entry); return; }  if (configurationProperties.isEmpty()) { logger.info("No configuration properties found for configuration {}", path);
@Override public final void handle(String path, Archive archive, Entry entry, ContentPackage2FeatureModelConverter converter) throws Exception { String pid = entry.getName().substring(0, entry.getName().lastIndexOf('.'));  String id; int n = pid.indexOf('~'); if (n == -1) { n = pid.indexOf('-'); } if (n > 0) { id = pid.substring(0, n).concat("~").concat(pid.substring(n + 1)); } else { id = pid; }  logger.info("Processing configuration '{}'.", id);  Dictionary<String, Object> configurationProperties; <BUGS> try (InputStream input = archive.openInputStream(entry)) { configurationProperties = parseConfiguration(id, input); } <BUGE>  if (configurationProperties == null) { logger.info("{} entry does not contain a valid OSGi configuration, treating it as a regular resource", path); converter.getMainPackageAssembler().addEntry(path, archive, entry); return; }  if (configurationProperties.isEmpty()) { logger.info("No configuration properties found for configuration {}", path);
@Override public final void handle(String path, Archive archive, Entry entry, ContentPackage2FeatureModelConverter converter) throws Exception { String pid = entry.getName().substring(0, entry.getName().lastIndexOf('.'));  String id; int n = pid.indexOf('~'); if (n == -1) { n = pid.indexOf('-'); } if (n > 0) { id = pid.substring(0, n).concat("~").concat(pid.substring(n + 1)); } else { id = pid; }  logger.info("Processing configuration '{}'.", id);  Dictionary<String, Object> configurationProperties; try (InputStream input = archive.openInputStream(entry)) { configurationProperties = parseConfiguration(id, input); }  <BUGS> if (configurationProperties == null) { <BUGE> logger.info("{} entry does not contain a valid OSGi configuration, treating it as a regular resource", path); converter.getMainPackageAssembler().addEntry(path, archive, entry); return; }  if (configurationProperties.isEmpty()) { logger.info("No configuration properties found for configuration {}", path);
@Override public final void handle(String path, Archive archive, Entry entry, ContentPackage2FeatureModelConverter converter) throws Exception { String pid = entry.getName().substring(0, entry.getName().lastIndexOf('.'));  String id; int n = pid.indexOf('~'); if (n == -1) { n = pid.indexOf('-'); } if (n > 0) { id = pid.substring(0, n).concat("~").concat(pid.substring(n + 1)); } else { id = pid; }  logger.info("Processing configuration '{}'.", id);  Dictionary<String, Object> configurationProperties; try (InputStream input = archive.openInputStream(entry)) { configurationProperties = parseConfiguration(id, input); }  if (configurationProperties == null) { logger.info("{} entry does not contain a valid OSGi configuration, treating it as a regular resource", path); converter.getMainPackageAssembler().addEntry(path, archive, entry); return; }  <BUGS> if (configurationProperties.isEmpty()) { <BUGE> logger.info("No configuration properties found for configuration {}", path);
import java.io.InputStream; import java.util.Dictionary; import java.util.regex.Matcher;  import org.apache.jackrabbit.vault.fs.io.Archive; import org.apache.jackrabbit.vault.fs.io.Archive.Entry; import org.apache.sling.feature.cpconverter.ContentPackage2FeatureModelConverter;  abstract class AbstractConfigurationEntryHandler extends AbstractRegexEntryHandler {  public AbstractConfigurationEntryHandler(String extension) { super("(jcr_root)?/(?:apps|libs)/.+/config(\\.([^/]+))?/.+\\." + extension); }   <BUGS> Matcher matcher = getPattern().matcher(path); String runMode = null; <BUGE> /* we are pretty sure it matches, here*/ if (matcher.matches()) { /* there is a specified RunMode*/ runMode = matcher.group(3); } else { throw new IllegalStateException("Something went terribly wrong: pattern '" + getPattern().pattern() + "' should have matched already with path '" + path + "' but it does not, currently"); }  converter.addConfiguration(runMode, id, configurationProperties);
import java.io.InputStream; import java.util.Dictionary; import java.util.regex.Matcher;  import org.apache.jackrabbit.vault.fs.io.Archive; import org.apache.jackrabbit.vault.fs.io.Archive.Entry; import org.apache.sling.feature.cpconverter.ContentPackage2FeatureModelConverter;  abstract class AbstractConfigurationEntryHandler extends AbstractRegexEntryHandler {  public AbstractConfigurationEntryHandler(String extension) { super("(jcr_root)?/(?:apps|libs)/.+/config(\\.([^/]+))?/.+\\." + extension); }  /* we are pretty sure it matches, here*/ <BUGS> if (matcher.matches()) { <BUGE> /* there is a specified RunMode*/ runMode = matcher.group(3); } else { throw new IllegalStateException("Something went terribly wrong: pattern '" + getPattern().pattern() + "' should have matched already with path '" + path + "' but it does not, currently"); }  converter.addConfiguration(runMode, id, configurationProperties); }  protected abstract Dictionary<String, Object> parseConfiguration(String name, InputStream input) throws Exception;
import java.io.InputStream; import java.util.Dictionary; import java.util.regex.Matcher;  import org.apache.jackrabbit.vault.fs.io.Archive; import org.apache.jackrabbit.vault.fs.io.Archive.Entry; import org.apache.sling.feature.cpconverter.ContentPackage2FeatureModelConverter;  abstract class AbstractConfigurationEntryHandler extends AbstractRegexEntryHandler {  public AbstractConfigurationEntryHandler(String extension) { super("(jcr_root)?/(?:apps|libs)/.+/config(\\.([^/]+))?/.+\\." + extension); }  /* there is a specified RunMode*/ <BUGS> runMode = matcher.group(3); <BUGE> } else { throw new IllegalStateException("Something went terribly wrong: pattern '" + getPattern().pattern() + "' should have matched already with path '" + path + "' but it does not, currently"); }  converter.addConfiguration(runMode, id, configurationProperties); }  protected abstract Dictionary<String, Object> parseConfiguration(String name, InputStream input) throws Exception;  }
import java.io.InputStream; import java.util.Dictionary; import java.util.regex.Matcher;  import org.apache.jackrabbit.vault.fs.io.Archive; import org.apache.jackrabbit.vault.fs.io.Archive.Entry; import org.apache.sling.feature.cpconverter.ContentPackage2FeatureModelConverter;  abstract class AbstractConfigurationEntryHandler extends AbstractRegexEntryHandler {  public AbstractConfigurationEntryHandler(String extension) { super("(jcr_root)?/(?:apps|libs)/.+/config(\\.([^/]+))?/.+\\." + extension); }   <BUGS> converter.addConfiguration(runMode, id, configurationProperties); } <BUGE>  protected abstract Dictionary<String, Object> parseConfiguration(String name, InputStream input) throws Exception;  }
private static void addAclStatement(Formatter formatter, String systemUser, List<Acl> authorizations) { <BUGS> if (areEmpty(authorizations)) { <BUGE> return; }  formatter.format("set ACL for %s%n", systemUser);  for (Acl authorization : authorizations) { formatter.format("%s %s on %s", authorization.getOperation(), authorization.getPrivileges(), authorization.getPath());  if (!authorization.getRestrictions().isEmpty()) { formatter.format(" restriction(%s)", authorization.getRestrictions().stream().collect(Collectors.joining(","))); }  formatter.format("%n"); }  formatter.format("end%n"); }
private static void addAclStatement(Formatter formatter, String systemUser, List<Acl> authorizations) { if (areEmpty(authorizations)) { return; }  <BUGS> formatter.format("set ACL for %s%n", systemUser); <BUGE>  for (Acl authorization : authorizations) { formatter.format("%s %s on %s", authorization.getOperation(), authorization.getPrivileges(), authorization.getPath());  if (!authorization.getRestrictions().isEmpty()) { formatter.format(" restriction(%s)", authorization.getRestrictions().stream().collect(Collectors.joining(","))); }  formatter.format("%n"); }  formatter.format("end%n"); }
private static void addAclStatement(Formatter formatter, String systemUser, List<Acl> authorizations) { if (areEmpty(authorizations)) { return; }  formatter.format("set ACL for %s%n", systemUser);  <BUGS> for (Acl authorization : authorizations) { formatter.format("%s %s on %s", authorization.getOperation(), authorization.getPrivileges(), authorization.getPath()); <BUGE>  if (!authorization.getRestrictions().isEmpty()) { formatter.format(" restriction(%s)", authorization.getRestrictions().stream().collect(Collectors.joining(","))); }  formatter.format("%n"); }  formatter.format("end%n"); }
private static void addAclStatement(Formatter formatter, String systemUser, List<Acl> authorizations) { if (areEmpty(authorizations)) { return; }  formatter.format("set ACL for %s%n", systemUser);  for (Acl authorization : authorizations) { formatter.format("%s %s on %s", authorization.getOperation(), authorization.getPrivileges(), authorization.getPath());  <BUGS> if (!authorization.getRestrictions().isEmpty()) { formatter.format(" restriction(%s)", authorization.getRestrictions().stream().collect(Collectors.joining(","))); <BUGE> }  formatter.format("%n"); }  formatter.format("end%n"); }
private static void addAclStatement(Formatter formatter, String systemUser, List<Acl> authorizations) { if (areEmpty(authorizations)) { return; }  formatter.format("set ACL for %s%n", systemUser);  for (Acl authorization : authorizations) { formatter.format("%s %s on %s", authorization.getOperation(), authorization.getPrivileges(), authorization.getPath());  if (!authorization.getRestrictions().isEmpty()) { formatter.format(" restriction(%s)", authorization.getRestrictions().stream().collect(Collectors.joining(","))); }  <BUGS> formatter.format("%n"); } <BUGE>  formatter.format("end%n"); }
private static void addAclStatement(Formatter formatter, String systemUser, List<Acl> authorizations) { if (areEmpty(authorizations)) { return; }  formatter.format("set ACL for %s%n", systemUser);  for (Acl authorization : authorizations) { formatter.format("%s %s on %s", authorization.getOperation(), authorization.getPrivileges(), authorization.getPath());  if (!authorization.getRestrictions().isEmpty()) { formatter.format(" restriction(%s)", authorization.getRestrictions().stream().collect(Collectors.joining(","))); }  formatter.format("%n"); }  <BUGS> formatter.format("end%n"); } <BUGE>
@Override public List<Pair<K2, V2>> run() throws IOException { try { <BUGS> preRunChecks(myReducer); initDistributedCache(); MockReduceContextWrapper<K1, V1, K2, V2> wrapper = getContextWrapper(); mos = new MockMultipleOutputs(wrapper.getMockContext()); <BUGE> try { PowerMockito.whenNew(MultipleOutputs.class).withArguments(wrapper.getMockContext()).thenReturn(mos); } catch(Exception ex) { /*Wrap the exception to avoid changing the method signature*/ throw new IOException(ex); } myReducer.run(wrapper.getMockContext()); return wrapper.getOutputs(); } catch (final InterruptedException ie) { throw new IOException(ie); } finally { cleanupDistributedCache(); } }
@Override public List<Pair<K2, V2>> run() throws IOException { try { preRunChecks(myReducer); initDistributedCache(); MockReduceContextWrapper<K1, V1, K2, V2> wrapper = getContextWrapper(); mos = new MockMultipleOutputs(wrapper.getMockContext()); try { <BUGS> PowerMockito.whenNew(MultipleOutputs.class).withArguments(wrapper.getMockContext()).thenReturn(mos); <BUGE> } catch(Exception ex) { /*Wrap the exception to avoid changing the method signature*/ throw new IOException(ex); } myReducer.run(wrapper.getMockContext()); return wrapper.getOutputs(); } catch (final InterruptedException ie) { throw new IOException(ie); } finally { cleanupDistributedCache(); } }
@Override public List<Pair<K2, V2>> run() throws IOException { try { preRunChecks(myReducer); initDistributedCache(); MockReduceContextWrapper<K1, V1, K2, V2> wrapper = getContextWrapper(); mos = new MockMultipleOutputs(wrapper.getMockContext()); try { PowerMockito.whenNew(MultipleOutputs.class).withArguments(wrapper.getMockContext()).thenReturn(mos); } catch(Exception ex) { /*Wrap the exception to avoid changing the method signature*/ throw new IOException(ex); <BUGS> } myReducer.run(wrapper.getMockContext()); <BUGE> return wrapper.getOutputs(); } catch (final InterruptedException ie) { throw new IOException(ie); } finally { cleanupDistributedCache(); } }
@Override public List<Pair<K2, V2>> run() throws IOException { try { preRunChecks(myReducer); initDistributedCache(); MockReduceContextWrapper<K1, V1, K2, V2> wrapper = getContextWrapper(); mos = new MockMultipleOutputs(wrapper.getMockContext()); try { PowerMockito.whenNew(MultipleOutputs.class).withArguments(wrapper.getMockContext()).thenReturn(mos); } catch(Exception ex) { /*Wrap the exception to avoid changing the method signature*/ throw new IOException(ex); } myReducer.run(wrapper.getMockContext()); return wrapper.getOutputs(); } catch (final InterruptedException ie) { throw new IOException(ie); } finally { <BUGS> cleanupDistributedCache(); } <BUGE> }
@SuppressWarnings("unchecked") public <T> T copy(final T orig, final T copy) { <BUGS> if (copy != null && orig.getClass() != copy.getClass()) { <BUGE> throw new IllegalArgumentException(orig.getClass() + " != " + copy.getClass()); } final Class<?> clazz = orig.getClass(); final Serializer<Object> serializer; final Deserializer<Object> deserializer; String errorMsg = "No applicable class implementing Serialization in conf " + "at io.serializations: " + clazz; try { serializer = (Serializer<Object>) serializationFactory .getSerializer(clazz); deserializer = (Deserializer<Object>) serializationFactory .getDeserializer(clazz); /* hadoop 1.x will throw*/ } catch (NullPointerException e) { throw new IllegalStateException(errorMsg, e); } /* hadoop 2.x will return a null*/ try { final DataOutputBuffer outputBuffer = new DataOutputBuffer(); serializer.open(outputBuffer); serializer.serialize(orig); final DataInputBuffer inputBuffer = new DataInputBuffer(); inputBuffer.reset(outputBuffer.getData(), outputBuffer.getLength()); deserializer.open(inputBuffer); return (T) deserializer.deserialize(copy); } catch (final IOException e) {
@SuppressWarnings("unchecked") public <T> T copy(final T orig, final T copy) { if (copy != null && orig.getClass() != copy.getClass()) { throw new IllegalArgumentException(orig.getClass() + " != " + copy.getClass()); } <BUGS> final Class<?> clazz = orig.getClass(); <BUGE> final Serializer<Object> serializer; final Deserializer<Object> deserializer; String errorMsg = "No applicable class implementing Serialization in conf " + "at io.serializations: " + clazz; try { serializer = (Serializer<Object>) serializationFactory .getSerializer(clazz); deserializer = (Deserializer<Object>) serializationFactory .getDeserializer(clazz); /* hadoop 1.x will throw*/ } catch (NullPointerException e) { throw new IllegalStateException(errorMsg, e); } /* hadoop 2.x will return a null*/ try { final DataOutputBuffer outputBuffer = new DataOutputBuffer(); serializer.open(outputBuffer); serializer.serialize(orig); final DataInputBuffer inputBuffer = new DataInputBuffer(); inputBuffer.reset(outputBuffer.getData(), outputBuffer.getLength()); deserializer.open(inputBuffer); return (T) deserializer.deserialize(copy); } catch (final IOException e) {
@SuppressWarnings("unchecked") public <T> T copy(final T orig, final T copy) { if (copy != null && orig.getClass() != copy.getClass()) { throw new IllegalArgumentException(orig.getClass() + " != " + copy.getClass()); } final Class<?> clazz = orig.getClass(); final Serializer<Object> serializer; final Deserializer<Object> deserializer; <BUGS> String errorMsg = "No applicable class implementing Serialization in conf " <BUGE> + "at io.serializations: " + clazz; try { serializer = (Serializer<Object>) serializationFactory .getSerializer(clazz); deserializer = (Deserializer<Object>) serializationFactory .getDeserializer(clazz); /* hadoop 1.x will throw*/ } catch (NullPointerException e) { throw new IllegalStateException(errorMsg, e); } /* hadoop 2.x will return a null*/ try { final DataOutputBuffer outputBuffer = new DataOutputBuffer(); serializer.open(outputBuffer); serializer.serialize(orig); final DataInputBuffer inputBuffer = new DataInputBuffer(); inputBuffer.reset(outputBuffer.getData(), outputBuffer.getLength()); deserializer.open(inputBuffer); return (T) deserializer.deserialize(copy); } catch (final IOException e) {
@SuppressWarnings("unchecked") public <T> T copy(final T orig, final T copy) { if (copy != null && orig.getClass() != copy.getClass()) { throw new IllegalArgumentException(orig.getClass() + " != " + copy.getClass()); } final Class<?> clazz = orig.getClass(); final Serializer<Object> serializer; final Deserializer<Object> deserializer; String errorMsg = "No applicable class implementing Serialization in conf " + "at io.serializations: " + clazz; try { <BUGS> serializer = (Serializer<Object>) serializationFactory .getSerializer(clazz); deserializer = (Deserializer<Object>) serializationFactory .getDeserializer(clazz); <BUGE> /* hadoop 1.x will throw*/ } catch (NullPointerException e) { throw new IllegalStateException(errorMsg, e); } /* hadoop 2.x will return a null*/ try { final DataOutputBuffer outputBuffer = new DataOutputBuffer(); serializer.open(outputBuffer); serializer.serialize(orig); final DataInputBuffer inputBuffer = new DataInputBuffer(); inputBuffer.reset(outputBuffer.getData(), outputBuffer.getLength()); deserializer.open(inputBuffer); return (T) deserializer.deserialize(copy); } catch (final IOException e) {
@SuppressWarnings("unchecked") public <T> T copy(final T orig, final T copy) { if (copy != null && orig.getClass() != copy.getClass()) { throw new IllegalArgumentException(orig.getClass() + " != " + copy.getClass()); } final Class<?> clazz = orig.getClass(); final Serializer<Object> serializer; final Deserializer<Object> deserializer; String errorMsg = "No applicable class implementing Serialization in conf " + "at io.serializations: " + clazz; try { serializer = (Serializer<Object>) serializationFactory .getSerializer(clazz); deserializer = (Deserializer<Object>) serializationFactory .getDeserializer(clazz); /* hadoop 1.x will throw*/ } catch (NullPointerException e) { throw new IllegalStateException(errorMsg, e); <BUGS> } <BUGE> /* hadoop 2.x will return a null*/ try { final DataOutputBuffer outputBuffer = new DataOutputBuffer(); serializer.open(outputBuffer); serializer.serialize(orig); final DataInputBuffer inputBuffer = new DataInputBuffer(); inputBuffer.reset(outputBuffer.getData(), outputBuffer.getLength()); deserializer.open(inputBuffer); return (T) deserializer.deserialize(copy); } catch (final IOException e) {
@SuppressWarnings("unchecked") public <T> T copy(final T orig, final T copy) { if (copy != null && orig.getClass() != copy.getClass()) { throw new IllegalArgumentException(orig.getClass() + " != " + copy.getClass()); } final Class<?> clazz = orig.getClass(); final Serializer<Object> serializer; final Deserializer<Object> deserializer; String errorMsg = "No applicable class implementing Serialization in conf " + "at io.serializations: " + clazz; try { serializer = (Serializer<Object>) serializationFactory .getSerializer(clazz); deserializer = (Deserializer<Object>) serializationFactory .getDeserializer(clazz); /* hadoop 1.x will throw*/ } catch (NullPointerException e) { throw new IllegalStateException(errorMsg, e); } /* hadoop 2.x will return a null*/ try { <BUGS> final DataOutputBuffer outputBuffer = new DataOutputBuffer(); serializer.open(outputBuffer); <BUGE> serializer.serialize(orig); final DataInputBuffer inputBuffer = new DataInputBuffer(); inputBuffer.reset(outputBuffer.getData(), outputBuffer.getLength()); deserializer.open(inputBuffer); return (T) deserializer.deserialize(copy); } catch (final IOException e) {
*/ public static String join(Iterable<?> iterable, String separator) { <BUGS> final StringBuilder sb = new StringBuilder(); boolean first = true; <BUGE>  for (Object item : iterable) { if (first) { first = false; } else { sb.append(separator); }  sb.append(item.toString()); }  return sb.toString(); }
*/ public static String join(Iterable<?> iterable, String separator) { final StringBuilder sb = new StringBuilder(); boolean first = true;  <BUGS> for (Object item : iterable) { if (first) { first = false; <BUGE> } else { sb.append(separator); }  sb.append(item.toString()); }  return sb.toString(); }
*/ public static String join(Iterable<?> iterable, String separator) { final StringBuilder sb = new StringBuilder(); boolean first = true;  for (Object item : iterable) { if (first) { first = false; } else { <BUGS> sb.append(separator); <BUGE> }  sb.append(item.toString()); }  return sb.toString(); }
*/ public static String join(Iterable<?> iterable, String separator) { final StringBuilder sb = new StringBuilder(); boolean first = true;  for (Object item : iterable) { if (first) { first = false; } else { sb.append(separator); }  <BUGS> sb.append(item.toString()); } <BUGE>  return sb.toString(); }
*/ public static String join(Iterable<?> iterable, String separator) { final StringBuilder sb = new StringBuilder(); boolean first = true;  for (Object item : iterable) { if (first) { first = false; } else { sb.append(separator); }  sb.append(item.toString()); }  <BUGS> return sb.toString(); <BUGE> }
@Override public IntStreamEx mapToInt(ToIntFunction<? super T> mapper) { <BUGS> return strategy().newIntStreamEx(stream.mapToInt(mapper)); <BUGE> }
@Override public Optional<T> reduce(BinaryOperator<T> accumulator) { <BUGS> return stream.reduce(accumulator); <BUGE> }
*/ public static <T> StreamEx<List<T>> cartesianProduct(Collection<? extends Collection<T>> source) { <BUGS> if (source.isEmpty()) return StreamEx.<List<T>>of(Collections.emptyList()); return of(new CrossSpliterator.ToList<>(source)); <BUGE> }
@Override public S trySplit() { <BUGS> long remaining = this.remaining; if (remaining >= 2) { <BUGE> S clone = doClone(); remaining >>= 1; clone.remaining = remaining; this.remaining -= remaining; return clone; } return null; }
@Override public S trySplit() { long remaining = this.remaining; if (remaining >= 2) { S clone = doClone(); remaining >>= 1; clone.remaining = remaining; this.remaining -= remaining; return clone; } <BUGS> return null; <BUGE> }
@Override public void forEachOrdered(Consumer<? super T> action) { <BUGS> strategy.terminate(() -> { <BUGE> stream.forEachOrdered(action); return null; }); }
@Override public void forEachOrdered(Consumer<? super T> action) { strategy.terminate(() -> { stream.forEachOrdered(action); return null; }); <BUGS> } <BUGE>
*/ public JavaWriter emitStaticImports(Collection<String> types) throws IOException { <BUGS> for (String type : new TreeSet<String>(types)) { Matcher matcher = TYPE_PATTERN.matcher(type); if (!matcher.matches()) { throw new IllegalArgumentException(type); <BUGE> } if (importedTypes.put(type, matcher.group(1)) != null) { throw new IllegalArgumentException(type); } out.write("import static "); out.write(type); out.write(";\n"); } return this; }
*/ public JavaWriter emitImports(String... types) throws IOException { <BUGS> return emitImports(Arrays.asList(types)); <BUGE> }
*/ public JavaWriter emitImports(String... types) throws IOException { <BUGS> return emitImports(Arrays.asList(types)); <BUGE> }
/** Emits a single line comment. */ public JavaWriter emitEndOfLineComment(String comment, Object... args) throws IOException { <BUGS> out.write("/* ");*/ out.write(String.format(comment, args)); out.write("\n"); return this; <BUGE> }
/** Try to compress a fully-qualified class name to only the class name. */ public String compressType(String type) { <BUGS> StringBuilder sb = new StringBuilder(); if (this.packagePrefix == null) { <BUGE> throw new IllegalStateException(); }  Matcher m = TYPE_PATTERN.matcher(type); int pos = 0; while (true) { boolean found = m.find(pos);  /* Copy non-matching characters like "<".*/ int typeStart = found ? m.start() : type.length(); sb.append(type, pos, typeStart);  if (!found) { break; }  /* Copy a single class name, shortening it if possible.*/ String name = m.group(0); String imported = importedTypes.get(name); if (imported != null) { sb.append(imported); } else if (isClassInPackage(name)) { String compressed = name.substring(packagePrefix.length()); if (isAmbiguous(compressed)) { sb.append(name); } else {
/** Try to compress a fully-qualified class name to only the class name. */ public String compressType(String type) { StringBuilder sb = new StringBuilder(); if (this.packagePrefix == null) { throw new IllegalStateException(); }  <BUGS> Matcher m = TYPE_PATTERN.matcher(type); int pos = 0; <BUGE> while (true) { boolean found = m.find(pos);  /* Copy non-matching characters like "<".*/ int typeStart = found ? m.start() : type.length(); sb.append(type, pos, typeStart);  if (!found) { break; }  /* Copy a single class name, shortening it if possible.*/ String name = m.group(0); String imported = importedTypes.get(name); if (imported != null) { sb.append(imported); } else if (isClassInPackage(name)) { String compressed = name.substring(packagePrefix.length()); if (isAmbiguous(compressed)) { sb.append(name); } else {
/** Try to compress a fully-qualified class name to only the class name. */ public String compressType(String type) { StringBuilder sb = new StringBuilder(); if (this.packagePrefix == null) { throw new IllegalStateException(); }  Matcher m = TYPE_PATTERN.matcher(type); int pos = 0; while (true) { <BUGS> boolean found = m.find(pos); <BUGE>  /* Copy non-matching characters like "<".*/ int typeStart = found ? m.start() : type.length(); sb.append(type, pos, typeStart);  if (!found) { break; }  /* Copy a single class name, shortening it if possible.*/ String name = m.group(0); String imported = importedTypes.get(name); if (imported != null) { sb.append(imported); } else if (isClassInPackage(name)) { String compressed = name.substring(packagePrefix.length()); if (isAmbiguous(compressed)) { sb.append(name); } else {
/** Try to compress a fully-qualified class name to only the class name. */ public String compressType(String type) { StringBuilder sb = new StringBuilder(); if (this.packagePrefix == null) { throw new IllegalStateException(); }  Matcher m = TYPE_PATTERN.matcher(type); int pos = 0; while (true) { boolean found = m.find(pos);  /* Copy non-matching characters like "<".*/ <BUGS> int typeStart = found ? m.start() : type.length(); sb.append(type, pos, typeStart); <BUGE>  if (!found) { break; }  /* Copy a single class name, shortening it if possible.*/ String name = m.group(0); String imported = importedTypes.get(name); if (imported != null) { sb.append(imported); } else if (isClassInPackage(name)) { String compressed = name.substring(packagePrefix.length()); if (isAmbiguous(compressed)) { sb.append(name); } else {
/** Try to compress a fully-qualified class name to only the class name. */ public String compressType(String type) { StringBuilder sb = new StringBuilder(); if (this.packagePrefix == null) { throw new IllegalStateException(); }  Matcher m = TYPE_PATTERN.matcher(type); int pos = 0; while (true) { boolean found = m.find(pos);  /* Copy non-matching characters like "<".*/ int typeStart = found ? m.start() : type.length(); sb.append(type, pos, typeStart);  <BUGS> if (!found) { break; <BUGE> }  /* Copy a single class name, shortening it if possible.*/ String name = m.group(0); String imported = importedTypes.get(name); if (imported != null) { sb.append(imported); } else if (isClassInPackage(name)) { String compressed = name.substring(packagePrefix.length()); if (isAmbiguous(compressed)) { sb.append(name); } else {
/** Try to compress a fully-qualified class name to only the class name. */ public String compressType(String type) { StringBuilder sb = new StringBuilder(); if (this.packagePrefix == null) { throw new IllegalStateException(); }  Matcher m = TYPE_PATTERN.matcher(type); int pos = 0; while (true) { boolean found = m.find(pos);  /* Copy non-matching characters like "<".*/ int typeStart = found ? m.start() : type.length(); sb.append(type, pos, typeStart);  if (!found) { break; }  /* Copy a single class name, shortening it if possible.*/ <BUGS> String name = m.group(0); String imported = importedTypes.get(name); if (imported != null) { <BUGE> sb.append(imported); } else if (isClassInPackage(name)) { String compressed = name.substring(packagePrefix.length()); if (isAmbiguous(compressed)) { sb.append(name); } else {
/** Try to compress a fully-qualified class name to only the class name. */ public String compressType(String type) { StringBuilder sb = new StringBuilder(); if (this.packagePrefix == null) { throw new IllegalStateException(); }  Matcher m = TYPE_PATTERN.matcher(type); int pos = 0; while (true) { boolean found = m.find(pos);  /* Copy non-matching characters like "<".*/ int typeStart = found ? m.start() : type.length(); sb.append(type, pos, typeStart);  if (!found) { break; }  /* Copy a single class name, shortening it if possible.*/ String name = m.group(0); String imported = importedTypes.get(name); if (imported != null) { sb.append(imported); <BUGS> } else if (isClassInPackage(name)) { <BUGE> String compressed = name.substring(packagePrefix.length()); if (isAmbiguous(compressed)) { sb.append(name); } else {
/** * Emits a name like {@code java.lang.String} or {@code java.util.List<java.lang.String>}, * compressing it with imports if possible. Type compression will only be enabled if * {@link #isCompressingTypes} is true. */ private JavaWriter emitCompressedType(String type) throws IOException { if (isCompressingTypes) { out.write(compressType(type)); } else { out.write(type); } return this; }  } <BUGS> } else if (name.startsWith("java.lang.")) { sb.append(name.substring("java.lang.".length())); <BUGE> } else { sb.append(name); } pos = m.end(); } return sb.toString(); }  private boolean isClassInPackage(String name) { if (name.startsWith(packagePrefix)) { if (name.indexOf('.', packagePrefix.length()) == -1) { return true; }
* Emits a name like {@code java.lang.String} or {@code java.util.List<java.lang.String>}, * compressing it with imports if possible. Type compression will only be enabled if * {@link #isCompressingTypes} is true. */ private JavaWriter emitCompressedType(String type) throws IOException { if (isCompressingTypes) { out.write(compressType(type)); } else { out.write(type); } return this; }  } <BUGS> pos = m.end(); } return sb.toString(); <BUGE> }  private boolean isClassInPackage(String name) { if (name.startsWith(packagePrefix)) { if (name.indexOf('.', packagePrefix.length()) == -1) { return true; } /* check to see if the part after the package looks like a class*/ if (Character.isUpperCase(name.charAt(packagePrefix.length()))) { return true; } } return false;
*/ public JavaWriter beginMethod(String returnType, String name, Set<Modifier> modifiers, List<String> parameters, List<String> throwsTypes) throws IOException { <BUGS> indent(); emitModifiers(modifiers); if (returnType != null) { emitCompressedType(returnType); out.write(" "); out.write(name); <BUGE> } else { emitCompressedType(name); } out.write("("); if (parameters != null) { for (int p = 0; p < parameters.size();) { if (p != 0) { out.write(", "); } emitCompressedType(parameters.get(p++)); out.write(" "); emitCompressedType(parameters.get(p++)); } } out.write(")"); if (throwsTypes != null && throwsTypes.size() > 0) { out.write("\n"); indent(); out.write("    throws "); for (int i = 0; i < throwsTypes.size(); i++) { if (i != 0) {
*/ public JavaWriter beginMethod(String returnType, String name, Set<Modifier> modifiers, List<String> parameters, List<String> throwsTypes) throws IOException { indent(); emitModifiers(modifiers); if (returnType != null) { emitCompressedType(returnType); out.write(" "); out.write(name); } else { emitCompressedType(name); } <BUGS> out.write("("); if (parameters != null) { for (int p = 0; p < parameters.size();) { if (p != 0) { out.write(", "); <BUGE> } emitCompressedType(parameters.get(p++)); out.write(" "); emitCompressedType(parameters.get(p++)); } } out.write(")"); if (throwsTypes != null && throwsTypes.size() > 0) { out.write("\n"); indent(); out.write("    throws "); for (int i = 0; i < throwsTypes.size(); i++) { if (i != 0) {
*/ public JavaWriter beginMethod(String returnType, String name, Set<Modifier> modifiers, List<String> parameters, List<String> throwsTypes) throws IOException { indent(); emitModifiers(modifiers); if (returnType != null) { emitCompressedType(returnType); out.write(" "); out.write(name); } else { emitCompressedType(name); } out.write("("); if (parameters != null) { for (int p = 0; p < parameters.size();) { if (p != 0) { out.write(", "); } <BUGS> emitCompressedType(parameters.get(p++)); out.write(" "); emitCompressedType(parameters.get(p++)); <BUGE> } } out.write(")"); if (throwsTypes != null && throwsTypes.size() > 0) { out.write("\n"); indent(); out.write("    throws "); for (int i = 0; i < throwsTypes.size(); i++) { if (i != 0) {
*/ public JavaWriter beginMethod(String returnType, String name, Set<Modifier> modifiers, List<String> parameters, List<String> throwsTypes) throws IOException { indent(); emitModifiers(modifiers); if (returnType != null) { emitCompressedType(returnType); out.write(" "); out.write(name); } else { emitCompressedType(name); } out.write("("); if (parameters != null) { for (int p = 0; p < parameters.size();) { if (p != 0) { out.write(", "); } emitCompressedType(parameters.get(p++)); out.write(" "); emitCompressedType(parameters.get(p++)); } } <BUGS> out.write(")"); if (throwsTypes != null && throwsTypes.size() > 0) { out.write("\n"); indent(); out.write("    throws "); for (int i = 0; i < throwsTypes.size(); i++) { if (i != 0) { <BUGE>
}  /** * Emit a method declaration. * * <p>A {@code null} return type may be used to indicate a constructor, but * {@link #beginConstructor(Set, List, List)} should be preferred. This behavior may be removed in * a future release. * * @param returnType the method's return type, or null for constructors. * @param name the method name, or the fully qualified class name for constructors. * @param modifiers the set of modifiers to be applied to the method * @param parameters alternating parameter types and names. * @param throwsTypes the classes to throw, or null for no throws clause. } <BUGS> emitCompressedType(throwsTypes.get(i)); <BUGE> } } if (modifiers.contains(ABSTRACT)) { out.write(";\n"); scopes.push(Scope.ABSTRACT_METHOD); } else { out.write(" {\n"); scopes.push(returnType == null ? Scope.CONSTRUCTOR : Scope.NON_ABSTRACT_METHOD); } return this; }  public JavaWriter beginConstructor(Set<Modifier> modifiers, String... parameters) throws IOException {
}  /** * Emit a method declaration. * * <p>A {@code null} return type may be used to indicate a constructor, but * {@link #beginConstructor(Set, List, List)} should be preferred. This behavior may be removed in * a future release. * * @param returnType the method's return type, or null for constructors. * @param name the method name, or the fully qualified class name for constructors. * @param modifiers the set of modifiers to be applied to the method * @param parameters alternating parameter types and names. * @param throwsTypes the classes to throw, or null for no throws clause. } <BUGS> if (modifiers.contains(ABSTRACT)) { <BUGE> out.write(";\n"); scopes.push(Scope.ABSTRACT_METHOD); } else { out.write(" {\n"); scopes.push(returnType == null ? Scope.CONSTRUCTOR : Scope.NON_ABSTRACT_METHOD); } return this; }  public JavaWriter beginConstructor(Set<Modifier> modifiers, String... parameters) throws IOException { beginMethod(null, types.peekFirst(), modifiers, parameters); return this; }
}  /** * Emit a method declaration. * * <p>A {@code null} return type may be used to indicate a constructor, but * {@link #beginConstructor(Set, List, List)} should be preferred. This behavior may be removed in * a future release. * * @param returnType the method's return type, or null for constructors. * @param name the method name, or the fully qualified class name for constructors. * @param modifiers the set of modifiers to be applied to the method * @param parameters alternating parameter types and names. * @param throwsTypes the classes to throw, or null for no throws clause. } else { <BUGS> out.write(" {\n"); scopes.push(returnType == null ? Scope.CONSTRUCTOR : Scope.NON_ABSTRACT_METHOD); <BUGE> } return this; }  public JavaWriter beginConstructor(Set<Modifier> modifiers, String... parameters) throws IOException { beginMethod(null, types.peekFirst(), modifiers, parameters); return this; }  public JavaWriter beginConstructor(Set<Modifier> modifiers, List<String> parameters, List<String> throwsTypes) throws IOException {
}  /** * Emit a method declaration. * * <p>A {@code null} return type may be used to indicate a constructor, but * {@link #beginConstructor(Set, List, List)} should be preferred. This behavior may be removed in * a future release. * * @param returnType the method's return type, or null for constructors. * @param name the method name, or the fully qualified class name for constructors. * @param modifiers the set of modifiers to be applied to the method * @param parameters alternating parameter types and names. * @param throwsTypes the classes to throw, or null for no throws clause. } <BUGS> return this; <BUGE> }  public JavaWriter beginConstructor(Set<Modifier> modifiers, String... parameters) throws IOException { beginMethod(null, types.peekFirst(), modifiers, parameters); return this; }  public JavaWriter beginConstructor(Set<Modifier> modifiers, List<String> parameters, List<String> throwsTypes) throws IOException { beginMethod(null, types.peekFirst(), modifiers, parameters, throwsTypes); return this; }
/** Emits the modifiers to the writer. */ private void emitModifiers(Set<Modifier> modifiers) throws IOException { /* Use an EnumSet to ensure the proper ordering*/ <BUGS> if (!(modifiers instanceof EnumSet)) { modifiers = EnumSet.copyOf(modifiers); <BUGE> } for (Modifier modifier : modifiers) { out.append(modifier.toString()).append(' '); } }
*/ public JavaWriter emitImports(Class<?>... types) throws IOException { <BUGS> List<String> classNames = new ArrayList<String>(types.length); for (Class<?> classToImport : types) { classNames.add(classToImport.getName()); <BUGE> } return emitImports(classNames); }
*/ public JavaWriter emitImports(Class<?>... types) throws IOException { List<String> classNames = new ArrayList<String>(types.length); for (Class<?> classToImport : types) { classNames.add(classToImport.getName()); } <BUGS> return emitImports(classNames); <BUGE> }
*/ public JavaWriter emitAnnotation(String annotation, Map<String, ?> attributes) throws IOException { <BUGS> indent(); out.write("@"); emitType(annotation); if (!attributes.isEmpty()) { out.write("("); pushScope(Scope.ANNOTATION_ATTRIBUTE); boolean firstAttribute = true; for (Map.Entry<String, ?> entry : attributes.entrySet()) { if (firstAttribute) { firstAttribute = false; out.write("\n"); <BUGE> } else { out.write(",\n"); } indent(); out.write(entry.getKey()); out.write(" = "); Object value = entry.getValue(); emitAnnotationValue(value); } popScope(Scope.ANNOTATION_ATTRIBUTE); out.write("\n"); indent(); out.write(")"); } out.write("\n"); return this;
*/ public JavaWriter emitAnnotation(String annotation, Map<String, ?> attributes) throws IOException { indent(); out.write("@"); emitType(annotation); if (!attributes.isEmpty()) { out.write("("); pushScope(Scope.ANNOTATION_ATTRIBUTE); boolean firstAttribute = true; for (Map.Entry<String, ?> entry : attributes.entrySet()) { if (firstAttribute) { firstAttribute = false; out.write("\n"); } else { out.write(",\n"); } <BUGS> indent(); out.write(entry.getKey()); out.write(" = "); Object value = entry.getValue(); emitAnnotationValue(value); } popScope(Scope.ANNOTATION_ATTRIBUTE); out.write("\n"); indent(); out.write(")"); <BUGE> } out.write("\n"); return this;
*/ public JavaWriter emitAnnotation(String annotation, Map<String, ?> attributes) throws IOException { indent(); out.write("@"); emitType(annotation); if (!attributes.isEmpty()) { out.write("("); pushScope(Scope.ANNOTATION_ATTRIBUTE); boolean firstAttribute = true; for (Map.Entry<String, ?> entry : attributes.entrySet()) { if (firstAttribute) { firstAttribute = false; out.write("\n"); } else { out.write(",\n"); } indent(); out.write(entry.getKey()); out.write(" = "); Object value = entry.getValue(); emitAnnotationValue(value); } popScope(Scope.ANNOTATION_ATTRIBUTE); out.write("\n"); indent(); out.write(")"); } <BUGS> out.write("\n"); return this; <BUGE>
/** Returns the string literal representing {@code data}, including wrapping quotes. */
/** Returns the string literal representing {@code data}, including wrapping quotes. */
/** Returns the string literal representing {@code data}, including wrapping quotes. */
/** Returns the string literal representing {@code data}, including wrapping quotes. */
/** Returns the string literal representing {@code data}, including wrapping quotes. */
/** Returns the string literal representing {@code data}, including wrapping quotes. */
private boolean containsArray(Collection<?> values) { <BUGS> for (Object value : values) { if (value instanceof Object[]) { <BUGE> return true; } } return false; }
private boolean containsArray(Collection<?> values) { for (Object value : values) { if (value instanceof Object[]) { return true; } <BUGS> } return false; <BUGE> }
/** Emits some Javadoc comments with line separated by {@code \n}. */
/** Emits some Javadoc comments with line separated by {@code \n}. */
/** Emits some Javadoc comments with line separated by {@code \n}. */
/** Emits some Javadoc comments with line separated by {@code \n}. */
private void checkInMethod() { <BUGS> if (scopes.peekFirst() != Scope.NON_ABSTRACT_METHOD && scopes.peekFirst() != Scope.CONTROL_FLOW && scopes.peekFirst() != Scope.INITIALIZER) { throw new IllegalArgumentException(); <BUGE> } }
/** Emits a field declaration. Should not contain a trailing semicolon. */ public JavaWriter emitField(String type, String name, Set<Modifier> modifiers, String initialValue) throws IOException { <BUGS> indent(); emitModifiers(modifiers); emitCompressedType(type); out.write(" "); out.write(name); <BUGE>  if (initialValue != null) { out.write(" = ");  String[] lines = initialValue.split("\n", -1); out.write(initialValue); for (int i = 1; i < lines.length; i++) { } } out.write(";\n"); return this; }
/** Emits a field declaration. Should not contain a trailing semicolon. */ public JavaWriter emitField(String type, String name, Set<Modifier> modifiers, String initialValue) throws IOException { indent(); emitModifiers(modifiers); emitCompressedType(type); out.write(" "); out.write(name);  <BUGS> if (initialValue != null) { out.write(" = "); <BUGE>  String[] lines = initialValue.split("\n", -1); out.write(initialValue); for (int i = 1; i < lines.length; i++) { } } out.write(";\n"); return this; }
/** Emits a field declaration. Should not contain a trailing semicolon. */ public JavaWriter emitField(String type, String name, Set<Modifier> modifiers, String initialValue) throws IOException { indent(); emitModifiers(modifiers); emitCompressedType(type); out.write(" "); out.write(name);  if (initialValue != null) { out.write(" = ");  <BUGS> String[] lines = initialValue.split("\n", -1); out.write(initialValue); for (int i = 1; i < lines.length; i++) { <BUGE> } } out.write(";\n"); return this; }
/** Emits a field declaration. Should not contain a trailing semicolon. */ public JavaWriter emitField(String type, String name, Set<Modifier> modifiers, String initialValue) throws IOException { indent(); emitModifiers(modifiers); emitCompressedType(type); out.write(" "); out.write(name);  if (initialValue != null) { out.write(" = ");  String[] lines = initialValue.split("\n", -1); out.write(initialValue); for (int i = 1; i < lines.length; i++) { } } <BUGS> out.write(";\n"); return this; <BUGE> }
/** Emits a field declaration. */ public JavaWriter emitField(String type, String name, Set<Modifier> modifiers, String initialValue) throws IOException { <BUGS> indent(); emitModifiers(modifiers); emitCompressedType(type); out.write(" "); out.write(name); <BUGE>  if (initialValue != null) { out.write(" = "); if (!initialValue.startsWith("\n")) { }  String[] lines = initialValue.split("\n", -1); out.write(lines[0]); for (int i = 1; i < lines.length; i++) { out.write("\n"); hangingIndent(); out.write(lines[i]); } } out.write(";\n"); return this; }
/** Emits a field declaration. */ public JavaWriter emitField(String type, String name, Set<Modifier> modifiers, String initialValue) throws IOException { indent(); emitModifiers(modifiers); emitCompressedType(type); out.write(" "); out.write(name);  <BUGS> if (initialValue != null) { out.write(" = "); if (!initialValue.startsWith("\n")) { <BUGE> }  String[] lines = initialValue.split("\n", -1); out.write(lines[0]); for (int i = 1; i < lines.length; i++) { out.write("\n"); hangingIndent(); out.write(lines[i]); } } out.write(";\n"); return this; }
/** Emits a field declaration. */ public JavaWriter emitField(String type, String name, Set<Modifier> modifiers, String initialValue) throws IOException { indent(); emitModifiers(modifiers); emitCompressedType(type); out.write(" "); out.write(name);  if (initialValue != null) { out.write(" = "); if (!initialValue.startsWith("\n")) { }  <BUGS> String[] lines = initialValue.split("\n", -1); out.write(lines[0]); for (int i = 1; i < lines.length; i++) { out.write("\n"); hangingIndent(); out.write(lines[i]); <BUGE> } } out.write(";\n"); return this; }
/** Emits a field declaration. */ public JavaWriter emitField(String type, String name, Set<Modifier> modifiers, String initialValue) throws IOException { indent(); emitModifiers(modifiers); emitCompressedType(type); out.write(" "); out.write(name);  if (initialValue != null) { out.write(" = "); if (!initialValue.startsWith("\n")) { }  String[] lines = initialValue.split("\n", -1); out.write(lines[0]); for (int i = 1; i < lines.length; i++) { out.write("\n"); hangingIndent(); out.write(lines[i]); } } <BUGS> out.write(";\n"); return this; <BUGE> }
*/ public JavaWriter emitImports(String... types) throws IOException { <BUGS> return emitImports(Arrays.asList(types)); <BUGE> }
/** Returns the string literal representing {@code data}, including wrapping quotes. */
/** Returns the string literal representing {@code data}, including wrapping quotes. */
/** Returns the string literal representing {@code data}, including wrapping quotes. */
/** Returns the string literal representing {@code data}, including wrapping quotes. */
/** Returns the string literal representing {@code data}, including wrapping quotes. */
/** Returns the string literal representing {@code data}, including wrapping quotes. */
/** Returns the string literal representing {@code data}, including wrapping quotes. */
@VisibleForTesting static double normalizeLongitude(double d) { <BUGS> double sign = Math.signum(d); double x = Math.abs(d) / 360; double x2 = (x - Math.floor(x)) * 360; if (x2 >= 180) x2 -= 360; return x2 * sign; <BUGE> }
@Override public Geometry geometry() { <BUGS> return this; <BUGE> }
@Override public double distance(Rectangle r) { <BUGS> if (r.contains(x1, y1) || r.contains(x2, y2)) { <BUGE> return 0; } else { double d1 = distance(r.x1(), r.y1(), r.x1(), r.y2()); if (d1 == 0) return 0; double d2 = distance(r.x1(), r.y2(), r.x2(), r.y2()); if (d2 == 0) return 0; double d3 = distance(r.x2(), r.y2(), r.x2(), r.y1()); double d4 = distance(r.x2(), r.y1(), r.x1(), r.y1()); return Math.min(d1, Math.min(d2, Math.min(d3, d4))); } }
@Override public double distance(Rectangle r) { if (r.contains(x1, y1) || r.contains(x2, y2)) { return 0; } else { <BUGS> double d1 = distance(r.x1(), r.y1(), r.x1(), r.y2()); if (d1 == 0) <BUGE> return 0; double d2 = distance(r.x1(), r.y2(), r.x2(), r.y2()); if (d2 == 0) return 0; double d3 = distance(r.x2(), r.y2(), r.x2(), r.y1()); double d4 = distance(r.x2(), r.y1(), r.x1(), r.y1()); return Math.min(d1, Math.min(d2, Math.min(d3, d4))); } }
@Override public double distance(Rectangle r) { if (r.contains(x1, y1) || r.contains(x2, y2)) { return 0; } else { double d1 = distance(r.x1(), r.y1(), r.x1(), r.y2()); if (d1 == 0) return 0; <BUGS> double d2 = distance(r.x1(), r.y2(), r.x2(), r.y2()); if (d2 == 0) <BUGE> return 0; double d3 = distance(r.x2(), r.y2(), r.x2(), r.y1()); double d4 = distance(r.x2(), r.y1(), r.x1(), r.y1()); return Math.min(d1, Math.min(d2, Math.min(d3, d4))); } }
@Override public double distance(Rectangle r) { if (r.contains(x1, y1) || r.contains(x2, y2)) { return 0; } else { double d1 = distance(r.x1(), r.y1(), r.x1(), r.y2()); if (d1 == 0) return 0; double d2 = distance(r.x1(), r.y2(), r.x2(), r.y2()); if (d2 == 0) return 0; <BUGS> double d3 = distance(r.x2(), r.y2(), r.x2(), r.y1()); double d4 = distance(r.x2(), r.y1(), r.x1(), r.y1()); return Math.min(d1, Math.min(d2, Math.min(d3, d4))); <BUGE> } }
private void requestSome(long n) { /* back pressure path*/ /* this algorithm copied roughly from*/ /* rxjava-core/OnSubscribeFromIterable.java*/  /* rxjava used AtomicLongFieldUpdater instead of AtomicLong*/ /* but benchmarks showed no benefit here so reverted to AtomicLong*/ <BUGS> long previousCount = requested.getAndAdd(n); if (previousCount == 0) { <BUGE> /* don't touch stack every time during the loop because*/ /* is a volatile and every write forces a thread memory*/ /* cache flush*/ ImmutableStack<NodePosition<T, S>> st = stack; while (true) { /* minimize atomic reads by assigning to a variable here*/ long r = requested.get(); long numToEmit = r; st = Backpressure.search(condition, subscriber, st, numToEmit); if (st.isEmpty()) { if (!subscriber.isUnsubscribed()) { subscriber.onCompleted(); break; } else break; } else if (requested.addAndGet(-r) == 0) break; } stack = st; }
private void requestSome(long n) { /* back pressure path*/ /* this algorithm copied roughly from*/ /* rxjava-core/OnSubscribeFromIterable.java*/  /* rxjava used AtomicLongFieldUpdater instead of AtomicLong*/ /* but benchmarks showed no benefit here so reverted to AtomicLong*/ long previousCount = requested.getAndAdd(n); if (previousCount == 0) { /* don't touch stack every time during the loop because*/ /* is a volatile and every write forces a thread memory*/ /* cache flush*/ <BUGS> ImmutableStack<NodePosition<T, S>> st = stack; <BUGE> while (true) { /* minimize atomic reads by assigning to a variable here*/ long r = requested.get(); long numToEmit = r; st = Backpressure.search(condition, subscriber, st, numToEmit); if (st.isEmpty()) { if (!subscriber.isUnsubscribed()) { subscriber.onCompleted(); break; } else break; } else if (requested.addAndGet(-r) == 0) break; } stack = st; }
private void requestSome(long n) { /* back pressure path*/ /* this algorithm copied roughly from*/ /* rxjava-core/OnSubscribeFromIterable.java*/  /* rxjava used AtomicLongFieldUpdater instead of AtomicLong*/ /* but benchmarks showed no benefit here so reverted to AtomicLong*/ long previousCount = requested.getAndAdd(n); if (previousCount == 0) { /* don't touch stack every time during the loop because*/ /* is a volatile and every write forces a thread memory*/ /* cache flush*/ ImmutableStack<NodePosition<T, S>> st = stack; while (true) { /* minimize atomic reads by assigning to a variable here*/ <BUGS> long r = requested.get(); long numToEmit = r; st = Backpressure.search(condition, subscriber, st, numToEmit); if (st.isEmpty()) { <BUGE> if (!subscriber.isUnsubscribed()) { subscriber.onCompleted(); break; } else break; } else if (requested.addAndGet(-r) == 0) break; } stack = st; }
private void requestSome(long n) { /* back pressure path*/ /* this algorithm copied roughly from*/ /* rxjava-core/OnSubscribeFromIterable.java*/  /* rxjava used AtomicLongFieldUpdater instead of AtomicLong*/ /* but benchmarks showed no benefit here so reverted to AtomicLong*/ long previousCount = requested.getAndAdd(n); if (previousCount == 0) { /* don't touch stack every time during the loop because*/ /* is a volatile and every write forces a thread memory*/ /* cache flush*/ ImmutableStack<NodePosition<T, S>> st = stack; while (true) { /* minimize atomic reads by assigning to a variable here*/ long r = requested.get(); long numToEmit = r; st = Backpressure.search(condition, subscriber, st, numToEmit); if (st.isEmpty()) { if (!subscriber.isUnsubscribed()) { subscriber.onCompleted(); break; } else break; <BUGS> } else if (requested.addAndGet(-r) == 0) break; } stack = st; <BUGE> }
private void requestSome(long n) { /* back pressure path*/ /* this algorithm copied roughly from*/ /* rxjava-core/OnSubscribeFromIterable.java*/  /* rxjava used AtomicLongFieldUpdater instead of AtomicLong*/ /* but benchmarks showed no benefit here so reverted to AtomicLong*/ long previousCount = requested.getAndAdd(n); if (previousCount == 0) { /* don't touch stack every time during the loop because*/ /* is a volatile and every write forces a thread memory*/ /* cache flush*/ ImmutableStack<NodePosition<T, S>> st = stack; while (true) { /* minimize atomic reads by assigning to a variable here*/ long r = requested.get(); long numToEmit = r; st = Backpressure.search(condition, subscriber, st, numToEmit); if (st.isEmpty()) { if (!subscriber.isUnsubscribed()) { subscriber.onCompleted(); break; } else break; } else if (requested.addAndGet(-r) == 0) break; } stack = st; }
@Override public boolean contains(double x, double y) { <BUGS> return x == x && y == y; <BUGE> }
private static int outcode(double rectX, double rectY, double rectWidth, double rectHeight, double x, double y) { <BUGS> int out = 0; if (rectWidth <= 0) { <BUGE> out |= OUT_LEFT | OUT_RIGHT; } else if (x < rectX) { out |= OUT_LEFT; } else if (x > rectX + rectWidth) { out |= OUT_RIGHT; } if (rectHeight <= 0) { out |= OUT_TOP | OUT_BOTTOM; } else if (y < rectY) { out |= OUT_TOP; } else if (y > rectY + rectHeight) { out |= OUT_BOTTOM; } return out; }
private static int outcode(double rectX, double rectY, double rectWidth, double rectHeight, double x, double y) { int out = 0; if (rectWidth <= 0) { out |= OUT_LEFT | OUT_RIGHT; <BUGS> } else if (x < rectX) { <BUGE> out |= OUT_LEFT; } else if (x > rectX + rectWidth) { out |= OUT_RIGHT; } if (rectHeight <= 0) { out |= OUT_TOP | OUT_BOTTOM; } else if (y < rectY) { out |= OUT_TOP; } else if (y > rectY + rectHeight) { out |= OUT_BOTTOM; } return out; }
private static int outcode(double rectX, double rectY, double rectWidth, double rectHeight, double x, double y) { int out = 0; if (rectWidth <= 0) { out |= OUT_LEFT | OUT_RIGHT; } else if (x < rectX) { out |= OUT_LEFT; <BUGS> } else if (x > rectX + rectWidth) { <BUGE> out |= OUT_RIGHT; } if (rectHeight <= 0) { out |= OUT_TOP | OUT_BOTTOM; } else if (y < rectY) { out |= OUT_TOP; } else if (y > rectY + rectHeight) { out |= OUT_BOTTOM; } return out; }
private static int outcode(double rectX, double rectY, double rectWidth, double rectHeight, double x, double y) { int out = 0; if (rectWidth <= 0) { out |= OUT_LEFT | OUT_RIGHT; } else if (x < rectX) { out |= OUT_LEFT; } else if (x > rectX + rectWidth) { out |= OUT_RIGHT; } <BUGS> if (rectHeight <= 0) { out |= OUT_TOP | OUT_BOTTOM; <BUGE> } else if (y < rectY) { out |= OUT_TOP; } else if (y > rectY + rectHeight) { out |= OUT_BOTTOM; } return out; }
private static int outcode(double rectX, double rectY, double rectWidth, double rectHeight, double x, double y) { int out = 0; if (rectWidth <= 0) { out |= OUT_LEFT | OUT_RIGHT; } else if (x < rectX) { out |= OUT_LEFT; } else if (x > rectX + rectWidth) { out |= OUT_RIGHT; } if (rectHeight <= 0) { out |= OUT_TOP | OUT_BOTTOM; } else if (y < rectY) { out |= OUT_TOP; } else if (y > rectY + rectHeight) { out |= OUT_BOTTOM; } <BUGS> return out; <BUGE> }
private static int outcode(double rectX, double rectY, double rectWidth, double rectHeight, double x, double y) { <BUGS> int out = 0; if (rectWidth <= 0) { <BUGE> out |= OUT_LEFT | OUT_RIGHT; } else if (x < rectX) { out |= OUT_LEFT; } else if (x > rectX + rectWidth) { out |= OUT_RIGHT; } if (rectHeight <= 0) { out |= OUT_TOP | OUT_BOTTOM; } else if (y < rectY) { out |= OUT_TOP; } else if (y > rectY + rectHeight) { out |= OUT_BOTTOM; } return out; }
private static int outcode(double rectX, double rectY, double rectWidth, double rectHeight, double x, double y) { int out = 0; if (rectWidth <= 0) { out |= OUT_LEFT | OUT_RIGHT; <BUGS> } else if (x < rectX) { <BUGE> out |= OUT_LEFT; } else if (x > rectX + rectWidth) { out |= OUT_RIGHT; } if (rectHeight <= 0) { out |= OUT_TOP | OUT_BOTTOM; } else if (y < rectY) { out |= OUT_TOP; } else if (y > rectY + rectHeight) { out |= OUT_BOTTOM; } return out; }
private static int outcode(double rectX, double rectY, double rectWidth, double rectHeight, double x, double y) { int out = 0; if (rectWidth <= 0) { out |= OUT_LEFT | OUT_RIGHT; } else if (x < rectX) { out |= OUT_LEFT; <BUGS> } else if (x > rectX + rectWidth) { <BUGE> out |= OUT_RIGHT; } if (rectHeight <= 0) { out |= OUT_TOP | OUT_BOTTOM; } else if (y < rectY) { out |= OUT_TOP; } else if (y > rectY + rectHeight) { out |= OUT_BOTTOM; } return out; }
private static int outcode(double rectX, double rectY, double rectWidth, double rectHeight, double x, double y) { int out = 0; if (rectWidth <= 0) { out |= OUT_LEFT | OUT_RIGHT; } else if (x < rectX) { out |= OUT_LEFT; } else if (x > rectX + rectWidth) { out |= OUT_RIGHT; } <BUGS> if (rectHeight <= 0) { out |= OUT_TOP | OUT_BOTTOM; <BUGE> } else if (y < rectY) { out |= OUT_TOP; } else if (y > rectY + rectHeight) { out |= OUT_BOTTOM; } return out; }
private static int outcode(double rectX, double rectY, double rectWidth, double rectHeight, double x, double y) { int out = 0; if (rectWidth <= 0) { out |= OUT_LEFT | OUT_RIGHT; } else if (x < rectX) { out |= OUT_LEFT; } else if (x > rectX + rectWidth) { out |= OUT_RIGHT; } if (rectHeight <= 0) { out |= OUT_TOP | OUT_BOTTOM; } else if (y < rectY) { out |= OUT_TOP; } else if (y > rectY + rectHeight) { out |= OUT_BOTTOM; } <BUGS> return out; <BUGE> }
@Override public boolean equals(Object obj) { <BUGS> Optional<Point> other = ObjectsHelper.asClass(obj, Point.class); if (other.isPresent()) { return Objects.equal(mbr, other.get().mbr()); <BUGE> } else return false; }
public boolean intersects(Point point) { <BUGS> return intersects(point.mbr()); <BUGE> }
@VisibleForTesting static byte[] readFully(InputStream is, int numBytes) throws IOException { <BUGS> byte[] b = new byte[numBytes]; int count = 0; int n = is.read(b, count, numBytes - count); if (n == numBytes){ <BUGE> count += n; } else { throw new RuntimeException("unexpected"); } return b; }
@VisibleForTesting static byte[] readFully(InputStream is, int numBytes) throws IOException { byte[] b = new byte[numBytes]; int count = 0; int n = is.read(b, count, numBytes - count); if (n == numBytes){ count += n; } else { <BUGS> throw new RuntimeException("unexpected"); <BUGE> } return b; }
public static Point pointGeographic(double lon, double lat) { <BUGS> return point(normalizeLongitudeDouble(lon), lat); <BUGE> }
@SafeVarargs <BUGS> public CompositeFilter(FilteringOperator operator, Filter<T>... filters) { this.filters = filters; this.operator = operator; } <BUGE>
@SuppressWarnings("unchecked") public Class<T> getActualClass() { <BUGS> if (isPrimitive()) { <BUGE> String simpleN = getSimpleName(); if (simpleN.equals("boolean")) { return (Class<T>) boolean.class; } else if (simpleN.equals("byte")) { return (Class<T>) byte.class; } else if (simpleN.equals("double")) { return (Class<T>) double.class; } else if (simpleN.equals("int")) { return (Class<T>) int.class; } else if (simpleN.equals("short")) { return (Class<T>) short.class; } else if (simpleN.equals("char")) { return (Class<T>) char.class; } else if (simpleN.equals("long")) { return (Class<T>) long.class; } else if (simpleN.equals("float")) { return (Class<T>) float.class; } else if (simpleN.equals("void")) { return (Class<T>) void.class; } } try { return (Class<T>) Thread.currentThread().getContextClassLoader() .loadClass(getQualifiedName()); } catch (Exception e) { /* class cannot be found*/ throw new RuntimeException("cannot load class: "
@SuppressWarnings("unchecked") public Class<T> getActualClass() { if (isPrimitive()) { String simpleN = getSimpleName(); if (simpleN.equals("boolean")) { return (Class<T>) boolean.class; } else if (simpleN.equals("byte")) { return (Class<T>) byte.class; } else if (simpleN.equals("double")) { return (Class<T>) double.class; } else if (simpleN.equals("int")) { return (Class<T>) int.class; } else if (simpleN.equals("short")) { return (Class<T>) short.class; } else if (simpleN.equals("char")) { return (Class<T>) char.class; } else if (simpleN.equals("long")) { return (Class<T>) long.class; } else if (simpleN.equals("float")) { return (Class<T>) float.class; } else if (simpleN.equals("void")) { return (Class<T>) void.class; } } try { <BUGS> return (Class<T>) Thread.currentThread().getContextClassLoader() .loadClass(getQualifiedName()); } catch (Exception e) { <BUGE> /* class cannot be found*/ throw new RuntimeException("cannot load class: "
} if (getSimpleName().equals("short")) { return factory.Type().createReference(Short.class); } if (getSimpleName().equals("byte")) { return factory.Type().createReference(Byte.class); } if (getSimpleName().equals("void")) { return factory.Type().createReference(Void.class); } return this; }  /* class cannot be found*/ <BUGS> throw new RuntimeException("cannot load class: " + getQualifiedName() + " with class loader " + Thread.currentThread().getContextClassLoader(), e); <BUGE> /* return null;*/ } }  public List<CtTypeReference<?>> getActualTypeArguments() { return actualTypeArguments; }  @Override public <A extends Annotation> A getAnnotation(Class<A> annotationType) { A a = super.getAnnotation(annotationType); if (a == null) { /* Couldn't get annotation from CtModel, trying with RT*/ /* reflection*/
@SuppressWarnings("unchecked") public <T> T getElementValue(String key) { <BUGS> Object ret = this.elementValues.get(key); if (ret == null) { <BUGE> ret = getDefaultValue(key); } if (ret == null) { ret = getReflectValue(key); }  Class<?> type = getElementType(key);  if (type.isArray()) { if (!(ret instanceof Collection)) { List<Object> lst = new ArrayList<Object>();  if (ret.getClass().isArray()) { Object[] temp = (Object[]) ret; lst.addAll(Arrays.asList(temp)); } else { lst.add(ret); } ret = lst;  } Collection<?> col = (Collection<?>) ret; Object[] array = (Object[]) Array.newInstance( type.getComponentType(), col.size()); int i = 0; for (Object obj : col) {
@SuppressWarnings("unchecked") public <T> T getElementValue(String key) { Object ret = this.elementValues.get(key); if (ret == null) { ret = getDefaultValue(key); } <BUGS> if (ret == null) { <BUGE> ret = getReflectValue(key); }  Class<?> type = getElementType(key);  if (type.isArray()) { if (!(ret instanceof Collection)) { List<Object> lst = new ArrayList<Object>();  if (ret.getClass().isArray()) { Object[] temp = (Object[]) ret; lst.addAll(Arrays.asList(temp)); } else { lst.add(ret); } ret = lst;  } Collection<?> col = (Collection<?>) ret; Object[] array = (Object[]) Array.newInstance( type.getComponentType(), col.size()); int i = 0; for (Object obj : col) {
@SuppressWarnings("unchecked") public <T> T getElementValue(String key) { Object ret = this.elementValues.get(key); if (ret == null) { ret = getDefaultValue(key); } if (ret == null) { ret = getReflectValue(key); }  <BUGS> Class<?> type = getElementType(key); <BUGE>  if (type.isArray()) { if (!(ret instanceof Collection)) { List<Object> lst = new ArrayList<Object>();  if (ret.getClass().isArray()) { Object[] temp = (Object[]) ret; lst.addAll(Arrays.asList(temp)); } else { lst.add(ret); } ret = lst;  } Collection<?> col = (Collection<?>) ret; Object[] array = (Object[]) Array.newInstance( type.getComponentType(), col.size()); int i = 0; for (Object obj : col) {
@SuppressWarnings("unchecked") public <T> T getElementValue(String key) { Object ret = this.elementValues.get(key); if (ret == null) { ret = getDefaultValue(key); } if (ret == null) { ret = getReflectValue(key); }  Class<?> type = getElementType(key);  <BUGS> if (type.isArray()) { if (!(ret instanceof Collection)) { List<Object> lst = new ArrayList<Object>(); <BUGE>  if (ret.getClass().isArray()) { Object[] temp = (Object[]) ret; lst.addAll(Arrays.asList(temp)); } else { lst.add(ret); } ret = lst;  } Collection<?> col = (Collection<?>) ret; Object[] array = (Object[]) Array.newInstance( type.getComponentType(), col.size()); int i = 0; for (Object obj : col) {
@SuppressWarnings("unchecked") public <T> T getElementValue(String key) { Object ret = this.elementValues.get(key); if (ret == null) { ret = getDefaultValue(key); } if (ret == null) { ret = getReflectValue(key); }  Class<?> type = getElementType(key);  if (type.isArray()) { if (!(ret instanceof Collection)) { List<Object> lst = new ArrayList<Object>();  <BUGS> if (ret.getClass().isArray()) { <BUGE> Object[] temp = (Object[]) ret; lst.addAll(Arrays.asList(temp)); } else { lst.add(ret); } ret = lst;  } Collection<?> col = (Collection<?>) ret; Object[] array = (Object[]) Array.newInstance( type.getComponentType(), col.size()); int i = 0; for (Object obj : col) {
@SuppressWarnings("unchecked") public <T> T getElementValue(String key) { Object ret = this.elementValues.get(key); if (ret == null) { ret = getDefaultValue(key); } if (ret == null) { ret = getReflectValue(key); }  Class<?> type = getElementType(key);  if (type.isArray()) { if (!(ret instanceof Collection)) { List<Object> lst = new ArrayList<Object>();  if (ret.getClass().isArray()) { Object[] temp = (Object[]) ret; lst.addAll(Arrays.asList(temp)); } else { <BUGS> lst.add(ret); <BUGE> } ret = lst;  } Collection<?> col = (Collection<?>) ret; Object[] array = (Object[]) Array.newInstance( type.getComponentType(), col.size()); int i = 0; for (Object obj : col) {
@SuppressWarnings("unchecked") public <T> T getElementValue(String key) { Object ret = this.elementValues.get(key); if (ret == null) { ret = getDefaultValue(key); } if (ret == null) { ret = getReflectValue(key); }  Class<?> type = getElementType(key);  if (type.isArray()) { if (!(ret instanceof Collection)) { List<Object> lst = new ArrayList<Object>();  if (ret.getClass().isArray()) { Object[] temp = (Object[]) ret; lst.addAll(Arrays.asList(temp)); } else { lst.add(ret); } <BUGS> ret = lst; <BUGE>  } Collection<?> col = (Collection<?>) ret; Object[] array = (Object[]) Array.newInstance( type.getComponentType(), col.size()); int i = 0; for (Object obj : col) {
@SuppressWarnings("unchecked") public <T> T getElementValue(String key) { Object ret = this.elementValues.get(key); if (ret == null) { ret = getDefaultValue(key); } if (ret == null) { ret = getReflectValue(key); }  Class<?> type = getElementType(key);  if (type.isArray()) { if (!(ret instanceof Collection)) { List<Object> lst = new ArrayList<Object>();  if (ret.getClass().isArray()) { Object[] temp = (Object[]) ret; lst.addAll(Arrays.asList(temp)); } else { lst.add(ret); } ret = lst;  } <BUGS> Collection<?> col = (Collection<?>) ret; Object[] array = (Object[]) Array.newInstance( type.getComponentType(), col.size()); <BUGE> int i = 0; for (Object obj : col) {
return annotationType; }  private Object getDefaultValue(String fieldName) { Object ret = null; CtAnnotationType<?> at = (CtAnnotationType<?>) getAnnotationType() .getDeclaration(); if (at != null) { CtField<?> f = at.getField(fieldName); ret = f.getDefaultExpression(); } return ret; }  } else { <BUGS> ret = convertValue(ret); <BUGE> }  if (type.isPrimitive()) { if ((type == boolean.class) && (ret.getClass() != boolean.class)) { ret = Boolean.parseBoolean(ret.toString()); } else if ((type == byte.class) && (ret.getClass() != byte.class)) { ret = Byte.parseByte(ret.toString()); } else if ((type == char.class) && (ret.getClass() != char.class)) { ret = ret.toString().charAt(0); } else if ((type == double.class) && (ret.getClass() != double.class)) { ret = Double.parseDouble(ret.toString()); } else if ((type == float.class) && (ret.getClass() != float.class)) { ret = Float.parseFloat(ret.toString());
return annotationType; }  private Object getDefaultValue(String fieldName) { Object ret = null; CtAnnotationType<?> at = (CtAnnotationType<?>) getAnnotationType() .getDeclaration(); if (at != null) { CtField<?> f = at.getField(fieldName); ret = f.getDefaultExpression(); } return ret; }   <BUGS> if (type.isPrimitive()) { if ((type == boolean.class) && (ret.getClass() != boolean.class)) { <BUGE> ret = Boolean.parseBoolean(ret.toString()); } else if ((type == byte.class) && (ret.getClass() != byte.class)) { ret = Byte.parseByte(ret.toString()); } else if ((type == char.class) && (ret.getClass() != char.class)) { ret = ret.toString().charAt(0); } else if ((type == double.class) && (ret.getClass() != double.class)) { ret = Double.parseDouble(ret.toString()); } else if ((type == float.class) && (ret.getClass() != float.class)) { ret = Float.parseFloat(ret.toString()); } else if ((type == int.class) && (ret.getClass() != int.class)) { ret = Integer.parseInt(ret.toString()); } else if ((type == long.class) && (ret.getClass() != long.class)) {
return annotationType; }  private Object getDefaultValue(String fieldName) { Object ret = null; CtAnnotationType<?> at = (CtAnnotationType<?>) getAnnotationType() .getDeclaration(); if (at != null) { CtField<?> f = at.getField(fieldName); ret = f.getDefaultExpression(); } return ret; }  ret = Boolean.parseBoolean(ret.toString()); <BUGS> } else if ((type == byte.class) && (ret.getClass() != byte.class)) { <BUGE> ret = Byte.parseByte(ret.toString()); } else if ((type == char.class) && (ret.getClass() != char.class)) { ret = ret.toString().charAt(0); } else if ((type == double.class) && (ret.getClass() != double.class)) { ret = Double.parseDouble(ret.toString()); } else if ((type == float.class) && (ret.getClass() != float.class)) { ret = Float.parseFloat(ret.toString()); } else if ((type == int.class) && (ret.getClass() != int.class)) { ret = Integer.parseInt(ret.toString()); } else if ((type == long.class) && (ret.getClass() != long.class)) { ret = Long.parseLong(ret.toString()); } else if (type == short.class && ret.getClass() != short.class)
return annotationType; }  private Object getDefaultValue(String fieldName) { Object ret = null; CtAnnotationType<?> at = (CtAnnotationType<?>) getAnnotationType() .getDeclaration(); if (at != null) { CtField<?> f = at.getField(fieldName); ret = f.getDefaultExpression(); } return ret; }  ret = Byte.parseByte(ret.toString()); <BUGS> } else if ((type == char.class) && (ret.getClass() != char.class)) { <BUGE> ret = ret.toString().charAt(0); } else if ((type == double.class) && (ret.getClass() != double.class)) { ret = Double.parseDouble(ret.toString()); } else if ((type == float.class) && (ret.getClass() != float.class)) { ret = Float.parseFloat(ret.toString()); } else if ((type == int.class) && (ret.getClass() != int.class)) { ret = Integer.parseInt(ret.toString()); } else if ((type == long.class) && (ret.getClass() != long.class)) { ret = Long.parseLong(ret.toString()); } else if (type == short.class && ret.getClass() != short.class) { ret = Short.parseShort(ret.toString());
return annotationType; }  private Object getDefaultValue(String fieldName) { Object ret = null; CtAnnotationType<?> at = (CtAnnotationType<?>) getAnnotationType() .getDeclaration(); if (at != null) { CtField<?> f = at.getField(fieldName); ret = f.getDefaultExpression(); } return ret; }  ret = ret.toString().charAt(0); <BUGS> } else if ((type == double.class) <BUGE> && (ret.getClass() != double.class)) { ret = Double.parseDouble(ret.toString()); } else if ((type == float.class) && (ret.getClass() != float.class)) { ret = Float.parseFloat(ret.toString()); } else if ((type == int.class) && (ret.getClass() != int.class)) { ret = Integer.parseInt(ret.toString()); } else if ((type == long.class) && (ret.getClass() != long.class)) { ret = Long.parseLong(ret.toString()); } else if (type == short.class && ret.getClass() != short.class) { ret = Short.parseShort(ret.toString()); } }
return annotationType; }  private Object getDefaultValue(String fieldName) { Object ret = null; CtAnnotationType<?> at = (CtAnnotationType<?>) getAnnotationType() .getDeclaration(); if (at != null) { CtField<?> f = at.getField(fieldName); ret = f.getDefaultExpression(); } return ret; }  ret = Double.parseDouble(ret.toString()); <BUGS> } else if ((type == float.class) && (ret.getClass() != float.class)) { <BUGE> ret = Float.parseFloat(ret.toString()); } else if ((type == int.class) && (ret.getClass() != int.class)) { ret = Integer.parseInt(ret.toString()); } else if ((type == long.class) && (ret.getClass() != long.class)) { ret = Long.parseLong(ret.toString()); } else if (type == short.class && ret.getClass() != short.class) { ret = Short.parseShort(ret.toString()); } } return (T) ret; }
return annotationType; }  private Object getDefaultValue(String fieldName) { Object ret = null; CtAnnotationType<?> at = (CtAnnotationType<?>) getAnnotationType() .getDeclaration(); if (at != null) { CtField<?> f = at.getField(fieldName); ret = f.getDefaultExpression(); } return ret; }  ret = Float.parseFloat(ret.toString()); <BUGS> } else if ((type == int.class) && (ret.getClass() != int.class)) { ret = Integer.parseInt(ret.toString()); <BUGE> } else if ((type == long.class) && (ret.getClass() != long.class)) { ret = Long.parseLong(ret.toString()); } else if (type == short.class && ret.getClass() != short.class) { ret = Short.parseShort(ret.toString()); } } return (T) ret; }  public Map<String, Object> getElementValues() { return elementValues;
return annotationType; }  private Object getDefaultValue(String fieldName) { Object ret = null; CtAnnotationType<?> at = (CtAnnotationType<?>) getAnnotationType() .getDeclaration(); if (at != null) { CtField<?> f = at.getField(fieldName); ret = f.getDefaultExpression(); } return ret; }  } <BUGS> return (T) ret; <BUGE> }  public Map<String, Object> getElementValues() { return elementValues; }  private Object getReflectValue(String fieldname) { try { Class<?> c = getAnnotationType().getActualClass(); Method m = c.getMethod(fieldname); return m.getDefaultValue(); } catch (Exception e) { throw new RuntimeException(e); }
@Override public boolean visit(TypeDeclaration typeDeclaration, CompilationUnitScope scope) {  <BUGS> if (new String(typeDeclaration.name).equals("package-info")) { CtPackage pack = factory.Package() .getOrCreate( <BUGE> new String(typeDeclaration.binding.fPackage .readableName())); context.enter(pack, typeDeclaration);  /* AST bug HACK*/ if (typeDeclaration.annotations != null) for (Annotation a : typeDeclaration.annotations) { a.traverse(this, (BlockScope) null); } return true; } else { CtSimpleType<?> type = createType(typeDeclaration);  type.setDocComment(getJavaDoc(typeDeclaration.javadoc, scope.referenceContext));  CtPackage pack = null; if (typeDeclaration.binding.fPackage.shortReadableName() != null && typeDeclaration.binding.fPackage.shortReadableName().length > 0) { pack = factory.Package().getOrCreate( new String(typeDeclaration.binding.fPackage .shortReadableName())); } else {
@Override public boolean visit(TypeDeclaration typeDeclaration, CompilationUnitScope scope) {  if (new String(typeDeclaration.name).equals("package-info")) { CtPackage pack = factory.Package() .getOrCreate( new String(typeDeclaration.binding.fPackage <BUGS> .readableName())); context.enter(pack, typeDeclaration); <BUGE>  /* AST bug HACK*/ if (typeDeclaration.annotations != null) for (Annotation a : typeDeclaration.annotations) { a.traverse(this, (BlockScope) null); } return true; } else { CtSimpleType<?> type = createType(typeDeclaration);  type.setDocComment(getJavaDoc(typeDeclaration.javadoc, scope.referenceContext));  CtPackage pack = null; if (typeDeclaration.binding.fPackage.shortReadableName() != null && typeDeclaration.binding.fPackage.shortReadableName().length > 0) { pack = factory.Package().getOrCreate( new String(typeDeclaration.binding.fPackage .shortReadableName())); } else {
@Override public boolean visit(TypeDeclaration typeDeclaration, CompilationUnitScope scope) {  if (new String(typeDeclaration.name).equals("package-info")) { CtPackage pack = factory.Package() .getOrCreate( new String(typeDeclaration.binding.fPackage .readableName())); context.enter(pack, typeDeclaration);  /* AST bug HACK*/ <BUGS> if (typeDeclaration.annotations != null) for (Annotation a : typeDeclaration.annotations) { a.traverse(this, (BlockScope) null); <BUGE> } return true; } else { CtSimpleType<?> type = createType(typeDeclaration);  type.setDocComment(getJavaDoc(typeDeclaration.javadoc, scope.referenceContext));  CtPackage pack = null; if (typeDeclaration.binding.fPackage.shortReadableName() != null && typeDeclaration.binding.fPackage.shortReadableName().length > 0) { pack = factory.Package().getOrCreate( new String(typeDeclaration.binding.fPackage .shortReadableName())); } else {
@Override public boolean visit(TypeDeclaration typeDeclaration, CompilationUnitScope scope) {  if (new String(typeDeclaration.name).equals("package-info")) { CtPackage pack = factory.Package() .getOrCreate( new String(typeDeclaration.binding.fPackage .readableName())); context.enter(pack, typeDeclaration);  /* AST bug HACK*/ if (typeDeclaration.annotations != null) for (Annotation a : typeDeclaration.annotations) { a.traverse(this, (BlockScope) null); } <BUGS> return true; <BUGE> } else { CtSimpleType<?> type = createType(typeDeclaration);  type.setDocComment(getJavaDoc(typeDeclaration.javadoc, scope.referenceContext));  CtPackage pack = null; if (typeDeclaration.binding.fPackage.shortReadableName() != null && typeDeclaration.binding.fPackage.shortReadableName().length > 0) { pack = factory.Package().getOrCreate( new String(typeDeclaration.binding.fPackage .shortReadableName())); } else {
@Override public boolean visit(TypeDeclaration typeDeclaration, CompilationUnitScope scope) {  if (new String(typeDeclaration.name).equals("package-info")) { CtPackage pack = factory.Package() .getOrCreate( new String(typeDeclaration.binding.fPackage .readableName())); context.enter(pack, typeDeclaration);  /* AST bug HACK*/ if (typeDeclaration.annotations != null) for (Annotation a : typeDeclaration.annotations) { a.traverse(this, (BlockScope) null); } return true; } else { <BUGS> CtSimpleType<?> type = createType(typeDeclaration); <BUGE>  type.setDocComment(getJavaDoc(typeDeclaration.javadoc, scope.referenceContext));  CtPackage pack = null; if (typeDeclaration.binding.fPackage.shortReadableName() != null && typeDeclaration.binding.fPackage.shortReadableName().length > 0) { pack = factory.Package().getOrCreate( new String(typeDeclaration.binding.fPackage .shortReadableName())); } else {
@Override public boolean visit(TypeDeclaration typeDeclaration, CompilationUnitScope scope) {  if (new String(typeDeclaration.name).equals("package-info")) { CtPackage pack = factory.Package() .getOrCreate( new String(typeDeclaration.binding.fPackage .readableName())); context.enter(pack, typeDeclaration);  /* AST bug HACK*/ if (typeDeclaration.annotations != null) for (Annotation a : typeDeclaration.annotations) { a.traverse(this, (BlockScope) null); } return true; } else { CtSimpleType<?> type = createType(typeDeclaration);  <BUGS> type.setDocComment(getJavaDoc(typeDeclaration.javadoc, <BUGE> scope.referenceContext));  CtPackage pack = null; if (typeDeclaration.binding.fPackage.shortReadableName() != null && typeDeclaration.binding.fPackage.shortReadableName().length > 0) { pack = factory.Package().getOrCreate( new String(typeDeclaration.binding.fPackage .shortReadableName())); } else {
@Override public boolean visit(TypeDeclaration typeDeclaration, CompilationUnitScope scope) {  if (new String(typeDeclaration.name).equals("package-info")) { CtPackage pack = factory.Package() .getOrCreate( new String(typeDeclaration.binding.fPackage .readableName())); context.enter(pack, typeDeclaration);  /* AST bug HACK*/ if (typeDeclaration.annotations != null) for (Annotation a : typeDeclaration.annotations) { a.traverse(this, (BlockScope) null); } return true; } else { CtSimpleType<?> type = createType(typeDeclaration);  type.setDocComment(getJavaDoc(typeDeclaration.javadoc, scope.referenceContext));  <BUGS> CtPackage pack = null; if (typeDeclaration.binding.fPackage.shortReadableName() != null && typeDeclaration.binding.fPackage.shortReadableName().length > 0) { pack = factory.Package().getOrCreate( <BUGE> new String(typeDeclaration.binding.fPackage .shortReadableName())); } else {
@Override public boolean visit(TypeDeclaration typeDeclaration, CompilationUnitScope scope) {  if (new String(typeDeclaration.name).equals("package-info")) { CtPackage pack = factory.Package() .getOrCreate( new String(typeDeclaration.binding.fPackage .readableName())); context.enter(pack, typeDeclaration);  /* AST bug HACK*/ if (typeDeclaration.annotations != null) for (Annotation a : typeDeclaration.annotations) { a.traverse(this, (BlockScope) null); } return true; } else { CtSimpleType<?> type = createType(typeDeclaration);  type.setDocComment(getJavaDoc(typeDeclaration.javadoc, scope.referenceContext));  CtPackage pack = null; if (typeDeclaration.binding.fPackage.shortReadableName() != null && typeDeclaration.binding.fPackage.shortReadableName().length > 0) { pack = factory.Package().getOrCreate( new String(typeDeclaration.binding.fPackage <BUGS> .shortReadableName())); <BUGE> } else {
type.setDocComment(getJavaDoc(memberTypeDeclaration.javadoc, scope.referenceCompilationUnit())); context.enter(type, memberTypeDeclaration);  /* AST bug HACK*/ if (memberTypeDeclaration.annotations != null) for (Annotation a : memberTypeDeclaration.annotations) { a.traverse(this, (BlockScope) null); }  return true; }  } <BUGS> context.enter(pack, typeDeclaration); context.compilationunitdeclaration = scope.referenceContext; context.enter(type, typeDeclaration); <BUGE>  /* AST bug HACK*/ if (typeDeclaration.annotations != null) for (Annotation a : typeDeclaration.annotations) { a.traverse(this, (BlockScope) null); }  if (typeDeclaration.memberTypes != null) { int length = typeDeclaration.memberTypes.length; for (int i = 0; i < length; i++) typeDeclaration.memberTypes[i].traverse(this, typeDeclaration.scope); }
CtSimpleType<?> type = createType(memberTypeDeclaration); type.setDocComment(getJavaDoc(memberTypeDeclaration.javadoc, scope.referenceCompilationUnit())); context.enter(type, memberTypeDeclaration);  /* AST bug HACK*/ if (memberTypeDeclaration.annotations != null) for (Annotation a : memberTypeDeclaration.annotations) { a.traverse(this, (BlockScope) null); }  return true; }  /* AST bug HACK*/ <BUGS> if (typeDeclaration.annotations != null) <BUGE> for (Annotation a : typeDeclaration.annotations) { a.traverse(this, (BlockScope) null); }  if (typeDeclaration.memberTypes != null) { int length = typeDeclaration.memberTypes.length; for (int i = 0; i < length; i++) typeDeclaration.memberTypes[i].traverse(this, typeDeclaration.scope); } if (typeDeclaration.fields != null) { int length = typeDeclaration.fields.length; for (int i = 0; i < length; i++) { FieldDeclaration field;
CtSimpleType<?> type = createType(memberTypeDeclaration); type.setDocComment(getJavaDoc(memberTypeDeclaration.javadoc, scope.referenceCompilationUnit())); context.enter(type, memberTypeDeclaration);  /* AST bug HACK*/ if (memberTypeDeclaration.annotations != null) for (Annotation a : memberTypeDeclaration.annotations) { a.traverse(this, (BlockScope) null); }  return true; }   <BUGS> if (typeDeclaration.memberTypes != null) { <BUGE> int length = typeDeclaration.memberTypes.length; for (int i = 0; i < length; i++) typeDeclaration.memberTypes[i].traverse(this, typeDeclaration.scope); } if (typeDeclaration.fields != null) { int length = typeDeclaration.fields.length; for (int i = 0; i < length; i++) { FieldDeclaration field; if ((field = typeDeclaration.fields[i]).isStatic()) { field.traverse(this, typeDeclaration.staticInitializerScope); } else { field.traverse(this, typeDeclaration.initializerScope);
CtSimpleType<?> type = createType(memberTypeDeclaration); type.setDocComment(getJavaDoc(memberTypeDeclaration.javadoc, scope.referenceCompilationUnit())); context.enter(type, memberTypeDeclaration);  /* AST bug HACK*/ if (memberTypeDeclaration.annotations != null) for (Annotation a : memberTypeDeclaration.annotations) { a.traverse(this, (BlockScope) null); }  return true; }  } <BUGS> if (typeDeclaration.fields != null) { <BUGE> int length = typeDeclaration.fields.length; for (int i = 0; i < length; i++) { FieldDeclaration field; if ((field = typeDeclaration.fields[i]).isStatic()) { field.traverse(this, typeDeclaration.staticInitializerScope); } else { field.traverse(this, typeDeclaration.initializerScope); } } } if (typeDeclaration.methods != null) { int length = typeDeclaration.methods.length; for (int i = 0; i < length; i++)
type.setDocComment(getJavaDoc(memberTypeDeclaration.javadoc, scope.referenceCompilationUnit())); context.enter(type, memberTypeDeclaration);  /* AST bug HACK*/ if (memberTypeDeclaration.annotations != null) for (Annotation a : memberTypeDeclaration.annotations) { a.traverse(this, (BlockScope) null); }  return true; }  } <BUGS> if (typeDeclaration.methods != null) { int length = typeDeclaration.methods.length; for (int i = 0; i < length; i++) typeDeclaration.methods[i].traverse(this, <BUGE> typeDeclaration.scope); } return false; } }  @Override public boolean visit(UnaryExpression unaryExpression, BlockScope scope) { CtUnaryOperator<?> op = factory.Core().createUnaryOperator(); op.setKind(getUnaryOperator((unaryExpression.bits & ASTNode.OperatorMASK) >> ASTNode.OperatorSHIFT)); context.enter(op, unaryExpression); return true;
CtSimpleType<?> type = createType(memberTypeDeclaration); type.setDocComment(getJavaDoc(memberTypeDeclaration.javadoc, scope.referenceCompilationUnit())); context.enter(type, memberTypeDeclaration);  /* AST bug HACK*/ if (memberTypeDeclaration.annotations != null) for (Annotation a : memberTypeDeclaration.annotations) { a.traverse(this, (BlockScope) null); }  return true; }  } <BUGS> return false; <BUGE> } }  @Override public boolean visit(UnaryExpression unaryExpression, BlockScope scope) { CtUnaryOperator<?> op = factory.Core().createUnaryOperator(); op.setKind(getUnaryOperator((unaryExpression.bits & ASTNode.OperatorMASK) >> ASTNode.OperatorSHIFT)); context.enter(op, unaryExpression); return true; }  @Override public boolean visit(WhileStatement whileStatement, BlockScope scope) { CtWhile w = factory.Core().createWhile();
public <T> void visitCtConstructor(CtConstructor<T> c) { <BUGS> visitCtNamedElement(c); writeGenericsParameter(c.getFormalTypeParameters()); write(c.getDeclaringType().getSimpleName()); write("("); if (c.getParameters().size() > 0) { for (CtParameter<?> p : c.getParameters()) { visitCtParameter(p); write(" ,"); } removeLastChar(); <BUGE> } write(") "); if ((c.getThrownTypes() != null) && (c.getThrownTypes().size() > 0)) { write("throws "); for (CtTypeReference<?> ref : c.getThrownTypes()) { scan(ref); write(" , "); } removeLastChar(); write(" "); } scan(c.getBody()); }
public <T> void visitCtConstructor(CtConstructor<T> c) { visitCtNamedElement(c); writeGenericsParameter(c.getFormalTypeParameters()); write(c.getDeclaringType().getSimpleName()); write("("); if (c.getParameters().size() > 0) { for (CtParameter<?> p : c.getParameters()) { visitCtParameter(p); write(" ,"); } removeLastChar(); } <BUGS> write(") "); if ((c.getThrownTypes() != null) && (c.getThrownTypes().size() > 0)) { <BUGE> write("throws "); for (CtTypeReference<?> ref : c.getThrownTypes()) { scan(ref); write(" , "); } removeLastChar(); write(" "); } scan(c.getBody()); }
public <T> void visitCtConstructor(CtConstructor<T> c) { visitCtNamedElement(c); writeGenericsParameter(c.getFormalTypeParameters()); write(c.getDeclaringType().getSimpleName()); write("("); if (c.getParameters().size() > 0) { for (CtParameter<?> p : c.getParameters()) { visitCtParameter(p); write(" ,"); } removeLastChar(); } write(") "); if ((c.getThrownTypes() != null) && (c.getThrownTypes().size() > 0)) { write("throws "); for (CtTypeReference<?> ref : c.getThrownTypes()) { scan(ref); write(" , "); } removeLastChar(); write(" "); } <BUGS> scan(c.getBody()); } <BUGE>
*/ public static SpoonFolder createFolder(File f) throws FileNotFoundException { <BUGS> if (!f.exists()) { <BUGE> throw new FileNotFoundException(f.toString() + " does not exist"); } try { if (f.isDirectory()) { return new FileSystemFolder(f); } if (isArchive(f)) { return new ZipFolder(f); } } catch (IOException e) { Launcher.logger.error(e.getMessage(), e); }  return null; }
*/ public static SpoonFolder createFolder(File f) throws FileNotFoundException { if (!f.exists()) { throw new FileNotFoundException(f.toString() + " does not exist"); } try { <BUGS> if (f.isDirectory()) { <BUGE> return new FileSystemFolder(f); } if (isArchive(f)) { return new ZipFolder(f); } } catch (IOException e) { Launcher.logger.error(e.getMessage(), e); }  return null; }
*/ public static SpoonFolder createFolder(File f) throws FileNotFoundException { if (!f.exists()) { throw new FileNotFoundException(f.toString() + " does not exist"); } try { if (f.isDirectory()) { return new FileSystemFolder(f); } <BUGS> if (isArchive(f)) { return new ZipFolder(f); <BUGE> } } catch (IOException e) { Launcher.logger.error(e.getMessage(), e); }  return null; }
public <T, A extends T> CtOperatorAssignment<T, A> createOperatorAssignment() { <BUGS> CtOperatorAssignment<T, A> e = new CtOperatorAssignmentImpl<T, A>(); e.setFactory(getMainFactory()); return e; <BUGE> }
/** returns the current factory */ public Factory getFactory() { <BUGS> return factory; <BUGE> }
*/ public EvalFactory Eval() { <BUGS> if (Eval == null) { Eval = new EvalFactory(this); <BUGE> } return Eval; }
*/ public EvalFactory Eval() { if (Eval == null) { Eval = new EvalFactory(this); } <BUGS> return Eval; <BUGE> }
*/ public Slack icon(String imageOrIcon) {  <BUGS> this.icon = imageOrIcon; return this; <BUGE> }
public void setExternalFileAttributes(byte[] externalFileAttributes) { <BUGS> this.externalFileAttributes = externalFileAttributes; } <BUGE>
private static FileHeader getFileHeaderWithExactMatch(ZipModel zipModel, String fileName) throws ZipException { <BUGS> if (zipModel == null) { <BUGE> throw new ZipException("zip model is null, cannot determine file header with exact match for fileName: " + fileName); }  if (!isStringNotNullAndNotEmpty(fileName)) { throw new ZipException("file name is null, cannot determine file header with exact match for fileName: " + fileName); }  if (zipModel.getCentralDirectory() == null) { throw new ZipException("central directory is null, cannot determine file header with exact match for fileName: " + fileName); }  if (zipModel.getCentralDirectory().getFileHeaders() == null) { throw new ZipException("file Headers are null, cannot determine file header with exact match for fileName: " + fileName); }  if (zipModel.getCentralDirectory().getFileHeaders().size() == 0) { return null; }  for (FileHeader fileHeader : zipModel.getCentralDirectory().getFileHeaders()) { String fileNameForHdr = fileHeader.getFileName(); if (!isStringNotNullAndNotEmpty(fileNameForHdr)) { continue;
private static FileHeader getFileHeaderWithExactMatch(ZipModel zipModel, String fileName) throws ZipException { if (zipModel == null) { throw new ZipException("zip model is null, cannot determine file header with exact match for fileName: " + fileName); }  <BUGS> if (!isStringNotNullAndNotEmpty(fileName)) { <BUGE> throw new ZipException("file name is null, cannot determine file header with exact match for fileName: " + fileName); }  if (zipModel.getCentralDirectory() == null) { throw new ZipException("central directory is null, cannot determine file header with exact match for fileName: " + fileName); }  if (zipModel.getCentralDirectory().getFileHeaders() == null) { throw new ZipException("file Headers are null, cannot determine file header with exact match for fileName: " + fileName); }  if (zipModel.getCentralDirectory().getFileHeaders().size() == 0) { return null; }  for (FileHeader fileHeader : zipModel.getCentralDirectory().getFileHeaders()) { String fileNameForHdr = fileHeader.getFileName(); if (!isStringNotNullAndNotEmpty(fileNameForHdr)) { continue;
private static FileHeader getFileHeaderWithExactMatch(ZipModel zipModel, String fileName) throws ZipException { if (zipModel == null) { throw new ZipException("zip model is null, cannot determine file header with exact match for fileName: " + fileName); }  if (!isStringNotNullAndNotEmpty(fileName)) { throw new ZipException("file name is null, cannot determine file header with exact match for fileName: " + fileName); }  <BUGS> if (zipModel.getCentralDirectory() == null) { <BUGE> throw new ZipException("central directory is null, cannot determine file header with exact match for fileName: " + fileName); }  if (zipModel.getCentralDirectory().getFileHeaders() == null) { throw new ZipException("file Headers are null, cannot determine file header with exact match for fileName: " + fileName); }  if (zipModel.getCentralDirectory().getFileHeaders().size() == 0) { return null; }  for (FileHeader fileHeader : zipModel.getCentralDirectory().getFileHeaders()) { String fileNameForHdr = fileHeader.getFileName(); if (!isStringNotNullAndNotEmpty(fileNameForHdr)) { continue;
private static FileHeader getFileHeaderWithExactMatch(ZipModel zipModel, String fileName) throws ZipException { if (zipModel == null) { throw new ZipException("zip model is null, cannot determine file header with exact match for fileName: " + fileName); }  if (!isStringNotNullAndNotEmpty(fileName)) { throw new ZipException("file name is null, cannot determine file header with exact match for fileName: " + fileName); }  if (zipModel.getCentralDirectory() == null) { throw new ZipException("central directory is null, cannot determine file header with exact match for fileName: " + fileName); }  <BUGS> if (zipModel.getCentralDirectory().getFileHeaders() == null) { <BUGE> throw new ZipException("file Headers are null, cannot determine file header with exact match for fileName: " + fileName); }  if (zipModel.getCentralDirectory().getFileHeaders().size() == 0) { return null; }  for (FileHeader fileHeader : zipModel.getCentralDirectory().getFileHeaders()) { String fileNameForHdr = fileHeader.getFileName(); if (!isStringNotNullAndNotEmpty(fileNameForHdr)) { continue;
private static FileHeader getFileHeaderWithExactMatch(ZipModel zipModel, String fileName) throws ZipException { if (zipModel == null) { throw new ZipException("zip model is null, cannot determine file header with exact match for fileName: " + fileName); }  if (!isStringNotNullAndNotEmpty(fileName)) { throw new ZipException("file name is null, cannot determine file header with exact match for fileName: " + fileName); }  if (zipModel.getCentralDirectory() == null) { throw new ZipException("central directory is null, cannot determine file header with exact match for fileName: " + fileName); }  if (zipModel.getCentralDirectory().getFileHeaders() == null) { throw new ZipException("file Headers are null, cannot determine file header with exact match for fileName: " + fileName); }  <BUGS> if (zipModel.getCentralDirectory().getFileHeaders().size() == 0) { <BUGE> return null; }  for (FileHeader fileHeader : zipModel.getCentralDirectory().getFileHeaders()) { String fileNameForHdr = fileHeader.getFileName(); if (!isStringNotNullAndNotEmpty(fileNameForHdr)) { continue;
private static FileHeader getFileHeaderWithExactMatch(ZipModel zipModel, String fileName) throws ZipException { if (zipModel == null) { throw new ZipException("zip model is null, cannot determine file header with exact match for fileName: " + fileName); }  if (!isStringNotNullAndNotEmpty(fileName)) { throw new ZipException("file name is null, cannot determine file header with exact match for fileName: " + fileName); }  if (zipModel.getCentralDirectory() == null) { throw new ZipException("central directory is null, cannot determine file header with exact match for fileName: " + fileName); }  if (zipModel.getCentralDirectory().getFileHeaders() == null) { throw new ZipException("file Headers are null, cannot determine file header with exact match for fileName: " + fileName); }  if (zipModel.getCentralDirectory().getFileHeaders().size() == 0) { return null; }  <BUGS> for (FileHeader fileHeader : zipModel.getCentralDirectory().getFileHeaders()) { String fileNameForHdr = fileHeader.getFileName(); if (!isStringNotNullAndNotEmpty(fileNameForHdr)) { <BUGE> continue;
return -1; }  public static String decodeStringWithCharset(byte[] data, boolean isUtf8Encoded) { if (isUtf8Encoded) { return new String(data, StandardCharsets.UTF_8); }  try { return new String(data, ZIP_STANDARD_CHARSET); } catch (UnsupportedEncodingException e) { return new String(data); } }  <BUGS> if (fileName.equalsIgnoreCase(fileNameForHdr)) { <BUGE> return fileHeader; } }  return null; } }
return -1; }  public static String decodeStringWithCharset(byte[] data, boolean isUtf8Encoded) { if (isUtf8Encoded) { return new String(data, StandardCharsets.UTF_8); }  try { return new String(data, ZIP_STANDARD_CHARSET); } catch (UnsupportedEncodingException e) { return new String(data); } } } <BUGS> } <BUGE>  return null; } }
return -1; }  public static String decodeStringWithCharset(byte[] data, boolean isUtf8Encoded) { if (isUtf8Encoded) { return new String(data, StandardCharsets.UTF_8); }  try { return new String(data, ZIP_STANDARD_CHARSET); } catch (UnsupportedEncodingException e) { return new String(data); } }  <BUGS> return null; <BUGE> } }
*/ public void addFile(File fileToAdd, ZipParameters parameters) throws ZipException { <BUGS> addFiles(Collections.singletonList(fileToAdd), parameters); } <BUGE>
*/ public void addFile(File fileToAdd) throws ZipException { <BUGS> addFiles(Collections.singletonList(fileToAdd), new ZipParameters()); } <BUGE>
private void verifyContent(byte[] storedMac) throws IOException { <BUGS> if (getLocalFileHeader().isDataDescriptorExists() && CompressionMethod.DEFLATE.equals(Zip4jUtil.getCompressionMethod(getLocalFileHeader()))) { <BUGE> /* Skip content verification in case of Deflate compression and if data descriptor exists.*/ /* In this case, we do not know the exact size of compressed data before hand and it is possible that we read*/ /* and pass more than required data into inflater, thereby corrupting the aes mac bytes.*/ /* See usage of PushBackInputStream in the project for how this push back of data is done*/ /* Unfortunately, in this case we cannot perform a content verification and have to skip*/ return; }  byte[] calculatedMac = getDecrypter().getCalculatedAuthenticationBytes(); byte[] first10BytesOfCalculatedMac = new byte[AES_AUTH_LENGTH]; System.arraycopy(calculatedMac, 0, first10BytesOfCalculatedMac, 0, InternalZipConstants.AES_AUTH_LENGTH);  if (!Arrays.equals(storedMac, first10BytesOfCalculatedMac)) { throw new IOException("Reached end of data for this entry, but aes verification failed"); } }
private void verifyContent(byte[] storedMac) throws IOException { if (getLocalFileHeader().isDataDescriptorExists() && CompressionMethod.DEFLATE.equals(Zip4jUtil.getCompressionMethod(getLocalFileHeader()))) { /* Skip content verification in case of Deflate compression and if data descriptor exists.*/ /* In this case, we do not know the exact size of compressed data before hand and it is possible that we read*/ /* and pass more than required data into inflater, thereby corrupting the aes mac bytes.*/ /* See usage of PushBackInputStream in the project for how this push back of data is done*/ /* Unfortunately, in this case we cannot perform a content verification and have to skip*/ <BUGS> return; <BUGE> }  byte[] calculatedMac = getDecrypter().getCalculatedAuthenticationBytes(); byte[] first10BytesOfCalculatedMac = new byte[AES_AUTH_LENGTH]; System.arraycopy(calculatedMac, 0, first10BytesOfCalculatedMac, 0, InternalZipConstants.AES_AUTH_LENGTH);  if (!Arrays.equals(storedMac, first10BytesOfCalculatedMac)) { throw new IOException("Reached end of data for this entry, but aes verification failed"); } }
*/ private void readZipInfo() throws ZipException { <BUGS> if (zipModel != null) { <BUGE> return; }  if (!zipFile.exists()) { createNewZipModel(); return; }  if (!zipFile.canRead()) { throw new ZipException("no read access for the input zip file"); }  try (RandomAccessFile randomAccessFile = new RandomAccessFile(zipFile, RandomAccessFileMode.READ.getValue())) { HeaderReader headerReader = new HeaderReader(); zipModel = headerReader.readAllHeaders(randomAccessFile, charset); zipModel.setZipFile(zipFile); } catch (ZipException e) { throw e; } catch (IOException e) { throw new ZipException(e); } }
*/ private void readZipInfo() throws ZipException { if (zipModel != null) { return; }  <BUGS> if (!zipFile.exists()) { <BUGE> createNewZipModel(); return; }  if (!zipFile.canRead()) { throw new ZipException("no read access for the input zip file"); }  try (RandomAccessFile randomAccessFile = new RandomAccessFile(zipFile, RandomAccessFileMode.READ.getValue())) { HeaderReader headerReader = new HeaderReader(); zipModel = headerReader.readAllHeaders(randomAccessFile, charset); zipModel.setZipFile(zipFile); } catch (ZipException e) { throw e; } catch (IOException e) { throw new ZipException(e); } }
*/ private void readZipInfo() throws ZipException { if (zipModel != null) { return; }  if (!zipFile.exists()) { createNewZipModel(); return; }  <BUGS> if (!zipFile.canRead()) { <BUGE> throw new ZipException("no read access for the input zip file"); }  try (RandomAccessFile randomAccessFile = new RandomAccessFile(zipFile, RandomAccessFileMode.READ.getValue())) { HeaderReader headerReader = new HeaderReader(); zipModel = headerReader.readAllHeaders(randomAccessFile, charset); zipModel.setZipFile(zipFile); } catch (ZipException e) { throw e; } catch (IOException e) { throw new ZipException(e); } }
*/ private void readZipInfo() throws ZipException { if (zipModel != null) { return; }  if (!zipFile.exists()) { createNewZipModel(); return; }  if (!zipFile.canRead()) { throw new ZipException("no read access for the input zip file"); }  <BUGS> try (RandomAccessFile randomAccessFile = new RandomAccessFile(zipFile, RandomAccessFileMode.READ.getValue())) { HeaderReader headerReader = new HeaderReader(); zipModel = headerReader.readAllHeaders(randomAccessFile, charset); <BUGE> zipModel.setZipFile(zipFile); } catch (ZipException e) { throw e; } catch (IOException e) { throw new ZipException(e); } }
*/ private void readZipInfo() throws ZipException { if (zipModel != null) { return; }  if (!zipFile.exists()) { createNewZipModel(); return; }  if (!zipFile.canRead()) { throw new ZipException("no read access for the input zip file"); }  try (RandomAccessFile randomAccessFile = new RandomAccessFile(zipFile, RandomAccessFileMode.READ.getValue())) { HeaderReader headerReader = new HeaderReader(); zipModel = headerReader.readAllHeaders(randomAccessFile, charset); zipModel.setZipFile(zipFile); <BUGS> } catch (ZipException e) { throw e; <BUGE> } catch (IOException e) { throw new ZipException(e); } }
*/ private void readZipInfo() throws ZipException { <BUGS> if (zipModel != null) { <BUGE> return; }  if (!zipFile.exists()) { createNewZipModel(); return; }  if (!zipFile.canRead()) { throw new ZipException("no read access for the input zip file"); }  try (RandomAccessFile randomAccessFile = new RandomAccessFile(zipFile, RandomAccessFileMode.READ.getValue())) { HeaderReader headerReader = new HeaderReader(); zipModel = headerReader.readAllHeaders(randomAccessFile, charset); zipModel.setZipFile(zipFile); } catch (ZipException e) { throw e; } catch (IOException e) { throw new ZipException(e); } }
*/ private void readZipInfo() throws ZipException { if (zipModel != null) { return; }  <BUGS> if (!zipFile.exists()) { <BUGE> createNewZipModel(); return; }  if (!zipFile.canRead()) { throw new ZipException("no read access for the input zip file"); }  try (RandomAccessFile randomAccessFile = new RandomAccessFile(zipFile, RandomAccessFileMode.READ.getValue())) { HeaderReader headerReader = new HeaderReader(); zipModel = headerReader.readAllHeaders(randomAccessFile, charset); zipModel.setZipFile(zipFile); } catch (ZipException e) { throw e; } catch (IOException e) { throw new ZipException(e); } }
*/ private void readZipInfo() throws ZipException { if (zipModel != null) { return; }  if (!zipFile.exists()) { createNewZipModel(); return; }  <BUGS> if (!zipFile.canRead()) { <BUGE> throw new ZipException("no read access for the input zip file"); }  try (RandomAccessFile randomAccessFile = new RandomAccessFile(zipFile, RandomAccessFileMode.READ.getValue())) { HeaderReader headerReader = new HeaderReader(); zipModel = headerReader.readAllHeaders(randomAccessFile, charset); zipModel.setZipFile(zipFile); } catch (ZipException e) { throw e; } catch (IOException e) { throw new ZipException(e); } }
*/ private void readZipInfo() throws ZipException { if (zipModel != null) { return; }  if (!zipFile.exists()) { createNewZipModel(); return; }  if (!zipFile.canRead()) { throw new ZipException("no read access for the input zip file"); }  <BUGS> try (RandomAccessFile randomAccessFile = new RandomAccessFile(zipFile, RandomAccessFileMode.READ.getValue())) { HeaderReader headerReader = new HeaderReader(); zipModel = headerReader.readAllHeaders(randomAccessFile, charset); <BUGE> zipModel.setZipFile(zipFile); } catch (ZipException e) { throw e; } catch (IOException e) { throw new ZipException(e); } }
*/ private void readZipInfo() throws ZipException { if (zipModel != null) { return; }  if (!zipFile.exists()) { createNewZipModel(); return; }  if (!zipFile.canRead()) { throw new ZipException("no read access for the input zip file"); }  try (RandomAccessFile randomAccessFile = new RandomAccessFile(zipFile, RandomAccessFileMode.READ.getValue())) { HeaderReader headerReader = new HeaderReader(); zipModel = headerReader.readAllHeaders(randomAccessFile, charset); zipModel.setZipFile(zipFile); <BUGS> } catch (ZipException e) { <BUGE> throw e; } catch (IOException e) { throw new ZipException(e); } }
*/ private void readZipInfo() throws ZipException { if (zipModel != null) { return; }  if (!zipFile.exists()) { createNewZipModel(); return; }  if (!zipFile.canRead()) { throw new ZipException("no read access for the input zip file"); }  try (RandomAccessFile randomAccessFile = new RandomAccessFile(zipFile, RandomAccessFileMode.READ.getValue())) { HeaderReader headerReader = new HeaderReader(); zipModel = headerReader.readAllHeaders(randomAccessFile, charset); zipModel.setZipFile(zipFile); } catch (ZipException e) { throw e; <BUGS> } catch (IOException e) { throw new ZipException(e); <BUGE> } }
*/ public void addFile(File fileToAdd, ZipParameters parameters) throws ZipException { <BUGS> addFiles(Collections.singletonList(fileToAdd), parameters); } <BUGE>
public long readLongLittleEndian(byte[] array, int pos) { <BUGS> if (array.length < 8) { resetBytes(longBuff); <BUGE> } System.arraycopy(array, pos, longBuff, 0, array.length < 8 ? array.length : 8);  long temp = 0; temp |= longBuff[7] & 0xff; temp <<= 8; temp |= longBuff[6] & 0xff; temp <<= 8; temp |= longBuff[5] & 0xff; temp <<= 8; temp |= longBuff[4] & 0xff; temp <<= 8; temp |= longBuff[3] & 0xff; temp <<= 8; temp |= longBuff[2] & 0xff; temp <<= 8; temp |= longBuff[1] & 0xff; temp <<= 8; temp |= longBuff[0] & 0xff; return temp; }
public long readLongLittleEndian(byte[] array, int pos) { if (array.length < 8) { resetBytes(longBuff); } <BUGS> System.arraycopy(array, pos, longBuff, 0, array.length < 8 ? array.length : 8); <BUGE>  long temp = 0; temp |= longBuff[7] & 0xff; temp <<= 8; temp |= longBuff[6] & 0xff; temp <<= 8; temp |= longBuff[5] & 0xff; temp <<= 8; temp |= longBuff[4] & 0xff; temp <<= 8; temp |= longBuff[3] & 0xff; temp <<= 8; temp |= longBuff[2] & 0xff; temp <<= 8; temp |= longBuff[1] & 0xff; temp <<= 8; temp |= longBuff[0] & 0xff; return temp; }
public void writeLocalFileHeader(ZipModel zipModel, LocalFileHeader localFileHeader, OutputStream outputStream, Charset charset) throws IOException {  <BUGS> try(ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream()) { rawIO.writeIntLittleEndian(byteArrayOutputStream, (int) localFileHeader.getSignature().getValue()); rawIO.writeShortLittleEndian(byteArrayOutputStream, localFileHeader.getVersionNeededToExtract()); byteArrayOutputStream.write(localFileHeader.getGeneralPurposeFlag()); rawIO.writeShortLittleEndian(byteArrayOutputStream, localFileHeader.getCompressionMethod().getCode()); <BUGE>  rawIO.writeLongLittleEndian(longBuff, 0, localFileHeader.getLastModifiedTime()); byteArrayOutputStream.write(longBuff, 0, 4);  rawIO.writeLongLittleEndian(longBuff, 0, localFileHeader.getCrc()); byteArrayOutputStream.write(longBuff, 0, 4);  boolean writeZip64Header = localFileHeader.getCompressedSize() >= ZIP_64_SIZE_LIMIT || localFileHeader.getUncompressedSize() >= ZIP_64_SIZE_LIMIT;  if (writeZip64Header) { rawIO.writeLongLittleEndian(longBuff, 0, ZIP_64_SIZE_LIMIT);  /*Set the uncompressed size to ZipConstants.ZIP_64_SIZE_LIMIT as*/ /*these values will be stored in Zip64 extra record*/ byteArrayOutputStream.write(longBuff, 0, 4); byteArrayOutputStream.write(longBuff, 0, 4);  zipModel.setZip64Format(true); localFileHeader.setWriteCompressedSizeInZip64ExtraRecord(true); } else {
public void writeLocalFileHeader(ZipModel zipModel, LocalFileHeader localFileHeader, OutputStream outputStream, Charset charset) throws IOException {  try(ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream()) { rawIO.writeIntLittleEndian(byteArrayOutputStream, (int) localFileHeader.getSignature().getValue()); rawIO.writeShortLittleEndian(byteArrayOutputStream, localFileHeader.getVersionNeededToExtract()); byteArrayOutputStream.write(localFileHeader.getGeneralPurposeFlag()); rawIO.writeShortLittleEndian(byteArrayOutputStream, localFileHeader.getCompressionMethod().getCode());  <BUGS> rawIO.writeLongLittleEndian(longBuff, 0, localFileHeader.getLastModifiedTime()); byteArrayOutputStream.write(longBuff, 0, 4); <BUGE>  rawIO.writeLongLittleEndian(longBuff, 0, localFileHeader.getCrc()); byteArrayOutputStream.write(longBuff, 0, 4);  boolean writeZip64Header = localFileHeader.getCompressedSize() >= ZIP_64_SIZE_LIMIT || localFileHeader.getUncompressedSize() >= ZIP_64_SIZE_LIMIT;  if (writeZip64Header) { rawIO.writeLongLittleEndian(longBuff, 0, ZIP_64_SIZE_LIMIT);  /*Set the uncompressed size to ZipConstants.ZIP_64_SIZE_LIMIT as*/ /*these values will be stored in Zip64 extra record*/ byteArrayOutputStream.write(longBuff, 0, 4); byteArrayOutputStream.write(longBuff, 0, 4);  zipModel.setZip64Format(true); localFileHeader.setWriteCompressedSizeInZip64ExtraRecord(true); } else {
public void writeLocalFileHeader(ZipModel zipModel, LocalFileHeader localFileHeader, OutputStream outputStream, Charset charset) throws IOException {  try(ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream()) { rawIO.writeIntLittleEndian(byteArrayOutputStream, (int) localFileHeader.getSignature().getValue()); rawIO.writeShortLittleEndian(byteArrayOutputStream, localFileHeader.getVersionNeededToExtract()); byteArrayOutputStream.write(localFileHeader.getGeneralPurposeFlag()); rawIO.writeShortLittleEndian(byteArrayOutputStream, localFileHeader.getCompressionMethod().getCode());  rawIO.writeLongLittleEndian(longBuff, 0, localFileHeader.getLastModifiedTime()); byteArrayOutputStream.write(longBuff, 0, 4);  <BUGS> rawIO.writeLongLittleEndian(longBuff, 0, localFileHeader.getCrc()); byteArrayOutputStream.write(longBuff, 0, 4); <BUGE>  boolean writeZip64Header = localFileHeader.getCompressedSize() >= ZIP_64_SIZE_LIMIT || localFileHeader.getUncompressedSize() >= ZIP_64_SIZE_LIMIT;  if (writeZip64Header) { rawIO.writeLongLittleEndian(longBuff, 0, ZIP_64_SIZE_LIMIT);  /*Set the uncompressed size to ZipConstants.ZIP_64_SIZE_LIMIT as*/ /*these values will be stored in Zip64 extra record*/ byteArrayOutputStream.write(longBuff, 0, 4); byteArrayOutputStream.write(longBuff, 0, 4);  zipModel.setZip64Format(true); localFileHeader.setWriteCompressedSizeInZip64ExtraRecord(true); } else {
public void writeLocalFileHeader(ZipModel zipModel, LocalFileHeader localFileHeader, OutputStream outputStream, Charset charset) throws IOException {  try(ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream()) { rawIO.writeIntLittleEndian(byteArrayOutputStream, (int) localFileHeader.getSignature().getValue()); rawIO.writeShortLittleEndian(byteArrayOutputStream, localFileHeader.getVersionNeededToExtract()); byteArrayOutputStream.write(localFileHeader.getGeneralPurposeFlag()); rawIO.writeShortLittleEndian(byteArrayOutputStream, localFileHeader.getCompressionMethod().getCode());  rawIO.writeLongLittleEndian(longBuff, 0, localFileHeader.getLastModifiedTime()); byteArrayOutputStream.write(longBuff, 0, 4);  rawIO.writeLongLittleEndian(longBuff, 0, localFileHeader.getCrc()); byteArrayOutputStream.write(longBuff, 0, 4);  <BUGS> boolean writeZip64Header = localFileHeader.getCompressedSize() >= ZIP_64_SIZE_LIMIT || localFileHeader.getUncompressedSize() >= ZIP_64_SIZE_LIMIT; <BUGE>  if (writeZip64Header) { rawIO.writeLongLittleEndian(longBuff, 0, ZIP_64_SIZE_LIMIT);  /*Set the uncompressed size to ZipConstants.ZIP_64_SIZE_LIMIT as*/ /*these values will be stored in Zip64 extra record*/ byteArrayOutputStream.write(longBuff, 0, 4); byteArrayOutputStream.write(longBuff, 0, 4);  zipModel.setZip64Format(true); localFileHeader.setWriteCompressedSizeInZip64ExtraRecord(true); } else {
public void writeLocalFileHeader(ZipModel zipModel, LocalFileHeader localFileHeader, OutputStream outputStream, Charset charset) throws IOException {  try(ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream()) { rawIO.writeIntLittleEndian(byteArrayOutputStream, (int) localFileHeader.getSignature().getValue()); rawIO.writeShortLittleEndian(byteArrayOutputStream, localFileHeader.getVersionNeededToExtract()); byteArrayOutputStream.write(localFileHeader.getGeneralPurposeFlag()); rawIO.writeShortLittleEndian(byteArrayOutputStream, localFileHeader.getCompressionMethod().getCode());  rawIO.writeLongLittleEndian(longBuff, 0, localFileHeader.getLastModifiedTime()); byteArrayOutputStream.write(longBuff, 0, 4);  rawIO.writeLongLittleEndian(longBuff, 0, localFileHeader.getCrc()); byteArrayOutputStream.write(longBuff, 0, 4);  boolean writeZip64Header = localFileHeader.getCompressedSize() >= ZIP_64_SIZE_LIMIT || localFileHeader.getUncompressedSize() >= ZIP_64_SIZE_LIMIT;  <BUGS> if (writeZip64Header) { rawIO.writeLongLittleEndian(longBuff, 0, ZIP_64_SIZE_LIMIT); <BUGE>  /*Set the uncompressed size to ZipConstants.ZIP_64_SIZE_LIMIT as*/ /*these values will be stored in Zip64 extra record*/ byteArrayOutputStream.write(longBuff, 0, 4); byteArrayOutputStream.write(longBuff, 0, 4);  zipModel.setZip64Format(true); localFileHeader.setWriteCompressedSizeInZip64ExtraRecord(true); } else {
public void writeLocalFileHeader(ZipModel zipModel, LocalFileHeader localFileHeader, OutputStream outputStream, Charset charset) throws IOException {  try(ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream()) { rawIO.writeIntLittleEndian(byteArrayOutputStream, (int) localFileHeader.getSignature().getValue()); rawIO.writeShortLittleEndian(byteArrayOutputStream, localFileHeader.getVersionNeededToExtract()); byteArrayOutputStream.write(localFileHeader.getGeneralPurposeFlag()); rawIO.writeShortLittleEndian(byteArrayOutputStream, localFileHeader.getCompressionMethod().getCode());  rawIO.writeLongLittleEndian(longBuff, 0, localFileHeader.getLastModifiedTime()); byteArrayOutputStream.write(longBuff, 0, 4);  rawIO.writeLongLittleEndian(longBuff, 0, localFileHeader.getCrc()); byteArrayOutputStream.write(longBuff, 0, 4);  boolean writeZip64Header = localFileHeader.getCompressedSize() >= ZIP_64_SIZE_LIMIT || localFileHeader.getUncompressedSize() >= ZIP_64_SIZE_LIMIT;  if (writeZip64Header) { rawIO.writeLongLittleEndian(longBuff, 0, ZIP_64_SIZE_LIMIT);  /*Set the uncompressed size to ZipConstants.ZIP_64_SIZE_LIMIT as*/ /*these values will be stored in Zip64 extra record*/ <BUGS> byteArrayOutputStream.write(longBuff, 0, 4); byteArrayOutputStream.write(longBuff, 0, 4); <BUGE>  zipModel.setZip64Format(true); localFileHeader.setWriteCompressedSizeInZip64ExtraRecord(true); } else {
public void writeLocalFileHeader(ZipModel zipModel, LocalFileHeader localFileHeader, OutputStream outputStream, Charset charset) throws IOException {  try(ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream()) { rawIO.writeIntLittleEndian(byteArrayOutputStream, (int) localFileHeader.getSignature().getValue()); rawIO.writeShortLittleEndian(byteArrayOutputStream, localFileHeader.getVersionNeededToExtract()); byteArrayOutputStream.write(localFileHeader.getGeneralPurposeFlag()); rawIO.writeShortLittleEndian(byteArrayOutputStream, localFileHeader.getCompressionMethod().getCode());  rawIO.writeLongLittleEndian(longBuff, 0, localFileHeader.getLastModifiedTime()); byteArrayOutputStream.write(longBuff, 0, 4);  rawIO.writeLongLittleEndian(longBuff, 0, localFileHeader.getCrc()); byteArrayOutputStream.write(longBuff, 0, 4);  boolean writeZip64Header = localFileHeader.getCompressedSize() >= ZIP_64_SIZE_LIMIT || localFileHeader.getUncompressedSize() >= ZIP_64_SIZE_LIMIT;  if (writeZip64Header) { rawIO.writeLongLittleEndian(longBuff, 0, ZIP_64_SIZE_LIMIT);  /*Set the uncompressed size to ZipConstants.ZIP_64_SIZE_LIMIT as*/ /*these values will be stored in Zip64 extra record*/ byteArrayOutputStream.write(longBuff, 0, 4); byteArrayOutputStream.write(longBuff, 0, 4);  <BUGS> zipModel.setZip64Format(true); localFileHeader.setWriteCompressedSizeInZip64ExtraRecord(true); <BUGE> } else {
import static net.lingala.zip4j.util.InternalZipConstants.ZIP_64_NUMBER_OF_ENTRIES_LIMIT; import static net.lingala.zip4j.util.InternalZipConstants.ZIP_64_SIZE_LIMIT; import static net.lingala.zip4j.util.Zip4jUtil.isStringNotNullAndNotEmpty;  public class HeaderWriter {  private static final short ZIP64_EXTRA_DATA_RECORD_SIZE_LFH = 16; private static final short ZIP64_EXTRA_DATA_RECORD_SIZE_FH = 28; private static final short AES_EXTRA_DATA_RECORD_SIZE = 11;  private RawIO rawIO = new RawIO(); private byte[] longBuff = new byte[8]; private byte[] intBuff = new byte[4];  <BUGS> byte[] fileNameBytes = new byte[0]; if (isStringNotNullAndNotEmpty(localFileHeader.getFileName())) { fileNameBytes = localFileHeader.getFileName().getBytes(charset); <BUGE> } rawIO.writeShortLittleEndian(byteArrayOutputStream, fileNameBytes.length);  int extraFieldLength = 0; if (writeZip64Header) { extraFieldLength += ZIP64_EXTRA_DATA_RECORD_SIZE_LFH + 4; /* 4 for signature + size of record*/ } if (localFileHeader.getAesExtraDataRecord() != null) { extraFieldLength += AES_EXTRA_DATA_RECORD_SIZE; } rawIO.writeShortLittleEndian(byteArrayOutputStream, extraFieldLength);  if (fileNameBytes.length > 0) {
import static net.lingala.zip4j.util.FileUtils.getZipFileNameWithoutExtension; import static net.lingala.zip4j.util.InternalZipConstants.ZIP_64_NUMBER_OF_ENTRIES_LIMIT; import static net.lingala.zip4j.util.InternalZipConstants.ZIP_64_SIZE_LIMIT; import static net.lingala.zip4j.util.Zip4jUtil.isStringNotNullAndNotEmpty;  public class HeaderWriter {  private static final short ZIP64_EXTRA_DATA_RECORD_SIZE_LFH = 16; private static final short ZIP64_EXTRA_DATA_RECORD_SIZE_FH = 28; private static final short AES_EXTRA_DATA_RECORD_SIZE = 11;  private RawIO rawIO = new RawIO(); private byte[] longBuff = new byte[8]; private byte[] intBuff = new byte[4]; } <BUGS> rawIO.writeShortLittleEndian(byteArrayOutputStream, fileNameBytes.length); <BUGE>  int extraFieldLength = 0; if (writeZip64Header) { extraFieldLength += ZIP64_EXTRA_DATA_RECORD_SIZE_LFH + 4; /* 4 for signature + size of record*/ } if (localFileHeader.getAesExtraDataRecord() != null) { extraFieldLength += AES_EXTRA_DATA_RECORD_SIZE; } rawIO.writeShortLittleEndian(byteArrayOutputStream, extraFieldLength);  if (fileNameBytes.length > 0) { byteArrayOutputStream.write(fileNameBytes); }
import static net.lingala.zip4j.util.InternalZipConstants.ZIP_64_NUMBER_OF_ENTRIES_LIMIT; import static net.lingala.zip4j.util.InternalZipConstants.ZIP_64_SIZE_LIMIT; import static net.lingala.zip4j.util.Zip4jUtil.isStringNotNullAndNotEmpty;  public class HeaderWriter {  private static final short ZIP64_EXTRA_DATA_RECORD_SIZE_LFH = 16; private static final short ZIP64_EXTRA_DATA_RECORD_SIZE_FH = 28; private static final short AES_EXTRA_DATA_RECORD_SIZE = 11;  private RawIO rawIO = new RawIO(); private byte[] longBuff = new byte[8]; private byte[] intBuff = new byte[4];  <BUGS> int extraFieldLength = 0; if (writeZip64Header) { extraFieldLength += ZIP64_EXTRA_DATA_RECORD_SIZE_LFH + 4; /* 4 for signature + size of record <BUGE>*/ } if (localFileHeader.getAesExtraDataRecord() != null) { extraFieldLength += AES_EXTRA_DATA_RECORD_SIZE; } rawIO.writeShortLittleEndian(byteArrayOutputStream, extraFieldLength);  if (fileNameBytes.length > 0) { byteArrayOutputStream.write(fileNameBytes); }  /*Zip64 should be the first extra data record that should be written*/ /*This is NOT according to any specification but if this is changed*/ /*corresponding logic for updateLocalFileHeader for compressed size*/
import static net.lingala.zip4j.util.FileUtils.getZipFileNameWithoutExtension; import static net.lingala.zip4j.util.InternalZipConstants.ZIP_64_NUMBER_OF_ENTRIES_LIMIT; import static net.lingala.zip4j.util.InternalZipConstants.ZIP_64_SIZE_LIMIT; import static net.lingala.zip4j.util.Zip4jUtil.isStringNotNullAndNotEmpty;  public class HeaderWriter {  private static final short ZIP64_EXTRA_DATA_RECORD_SIZE_LFH = 16; private static final short ZIP64_EXTRA_DATA_RECORD_SIZE_FH = 28; private static final short AES_EXTRA_DATA_RECORD_SIZE = 11;  private RawIO rawIO = new RawIO(); private byte[] longBuff = new byte[8]; private byte[] intBuff = new byte[4]; } <BUGS> if (localFileHeader.getAesExtraDataRecord() != null) { <BUGE> extraFieldLength += AES_EXTRA_DATA_RECORD_SIZE; } rawIO.writeShortLittleEndian(byteArrayOutputStream, extraFieldLength);  if (fileNameBytes.length > 0) { byteArrayOutputStream.write(fileNameBytes); }  /*Zip64 should be the first extra data record that should be written*/ /*This is NOT according to any specification but if this is changed*/ /*corresponding logic for updateLocalFileHeader for compressed size*/ /*has to be modified as well*/ if (writeZip64Header) { rawIO.writeShortLittleEndian(byteArrayOutputStream,
import static net.lingala.zip4j.util.FileUtils.getZipFileNameWithoutExtension; import static net.lingala.zip4j.util.InternalZipConstants.ZIP_64_NUMBER_OF_ENTRIES_LIMIT; import static net.lingala.zip4j.util.InternalZipConstants.ZIP_64_SIZE_LIMIT; import static net.lingala.zip4j.util.Zip4jUtil.isStringNotNullAndNotEmpty;  public class HeaderWriter {  private static final short ZIP64_EXTRA_DATA_RECORD_SIZE_LFH = 16; private static final short ZIP64_EXTRA_DATA_RECORD_SIZE_FH = 28; private static final short AES_EXTRA_DATA_RECORD_SIZE = 11;  private RawIO rawIO = new RawIO(); private byte[] longBuff = new byte[8]; private byte[] intBuff = new byte[4]; } <BUGS> rawIO.writeShortLittleEndian(byteArrayOutputStream, extraFieldLength); <BUGE>  if (fileNameBytes.length > 0) { byteArrayOutputStream.write(fileNameBytes); }  /*Zip64 should be the first extra data record that should be written*/ /*This is NOT according to any specification but if this is changed*/ /*corresponding logic for updateLocalFileHeader for compressed size*/ /*has to be modified as well*/ if (writeZip64Header) { rawIO.writeShortLittleEndian(byteArrayOutputStream, (int) HeaderSignature.ZIP64_EXTRA_FIELD_SIGNATURE.getValue()); rawIO.writeShortLittleEndian(byteArrayOutputStream, ZIP64_EXTRA_DATA_RECORD_SIZE_LFH); rawIO.writeLongLittleEndian(byteArrayOutputStream, localFileHeader.getUncompressedSize());
import static net.lingala.zip4j.util.FileUtils.getZipFileNameWithoutExtension; import static net.lingala.zip4j.util.InternalZipConstants.ZIP_64_NUMBER_OF_ENTRIES_LIMIT; import static net.lingala.zip4j.util.InternalZipConstants.ZIP_64_SIZE_LIMIT; import static net.lingala.zip4j.util.Zip4jUtil.isStringNotNullAndNotEmpty;  public class HeaderWriter {  private static final short ZIP64_EXTRA_DATA_RECORD_SIZE_LFH = 16; private static final short ZIP64_EXTRA_DATA_RECORD_SIZE_FH = 28; private static final short AES_EXTRA_DATA_RECORD_SIZE = 11;  private RawIO rawIO = new RawIO(); private byte[] longBuff = new byte[8]; private byte[] intBuff = new byte[4];  <BUGS> if (fileNameBytes.length > 0) { byteArrayOutputStream.write(fileNameBytes); <BUGE> }  /*Zip64 should be the first extra data record that should be written*/ /*This is NOT according to any specification but if this is changed*/ /*corresponding logic for updateLocalFileHeader for compressed size*/ /*has to be modified as well*/ if (writeZip64Header) { rawIO.writeShortLittleEndian(byteArrayOutputStream, (int) HeaderSignature.ZIP64_EXTRA_FIELD_SIGNATURE.getValue()); rawIO.writeShortLittleEndian(byteArrayOutputStream, ZIP64_EXTRA_DATA_RECORD_SIZE_LFH); rawIO.writeLongLittleEndian(byteArrayOutputStream, localFileHeader.getUncompressedSize()); rawIO.writeLongLittleEndian(byteArrayOutputStream, localFileHeader.getCompressedSize()); }
import static net.lingala.zip4j.util.InternalZipConstants.ZIP_64_SIZE_LIMIT; import static net.lingala.zip4j.util.Zip4jUtil.isStringNotNullAndNotEmpty;  public class HeaderWriter {  private static final short ZIP64_EXTRA_DATA_RECORD_SIZE_LFH = 16; private static final short ZIP64_EXTRA_DATA_RECORD_SIZE_FH = 28; private static final short AES_EXTRA_DATA_RECORD_SIZE = 11;  private RawIO rawIO = new RawIO(); private byte[] longBuff = new byte[8]; private byte[] intBuff = new byte[4]; /*has to be modified as well*/ <BUGS> if (writeZip64Header) { rawIO.writeShortLittleEndian(byteArrayOutputStream, (int) HeaderSignature.ZIP64_EXTRA_FIELD_SIGNATURE.getValue()); rawIO.writeShortLittleEndian(byteArrayOutputStream, ZIP64_EXTRA_DATA_RECORD_SIZE_LFH); rawIO.writeLongLittleEndian(byteArrayOutputStream, localFileHeader.getUncompressedSize()); rawIO.writeLongLittleEndian(byteArrayOutputStream, localFileHeader.getCompressedSize()); <BUGE> }  if (localFileHeader.getAesExtraDataRecord() != null) { AESExtraDataRecord aesExtraDataRecord = localFileHeader.getAesExtraDataRecord(); rawIO.writeShortLittleEndian(byteArrayOutputStream, (int) aesExtraDataRecord.getSignature().getValue()); rawIO.writeShortLittleEndian(byteArrayOutputStream, aesExtraDataRecord.getDataSize()); rawIO.writeShortLittleEndian(byteArrayOutputStream, aesExtraDataRecord.getAesVersion().getVersionNumber()); byteArrayOutputStream.write(aesExtraDataRecord.getVendorID().getBytes());  byte[] aesStrengthBytes = new byte[1]; aesStrengthBytes[0] = (byte) aesExtraDataRecord.getAesKeyStrength().getRawCode();
import static net.lingala.zip4j.util.FileUtils.getZipFileNameWithoutExtension; import static net.lingala.zip4j.util.InternalZipConstants.ZIP_64_NUMBER_OF_ENTRIES_LIMIT; import static net.lingala.zip4j.util.InternalZipConstants.ZIP_64_SIZE_LIMIT; import static net.lingala.zip4j.util.Zip4jUtil.isStringNotNullAndNotEmpty;  public class HeaderWriter {  private static final short ZIP64_EXTRA_DATA_RECORD_SIZE_LFH = 16; private static final short ZIP64_EXTRA_DATA_RECORD_SIZE_FH = 28; private static final short AES_EXTRA_DATA_RECORD_SIZE = 11;  private RawIO rawIO = new RawIO(); private byte[] longBuff = new byte[8]; private byte[] intBuff = new byte[4];  <BUGS> if (localFileHeader.getAesExtraDataRecord() != null) { <BUGE> AESExtraDataRecord aesExtraDataRecord = localFileHeader.getAesExtraDataRecord(); rawIO.writeShortLittleEndian(byteArrayOutputStream, (int) aesExtraDataRecord.getSignature().getValue()); rawIO.writeShortLittleEndian(byteArrayOutputStream, aesExtraDataRecord.getDataSize()); rawIO.writeShortLittleEndian(byteArrayOutputStream, aesExtraDataRecord.getAesVersion().getVersionNumber()); byteArrayOutputStream.write(aesExtraDataRecord.getVendorID().getBytes());  byte[] aesStrengthBytes = new byte[1]; aesStrengthBytes[0] = (byte) aesExtraDataRecord.getAesKeyStrength().getRawCode(); byteArrayOutputStream.write(aesStrengthBytes);  rawIO.writeShortLittleEndian(byteArrayOutputStream, aesExtraDataRecord.getCompressionMethod().getCode()); }  outputStream.write(byteArrayOutputStream.toByteArray());
import static net.lingala.zip4j.util.InternalZipConstants.ZIP_64_NUMBER_OF_ENTRIES_LIMIT; import static net.lingala.zip4j.util.InternalZipConstants.ZIP_64_SIZE_LIMIT; import static net.lingala.zip4j.util.Zip4jUtil.isStringNotNullAndNotEmpty;  public class HeaderWriter {  private static final short ZIP64_EXTRA_DATA_RECORD_SIZE_LFH = 16; private static final short ZIP64_EXTRA_DATA_RECORD_SIZE_FH = 28; private static final short AES_EXTRA_DATA_RECORD_SIZE = 11;  private RawIO rawIO = new RawIO(); private byte[] longBuff = new byte[8]; private byte[] intBuff = new byte[4];  <BUGS> outputStream.write(byteArrayOutputStream.toByteArray()); } } <BUGE>  public void writeExtendedLocalHeader(LocalFileHeader localFileHeader, OutputStream outputStream) throws IOException {  if (localFileHeader == null || outputStream == null) { throw new ZipException("input parameters is null, cannot write extended local header"); }  try (ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream()) { rawIO.writeIntLittleEndian(byteArrayOutputStream, (int) HeaderSignature.EXTRA_DATA_RECORD.getValue());  rawIO.writeLongLittleEndian(longBuff, 0, localFileHeader.getCrc()); byteArrayOutputStream.write(longBuff, 0, 4);
*/ public void setLastModifiedFileTime(long lastModifiedFileTime) { <BUGS> if (lastModifiedFileTime <= 0) { return; <BUGE> }  this.lastModifiedFileTime = lastModifiedFileTime; }
*/ public void setLastModifiedFileTime(long lastModifiedFileTime) { if (lastModifiedFileTime <= 0) { return; }  <BUGS> this.lastModifiedFileTime = lastModifiedFileTime; } <BUGE>
public LocalFileHeader readLocalFileHeader(InputStream inputStream, Charset charset) throws IOException { <BUGS> LocalFileHeader localFileHeader = new LocalFileHeader(); byte[] intBuff = new byte[4]; <BUGE>  /*signature*/ int sig = rawIO.readIntLittleEndian(inputStream); if (sig != HeaderSignature.LOCAL_FILE_HEADER.getValue()) { return null; } localFileHeader.setSignature(HeaderSignature.LOCAL_FILE_HEADER); localFileHeader.setVersionNeededToExtract(rawIO.readShortLittleEndian(inputStream));  byte[] generalPurposeFlags = new byte[2]; if (readFully(inputStream, generalPurposeFlags) != 2) { throw new ZipException("Could not read enough bytes for generalPurposeFlags"); } localFileHeader.setEncrypted(isBitSet(generalPurposeFlags[0], 0)); localFileHeader.setDataDescriptorExists(isBitSet(generalPurposeFlags[0], 3)); localFileHeader.setFileNameUTF8Encoded(isBitSet(generalPurposeFlags[1], 3)); localFileHeader.setGeneralPurposeFlag(generalPurposeFlags.clone());  localFileHeader.setCompressionMethod(CompressionMethod.getCompressionMethodFromCode( rawIO.readShortLittleEndian(inputStream))); localFileHeader.setLastModifiedTime(rawIO.readIntLittleEndian(inputStream));  readFully(inputStream, intBuff); localFileHeader.setCrc(rawIO.readLongLittleEndian(intBuff, 0)); localFileHeader.setCrcRawData(intBuff.clone());
public LocalFileHeader readLocalFileHeader(InputStream inputStream, Charset charset) throws IOException { LocalFileHeader localFileHeader = new LocalFileHeader(); byte[] intBuff = new byte[4];  /*signature*/ <BUGS> int sig = rawIO.readIntLittleEndian(inputStream); if (sig != HeaderSignature.LOCAL_FILE_HEADER.getValue()) { <BUGE> return null; } localFileHeader.setSignature(HeaderSignature.LOCAL_FILE_HEADER); localFileHeader.setVersionNeededToExtract(rawIO.readShortLittleEndian(inputStream));  byte[] generalPurposeFlags = new byte[2]; if (readFully(inputStream, generalPurposeFlags) != 2) { throw new ZipException("Could not read enough bytes for generalPurposeFlags"); } localFileHeader.setEncrypted(isBitSet(generalPurposeFlags[0], 0)); localFileHeader.setDataDescriptorExists(isBitSet(generalPurposeFlags[0], 3)); localFileHeader.setFileNameUTF8Encoded(isBitSet(generalPurposeFlags[1], 3)); localFileHeader.setGeneralPurposeFlag(generalPurposeFlags.clone());  localFileHeader.setCompressionMethod(CompressionMethod.getCompressionMethodFromCode( rawIO.readShortLittleEndian(inputStream))); localFileHeader.setLastModifiedTime(rawIO.readIntLittleEndian(inputStream));  readFully(inputStream, intBuff); localFileHeader.setCrc(rawIO.readLongLittleEndian(intBuff, 0)); localFileHeader.setCrcRawData(intBuff.clone());
public LocalFileHeader readLocalFileHeader(InputStream inputStream, Charset charset) throws IOException { LocalFileHeader localFileHeader = new LocalFileHeader(); byte[] intBuff = new byte[4];  /*signature*/ int sig = rawIO.readIntLittleEndian(inputStream); if (sig != HeaderSignature.LOCAL_FILE_HEADER.getValue()) { return null; } <BUGS> localFileHeader.setSignature(HeaderSignature.LOCAL_FILE_HEADER); localFileHeader.setVersionNeededToExtract(rawIO.readShortLittleEndian(inputStream)); <BUGE>  byte[] generalPurposeFlags = new byte[2]; if (readFully(inputStream, generalPurposeFlags) != 2) { throw new ZipException("Could not read enough bytes for generalPurposeFlags"); } localFileHeader.setEncrypted(isBitSet(generalPurposeFlags[0], 0)); localFileHeader.setDataDescriptorExists(isBitSet(generalPurposeFlags[0], 3)); localFileHeader.setFileNameUTF8Encoded(isBitSet(generalPurposeFlags[1], 3)); localFileHeader.setGeneralPurposeFlag(generalPurposeFlags.clone());  localFileHeader.setCompressionMethod(CompressionMethod.getCompressionMethodFromCode( rawIO.readShortLittleEndian(inputStream))); localFileHeader.setLastModifiedTime(rawIO.readIntLittleEndian(inputStream));  readFully(inputStream, intBuff); localFileHeader.setCrc(rawIO.readLongLittleEndian(intBuff, 0)); localFileHeader.setCrcRawData(intBuff.clone());
public LocalFileHeader readLocalFileHeader(InputStream inputStream, Charset charset) throws IOException { LocalFileHeader localFileHeader = new LocalFileHeader(); byte[] intBuff = new byte[4];  /*signature*/ int sig = rawIO.readIntLittleEndian(inputStream); if (sig != HeaderSignature.LOCAL_FILE_HEADER.getValue()) { return null; } localFileHeader.setSignature(HeaderSignature.LOCAL_FILE_HEADER); localFileHeader.setVersionNeededToExtract(rawIO.readShortLittleEndian(inputStream));  <BUGS> byte[] generalPurposeFlags = new byte[2]; if (readFully(inputStream, generalPurposeFlags) != 2) { <BUGE> throw new ZipException("Could not read enough bytes for generalPurposeFlags"); } localFileHeader.setEncrypted(isBitSet(generalPurposeFlags[0], 0)); localFileHeader.setDataDescriptorExists(isBitSet(generalPurposeFlags[0], 3)); localFileHeader.setFileNameUTF8Encoded(isBitSet(generalPurposeFlags[1], 3)); localFileHeader.setGeneralPurposeFlag(generalPurposeFlags.clone());  localFileHeader.setCompressionMethod(CompressionMethod.getCompressionMethodFromCode( rawIO.readShortLittleEndian(inputStream))); localFileHeader.setLastModifiedTime(rawIO.readIntLittleEndian(inputStream));  readFully(inputStream, intBuff); localFileHeader.setCrc(rawIO.readLongLittleEndian(intBuff, 0)); localFileHeader.setCrcRawData(intBuff.clone());
public LocalFileHeader readLocalFileHeader(InputStream inputStream, Charset charset) throws IOException { LocalFileHeader localFileHeader = new LocalFileHeader(); byte[] intBuff = new byte[4];  /*signature*/ int sig = rawIO.readIntLittleEndian(inputStream); if (sig != HeaderSignature.LOCAL_FILE_HEADER.getValue()) { return null; } localFileHeader.setSignature(HeaderSignature.LOCAL_FILE_HEADER); localFileHeader.setVersionNeededToExtract(rawIO.readShortLittleEndian(inputStream));  byte[] generalPurposeFlags = new byte[2]; if (readFully(inputStream, generalPurposeFlags) != 2) { throw new ZipException("Could not read enough bytes for generalPurposeFlags"); } <BUGS> localFileHeader.setEncrypted(isBitSet(generalPurposeFlags[0], 0)); localFileHeader.setDataDescriptorExists(isBitSet(generalPurposeFlags[0], 3)); localFileHeader.setFileNameUTF8Encoded(isBitSet(generalPurposeFlags[1], 3)); localFileHeader.setGeneralPurposeFlag(generalPurposeFlags.clone()); <BUGE>  localFileHeader.setCompressionMethod(CompressionMethod.getCompressionMethodFromCode( rawIO.readShortLittleEndian(inputStream))); localFileHeader.setLastModifiedTime(rawIO.readIntLittleEndian(inputStream));  readFully(inputStream, intBuff); localFileHeader.setCrc(rawIO.readLongLittleEndian(intBuff, 0)); localFileHeader.setCrcRawData(intBuff.clone());
public LocalFileHeader readLocalFileHeader(InputStream inputStream, Charset charset) throws IOException { LocalFileHeader localFileHeader = new LocalFileHeader(); byte[] intBuff = new byte[4];  /*signature*/ int sig = rawIO.readIntLittleEndian(inputStream); if (sig != HeaderSignature.LOCAL_FILE_HEADER.getValue()) { return null; } localFileHeader.setSignature(HeaderSignature.LOCAL_FILE_HEADER); localFileHeader.setVersionNeededToExtract(rawIO.readShortLittleEndian(inputStream));  byte[] generalPurposeFlags = new byte[2]; if (readFully(inputStream, generalPurposeFlags) != 2) { throw new ZipException("Could not read enough bytes for generalPurposeFlags"); } localFileHeader.setEncrypted(isBitSet(generalPurposeFlags[0], 0)); localFileHeader.setDataDescriptorExists(isBitSet(generalPurposeFlags[0], 3)); localFileHeader.setFileNameUTF8Encoded(isBitSet(generalPurposeFlags[1], 3)); localFileHeader.setGeneralPurposeFlag(generalPurposeFlags.clone());  <BUGS> localFileHeader.setCompressionMethod(CompressionMethod.getCompressionMethodFromCode( rawIO.readShortLittleEndian(inputStream))); localFileHeader.setLastModifiedTime(rawIO.readIntLittleEndian(inputStream)); <BUGE>  readFully(inputStream, intBuff); localFileHeader.setCrc(rawIO.readLongLittleEndian(intBuff, 0)); localFileHeader.setCrcRawData(intBuff.clone());
public LocalFileHeader readLocalFileHeader(InputStream inputStream, Charset charset) throws IOException { LocalFileHeader localFileHeader = new LocalFileHeader(); byte[] intBuff = new byte[4];  /*signature*/ int sig = rawIO.readIntLittleEndian(inputStream); if (sig != HeaderSignature.LOCAL_FILE_HEADER.getValue()) { return null; } localFileHeader.setSignature(HeaderSignature.LOCAL_FILE_HEADER); localFileHeader.setVersionNeededToExtract(rawIO.readShortLittleEndian(inputStream));  byte[] generalPurposeFlags = new byte[2]; if (readFully(inputStream, generalPurposeFlags) != 2) { throw new ZipException("Could not read enough bytes for generalPurposeFlags"); } localFileHeader.setEncrypted(isBitSet(generalPurposeFlags[0], 0)); localFileHeader.setDataDescriptorExists(isBitSet(generalPurposeFlags[0], 3)); localFileHeader.setFileNameUTF8Encoded(isBitSet(generalPurposeFlags[1], 3)); localFileHeader.setGeneralPurposeFlag(generalPurposeFlags.clone());  localFileHeader.setCompressionMethod(CompressionMethod.getCompressionMethodFromCode( rawIO.readShortLittleEndian(inputStream))); localFileHeader.setLastModifiedTime(rawIO.readIntLittleEndian(inputStream));  <BUGS> readFully(inputStream, intBuff); localFileHeader.setCrc(rawIO.readLongLittleEndian(intBuff, 0)); localFileHeader.setCrcRawData(intBuff.clone()); <BUGE>
return null; }  private void setFilePointerToReadZip64EndCentralDirLoc(RandomAccessFile zip4jRaf, long offsetEndOfCentralDirectoryRecord) throws IOException { /* Now the file pointer is at the end of signature of Central Dir Rec*/ /* Seek back with the following values*/ /* 4 -> total number of disks*/ /* 8 -> relative offset of the zip64 end of central directory record*/ /* 4 -> number of the disk with the start of the zip64 end of central directory*/ /* 4 -> zip64 end of central dir locator signature*/ /* Refer to Appnote for more information*/ seekInCurrentPart(zip4jRaf, offsetEndOfCentralDirectoryRecord - 4 - 8 - 4 - 4); }  <BUGS> localFileHeader.setCompressedSize(rawIO.readLongLittleEndian(inputStream, 4)); localFileHeader.setUncompressedSize(rawIO.readLongLittleEndian(inputStream, 4)); <BUGE>  int fileNameLength = rawIO.readShortLittleEndian(inputStream); localFileHeader.setFileNameLength(fileNameLength);  localFileHeader.setExtraFieldLength(rawIO.readShortLittleEndian(inputStream));  if (fileNameLength > 0) { byte[] fileNameBuf = new byte[fileNameLength]; readFully(inputStream, fileNameBuf); // Modified after user reported an issue http:/*www.lingala.net/zip4j/forum/index.php?topic=2.0*/ /*				String fileName = new String(fileNameBuf, "Cp850");*/ /*				String fileName = Zip4jUtil.getCp850EncodedString(fileNameBuf);*/ String fileName = decodeStringWithCharset(fileNameBuf, localFileHeader.isFileNameUTF8Encoded(), charset);
return null; }  private void setFilePointerToReadZip64EndCentralDirLoc(RandomAccessFile zip4jRaf, long offsetEndOfCentralDirectoryRecord) throws IOException { /* Now the file pointer is at the end of signature of Central Dir Rec*/ /* Seek back with the following values*/ /* 4 -> total number of disks*/ /* 8 -> relative offset of the zip64 end of central directory record*/ /* 4 -> number of the disk with the start of the zip64 end of central directory*/ /* 4 -> zip64 end of central dir locator signature*/ /* Refer to Appnote for more information*/ seekInCurrentPart(zip4jRaf, offsetEndOfCentralDirectoryRecord - 4 - 8 - 4 - 4); }  <BUGS> int fileNameLength = rawIO.readShortLittleEndian(inputStream); localFileHeader.setFileNameLength(fileNameLength); <BUGE>  localFileHeader.setExtraFieldLength(rawIO.readShortLittleEndian(inputStream));  if (fileNameLength > 0) { byte[] fileNameBuf = new byte[fileNameLength]; readFully(inputStream, fileNameBuf); // Modified after user reported an issue http:/*www.lingala.net/zip4j/forum/index.php?topic=2.0*/ /*				String fileName = new String(fileNameBuf, "Cp850");*/ /*				String fileName = Zip4jUtil.getCp850EncodedString(fileNameBuf);*/ String fileName = decodeStringWithCharset(fileNameBuf, localFileHeader.isFileNameUTF8Encoded(), charset);  if (fileName == null) { throw new ZipException("file name is null, cannot assign file name to local file header");
return null; }  private void setFilePointerToReadZip64EndCentralDirLoc(RandomAccessFile zip4jRaf, long offsetEndOfCentralDirectoryRecord) throws IOException { /* Now the file pointer is at the end of signature of Central Dir Rec*/ /* Seek back with the following values*/ /* 4 -> total number of disks*/ /* 8 -> relative offset of the zip64 end of central directory record*/ /* 4 -> number of the disk with the start of the zip64 end of central directory*/ /* 4 -> zip64 end of central dir locator signature*/ /* Refer to Appnote for more information*/ seekInCurrentPart(zip4jRaf, offsetEndOfCentralDirectoryRecord - 4 - 8 - 4 - 4); }  <BUGS> localFileHeader.setExtraFieldLength(rawIO.readShortLittleEndian(inputStream)); <BUGE>  if (fileNameLength > 0) { byte[] fileNameBuf = new byte[fileNameLength]; readFully(inputStream, fileNameBuf); // Modified after user reported an issue http:/*www.lingala.net/zip4j/forum/index.php?topic=2.0*/ /*				String fileName = new String(fileNameBuf, "Cp850");*/ /*				String fileName = Zip4jUtil.getCp850EncodedString(fileNameBuf);*/ String fileName = decodeStringWithCharset(fileNameBuf, localFileHeader.isFileNameUTF8Encoded(), charset);  if (fileName == null) { throw new ZipException("file name is null, cannot assign file name to local file header"); }  if (fileName.contains(":" + System.getProperty("file.separator"))) {
}  private void setFilePointerToReadZip64EndCentralDirLoc(RandomAccessFile zip4jRaf, long offsetEndOfCentralDirectoryRecord) throws IOException { /* Now the file pointer is at the end of signature of Central Dir Rec*/ /* Seek back with the following values*/ /* 4 -> total number of disks*/ /* 8 -> relative offset of the zip64 end of central directory record*/ /* 4 -> number of the disk with the start of the zip64 end of central directory*/ /* 4 -> zip64 end of central dir locator signature*/ /* Refer to Appnote for more information*/ seekInCurrentPart(zip4jRaf, offsetEndOfCentralDirectoryRecord - 4 - 8 - 4 - 4); }  <BUGS> if (fileNameLength > 0) { byte[] fileNameBuf = new byte[fileNameLength]; readFully(inputStream, fileNameBuf); <BUGE> // Modified after user reported an issue http:/*www.lingala.net/zip4j/forum/index.php?topic=2.0*/ /*				String fileName = new String(fileNameBuf, "Cp850");*/ /*				String fileName = Zip4jUtil.getCp850EncodedString(fileNameBuf);*/ String fileName = decodeStringWithCharset(fileNameBuf, localFileHeader.isFileNameUTF8Encoded(), charset);  if (fileName == null) { throw new ZipException("file name is null, cannot assign file name to local file header"); }  if (fileName.contains(":" + System.getProperty("file.separator"))) { fileName = fileName.substring(fileName.indexOf(":" + System.getProperty("file.separator")) + 2); }
return null; }  private void setFilePointerToReadZip64EndCentralDirLoc(RandomAccessFile zip4jRaf, long offsetEndOfCentralDirectoryRecord) throws IOException { /* Now the file pointer is at the end of signature of Central Dir Rec*/ /* Seek back with the following values*/ /* 4 -> total number of disks*/ /* 8 -> relative offset of the zip64 end of central directory record*/ /* 4 -> number of the disk with the start of the zip64 end of central directory*/ /* 4 -> zip64 end of central dir locator signature*/ /* Refer to Appnote for more information*/ seekInCurrentPart(zip4jRaf, offsetEndOfCentralDirectoryRecord - 4 - 8 - 4 - 4); } /*				String fileName = Zip4jUtil.getCp850EncodedString(fileNameBuf);*/ <BUGS> String fileName = decodeStringWithCharset(fileNameBuf, localFileHeader.isFileNameUTF8Encoded(), charset); <BUGE>  if (fileName == null) { throw new ZipException("file name is null, cannot assign file name to local file header"); }  if (fileName.contains(":" + System.getProperty("file.separator"))) { fileName = fileName.substring(fileName.indexOf(":" + System.getProperty("file.separator")) + 2); }  localFileHeader.setFileName(fileName); localFileHeader.setDirectory(fileName.endsWith("/") || fileName.endsWith("\\")); } else { localFileHeader.setFileName(null); }
return null; }  private void setFilePointerToReadZip64EndCentralDirLoc(RandomAccessFile zip4jRaf, long offsetEndOfCentralDirectoryRecord) throws IOException { /* Now the file pointer is at the end of signature of Central Dir Rec*/ /* Seek back with the following values*/ /* 4 -> total number of disks*/ /* 8 -> relative offset of the zip64 end of central directory record*/ /* 4 -> number of the disk with the start of the zip64 end of central directory*/ /* 4 -> zip64 end of central dir locator signature*/ /* Refer to Appnote for more information*/ seekInCurrentPart(zip4jRaf, offsetEndOfCentralDirectoryRecord - 4 - 8 - 4 - 4); }  <BUGS> if (fileName == null) { <BUGE> throw new ZipException("file name is null, cannot assign file name to local file header"); }  if (fileName.contains(":" + System.getProperty("file.separator"))) { fileName = fileName.substring(fileName.indexOf(":" + System.getProperty("file.separator")) + 2); }  localFileHeader.setFileName(fileName); localFileHeader.setDirectory(fileName.endsWith("/") || fileName.endsWith("\\")); } else { localFileHeader.setFileName(null); }  readExtraDataRecords(inputStream, localFileHeader);
return null; }  private void setFilePointerToReadZip64EndCentralDirLoc(RandomAccessFile zip4jRaf, long offsetEndOfCentralDirectoryRecord) throws IOException { /* Now the file pointer is at the end of signature of Central Dir Rec*/ /* Seek back with the following values*/ /* 4 -> total number of disks*/ /* 8 -> relative offset of the zip64 end of central directory record*/ /* 4 -> number of the disk with the start of the zip64 end of central directory*/ /* 4 -> zip64 end of central dir locator signature*/ /* Refer to Appnote for more information*/ seekInCurrentPart(zip4jRaf, offsetEndOfCentralDirectoryRecord - 4 - 8 - 4 - 4); }  <BUGS> if (fileName.contains(":" + System.getProperty("file.separator"))) { <BUGE> fileName = fileName.substring(fileName.indexOf(":" + System.getProperty("file.separator")) + 2); }  localFileHeader.setFileName(fileName); localFileHeader.setDirectory(fileName.endsWith("/") || fileName.endsWith("\\")); } else { localFileHeader.setFileName(null); }  readExtraDataRecords(inputStream, localFileHeader); readZip64ExtendedInfo(localFileHeader, rawIO); readAesExtraDataRecord(localFileHeader, rawIO);  if (localFileHeader.isEncrypted()) {
}  private void setFilePointerToReadZip64EndCentralDirLoc(RandomAccessFile zip4jRaf, long offsetEndOfCentralDirectoryRecord) throws IOException { /* Now the file pointer is at the end of signature of Central Dir Rec*/ /* Seek back with the following values*/ /* 4 -> total number of disks*/ /* 8 -> relative offset of the zip64 end of central directory record*/ /* 4 -> number of the disk with the start of the zip64 end of central directory*/ /* 4 -> zip64 end of central dir locator signature*/ /* Refer to Appnote for more information*/ seekInCurrentPart(zip4jRaf, offsetEndOfCentralDirectoryRecord - 4 - 8 - 4 - 4); }  <BUGS> localFileHeader.setFileName(fileName); localFileHeader.setDirectory(fileName.endsWith("/") || fileName.endsWith("\\")); } else { <BUGE> localFileHeader.setFileName(null); }  readExtraDataRecords(inputStream, localFileHeader); readZip64ExtendedInfo(localFileHeader, rawIO); readAesExtraDataRecord(localFileHeader, rawIO);  if (localFileHeader.isEncrypted()) {  if (localFileHeader.getEncryptionMethod() == EncryptionMethod.AES) { /*Do nothing*/ } else { if (BigInteger.valueOf(localFileHeader.getGeneralPurposeFlag()[0]).testBit(6)) {
}  private void setFilePointerToReadZip64EndCentralDirLoc(RandomAccessFile zip4jRaf, long offsetEndOfCentralDirectoryRecord) throws IOException { /* Now the file pointer is at the end of signature of Central Dir Rec*/ /* Seek back with the following values*/ /* 4 -> total number of disks*/ /* 8 -> relative offset of the zip64 end of central directory record*/ /* 4 -> number of the disk with the start of the zip64 end of central directory*/ /* 4 -> zip64 end of central dir locator signature*/ /* Refer to Appnote for more information*/ seekInCurrentPart(zip4jRaf, offsetEndOfCentralDirectoryRecord - 4 - 8 - 4 - 4); }  <BUGS> readExtraDataRecords(inputStream, localFileHeader); readZip64ExtendedInfo(localFileHeader, rawIO); readAesExtraDataRecord(localFileHeader, rawIO); <BUGE>  if (localFileHeader.isEncrypted()) {  if (localFileHeader.getEncryptionMethod() == EncryptionMethod.AES) { /*Do nothing*/ } else { if (BigInteger.valueOf(localFileHeader.getGeneralPurposeFlag()[0]).testBit(6)) { localFileHeader.setEncryptionMethod(EncryptionMethod.ZIP_STANDARD_VARIANT_STRONG); } else { localFileHeader.setEncryptionMethod(EncryptionMethod.ZIP_STANDARD); } }
return null; }  private void setFilePointerToReadZip64EndCentralDirLoc(RandomAccessFile zip4jRaf, long offsetEndOfCentralDirectoryRecord) throws IOException { /* Now the file pointer is at the end of signature of Central Dir Rec*/ /* Seek back with the following values*/ /* 4 -> total number of disks*/ /* 8 -> relative offset of the zip64 end of central directory record*/ /* 4 -> number of the disk with the start of the zip64 end of central directory*/ /* 4 -> zip64 end of central dir locator signature*/ /* Refer to Appnote for more information*/ seekInCurrentPart(zip4jRaf, offsetEndOfCentralDirectoryRecord - 4 - 8 - 4 - 4); }  <BUGS> if (localFileHeader.isEncrypted()) { <BUGE>  if (localFileHeader.getEncryptionMethod() == EncryptionMethod.AES) { /*Do nothing*/ } else { if (BigInteger.valueOf(localFileHeader.getGeneralPurposeFlag()[0]).testBit(6)) { localFileHeader.setEncryptionMethod(EncryptionMethod.ZIP_STANDARD_VARIANT_STRONG); } else { localFileHeader.setEncryptionMethod(EncryptionMethod.ZIP_STANDARD); } }  }  return localFileHeader;
return null; }  private void setFilePointerToReadZip64EndCentralDirLoc(RandomAccessFile zip4jRaf, long offsetEndOfCentralDirectoryRecord) throws IOException { /* Now the file pointer is at the end of signature of Central Dir Rec*/ /* Seek back with the following values*/ /* 4 -> total number of disks*/ /* 8 -> relative offset of the zip64 end of central directory record*/ /* 4 -> number of the disk with the start of the zip64 end of central directory*/ /* 4 -> zip64 end of central dir locator signature*/ /* Refer to Appnote for more information*/ seekInCurrentPart(zip4jRaf, offsetEndOfCentralDirectoryRecord - 4 - 8 - 4 - 4); }  <BUGS> if (localFileHeader.getEncryptionMethod() == EncryptionMethod.AES) { <BUGE> /*Do nothing*/ } else { if (BigInteger.valueOf(localFileHeader.getGeneralPurposeFlag()[0]).testBit(6)) { localFileHeader.setEncryptionMethod(EncryptionMethod.ZIP_STANDARD_VARIANT_STRONG); } else { localFileHeader.setEncryptionMethod(EncryptionMethod.ZIP_STANDARD); } }  }  return localFileHeader; }
return null; }  private void setFilePointerToReadZip64EndCentralDirLoc(RandomAccessFile zip4jRaf, long offsetEndOfCentralDirectoryRecord) throws IOException { /* Now the file pointer is at the end of signature of Central Dir Rec*/ /* Seek back with the following values*/ /* 4 -> total number of disks*/ /* 8 -> relative offset of the zip64 end of central directory record*/ /* 4 -> number of the disk with the start of the zip64 end of central directory*/ /* 4 -> zip64 end of central dir locator signature*/ /* Refer to Appnote for more information*/ seekInCurrentPart(zip4jRaf, offsetEndOfCentralDirectoryRecord - 4 - 8 - 4 - 4); } } else { <BUGS> if (BigInteger.valueOf(localFileHeader.getGeneralPurposeFlag()[0]).testBit(6)) { localFileHeader.setEncryptionMethod(EncryptionMethod.ZIP_STANDARD_VARIANT_STRONG); <BUGE> } else { localFileHeader.setEncryptionMethod(EncryptionMethod.ZIP_STANDARD); } }  }  return localFileHeader; }  public DataDescriptor readDataDescriptor(InputStream inputStream, boolean isZip64Format) throws IOException {  DataDescriptor dataDescriptor = new DataDescriptor();
return null; }  private void setFilePointerToReadZip64EndCentralDirLoc(RandomAccessFile zip4jRaf, long offsetEndOfCentralDirectoryRecord) throws IOException { /* Now the file pointer is at the end of signature of Central Dir Rec*/ /* Seek back with the following values*/ /* 4 -> total number of disks*/ /* 8 -> relative offset of the zip64 end of central directory record*/ /* 4 -> number of the disk with the start of the zip64 end of central directory*/ /* 4 -> zip64 end of central dir locator signature*/ /* Refer to Appnote for more information*/ seekInCurrentPart(zip4jRaf, offsetEndOfCentralDirectoryRecord - 4 - 8 - 4 - 4); }  <BUGS> return localFileHeader; <BUGE> }  public DataDescriptor readDataDescriptor(InputStream inputStream, boolean isZip64Format) throws IOException {  DataDescriptor dataDescriptor = new DataDescriptor();  byte[] intBuff = new byte[4]; readFully(inputStream, intBuff); long sigOrCrc = rawIO.readLongLittleEndian(intBuff, 0);  /*According to zip specification, presence of extra data record header signature is optional.*/ /*If this signature is present, read it and read the next 4 bytes for crc*/ /*If signature not present, assign the read 4 bytes for crc*/ if (sigOrCrc == HeaderSignature.EXTRA_DATA_RECORD.getValue()) {
private long getCompressedSize(LocalFileHeader localFileHeader) { <BUGS> if (getCompressionMethod(localFileHeader).equals(CompressionMethod.STORE)) { <BUGE> return localFileHeader.getUncompressedSize(); }  if (localFileHeader.isDataDescriptorExists() && !canSkipExtendedLocalFileHeader) { return -1; }  return localFileHeader.getCompressedSize() - getEncryptionHeaderSize(localFileHeader); }
private long getCompressedSize(LocalFileHeader localFileHeader) { if (getCompressionMethod(localFileHeader).equals(CompressionMethod.STORE)) { return localFileHeader.getUncompressedSize(); }  <BUGS> if (localFileHeader.isDataDescriptorExists() && !canSkipExtendedLocalFileHeader) { return -1; <BUGE> }  return localFileHeader.getCompressedSize() - getEncryptionHeaderSize(localFileHeader); }
*/ public ZipFile(File zipFile) { <BUGS> this(zipFile, null); } <BUGE>
private CipherOutputStream initializeCipherOutputStream(ZipEntryOutputStream zipEntryOutputStream, ZipParameters zipParameters) throws IOException { <BUGS> if (!zipParameters.isEncryptFiles()) { <BUGE> return new NoCipherOutputStream(zipEntryOutputStream, zipParameters, null); }  if (password == null || password.length == 0) { throw new ZipException("password not set"); }  if (zipParameters.getEncryptionMethod() == EncryptionMethod.AES) { return new AesCipherOutputStream(zipEntryOutputStream, zipParameters, password); } else if (zipParameters.getEncryptionMethod() == EncryptionMethod.ZIP_STANDARD) { return new ZipStandardCipherOutputStream(zipEntryOutputStream, zipParameters, password); } else { throw new ZipException("Invalid encryption method"); } }
private CipherOutputStream initializeCipherOutputStream(ZipEntryOutputStream zipEntryOutputStream, ZipParameters zipParameters) throws IOException { if (!zipParameters.isEncryptFiles()) { return new NoCipherOutputStream(zipEntryOutputStream, zipParameters, null); }  <BUGS> if (password == null || password.length == 0) { <BUGE> throw new ZipException("password not set"); }  if (zipParameters.getEncryptionMethod() == EncryptionMethod.AES) { return new AesCipherOutputStream(zipEntryOutputStream, zipParameters, password); } else if (zipParameters.getEncryptionMethod() == EncryptionMethod.ZIP_STANDARD) { return new ZipStandardCipherOutputStream(zipEntryOutputStream, zipParameters, password); } else { throw new ZipException("Invalid encryption method"); } }
private CipherOutputStream initializeCipherOutputStream(ZipEntryOutputStream zipEntryOutputStream, ZipParameters zipParameters) throws IOException { if (!zipParameters.isEncryptFiles()) { return new NoCipherOutputStream(zipEntryOutputStream, zipParameters, null); }  if (password == null || password.length == 0) { throw new ZipException("password not set"); }  <BUGS> if (zipParameters.getEncryptionMethod() == EncryptionMethod.AES) { <BUGE> return new AesCipherOutputStream(zipEntryOutputStream, zipParameters, password); } else if (zipParameters.getEncryptionMethod() == EncryptionMethod.ZIP_STANDARD) { return new ZipStandardCipherOutputStream(zipEntryOutputStream, zipParameters, password); } else { throw new ZipException("Invalid encryption method"); } }
private CipherOutputStream initializeCipherOutputStream(ZipEntryOutputStream zipEntryOutputStream, ZipParameters zipParameters) throws IOException { if (!zipParameters.isEncryptFiles()) { return new NoCipherOutputStream(zipEntryOutputStream, zipParameters, null); }  if (password == null || password.length == 0) { throw new ZipException("password not set"); }  if (zipParameters.getEncryptionMethod() == EncryptionMethod.AES) { return new AesCipherOutputStream(zipEntryOutputStream, zipParameters, password); <BUGS> } else if (zipParameters.getEncryptionMethod() == EncryptionMethod.ZIP_STANDARD) { <BUGE> return new ZipStandardCipherOutputStream(zipEntryOutputStream, zipParameters, password); } else { throw new ZipException("Invalid encryption method"); } }
private CipherOutputStream initializeCipherOutputStream(ZipEntryOutputStream zipEntryOutputStream, ZipParameters zipParameters) throws IOException { if (!zipParameters.isEncryptFiles()) { return new NoCipherOutputStream(zipEntryOutputStream, zipParameters, null); }  if (password == null || password.length == 0) { throw new ZipException("password not set"); }  if (zipParameters.getEncryptionMethod() == EncryptionMethod.AES) { return new AesCipherOutputStream(zipEntryOutputStream, zipParameters, password); } else if (zipParameters.getEncryptionMethod() == EncryptionMethod.ZIP_STANDARD) { return new ZipStandardCipherOutputStream(zipEntryOutputStream, zipParameters, password); } else { <BUGS> throw new ZipException("Invalid encryption method"); <BUGE> } }
*/ public void addFolder(File folderToAdd) throws ZipException { <BUGS> addFolder(folderToAdd, new ZipParameters()); } <BUGE>
private void performTaskWithErrorHandling(T taskParameters, ProgressMonitor progressMonitor) throws ZipException { try { <BUGS> executeTask(taskParameters, progressMonitor); progressMonitor.endProgressMonitor(); <BUGE> } catch (ZipException e) { progressMonitor.endProgressMonitor(e); throw e; } catch (Exception e) { progressMonitor.endProgressMonitor(e); throw new ZipException(e); } }
private void performTaskWithErrorHandling(T taskParameters, ProgressMonitor progressMonitor) throws ZipException { try { executeTask(taskParameters, progressMonitor); progressMonitor.endProgressMonitor(); } catch (ZipException e) { progressMonitor.endProgressMonitor(e); throw e; <BUGS> } catch (Exception e) { progressMonitor.endProgressMonitor(e); throw new ZipException(e); } } <BUGE>
@Override public void close() throws IOException { <BUGS> if (zipFileClosed) { return; <BUGE> } for (InputStream inputStream : openInputStreams) { inputStream.close(); } openInputStreams.clear(); zipFileClosed = true; }
@Override public void close() throws IOException { if (zipFileClosed) { return; } <BUGS> for (InputStream inputStream : openInputStreams) { inputStream.close(); } openInputStreams.clear(); zipFileClosed = true; } <BUGE>
*/ public void addFolder(File folderToAdd) throws ZipException { <BUGS> addFolder(folderToAdd, new ZipParameters()); } <BUGE>
@Override protected void executeTask(ExtractFileTaskParameters taskParameters, ProgressMonitor progressMonitor) throws IOException {  <BUGS> try(ZipInputStream zipInputStream = createZipInputStream(taskParameters.zip4jConfig)) { List<FileHeader> fileHeadersUnderDirectory = getFileHeadersToExtract(taskParameters.fileToExtract); <BUGE> byte[] readBuff = new byte[taskParameters.zip4jConfig.getBufferSize()]; for (FileHeader fileHeader : fileHeadersUnderDirectory) { splitInputStream.prepareExtractionForFileHeader(fileHeader); String newFileName = determineNewFileName(taskParameters.newFileName, taskParameters.fileToExtract, fileHeader); extractFile(zipInputStream, fileHeader, taskParameters.outputPath, newFileName, progressMonitor, readBuff); } } finally { if (splitInputStream != null) { splitInputStream.close(); } } }
@Override protected void executeTask(ExtractFileTaskParameters taskParameters, ProgressMonitor progressMonitor) throws IOException {  try(ZipInputStream zipInputStream = createZipInputStream(taskParameters.zip4jConfig)) { List<FileHeader> fileHeadersUnderDirectory = getFileHeadersToExtract(taskParameters.fileToExtract); byte[] readBuff = new byte[taskParameters.zip4jConfig.getBufferSize()]; for (FileHeader fileHeader : fileHeadersUnderDirectory) { splitInputStream.prepareExtractionForFileHeader(fileHeader); String newFileName = determineNewFileName(taskParameters.newFileName, taskParameters.fileToExtract, fileHeader); extractFile(zipInputStream, fileHeader, taskParameters.outputPath, newFileName, progressMonitor, readBuff); } <BUGS> } finally { if (splitInputStream != null) { splitInputStream.close(); <BUGE> } } }
@Override protected void executeTask(ExtractFileTaskParameters taskParameters, ProgressMonitor progressMonitor) throws IOException {  try(ZipInputStream zipInputStream = createZipInputStream(taskParameters.zip4jConfig)) { List<FileHeader> fileHeadersUnderDirectory = getFileHeadersToExtract(taskParameters.fileToExtract); byte[] readBuff = new byte[taskParameters.zip4jConfig.getBufferSize()]; for (FileHeader fileHeader : fileHeadersUnderDirectory) { splitInputStream.prepareExtractionForFileHeader(fileHeader); String newFileName = determineNewFileName(taskParameters.newFileName, taskParameters.fileToExtract, fileHeader); extractFile(zipInputStream, fileHeader, taskParameters.outputPath, newFileName, progressMonitor, readBuff); } } finally { if (splitInputStream != null) { splitInputStream.close(); } <BUGS> } <BUGE> }
*/ public static AesKeyStrength getAesKeyStrengthFromRawCode(int code) { <BUGS> for (AesKeyStrength aesKeyStrength : values()) { if (aesKeyStrength.getRawCode() == code) { <BUGE> return aesKeyStrength; } }  return null; }
*/ public static AesKeyStrength getAesKeyStrengthFromRawCode(int code) { for (AesKeyStrength aesKeyStrength : values()) { if (aesKeyStrength.getRawCode() == code) { return aesKeyStrength; } }  <BUGS> return null; <BUGE> }
public LocalFileHeader readLocalFileHeader(InputStream inputStream, Charset charset) throws IOException { <BUGS> LocalFileHeader localFileHeader = new LocalFileHeader(); byte[] intBuff = new byte[4]; <BUGE>  /*signature*/ int sig = rawIO.readIntLittleEndian(inputStream); if (sig == HeaderSignature.TEMPORARY_SPANNING_MARKER.getValue()) { sig = rawIO.readIntLittleEndian(inputStream); } if (sig != HeaderSignature.LOCAL_FILE_HEADER.getValue()) { return null; } localFileHeader.setSignature(HeaderSignature.LOCAL_FILE_HEADER); localFileHeader.setVersionNeededToExtract(rawIO.readShortLittleEndian(inputStream));  byte[] generalPurposeFlags = new byte[2]; if (readFully(inputStream, generalPurposeFlags) != 2) { throw new ZipException("Could not read enough bytes for generalPurposeFlags"); } localFileHeader.setEncrypted(isBitSet(generalPurposeFlags[0], 0)); localFileHeader.setDataDescriptorExists(isBitSet(generalPurposeFlags[0], 3)); localFileHeader.setFileNameUTF8Encoded(isBitSet(generalPurposeFlags[1], 3)); localFileHeader.setGeneralPurposeFlag(generalPurposeFlags.clone());  localFileHeader.setCompressionMethod(CompressionMethod.getCompressionMethodFromCode( rawIO.readShortLittleEndian(inputStream))); localFileHeader.setLastModifiedTime(rawIO.readIntLittleEndian(inputStream));  readFully(inputStream, intBuff);
public LocalFileHeader readLocalFileHeader(InputStream inputStream, Charset charset) throws IOException { LocalFileHeader localFileHeader = new LocalFileHeader(); byte[] intBuff = new byte[4];  /*signature*/ <BUGS> int sig = rawIO.readIntLittleEndian(inputStream); if (sig == HeaderSignature.TEMPORARY_SPANNING_MARKER.getValue()) { <BUGE> sig = rawIO.readIntLittleEndian(inputStream); } if (sig != HeaderSignature.LOCAL_FILE_HEADER.getValue()) { return null; } localFileHeader.setSignature(HeaderSignature.LOCAL_FILE_HEADER); localFileHeader.setVersionNeededToExtract(rawIO.readShortLittleEndian(inputStream));  byte[] generalPurposeFlags = new byte[2]; if (readFully(inputStream, generalPurposeFlags) != 2) { throw new ZipException("Could not read enough bytes for generalPurposeFlags"); } localFileHeader.setEncrypted(isBitSet(generalPurposeFlags[0], 0)); localFileHeader.setDataDescriptorExists(isBitSet(generalPurposeFlags[0], 3)); localFileHeader.setFileNameUTF8Encoded(isBitSet(generalPurposeFlags[1], 3)); localFileHeader.setGeneralPurposeFlag(generalPurposeFlags.clone());  localFileHeader.setCompressionMethod(CompressionMethod.getCompressionMethodFromCode( rawIO.readShortLittleEndian(inputStream))); localFileHeader.setLastModifiedTime(rawIO.readIntLittleEndian(inputStream));  readFully(inputStream, intBuff);
public LocalFileHeader readLocalFileHeader(InputStream inputStream, Charset charset) throws IOException { LocalFileHeader localFileHeader = new LocalFileHeader(); byte[] intBuff = new byte[4];  /*signature*/ int sig = rawIO.readIntLittleEndian(inputStream); if (sig == HeaderSignature.TEMPORARY_SPANNING_MARKER.getValue()) { sig = rawIO.readIntLittleEndian(inputStream); } <BUGS> if (sig != HeaderSignature.LOCAL_FILE_HEADER.getValue()) { <BUGE> return null; } localFileHeader.setSignature(HeaderSignature.LOCAL_FILE_HEADER); localFileHeader.setVersionNeededToExtract(rawIO.readShortLittleEndian(inputStream));  byte[] generalPurposeFlags = new byte[2]; if (readFully(inputStream, generalPurposeFlags) != 2) { throw new ZipException("Could not read enough bytes for generalPurposeFlags"); } localFileHeader.setEncrypted(isBitSet(generalPurposeFlags[0], 0)); localFileHeader.setDataDescriptorExists(isBitSet(generalPurposeFlags[0], 3)); localFileHeader.setFileNameUTF8Encoded(isBitSet(generalPurposeFlags[1], 3)); localFileHeader.setGeneralPurposeFlag(generalPurposeFlags.clone());  localFileHeader.setCompressionMethod(CompressionMethod.getCompressionMethodFromCode( rawIO.readShortLittleEndian(inputStream))); localFileHeader.setLastModifiedTime(rawIO.readIntLittleEndian(inputStream));  readFully(inputStream, intBuff);
public LocalFileHeader readLocalFileHeader(InputStream inputStream, Charset charset) throws IOException { LocalFileHeader localFileHeader = new LocalFileHeader(); byte[] intBuff = new byte[4];  /*signature*/ int sig = rawIO.readIntLittleEndian(inputStream); if (sig == HeaderSignature.TEMPORARY_SPANNING_MARKER.getValue()) { sig = rawIO.readIntLittleEndian(inputStream); } if (sig != HeaderSignature.LOCAL_FILE_HEADER.getValue()) { return null; } <BUGS> localFileHeader.setSignature(HeaderSignature.LOCAL_FILE_HEADER); localFileHeader.setVersionNeededToExtract(rawIO.readShortLittleEndian(inputStream)); <BUGE>  byte[] generalPurposeFlags = new byte[2]; if (readFully(inputStream, generalPurposeFlags) != 2) { throw new ZipException("Could not read enough bytes for generalPurposeFlags"); } localFileHeader.setEncrypted(isBitSet(generalPurposeFlags[0], 0)); localFileHeader.setDataDescriptorExists(isBitSet(generalPurposeFlags[0], 3)); localFileHeader.setFileNameUTF8Encoded(isBitSet(generalPurposeFlags[1], 3)); localFileHeader.setGeneralPurposeFlag(generalPurposeFlags.clone());  localFileHeader.setCompressionMethod(CompressionMethod.getCompressionMethodFromCode( rawIO.readShortLittleEndian(inputStream))); localFileHeader.setLastModifiedTime(rawIO.readIntLittleEndian(inputStream));  readFully(inputStream, intBuff);
public LocalFileHeader readLocalFileHeader(InputStream inputStream, Charset charset) throws IOException { LocalFileHeader localFileHeader = new LocalFileHeader(); byte[] intBuff = new byte[4];  /*signature*/ int sig = rawIO.readIntLittleEndian(inputStream); if (sig == HeaderSignature.TEMPORARY_SPANNING_MARKER.getValue()) { sig = rawIO.readIntLittleEndian(inputStream); } if (sig != HeaderSignature.LOCAL_FILE_HEADER.getValue()) { return null; } localFileHeader.setSignature(HeaderSignature.LOCAL_FILE_HEADER); localFileHeader.setVersionNeededToExtract(rawIO.readShortLittleEndian(inputStream));  <BUGS> byte[] generalPurposeFlags = new byte[2]; if (readFully(inputStream, generalPurposeFlags) != 2) { <BUGE> throw new ZipException("Could not read enough bytes for generalPurposeFlags"); } localFileHeader.setEncrypted(isBitSet(generalPurposeFlags[0], 0)); localFileHeader.setDataDescriptorExists(isBitSet(generalPurposeFlags[0], 3)); localFileHeader.setFileNameUTF8Encoded(isBitSet(generalPurposeFlags[1], 3)); localFileHeader.setGeneralPurposeFlag(generalPurposeFlags.clone());  localFileHeader.setCompressionMethod(CompressionMethod.getCompressionMethodFromCode( rawIO.readShortLittleEndian(inputStream))); localFileHeader.setLastModifiedTime(rawIO.readIntLittleEndian(inputStream));  readFully(inputStream, intBuff);
public LocalFileHeader readLocalFileHeader(InputStream inputStream, Charset charset) throws IOException { LocalFileHeader localFileHeader = new LocalFileHeader(); byte[] intBuff = new byte[4];  /*signature*/ int sig = rawIO.readIntLittleEndian(inputStream); if (sig == HeaderSignature.TEMPORARY_SPANNING_MARKER.getValue()) { sig = rawIO.readIntLittleEndian(inputStream); } if (sig != HeaderSignature.LOCAL_FILE_HEADER.getValue()) { return null; } localFileHeader.setSignature(HeaderSignature.LOCAL_FILE_HEADER); localFileHeader.setVersionNeededToExtract(rawIO.readShortLittleEndian(inputStream));  byte[] generalPurposeFlags = new byte[2]; if (readFully(inputStream, generalPurposeFlags) != 2) { throw new ZipException("Could not read enough bytes for generalPurposeFlags"); } <BUGS> localFileHeader.setEncrypted(isBitSet(generalPurposeFlags[0], 0)); localFileHeader.setDataDescriptorExists(isBitSet(generalPurposeFlags[0], 3)); localFileHeader.setFileNameUTF8Encoded(isBitSet(generalPurposeFlags[1], 3)); localFileHeader.setGeneralPurposeFlag(generalPurposeFlags.clone()); <BUGE>  localFileHeader.setCompressionMethod(CompressionMethod.getCompressionMethodFromCode( rawIO.readShortLittleEndian(inputStream))); localFileHeader.setLastModifiedTime(rawIO.readIntLittleEndian(inputStream));  readFully(inputStream, intBuff);
public LocalFileHeader readLocalFileHeader(InputStream inputStream, Charset charset) throws IOException { LocalFileHeader localFileHeader = new LocalFileHeader(); byte[] intBuff = new byte[4];  /*signature*/ int sig = rawIO.readIntLittleEndian(inputStream); if (sig == HeaderSignature.TEMPORARY_SPANNING_MARKER.getValue()) { sig = rawIO.readIntLittleEndian(inputStream); } if (sig != HeaderSignature.LOCAL_FILE_HEADER.getValue()) { return null; } localFileHeader.setSignature(HeaderSignature.LOCAL_FILE_HEADER); localFileHeader.setVersionNeededToExtract(rawIO.readShortLittleEndian(inputStream));  byte[] generalPurposeFlags = new byte[2]; if (readFully(inputStream, generalPurposeFlags) != 2) { throw new ZipException("Could not read enough bytes for generalPurposeFlags"); } localFileHeader.setEncrypted(isBitSet(generalPurposeFlags[0], 0)); localFileHeader.setDataDescriptorExists(isBitSet(generalPurposeFlags[0], 3)); localFileHeader.setFileNameUTF8Encoded(isBitSet(generalPurposeFlags[1], 3)); localFileHeader.setGeneralPurposeFlag(generalPurposeFlags.clone());  <BUGS> localFileHeader.setCompressionMethod(CompressionMethod.getCompressionMethodFromCode( rawIO.readShortLittleEndian(inputStream))); localFileHeader.setLastModifiedTime(rawIO.readIntLittleEndian(inputStream)); <BUGE>  readFully(inputStream, intBuff);
public LocalFileHeader readLocalFileHeader(InputStream inputStream, Charset charset) throws IOException { LocalFileHeader localFileHeader = new LocalFileHeader(); byte[] intBuff = new byte[4];  /*signature*/ int sig = rawIO.readIntLittleEndian(inputStream); if (sig == HeaderSignature.TEMPORARY_SPANNING_MARKER.getValue()) { sig = rawIO.readIntLittleEndian(inputStream); } if (sig != HeaderSignature.LOCAL_FILE_HEADER.getValue()) { return null; } localFileHeader.setSignature(HeaderSignature.LOCAL_FILE_HEADER); localFileHeader.setVersionNeededToExtract(rawIO.readShortLittleEndian(inputStream));  byte[] generalPurposeFlags = new byte[2]; if (readFully(inputStream, generalPurposeFlags) != 2) { throw new ZipException("Could not read enough bytes for generalPurposeFlags"); } localFileHeader.setEncrypted(isBitSet(generalPurposeFlags[0], 0)); localFileHeader.setDataDescriptorExists(isBitSet(generalPurposeFlags[0], 3)); localFileHeader.setFileNameUTF8Encoded(isBitSet(generalPurposeFlags[1], 3)); localFileHeader.setGeneralPurposeFlag(generalPurposeFlags.clone());  localFileHeader.setCompressionMethod(CompressionMethod.getCompressionMethodFromCode( rawIO.readShortLittleEndian(inputStream))); localFileHeader.setLastModifiedTime(rawIO.readIntLittleEndian(inputStream));  <BUGS> readFully(inputStream, intBuff);
return null; }  private void setFilePointerToReadZip64EndCentralDirLoc(RandomAccessFile zip4jRaf, long offsetEndOfCentralDirectoryRecord) throws IOException { /* Now the file pointer is at the end of signature of Central Dir Rec*/ /* Seek back with the following values*/ /* 4 -> total number of disks*/ /* 8 -> relative offset of the zip64 end of central directory record*/ /* 4 -> number of the disk with the start of the zip64 end of central directory*/ /* 4 -> zip64 end of central dir locator signature*/ /* Refer to Appnote for more information*/ seekInCurrentPart(zip4jRaf, offsetEndOfCentralDirectoryRecord - 4 - 8 - 4 - 4); }  <BUGS> localFileHeader.setCompressedSize(rawIO.readLongLittleEndian(inputStream, 4)); localFileHeader.setUncompressedSize(rawIO.readLongLittleEndian(inputStream, 4)); <BUGE>  int fileNameLength = rawIO.readShortLittleEndian(inputStream); localFileHeader.setFileNameLength(fileNameLength);  localFileHeader.setExtraFieldLength(rawIO.readShortLittleEndian(inputStream));  if (fileNameLength > 0) { byte[] fileNameBuf = new byte[fileNameLength]; readFully(inputStream, fileNameBuf);  String fileName = decodeStringWithCharset(fileNameBuf, localFileHeader.isFileNameUTF8Encoded(), charset); localFileHeader.setFileName(fileName); localFileHeader.setDirectory(fileName.endsWith("/") || fileName.endsWith("\\"));
return null; }  private void setFilePointerToReadZip64EndCentralDirLoc(RandomAccessFile zip4jRaf, long offsetEndOfCentralDirectoryRecord) throws IOException { /* Now the file pointer is at the end of signature of Central Dir Rec*/ /* Seek back with the following values*/ /* 4 -> total number of disks*/ /* 8 -> relative offset of the zip64 end of central directory record*/ /* 4 -> number of the disk with the start of the zip64 end of central directory*/ /* 4 -> zip64 end of central dir locator signature*/ /* Refer to Appnote for more information*/ seekInCurrentPart(zip4jRaf, offsetEndOfCentralDirectoryRecord - 4 - 8 - 4 - 4); }  <BUGS> int fileNameLength = rawIO.readShortLittleEndian(inputStream); localFileHeader.setFileNameLength(fileNameLength); <BUGE>  localFileHeader.setExtraFieldLength(rawIO.readShortLittleEndian(inputStream));  if (fileNameLength > 0) { byte[] fileNameBuf = new byte[fileNameLength]; readFully(inputStream, fileNameBuf);  String fileName = decodeStringWithCharset(fileNameBuf, localFileHeader.isFileNameUTF8Encoded(), charset); localFileHeader.setFileName(fileName); localFileHeader.setDirectory(fileName.endsWith("/") || fileName.endsWith("\\")); } else { localFileHeader.setFileName(null); }
return null; }  private void setFilePointerToReadZip64EndCentralDirLoc(RandomAccessFile zip4jRaf, long offsetEndOfCentralDirectoryRecord) throws IOException { /* Now the file pointer is at the end of signature of Central Dir Rec*/ /* Seek back with the following values*/ /* 4 -> total number of disks*/ /* 8 -> relative offset of the zip64 end of central directory record*/ /* 4 -> number of the disk with the start of the zip64 end of central directory*/ /* 4 -> zip64 end of central dir locator signature*/ /* Refer to Appnote for more information*/ seekInCurrentPart(zip4jRaf, offsetEndOfCentralDirectoryRecord - 4 - 8 - 4 - 4); }  <BUGS> localFileHeader.setExtraFieldLength(rawIO.readShortLittleEndian(inputStream)); <BUGE>  if (fileNameLength > 0) { byte[] fileNameBuf = new byte[fileNameLength]; readFully(inputStream, fileNameBuf);  String fileName = decodeStringWithCharset(fileNameBuf, localFileHeader.isFileNameUTF8Encoded(), charset); localFileHeader.setFileName(fileName); localFileHeader.setDirectory(fileName.endsWith("/") || fileName.endsWith("\\")); } else { localFileHeader.setFileName(null); }  readExtraDataRecords(inputStream, localFileHeader); readZip64ExtendedInfo(localFileHeader, rawIO);
return null; }  private void setFilePointerToReadZip64EndCentralDirLoc(RandomAccessFile zip4jRaf, long offsetEndOfCentralDirectoryRecord) throws IOException { /* Now the file pointer is at the end of signature of Central Dir Rec*/ /* Seek back with the following values*/ /* 4 -> total number of disks*/ /* 8 -> relative offset of the zip64 end of central directory record*/ /* 4 -> number of the disk with the start of the zip64 end of central directory*/ /* 4 -> zip64 end of central dir locator signature*/ /* Refer to Appnote for more information*/ seekInCurrentPart(zip4jRaf, offsetEndOfCentralDirectoryRecord - 4 - 8 - 4 - 4); }  <BUGS> if (fileNameLength > 0) { <BUGE> byte[] fileNameBuf = new byte[fileNameLength]; readFully(inputStream, fileNameBuf);  String fileName = decodeStringWithCharset(fileNameBuf, localFileHeader.isFileNameUTF8Encoded(), charset); localFileHeader.setFileName(fileName); localFileHeader.setDirectory(fileName.endsWith("/") || fileName.endsWith("\\")); } else { localFileHeader.setFileName(null); }  readExtraDataRecords(inputStream, localFileHeader); readZip64ExtendedInfo(localFileHeader, rawIO); readAesExtraDataRecord(localFileHeader, rawIO);
return null; }  private void setFilePointerToReadZip64EndCentralDirLoc(RandomAccessFile zip4jRaf, long offsetEndOfCentralDirectoryRecord) throws IOException { /* Now the file pointer is at the end of signature of Central Dir Rec*/ /* Seek back with the following values*/ /* 4 -> total number of disks*/ /* 8 -> relative offset of the zip64 end of central directory record*/ /* 4 -> number of the disk with the start of the zip64 end of central directory*/ /* 4 -> zip64 end of central dir locator signature*/ /* Refer to Appnote for more information*/ seekInCurrentPart(zip4jRaf, offsetEndOfCentralDirectoryRecord - 4 - 8 - 4 - 4); } } else { <BUGS> localFileHeader.setFileName(null); <BUGE> }  readExtraDataRecords(inputStream, localFileHeader); readZip64ExtendedInfo(localFileHeader, rawIO); readAesExtraDataRecord(localFileHeader, rawIO);  if (localFileHeader.isEncrypted()) {  if (localFileHeader.getEncryptionMethod() == EncryptionMethod.AES) { /*Do nothing*/ } else { if (isBitSet(localFileHeader.getGeneralPurposeFlag()[0], 6)) { localFileHeader.setEncryptionMethod(EncryptionMethod.ZIP_STANDARD_VARIANT_STRONG); } else {
}  private void setFilePointerToReadZip64EndCentralDirLoc(RandomAccessFile zip4jRaf, long offsetEndOfCentralDirectoryRecord) throws IOException { /* Now the file pointer is at the end of signature of Central Dir Rec*/ /* Seek back with the following values*/ /* 4 -> total number of disks*/ /* 8 -> relative offset of the zip64 end of central directory record*/ /* 4 -> number of the disk with the start of the zip64 end of central directory*/ /* 4 -> zip64 end of central dir locator signature*/ /* Refer to Appnote for more information*/ seekInCurrentPart(zip4jRaf, offsetEndOfCentralDirectoryRecord - 4 - 8 - 4 - 4); }  <BUGS> readExtraDataRecords(inputStream, localFileHeader); readZip64ExtendedInfo(localFileHeader, rawIO); readAesExtraDataRecord(localFileHeader, rawIO); <BUGE>  if (localFileHeader.isEncrypted()) {  if (localFileHeader.getEncryptionMethod() == EncryptionMethod.AES) { /*Do nothing*/ } else { if (isBitSet(localFileHeader.getGeneralPurposeFlag()[0], 6)) { localFileHeader.setEncryptionMethod(EncryptionMethod.ZIP_STANDARD_VARIANT_STRONG); } else { localFileHeader.setEncryptionMethod(EncryptionMethod.ZIP_STANDARD); } }
return null; }  private void setFilePointerToReadZip64EndCentralDirLoc(RandomAccessFile zip4jRaf, long offsetEndOfCentralDirectoryRecord) throws IOException { /* Now the file pointer is at the end of signature of Central Dir Rec*/ /* Seek back with the following values*/ /* 4 -> total number of disks*/ /* 8 -> relative offset of the zip64 end of central directory record*/ /* 4 -> number of the disk with the start of the zip64 end of central directory*/ /* 4 -> zip64 end of central dir locator signature*/ /* Refer to Appnote for more information*/ seekInCurrentPart(zip4jRaf, offsetEndOfCentralDirectoryRecord - 4 - 8 - 4 - 4); }  <BUGS> if (localFileHeader.isEncrypted()) { <BUGE>  if (localFileHeader.getEncryptionMethod() == EncryptionMethod.AES) { /*Do nothing*/ } else { if (isBitSet(localFileHeader.getGeneralPurposeFlag()[0], 6)) { localFileHeader.setEncryptionMethod(EncryptionMethod.ZIP_STANDARD_VARIANT_STRONG); } else { localFileHeader.setEncryptionMethod(EncryptionMethod.ZIP_STANDARD); } }  }  return localFileHeader;
return null; }  private void setFilePointerToReadZip64EndCentralDirLoc(RandomAccessFile zip4jRaf, long offsetEndOfCentralDirectoryRecord) throws IOException { /* Now the file pointer is at the end of signature of Central Dir Rec*/ /* Seek back with the following values*/ /* 4 -> total number of disks*/ /* 8 -> relative offset of the zip64 end of central directory record*/ /* 4 -> number of the disk with the start of the zip64 end of central directory*/ /* 4 -> zip64 end of central dir locator signature*/ /* Refer to Appnote for more information*/ seekInCurrentPart(zip4jRaf, offsetEndOfCentralDirectoryRecord - 4 - 8 - 4 - 4); }  <BUGS> return localFileHeader; <BUGE> }  public DataDescriptor readDataDescriptor(InputStream inputStream, boolean isZip64Format) throws IOException {  DataDescriptor dataDescriptor = new DataDescriptor();  byte[] intBuff = new byte[4]; readFully(inputStream, intBuff); long sigOrCrc = rawIO.readLongLittleEndian(intBuff, 0);  /*According to zip specification, presence of extra data record header signature is optional.*/ /*If this signature is present, read it and read the next 4 bytes for crc*/ /*If signature not present, assign the read 4 bytes for crc*/ if (sigOrCrc == HeaderSignature.EXTRA_DATA_RECORD.getValue()) {
@Override public void close() throws IOException { <BUGS> if (!this.entryClosed) { closeEntry(); <BUGE> }  zipModel.getEndOfCentralDirectoryRecord().setOffsetOfStartOfCentralDirectory(countingOutputStream.getNumberOfBytesWritten()); headerWriter.finalizeZipFile(zipModel, countingOutputStream, zip4jConfig.getCharset()); countingOutputStream.close(); this.streamClosed = true; }
@Override public void close() throws IOException { if (!this.entryClosed) { closeEntry(); }  <BUGS> zipModel.getEndOfCentralDirectoryRecord().setOffsetOfStartOfCentralDirectory(countingOutputStream.getNumberOfBytesWritten()); headerWriter.finalizeZipFile(zipModel, countingOutputStream, zip4jConfig.getCharset()); countingOutputStream.close(); this.streamClosed = true; } <BUGE>
private AESExtraDataRecord readAesExtraDataRecord(List<ExtraDataRecord> extraDataRecords, RawIO rawIO) throws ZipException {  <BUGS> if (extraDataRecords == null) { <BUGE> return null; }  for (ExtraDataRecord extraDataRecord : extraDataRecords) { if (extraDataRecord == null) { continue; }  if (extraDataRecord.getHeader() == HeaderSignature.AES_EXTRA_DATA_RECORD.getValue()) {  if (extraDataRecord.getData() == null) { throw new ZipException("corrupt AES extra data records"); }  AESExtraDataRecord aesExtraDataRecord = new AESExtraDataRecord();  aesExtraDataRecord.setSignature(HeaderSignature.AES_EXTRA_DATA_RECORD); aesExtraDataRecord.setDataSize(extraDataRecord.getSizeOfData());  byte[] aesData = extraDataRecord.getData(); aesExtraDataRecord.setAesVersion(AesVersion.getFromVersionNumber(rawIO.readShortLittleEndian(aesData, 0))); byte[] vendorIDBytes = new byte[2]; System.arraycopy(aesData, 2, vendorIDBytes, 0, 2); aesExtraDataRecord.setVendorID(new String(vendorIDBytes)); aesExtraDataRecord.setAesKeyStrength(AesKeyStrength.getAesKeyStrengthFromRawCode(aesData[4] & 0xFF));
private AESExtraDataRecord readAesExtraDataRecord(List<ExtraDataRecord> extraDataRecords, RawIO rawIO) throws ZipException {  if (extraDataRecords == null) { return null; }  <BUGS> for (ExtraDataRecord extraDataRecord : extraDataRecords) { if (extraDataRecord == null) { <BUGE> continue; }  if (extraDataRecord.getHeader() == HeaderSignature.AES_EXTRA_DATA_RECORD.getValue()) {  if (extraDataRecord.getData() == null) { throw new ZipException("corrupt AES extra data records"); }  AESExtraDataRecord aesExtraDataRecord = new AESExtraDataRecord();  aesExtraDataRecord.setSignature(HeaderSignature.AES_EXTRA_DATA_RECORD); aesExtraDataRecord.setDataSize(extraDataRecord.getSizeOfData());  byte[] aesData = extraDataRecord.getData(); aesExtraDataRecord.setAesVersion(AesVersion.getFromVersionNumber(rawIO.readShortLittleEndian(aesData, 0))); byte[] vendorIDBytes = new byte[2]; System.arraycopy(aesData, 2, vendorIDBytes, 0, 2); aesExtraDataRecord.setVendorID(new String(vendorIDBytes)); aesExtraDataRecord.setAesKeyStrength(AesKeyStrength.getAesKeyStrengthFromRawCode(aesData[4] & 0xFF));
private AESExtraDataRecord readAesExtraDataRecord(List<ExtraDataRecord> extraDataRecords, RawIO rawIO) throws ZipException {  if (extraDataRecords == null) { return null; }  for (ExtraDataRecord extraDataRecord : extraDataRecords) { if (extraDataRecord == null) { continue; }  <BUGS> if (extraDataRecord.getHeader() == HeaderSignature.AES_EXTRA_DATA_RECORD.getValue()) { <BUGE>  if (extraDataRecord.getData() == null) { throw new ZipException("corrupt AES extra data records"); }  AESExtraDataRecord aesExtraDataRecord = new AESExtraDataRecord();  aesExtraDataRecord.setSignature(HeaderSignature.AES_EXTRA_DATA_RECORD); aesExtraDataRecord.setDataSize(extraDataRecord.getSizeOfData());  byte[] aesData = extraDataRecord.getData(); aesExtraDataRecord.setAesVersion(AesVersion.getFromVersionNumber(rawIO.readShortLittleEndian(aesData, 0))); byte[] vendorIDBytes = new byte[2]; System.arraycopy(aesData, 2, vendorIDBytes, 0, 2); aesExtraDataRecord.setVendorID(new String(vendorIDBytes)); aesExtraDataRecord.setAesKeyStrength(AesKeyStrength.getAesKeyStrengthFromRawCode(aesData[4] & 0xFF));
private AESExtraDataRecord readAesExtraDataRecord(List<ExtraDataRecord> extraDataRecords, RawIO rawIO) throws ZipException {  if (extraDataRecords == null) { return null; }  for (ExtraDataRecord extraDataRecord : extraDataRecords) { if (extraDataRecord == null) { continue; }  if (extraDataRecord.getHeader() == HeaderSignature.AES_EXTRA_DATA_RECORD.getValue()) {  <BUGS> if (extraDataRecord.getData() == null) { <BUGE> throw new ZipException("corrupt AES extra data records"); }  AESExtraDataRecord aesExtraDataRecord = new AESExtraDataRecord();  aesExtraDataRecord.setSignature(HeaderSignature.AES_EXTRA_DATA_RECORD); aesExtraDataRecord.setDataSize(extraDataRecord.getSizeOfData());  byte[] aesData = extraDataRecord.getData(); aesExtraDataRecord.setAesVersion(AesVersion.getFromVersionNumber(rawIO.readShortLittleEndian(aesData, 0))); byte[] vendorIDBytes = new byte[2]; System.arraycopy(aesData, 2, vendorIDBytes, 0, 2); aesExtraDataRecord.setVendorID(new String(vendorIDBytes)); aesExtraDataRecord.setAesKeyStrength(AesKeyStrength.getAesKeyStrengthFromRawCode(aesData[4] & 0xFF));
private AESExtraDataRecord readAesExtraDataRecord(List<ExtraDataRecord> extraDataRecords, RawIO rawIO) throws ZipException {  if (extraDataRecords == null) { return null; }  for (ExtraDataRecord extraDataRecord : extraDataRecords) { if (extraDataRecord == null) { continue; }  if (extraDataRecord.getHeader() == HeaderSignature.AES_EXTRA_DATA_RECORD.getValue()) {  if (extraDataRecord.getData() == null) { throw new ZipException("corrupt AES extra data records"); }  <BUGS> AESExtraDataRecord aesExtraDataRecord = new AESExtraDataRecord(); <BUGE>  aesExtraDataRecord.setSignature(HeaderSignature.AES_EXTRA_DATA_RECORD); aesExtraDataRecord.setDataSize(extraDataRecord.getSizeOfData());  byte[] aesData = extraDataRecord.getData(); aesExtraDataRecord.setAesVersion(AesVersion.getFromVersionNumber(rawIO.readShortLittleEndian(aesData, 0))); byte[] vendorIDBytes = new byte[2]; System.arraycopy(aesData, 2, vendorIDBytes, 0, 2); aesExtraDataRecord.setVendorID(new String(vendorIDBytes)); aesExtraDataRecord.setAesKeyStrength(AesKeyStrength.getAesKeyStrengthFromRawCode(aesData[4] & 0xFF));
private AESExtraDataRecord readAesExtraDataRecord(List<ExtraDataRecord> extraDataRecords, RawIO rawIO) throws ZipException {  if (extraDataRecords == null) { return null; }  for (ExtraDataRecord extraDataRecord : extraDataRecords) { if (extraDataRecord == null) { continue; }  if (extraDataRecord.getHeader() == HeaderSignature.AES_EXTRA_DATA_RECORD.getValue()) {  if (extraDataRecord.getData() == null) { throw new ZipException("corrupt AES extra data records"); }  AESExtraDataRecord aesExtraDataRecord = new AESExtraDataRecord();  <BUGS> aesExtraDataRecord.setSignature(HeaderSignature.AES_EXTRA_DATA_RECORD); aesExtraDataRecord.setDataSize(extraDataRecord.getSizeOfData()); <BUGE>  byte[] aesData = extraDataRecord.getData(); aesExtraDataRecord.setAesVersion(AesVersion.getFromVersionNumber(rawIO.readShortLittleEndian(aesData, 0))); byte[] vendorIDBytes = new byte[2]; System.arraycopy(aesData, 2, vendorIDBytes, 0, 2); aesExtraDataRecord.setVendorID(new String(vendorIDBytes)); aesExtraDataRecord.setAesKeyStrength(AesKeyStrength.getAesKeyStrengthFromRawCode(aesData[4] & 0xFF));
private AESExtraDataRecord readAesExtraDataRecord(List<ExtraDataRecord> extraDataRecords, RawIO rawIO) throws ZipException {  if (extraDataRecords == null) { return null; }  for (ExtraDataRecord extraDataRecord : extraDataRecords) { if (extraDataRecord == null) { continue; }  if (extraDataRecord.getHeader() == HeaderSignature.AES_EXTRA_DATA_RECORD.getValue()) {  if (extraDataRecord.getData() == null) { throw new ZipException("corrupt AES extra data records"); }  AESExtraDataRecord aesExtraDataRecord = new AESExtraDataRecord();  aesExtraDataRecord.setSignature(HeaderSignature.AES_EXTRA_DATA_RECORD); aesExtraDataRecord.setDataSize(extraDataRecord.getSizeOfData());  <BUGS> byte[] aesData = extraDataRecord.getData(); aesExtraDataRecord.setAesVersion(AesVersion.getFromVersionNumber(rawIO.readShortLittleEndian(aesData, 0))); byte[] vendorIDBytes = new byte[2]; System.arraycopy(aesData, 2, vendorIDBytes, 0, 2); <BUGE> aesExtraDataRecord.setVendorID(new String(vendorIDBytes)); aesExtraDataRecord.setAesKeyStrength(AesKeyStrength.getAesKeyStrengthFromRawCode(aesData[4] & 0xFF));
private AESExtraDataRecord readAesExtraDataRecord(List<ExtraDataRecord> extraDataRecords, RawIO rawIO) throws ZipException {  <BUGS> if (extraDataRecords == null) { <BUGE> return null; }  for (ExtraDataRecord extraDataRecord : extraDataRecords) { if (extraDataRecord == null) { continue; }  if (extraDataRecord.getHeader() == HeaderSignature.AES_EXTRA_DATA_RECORD.getValue()) {  byte[] aesExtraDataRecordBytes = extraDataRecord.getData(); if (aesExtraDataRecordBytes == null || aesExtraDataRecordBytes.length != 9) { throw new ZipException("corrupt AES extra data records"); }  AESExtraDataRecord aesExtraDataRecord = new AESExtraDataRecord();  aesExtraDataRecord.setSignature(HeaderSignature.AES_EXTRA_DATA_RECORD); aesExtraDataRecord.setDataSize(extraDataRecord.getSizeOfData());  byte[] aesData = extraDataRecord.getData(); aesExtraDataRecord.setAesVersion(AesVersion.getFromVersionNumber(rawIO.readShortLittleEndian(aesData, 0))); byte[] vendorIDBytes = new byte[2]; System.arraycopy(aesData, 2, vendorIDBytes, 0, 2); aesExtraDataRecord.setVendorID(new String(vendorIDBytes));
private AESExtraDataRecord readAesExtraDataRecord(List<ExtraDataRecord> extraDataRecords, RawIO rawIO) throws ZipException {  if (extraDataRecords == null) { return null; }  <BUGS> for (ExtraDataRecord extraDataRecord : extraDataRecords) { if (extraDataRecord == null) { <BUGE> continue; }  if (extraDataRecord.getHeader() == HeaderSignature.AES_EXTRA_DATA_RECORD.getValue()) {  byte[] aesExtraDataRecordBytes = extraDataRecord.getData(); if (aesExtraDataRecordBytes == null || aesExtraDataRecordBytes.length != 9) { throw new ZipException("corrupt AES extra data records"); }  AESExtraDataRecord aesExtraDataRecord = new AESExtraDataRecord();  aesExtraDataRecord.setSignature(HeaderSignature.AES_EXTRA_DATA_RECORD); aesExtraDataRecord.setDataSize(extraDataRecord.getSizeOfData());  byte[] aesData = extraDataRecord.getData(); aesExtraDataRecord.setAesVersion(AesVersion.getFromVersionNumber(rawIO.readShortLittleEndian(aesData, 0))); byte[] vendorIDBytes = new byte[2]; System.arraycopy(aesData, 2, vendorIDBytes, 0, 2); aesExtraDataRecord.setVendorID(new String(vendorIDBytes));
private AESExtraDataRecord readAesExtraDataRecord(List<ExtraDataRecord> extraDataRecords, RawIO rawIO) throws ZipException {  if (extraDataRecords == null) { return null; }  for (ExtraDataRecord extraDataRecord : extraDataRecords) { if (extraDataRecord == null) { continue; }  <BUGS> if (extraDataRecord.getHeader() == HeaderSignature.AES_EXTRA_DATA_RECORD.getValue()) { <BUGE>  byte[] aesExtraDataRecordBytes = extraDataRecord.getData(); if (aesExtraDataRecordBytes == null || aesExtraDataRecordBytes.length != 9) { throw new ZipException("corrupt AES extra data records"); }  AESExtraDataRecord aesExtraDataRecord = new AESExtraDataRecord();  aesExtraDataRecord.setSignature(HeaderSignature.AES_EXTRA_DATA_RECORD); aesExtraDataRecord.setDataSize(extraDataRecord.getSizeOfData());  byte[] aesData = extraDataRecord.getData(); aesExtraDataRecord.setAesVersion(AesVersion.getFromVersionNumber(rawIO.readShortLittleEndian(aesData, 0))); byte[] vendorIDBytes = new byte[2]; System.arraycopy(aesData, 2, vendorIDBytes, 0, 2); aesExtraDataRecord.setVendorID(new String(vendorIDBytes));
private AESExtraDataRecord readAesExtraDataRecord(List<ExtraDataRecord> extraDataRecords, RawIO rawIO) throws ZipException {  if (extraDataRecords == null) { return null; }  for (ExtraDataRecord extraDataRecord : extraDataRecords) { if (extraDataRecord == null) { continue; }  if (extraDataRecord.getHeader() == HeaderSignature.AES_EXTRA_DATA_RECORD.getValue()) {  <BUGS> byte[] aesExtraDataRecordBytes = extraDataRecord.getData(); if (aesExtraDataRecordBytes == null || aesExtraDataRecordBytes.length != 9) { throw new ZipException("corrupt AES extra data records"); <BUGE> }  AESExtraDataRecord aesExtraDataRecord = new AESExtraDataRecord();  aesExtraDataRecord.setSignature(HeaderSignature.AES_EXTRA_DATA_RECORD); aesExtraDataRecord.setDataSize(extraDataRecord.getSizeOfData());  byte[] aesData = extraDataRecord.getData(); aesExtraDataRecord.setAesVersion(AesVersion.getFromVersionNumber(rawIO.readShortLittleEndian(aesData, 0))); byte[] vendorIDBytes = new byte[2]; System.arraycopy(aesData, 2, vendorIDBytes, 0, 2); aesExtraDataRecord.setVendorID(new String(vendorIDBytes));
public int readRawFully(byte[] b) throws  IOException {  <BUGS> int readLen = inputStream.read(b); <BUGE>   if (readLen != b.length) { readLen = readUntilBufferIsFull(b, readLen);  if (readLen != b.length) { throw new IOException("Cannot read fully into byte buffer"); } }  return readLen; }
public int readRawFully(byte[] b) throws  IOException {  int readLen = inputStream.read(b);   <BUGS> if (readLen != b.length) { readLen = readUntilBufferIsFull(b, readLen); <BUGE>  if (readLen != b.length) { throw new IOException("Cannot read fully into byte buffer"); } }  return readLen; }
private void performTaskWithErrorHandling(T taskParameters, ProgressMonitor progressMonitor) throws ZipException { try { <BUGS> executeTask(taskParameters, progressMonitor); <BUGE> progressMonitor.endProgressMonitor(); } catch (ZipException e) { progressMonitor.endProgressMonitor(e); throw e; } catch (Exception e) { progressMonitor.endProgressMonitor(e); throw new ZipException(e); } }
private void performTaskWithErrorHandling(T taskParameters, ProgressMonitor progressMonitor) throws ZipException { try { executeTask(taskParameters, progressMonitor); progressMonitor.endProgressMonitor(); } catch (ZipException e) { progressMonitor.endProgressMonitor(e); throw e; <BUGS> } catch (Exception e) { progressMonitor.endProgressMonitor(e); throw new ZipException(e); <BUGE> } }
private void verifyZipParameters(ZipParameters zipParameters) { <BUGS> if (zipParameters.getCompressionMethod() == CompressionMethod.STORE && zipParameters.getEntrySize() < 0 && !isEntryDirectory(zipParameters.getFileNameInZip()) && zipParameters.isWriteExtendedLocalFileHeader()) { <BUGE> throw new IllegalArgumentException("uncompressed size should be set for zip entries of compression type store"); } }
private void verifyZipParameters(ZipParameters zipParameters) { if (zipParameters.getCompressionMethod() == CompressionMethod.STORE && zipParameters.getEntrySize() < 0 && !isEntryDirectory(zipParameters.getFileNameInZip()) && zipParameters.isWriteExtendedLocalFileHeader()) { throw new IllegalArgumentException("uncompressed size should be set for zip entries of compression type store"); } <BUGS> } <BUGE>
private void performTaskWithErrorHandling(T taskParameters, ProgressMonitor progressMonitor) throws ZipException { try { <BUGS> executeTask(taskParameters, progressMonitor); progressMonitor.endProgressMonitor(); <BUGE> } catch (ZipException e) { progressMonitor.endProgressMonitor(e); throw e; } catch (Exception e) { progressMonitor.endProgressMonitor(e); throw new ZipException(e); } }
private void performTaskWithErrorHandling(T taskParameters, ProgressMonitor progressMonitor) throws ZipException { try { executeTask(taskParameters, progressMonitor); progressMonitor.endProgressMonitor(); } catch (ZipException e) { progressMonitor.endProgressMonitor(e); throw e; <BUGS> } catch (Exception e) { progressMonitor.endProgressMonitor(e); throw new ZipException(e); } } <BUGE>
public static String decodeStringWithCharset(byte[] data, boolean isUtf8Encoded) { <BUGS> if (isUtf8Encoded) { <BUGE> return new String(data, StandardCharsets.UTF_8); }  try { return new String(data, ZIP_STANDARD_CHARSET); } catch (UnsupportedEncodingException e) { return new String(data); } }
public static String decodeStringWithCharset(byte[] data, boolean isUtf8Encoded) { if (isUtf8Encoded) { return new String(data, StandardCharsets.UTF_8); }  try { <BUGS> return new String(data, ZIP_STANDARD_CHARSET); <BUGE> } catch (UnsupportedEncodingException e) { return new String(data); } }
private void performTaskWithErrorHandling(T taskParameters, ProgressMonitor progressMonitor) throws ZipException { try { <BUGS> executeTask(taskParameters, progressMonitor); progressMonitor.endProgressMonitor(); } catch (ZipException e) { progressMonitor.endProgressMonitor(e); throw e; } catch (Exception e) { progressMonitor.endProgressMonitor(e); throw new ZipException(e); } } <BUGE>
private void performTaskWithErrorHandling(T taskParameters, ProgressMonitor progressMonitor) throws ZipException { try { <BUGS> executeTask(taskParameters, progressMonitor); <BUGE> progressMonitor.endProgressMonitor(); } catch (ZipException e) { progressMonitor.endProgressMonitor(e); throw e; } catch (Exception e) { progressMonitor.endProgressMonitor(e); throw new ZipException(e); } }
private void performTaskWithErrorHandling(T taskParameters, ProgressMonitor progressMonitor) throws ZipException { try { executeTask(taskParameters, progressMonitor); progressMonitor.endProgressMonitor(); } catch (ZipException e) { progressMonitor.endProgressMonitor(e); throw e; <BUGS> } catch (Exception e) { progressMonitor.endProgressMonitor(e); throw new ZipException(e); <BUGE> } }
public static String decodeStringWithCharset(byte[] data, boolean isUtf8Encoded, Charset charset) {  <BUGS> if(charset != null) { return new String(data, charset); <BUGE> }  if (isUtf8Encoded) { return new String(data, InternalZipConstants.CHARSET_UTF_8); } try { return new String(data, ZIP_STANDARD_CHARSET); } catch (UnsupportedEncodingException e) { return new String(data); } }
public ZipModel readAllHeaders(RandomAccessFile zip4jRaf, Charset charset) throws IOException {  <BUGS> if (zip4jRaf.length() < ENDHDR) { <BUGE> throw new ZipException("Zip file size less than minimum expected zip file size. " + "Probably not a zip file or a corrupted zip file"); }  zipModel = new ZipModel();  try { zipModel.setEndOfCentralDirectoryRecord(readEndOfCentralDirectoryRecord(zip4jRaf, rawIO, charset)); } catch (ZipException e){ throw e; } catch (IOException e) { throw new ZipException("Zip headers not found. Probably not a zip file or a corrupted zip file", e); }  if (zipModel.getEndOfCentralDirectoryRecord().getTotalNumberOfEntriesInCentralDirectory() == 0) { return zipModel; }  /* If file is Zip64 format, Zip64 headers have to be read before reading central directory*/ zipModel.setZip64EndOfCentralDirectoryLocator(readZip64EndOfCentralDirectoryLocator(zip4jRaf, rawIO));  if (zipModel.isZip64Format()) { zipModel.setZip64EndOfCentralDirectoryRecord(readZip64EndCentralDirRec(zip4jRaf, rawIO)); if (zipModel.getZip64EndOfCentralDirectoryRecord() != null && zipModel.getZip64EndOfCentralDirectoryRecord().getNumberOfThisDisk() > 0) { zipModel.setSplitArchive(true);
public ZipModel readAllHeaders(RandomAccessFile zip4jRaf, Charset charset) throws IOException {  if (zip4jRaf.length() < ENDHDR) { throw new ZipException("Zip file size less than minimum expected zip file size. " + "Probably not a zip file or a corrupted zip file"); }  <BUGS> zipModel = new ZipModel(); <BUGE>  try { zipModel.setEndOfCentralDirectoryRecord(readEndOfCentralDirectoryRecord(zip4jRaf, rawIO, charset)); } catch (ZipException e){ throw e; } catch (IOException e) { throw new ZipException("Zip headers not found. Probably not a zip file or a corrupted zip file", e); }  if (zipModel.getEndOfCentralDirectoryRecord().getTotalNumberOfEntriesInCentralDirectory() == 0) { return zipModel; }  /* If file is Zip64 format, Zip64 headers have to be read before reading central directory*/ zipModel.setZip64EndOfCentralDirectoryLocator(readZip64EndOfCentralDirectoryLocator(zip4jRaf, rawIO));  if (zipModel.isZip64Format()) { zipModel.setZip64EndOfCentralDirectoryRecord(readZip64EndCentralDirRec(zip4jRaf, rawIO)); if (zipModel.getZip64EndOfCentralDirectoryRecord() != null && zipModel.getZip64EndOfCentralDirectoryRecord().getNumberOfThisDisk() > 0) { zipModel.setSplitArchive(true);
public ZipModel readAllHeaders(RandomAccessFile zip4jRaf, Charset charset) throws IOException {  if (zip4jRaf.length() < ENDHDR) { throw new ZipException("Zip file size less than minimum expected zip file size. " + "Probably not a zip file or a corrupted zip file"); }  zipModel = new ZipModel();  try { <BUGS> zipModel.setEndOfCentralDirectoryRecord(readEndOfCentralDirectoryRecord(zip4jRaf, rawIO, charset)); <BUGE> } catch (ZipException e){ throw e; } catch (IOException e) { throw new ZipException("Zip headers not found. Probably not a zip file or a corrupted zip file", e); }  if (zipModel.getEndOfCentralDirectoryRecord().getTotalNumberOfEntriesInCentralDirectory() == 0) { return zipModel; }  /* If file is Zip64 format, Zip64 headers have to be read before reading central directory*/ zipModel.setZip64EndOfCentralDirectoryLocator(readZip64EndOfCentralDirectoryLocator(zip4jRaf, rawIO));  if (zipModel.isZip64Format()) { zipModel.setZip64EndOfCentralDirectoryRecord(readZip64EndCentralDirRec(zip4jRaf, rawIO)); if (zipModel.getZip64EndOfCentralDirectoryRecord() != null && zipModel.getZip64EndOfCentralDirectoryRecord().getNumberOfThisDisk() > 0) { zipModel.setSplitArchive(true);
public ZipModel readAllHeaders(RandomAccessFile zip4jRaf, Charset charset) throws IOException {  if (zip4jRaf.length() < ENDHDR) { throw new ZipException("Zip file size less than minimum expected zip file size. " + "Probably not a zip file or a corrupted zip file"); }  zipModel = new ZipModel();  try { zipModel.setEndOfCentralDirectoryRecord(readEndOfCentralDirectoryRecord(zip4jRaf, rawIO, charset)); } catch (ZipException e){ throw e; <BUGS> } catch (IOException e) { throw new ZipException("Zip headers not found. Probably not a zip file or a corrupted zip file", e); <BUGE> }  if (zipModel.getEndOfCentralDirectoryRecord().getTotalNumberOfEntriesInCentralDirectory() == 0) { return zipModel; }  /* If file is Zip64 format, Zip64 headers have to be read before reading central directory*/ zipModel.setZip64EndOfCentralDirectoryLocator(readZip64EndOfCentralDirectoryLocator(zip4jRaf, rawIO));  if (zipModel.isZip64Format()) { zipModel.setZip64EndOfCentralDirectoryRecord(readZip64EndCentralDirRec(zip4jRaf, rawIO)); if (zipModel.getZip64EndOfCentralDirectoryRecord() != null && zipModel.getZip64EndOfCentralDirectoryRecord().getNumberOfThisDisk() > 0) { zipModel.setSplitArchive(true);
public Task getCurrentTask() { <BUGS> return currentTask; <BUGE> }
private void performTaskWithErrorHandling(T taskParameters, ProgressMonitor progressMonitor) throws ZipException { try { <BUGS> executeTask(taskParameters, progressMonitor); <BUGE> progressMonitor.endProgressMonitor(); } catch (ZipException e) { progressMonitor.endProgressMonitor(e); throw e; } catch (Exception e) { progressMonitor.endProgressMonitor(e); throw new ZipException(e); } }
private void performTaskWithErrorHandling(T taskParameters, ProgressMonitor progressMonitor) throws ZipException { try { executeTask(taskParameters, progressMonitor); progressMonitor.endProgressMonitor(); } catch (ZipException e) { progressMonitor.endProgressMonitor(e); throw e; <BUGS> } catch (Exception e) { progressMonitor.endProgressMonitor(e); throw new ZipException(e); <BUGE> } }
*/ public boolean isValidZipFile() { <BUGS> if (!zipFile.exists()) { <BUGE> return false; }  try { readZipInfo(); return true; } catch (Exception e) { return false; } }
*/ public boolean isValidZipFile() { if (!zipFile.exists()) { return false; }  try { <BUGS> readZipInfo(); return true; <BUGE> } catch (Exception e) { return false; } }
public static void copyFile(RandomAccessFile randomAccessFile, OutputStream outputStream, long start, long end, ProgressMonitor progressMonitor) throws ZipException {  <BUGS> if (start < 0 || end < 0 || start > end) { throw new ZipException("invalid offsets"); <BUGE> }  if (start == end) { return; }  try { randomAccessFile.seek(start);  int readLen; byte[] buff; long bytesRead = 0; long bytesToRead = end - start;  if ((end - start) < BUFF_SIZE) { buff = new byte[(int) bytesToRead]; } else { buff = new byte[BUFF_SIZE]; }  while ((readLen = randomAccessFile.read(buff)) != -1) { outputStream.write(buff, 0, readLen);  progressMonitor.updateWorkCompleted(readLen);
public static void copyFile(RandomAccessFile randomAccessFile, OutputStream outputStream, long start, long end, ProgressMonitor progressMonitor) throws ZipException {  if (start < 0 || end < 0 || start > end) { throw new ZipException("invalid offsets"); }  <BUGS> if (start == end) { <BUGE> return; }  try { randomAccessFile.seek(start);  int readLen; byte[] buff; long bytesRead = 0; long bytesToRead = end - start;  if ((end - start) < BUFF_SIZE) { buff = new byte[(int) bytesToRead]; } else { buff = new byte[BUFF_SIZE]; }  while ((readLen = randomAccessFile.read(buff)) != -1) { outputStream.write(buff, 0, readLen);  progressMonitor.updateWorkCompleted(readLen);
public static void copyFile(RandomAccessFile randomAccessFile, OutputStream outputStream, long start, long end, ProgressMonitor progressMonitor) throws ZipException {  if (start < 0 || end < 0 || start > end) { throw new ZipException("invalid offsets"); }  if (start == end) { return; }  try { <BUGS> randomAccessFile.seek(start); <BUGE>  int readLen; byte[] buff; long bytesRead = 0; long bytesToRead = end - start;  if ((end - start) < BUFF_SIZE) { buff = new byte[(int) bytesToRead]; } else { buff = new byte[BUFF_SIZE]; }  while ((readLen = randomAccessFile.read(buff)) != -1) { outputStream.write(buff, 0, readLen);  progressMonitor.updateWorkCompleted(readLen);
public static void copyFile(RandomAccessFile randomAccessFile, OutputStream outputStream, long start, long end, ProgressMonitor progressMonitor) throws ZipException {  if (start < 0 || end < 0 || start > end) { throw new ZipException("invalid offsets"); }  if (start == end) { return; }  try { randomAccessFile.seek(start);  int readLen; byte[] buff; <BUGS> long bytesRead = 0; long bytesToRead = end - start; <BUGE>  if ((end - start) < BUFF_SIZE) { buff = new byte[(int) bytesToRead]; } else { buff = new byte[BUFF_SIZE]; }  while ((readLen = randomAccessFile.read(buff)) != -1) { outputStream.write(buff, 0, readLen);  progressMonitor.updateWorkCompleted(readLen);
public static void copyFile(RandomAccessFile randomAccessFile, OutputStream outputStream, long start, long end, ProgressMonitor progressMonitor) throws ZipException {  if (start < 0 || end < 0 || start > end) { throw new ZipException("invalid offsets"); }  if (start == end) { return; }  try { randomAccessFile.seek(start);  int readLen; byte[] buff; long bytesRead = 0; long bytesToRead = end - start;  <BUGS> if ((end - start) < BUFF_SIZE) { buff = new byte[(int) bytesToRead]; <BUGE> } else { buff = new byte[BUFF_SIZE]; }  while ((readLen = randomAccessFile.read(buff)) != -1) { outputStream.write(buff, 0, readLen);  progressMonitor.updateWorkCompleted(readLen);
public static void copyFile(RandomAccessFile randomAccessFile, OutputStream outputStream, long start, long end, ProgressMonitor progressMonitor) throws ZipException {  if (start < 0 || end < 0 || start > end) { throw new ZipException("invalid offsets"); }  if (start == end) { return; }  try { randomAccessFile.seek(start);  int readLen; byte[] buff; long bytesRead = 0; long bytesToRead = end - start;  if ((end - start) < BUFF_SIZE) { buff = new byte[(int) bytesToRead]; } else { <BUGS> buff = new byte[BUFF_SIZE]; <BUGE> }  while ((readLen = randomAccessFile.read(buff)) != -1) { outputStream.write(buff, 0, readLen);  progressMonitor.updateWorkCompleted(readLen);
public static void copyFile(RandomAccessFile randomAccessFile, OutputStream outputStream, long start, long end, ProgressMonitor progressMonitor) throws ZipException {  if (start < 0 || end < 0 || start > end) { throw new ZipException("invalid offsets"); }  if (start == end) { return; }  try { randomAccessFile.seek(start);  int readLen; byte[] buff; long bytesRead = 0; long bytesToRead = end - start;  if ((end - start) < BUFF_SIZE) { buff = new byte[(int) bytesToRead]; } else { buff = new byte[BUFF_SIZE]; }  <BUGS> while ((readLen = randomAccessFile.read(buff)) != -1) { outputStream.write(buff, 0, readLen); <BUGE>  progressMonitor.updateWorkCompleted(readLen);
public static void copyFile(RandomAccessFile randomAccessFile, OutputStream outputStream, long start, long end, ProgressMonitor progressMonitor) throws ZipException {  if (start < 0 || end < 0 || start > end) { throw new ZipException("invalid offsets"); }  if (start == end) { return; }  try { randomAccessFile.seek(start);  int readLen; byte[] buff; long bytesRead = 0; long bytesToRead = end - start;  if ((end - start) < BUFF_SIZE) { buff = new byte[(int) bytesToRead]; } else { buff = new byte[BUFF_SIZE]; }  while ((readLen = randomAccessFile.read(buff)) != -1) { outputStream.write(buff, 0, readLen);  <BUGS> progressMonitor.updateWorkCompleted(readLen);
if (isStringNotNullAndNotEmpty(fileNameInZip)) { return fileNameInZip; }  if (isSymbolicLink(fileToAdd)) { return fileToAdd.toPath().toRealPath(LinkOption.NOFOLLOW_LINKS).getFileName().toString(); }  return fileToAdd.getName(); }  public static boolean isZipEntryDirectory(String fileNameInZip) { return fileNameInZip.endsWith("/") || fileNameInZip.endsWith("\\"); }  <BUGS> bytesRead += readLen; <BUGE>  if (bytesRead == bytesToRead) { break; } else if (bytesRead + buff.length > bytesToRead) { buff = new byte[(int) (bytesToRead - bytesRead)]; } }  } catch (IOException e) { throw new ZipException(e); } }  public static void assertFilesExist(List<File> files, ZipParameters.SymbolicLinkAction symLinkAction) throws ZipException {
return fileNameInZip; }  if (isSymbolicLink(fileToAdd)) { return fileToAdd.toPath().toRealPath(LinkOption.NOFOLLOW_LINKS).getFileName().toString(); }  return fileToAdd.getName(); }  public static boolean isZipEntryDirectory(String fileNameInZip) { return fileNameInZip.endsWith("/") || fileNameInZip.endsWith("\\"); }  <BUGS> if (bytesRead == bytesToRead) { break; } else if (bytesRead + buff.length > bytesToRead) { buff = new byte[(int) (bytesToRead - bytesRead)]; <BUGE> } }  } catch (IOException e) { throw new ZipException(e); } }  public static void assertFilesExist(List<File> files, ZipParameters.SymbolicLinkAction symLinkAction) throws ZipException { for (File file : files) { if (isSymbolicLink(file)) { /* If symlink is INCLUDE_LINK_ONLY, and if the above condition is true, it means that the link exists and there*/
if (isStringNotNullAndNotEmpty(fileNameInZip)) { return fileNameInZip; }  if (isSymbolicLink(fileToAdd)) { return fileToAdd.toPath().toRealPath(LinkOption.NOFOLLOW_LINKS).getFileName().toString(); }  return fileToAdd.getName(); }  public static boolean isZipEntryDirectory(String fileNameInZip) { return fileNameInZip.endsWith("/") || fileNameInZip.endsWith("\\"); } throw new ZipException(e); <BUGS> } } <BUGE>  public static void assertFilesExist(List<File> files, ZipParameters.SymbolicLinkAction symLinkAction) throws ZipException { for (File file : files) { if (isSymbolicLink(file)) { /* If symlink is INCLUDE_LINK_ONLY, and if the above condition is true, it means that the link exists and there*/ /* will be no need to check for link existence explicitly, check only for target file existence if required*/ if (symLinkAction.equals(ZipParameters.SymbolicLinkAction.INCLUDE_LINK_AND_LINKED_FILE) || symLinkAction.equals(ZipParameters.SymbolicLinkAction.INCLUDE_LINKED_FILE_ONLY)) { assertSymbolicLinkTargetExists(file); } } else { assertFileExists(file); }
private void performTaskWithErrorHandling(T taskParameters, ProgressMonitor progressMonitor) throws ZipException { try { <BUGS> executeTask(taskParameters, progressMonitor); progressMonitor.endProgressMonitor(); } catch (ZipException e) { progressMonitor.endProgressMonitor(e); throw e; } catch (Exception e) { progressMonitor.endProgressMonitor(e); throw new ZipException(e); } } <BUGE>
public LocalFileHeader readLocalFileHeader(InputStream inputStream, Charset charset) throws IOException { <BUGS> LocalFileHeader localFileHeader = new LocalFileHeader(); byte[] intBuff = new byte[4]; <BUGE>  /*signature*/ int sig = rawIO.readIntLittleEndian(inputStream); if (sig != HeaderSignature.LOCAL_FILE_HEADER.getValue()) { return null; } localFileHeader.setSignature(HeaderSignature.LOCAL_FILE_HEADER); localFileHeader.setVersionNeededToExtract(rawIO.readShortLittleEndian(inputStream));  byte[] generalPurposeFlags = new byte[2]; if (readFully(inputStream, generalPurposeFlags) != 2) { throw new ZipException("Could not read enough bytes for generalPurposeFlags"); } localFileHeader.setEncrypted(isBitSet(generalPurposeFlags[0], 0)); localFileHeader.setDataDescriptorExists(isBitSet(generalPurposeFlags[0], 3)); localFileHeader.setFileNameUTF8Encoded(isBitSet(generalPurposeFlags[1], 3)); localFileHeader.setGeneralPurposeFlag(generalPurposeFlags.clone());  localFileHeader.setCompressionMethod(CompressionMethod.getCompressionMethodFromCode( rawIO.readShortLittleEndian(inputStream))); localFileHeader.setLastModifiedTime(rawIO.readIntLittleEndian(inputStream));  readFully(inputStream, intBuff); localFileHeader.setCrc(rawIO.readLongLittleEndian(intBuff, 0)); localFileHeader.setCrcRawData(intBuff.clone());
public LocalFileHeader readLocalFileHeader(InputStream inputStream, Charset charset) throws IOException { LocalFileHeader localFileHeader = new LocalFileHeader(); byte[] intBuff = new byte[4];  /*signature*/ <BUGS> int sig = rawIO.readIntLittleEndian(inputStream); if (sig != HeaderSignature.LOCAL_FILE_HEADER.getValue()) { <BUGE> return null; } localFileHeader.setSignature(HeaderSignature.LOCAL_FILE_HEADER); localFileHeader.setVersionNeededToExtract(rawIO.readShortLittleEndian(inputStream));  byte[] generalPurposeFlags = new byte[2]; if (readFully(inputStream, generalPurposeFlags) != 2) { throw new ZipException("Could not read enough bytes for generalPurposeFlags"); } localFileHeader.setEncrypted(isBitSet(generalPurposeFlags[0], 0)); localFileHeader.setDataDescriptorExists(isBitSet(generalPurposeFlags[0], 3)); localFileHeader.setFileNameUTF8Encoded(isBitSet(generalPurposeFlags[1], 3)); localFileHeader.setGeneralPurposeFlag(generalPurposeFlags.clone());  localFileHeader.setCompressionMethod(CompressionMethod.getCompressionMethodFromCode( rawIO.readShortLittleEndian(inputStream))); localFileHeader.setLastModifiedTime(rawIO.readIntLittleEndian(inputStream));  readFully(inputStream, intBuff); localFileHeader.setCrc(rawIO.readLongLittleEndian(intBuff, 0)); localFileHeader.setCrcRawData(intBuff.clone());
public LocalFileHeader readLocalFileHeader(InputStream inputStream, Charset charset) throws IOException { LocalFileHeader localFileHeader = new LocalFileHeader(); byte[] intBuff = new byte[4];  /*signature*/ int sig = rawIO.readIntLittleEndian(inputStream); if (sig != HeaderSignature.LOCAL_FILE_HEADER.getValue()) { return null; } <BUGS> localFileHeader.setSignature(HeaderSignature.LOCAL_FILE_HEADER); localFileHeader.setVersionNeededToExtract(rawIO.readShortLittleEndian(inputStream)); <BUGE>  byte[] generalPurposeFlags = new byte[2]; if (readFully(inputStream, generalPurposeFlags) != 2) { throw new ZipException("Could not read enough bytes for generalPurposeFlags"); } localFileHeader.setEncrypted(isBitSet(generalPurposeFlags[0], 0)); localFileHeader.setDataDescriptorExists(isBitSet(generalPurposeFlags[0], 3)); localFileHeader.setFileNameUTF8Encoded(isBitSet(generalPurposeFlags[1], 3)); localFileHeader.setGeneralPurposeFlag(generalPurposeFlags.clone());  localFileHeader.setCompressionMethod(CompressionMethod.getCompressionMethodFromCode( rawIO.readShortLittleEndian(inputStream))); localFileHeader.setLastModifiedTime(rawIO.readIntLittleEndian(inputStream));  readFully(inputStream, intBuff); localFileHeader.setCrc(rawIO.readLongLittleEndian(intBuff, 0)); localFileHeader.setCrcRawData(intBuff.clone());
public LocalFileHeader readLocalFileHeader(InputStream inputStream, Charset charset) throws IOException { LocalFileHeader localFileHeader = new LocalFileHeader(); byte[] intBuff = new byte[4];  /*signature*/ int sig = rawIO.readIntLittleEndian(inputStream); if (sig != HeaderSignature.LOCAL_FILE_HEADER.getValue()) { return null; } localFileHeader.setSignature(HeaderSignature.LOCAL_FILE_HEADER); localFileHeader.setVersionNeededToExtract(rawIO.readShortLittleEndian(inputStream));  <BUGS> byte[] generalPurposeFlags = new byte[2]; if (readFully(inputStream, generalPurposeFlags) != 2) { <BUGE> throw new ZipException("Could not read enough bytes for generalPurposeFlags"); } localFileHeader.setEncrypted(isBitSet(generalPurposeFlags[0], 0)); localFileHeader.setDataDescriptorExists(isBitSet(generalPurposeFlags[0], 3)); localFileHeader.setFileNameUTF8Encoded(isBitSet(generalPurposeFlags[1], 3)); localFileHeader.setGeneralPurposeFlag(generalPurposeFlags.clone());  localFileHeader.setCompressionMethod(CompressionMethod.getCompressionMethodFromCode( rawIO.readShortLittleEndian(inputStream))); localFileHeader.setLastModifiedTime(rawIO.readIntLittleEndian(inputStream));  readFully(inputStream, intBuff); localFileHeader.setCrc(rawIO.readLongLittleEndian(intBuff, 0)); localFileHeader.setCrcRawData(intBuff.clone());
public LocalFileHeader readLocalFileHeader(InputStream inputStream, Charset charset) throws IOException { LocalFileHeader localFileHeader = new LocalFileHeader(); byte[] intBuff = new byte[4];  /*signature*/ int sig = rawIO.readIntLittleEndian(inputStream); if (sig != HeaderSignature.LOCAL_FILE_HEADER.getValue()) { return null; } localFileHeader.setSignature(HeaderSignature.LOCAL_FILE_HEADER); localFileHeader.setVersionNeededToExtract(rawIO.readShortLittleEndian(inputStream));  byte[] generalPurposeFlags = new byte[2]; if (readFully(inputStream, generalPurposeFlags) != 2) { throw new ZipException("Could not read enough bytes for generalPurposeFlags"); } <BUGS> localFileHeader.setEncrypted(isBitSet(generalPurposeFlags[0], 0)); localFileHeader.setDataDescriptorExists(isBitSet(generalPurposeFlags[0], 3)); localFileHeader.setFileNameUTF8Encoded(isBitSet(generalPurposeFlags[1], 3)); localFileHeader.setGeneralPurposeFlag(generalPurposeFlags.clone()); <BUGE>  localFileHeader.setCompressionMethod(CompressionMethod.getCompressionMethodFromCode( rawIO.readShortLittleEndian(inputStream))); localFileHeader.setLastModifiedTime(rawIO.readIntLittleEndian(inputStream));  readFully(inputStream, intBuff); localFileHeader.setCrc(rawIO.readLongLittleEndian(intBuff, 0)); localFileHeader.setCrcRawData(intBuff.clone());
public LocalFileHeader readLocalFileHeader(InputStream inputStream, Charset charset) throws IOException { LocalFileHeader localFileHeader = new LocalFileHeader(); byte[] intBuff = new byte[4];  /*signature*/ int sig = rawIO.readIntLittleEndian(inputStream); if (sig != HeaderSignature.LOCAL_FILE_HEADER.getValue()) { return null; } localFileHeader.setSignature(HeaderSignature.LOCAL_FILE_HEADER); localFileHeader.setVersionNeededToExtract(rawIO.readShortLittleEndian(inputStream));  byte[] generalPurposeFlags = new byte[2]; if (readFully(inputStream, generalPurposeFlags) != 2) { throw new ZipException("Could not read enough bytes for generalPurposeFlags"); } localFileHeader.setEncrypted(isBitSet(generalPurposeFlags[0], 0)); localFileHeader.setDataDescriptorExists(isBitSet(generalPurposeFlags[0], 3)); localFileHeader.setFileNameUTF8Encoded(isBitSet(generalPurposeFlags[1], 3)); localFileHeader.setGeneralPurposeFlag(generalPurposeFlags.clone());  <BUGS> localFileHeader.setCompressionMethod(CompressionMethod.getCompressionMethodFromCode( rawIO.readShortLittleEndian(inputStream))); localFileHeader.setLastModifiedTime(rawIO.readIntLittleEndian(inputStream)); <BUGE>  readFully(inputStream, intBuff); localFileHeader.setCrc(rawIO.readLongLittleEndian(intBuff, 0)); localFileHeader.setCrcRawData(intBuff.clone());
public LocalFileHeader readLocalFileHeader(InputStream inputStream, Charset charset) throws IOException { LocalFileHeader localFileHeader = new LocalFileHeader(); byte[] intBuff = new byte[4];  /*signature*/ int sig = rawIO.readIntLittleEndian(inputStream); if (sig != HeaderSignature.LOCAL_FILE_HEADER.getValue()) { return null; } localFileHeader.setSignature(HeaderSignature.LOCAL_FILE_HEADER); localFileHeader.setVersionNeededToExtract(rawIO.readShortLittleEndian(inputStream));  byte[] generalPurposeFlags = new byte[2]; if (readFully(inputStream, generalPurposeFlags) != 2) { throw new ZipException("Could not read enough bytes for generalPurposeFlags"); } localFileHeader.setEncrypted(isBitSet(generalPurposeFlags[0], 0)); localFileHeader.setDataDescriptorExists(isBitSet(generalPurposeFlags[0], 3)); localFileHeader.setFileNameUTF8Encoded(isBitSet(generalPurposeFlags[1], 3)); localFileHeader.setGeneralPurposeFlag(generalPurposeFlags.clone());  localFileHeader.setCompressionMethod(CompressionMethod.getCompressionMethodFromCode( rawIO.readShortLittleEndian(inputStream))); localFileHeader.setLastModifiedTime(rawIO.readIntLittleEndian(inputStream));  <BUGS> readFully(inputStream, intBuff); localFileHeader.setCrc(rawIO.readLongLittleEndian(intBuff, 0)); localFileHeader.setCrcRawData(intBuff.clone()); <BUGE>
return null; }  private void setFilePointerToReadZip64EndCentralDirLoc(RandomAccessFile zip4jRaf, long offsetEndOfCentralDirectoryRecord) throws IOException { /* Now the file pointer is at the end of signature of Central Dir Rec*/ /* Seek back with the following values*/ /* 4 -> total number of disks*/ /* 8 -> relative offset of the zip64 end of central directory record*/ /* 4 -> number of the disk with the start of the zip64 end of central directory*/ /* 4 -> zip64 end of central dir locator signature*/ /* Refer to Appnote for more information*/ seekInCurrentPart(zip4jRaf, offsetEndOfCentralDirectoryRecord - 4 - 8 - 4 - 4); }  <BUGS> localFileHeader.setCompressedSize(rawIO.readLongLittleEndian(inputStream, 4)); localFileHeader.setUncompressedSize(rawIO.readLongLittleEndian(inputStream, 4)); <BUGE>  int fileNameLength = rawIO.readShortLittleEndian(inputStream); localFileHeader.setFileNameLength(fileNameLength);  localFileHeader.setExtraFieldLength(rawIO.readShortLittleEndian(inputStream));  if (fileNameLength > 0) { byte[] fileNameBuf = new byte[fileNameLength]; readFully(inputStream, fileNameBuf); // Modified after user reported an issue http:/*www.lingala.net/zip4j/forum/index.php?topic=2.0*/ /*				String fileName = new String(fileNameBuf, "Cp850");*/ /*				String fileName = Zip4jUtil.getCp850EncodedString(fileNameBuf);*/ String fileName = decodeStringWithCharset(fileNameBuf, localFileHeader.isFileNameUTF8Encoded(), charset);
return null; }  private void setFilePointerToReadZip64EndCentralDirLoc(RandomAccessFile zip4jRaf, long offsetEndOfCentralDirectoryRecord) throws IOException { /* Now the file pointer is at the end of signature of Central Dir Rec*/ /* Seek back with the following values*/ /* 4 -> total number of disks*/ /* 8 -> relative offset of the zip64 end of central directory record*/ /* 4 -> number of the disk with the start of the zip64 end of central directory*/ /* 4 -> zip64 end of central dir locator signature*/ /* Refer to Appnote for more information*/ seekInCurrentPart(zip4jRaf, offsetEndOfCentralDirectoryRecord - 4 - 8 - 4 - 4); }  <BUGS> int fileNameLength = rawIO.readShortLittleEndian(inputStream); localFileHeader.setFileNameLength(fileNameLength); <BUGE>  localFileHeader.setExtraFieldLength(rawIO.readShortLittleEndian(inputStream));  if (fileNameLength > 0) { byte[] fileNameBuf = new byte[fileNameLength]; readFully(inputStream, fileNameBuf); // Modified after user reported an issue http:/*www.lingala.net/zip4j/forum/index.php?topic=2.0*/ /*				String fileName = new String(fileNameBuf, "Cp850");*/ /*				String fileName = Zip4jUtil.getCp850EncodedString(fileNameBuf);*/ String fileName = decodeStringWithCharset(fileNameBuf, localFileHeader.isFileNameUTF8Encoded(), charset);  if (fileName == null) { throw new ZipException("file name is null, cannot assign file name to local file header");
return null; }  private void setFilePointerToReadZip64EndCentralDirLoc(RandomAccessFile zip4jRaf, long offsetEndOfCentralDirectoryRecord) throws IOException { /* Now the file pointer is at the end of signature of Central Dir Rec*/ /* Seek back with the following values*/ /* 4 -> total number of disks*/ /* 8 -> relative offset of the zip64 end of central directory record*/ /* 4 -> number of the disk with the start of the zip64 end of central directory*/ /* 4 -> zip64 end of central dir locator signature*/ /* Refer to Appnote for more information*/ seekInCurrentPart(zip4jRaf, offsetEndOfCentralDirectoryRecord - 4 - 8 - 4 - 4); }  <BUGS> localFileHeader.setExtraFieldLength(rawIO.readShortLittleEndian(inputStream)); <BUGE>  if (fileNameLength > 0) { byte[] fileNameBuf = new byte[fileNameLength]; readFully(inputStream, fileNameBuf); // Modified after user reported an issue http:/*www.lingala.net/zip4j/forum/index.php?topic=2.0*/ /*				String fileName = new String(fileNameBuf, "Cp850");*/ /*				String fileName = Zip4jUtil.getCp850EncodedString(fileNameBuf);*/ String fileName = decodeStringWithCharset(fileNameBuf, localFileHeader.isFileNameUTF8Encoded(), charset);  if (fileName == null) { throw new ZipException("file name is null, cannot assign file name to local file header"); }  if (fileName.contains(":" + System.getProperty("file.separator"))) {
}  private void setFilePointerToReadZip64EndCentralDirLoc(RandomAccessFile zip4jRaf, long offsetEndOfCentralDirectoryRecord) throws IOException { /* Now the file pointer is at the end of signature of Central Dir Rec*/ /* Seek back with the following values*/ /* 4 -> total number of disks*/ /* 8 -> relative offset of the zip64 end of central directory record*/ /* 4 -> number of the disk with the start of the zip64 end of central directory*/ /* 4 -> zip64 end of central dir locator signature*/ /* Refer to Appnote for more information*/ seekInCurrentPart(zip4jRaf, offsetEndOfCentralDirectoryRecord - 4 - 8 - 4 - 4); }  <BUGS> if (fileNameLength > 0) { byte[] fileNameBuf = new byte[fileNameLength]; readFully(inputStream, fileNameBuf); <BUGE> // Modified after user reported an issue http:/*www.lingala.net/zip4j/forum/index.php?topic=2.0*/ /*				String fileName = new String(fileNameBuf, "Cp850");*/ /*				String fileName = Zip4jUtil.getCp850EncodedString(fileNameBuf);*/ String fileName = decodeStringWithCharset(fileNameBuf, localFileHeader.isFileNameUTF8Encoded(), charset);  if (fileName == null) { throw new ZipException("file name is null, cannot assign file name to local file header"); }  if (fileName.contains(":" + System.getProperty("file.separator"))) { fileName = fileName.substring(fileName.indexOf(":" + System.getProperty("file.separator")) + 2); }
return null; }  private void setFilePointerToReadZip64EndCentralDirLoc(RandomAccessFile zip4jRaf, long offsetEndOfCentralDirectoryRecord) throws IOException { /* Now the file pointer is at the end of signature of Central Dir Rec*/ /* Seek back with the following values*/ /* 4 -> total number of disks*/ /* 8 -> relative offset of the zip64 end of central directory record*/ /* 4 -> number of the disk with the start of the zip64 end of central directory*/ /* 4 -> zip64 end of central dir locator signature*/ /* Refer to Appnote for more information*/ seekInCurrentPart(zip4jRaf, offsetEndOfCentralDirectoryRecord - 4 - 8 - 4 - 4); } /*				String fileName = Zip4jUtil.getCp850EncodedString(fileNameBuf);*/ <BUGS> String fileName = decodeStringWithCharset(fileNameBuf, localFileHeader.isFileNameUTF8Encoded(), charset); <BUGE>  if (fileName == null) { throw new ZipException("file name is null, cannot assign file name to local file header"); }  if (fileName.contains(":" + System.getProperty("file.separator"))) { fileName = fileName.substring(fileName.indexOf(":" + System.getProperty("file.separator")) + 2); }  localFileHeader.setFileName(fileName); localFileHeader.setDirectory(fileName.endsWith("/") || fileName.endsWith("\\")); } else { localFileHeader.setFileName(null); }
return null; }  private void setFilePointerToReadZip64EndCentralDirLoc(RandomAccessFile zip4jRaf, long offsetEndOfCentralDirectoryRecord) throws IOException { /* Now the file pointer is at the end of signature of Central Dir Rec*/ /* Seek back with the following values*/ /* 4 -> total number of disks*/ /* 8 -> relative offset of the zip64 end of central directory record*/ /* 4 -> number of the disk with the start of the zip64 end of central directory*/ /* 4 -> zip64 end of central dir locator signature*/ /* Refer to Appnote for more information*/ seekInCurrentPart(zip4jRaf, offsetEndOfCentralDirectoryRecord - 4 - 8 - 4 - 4); }  <BUGS> if (fileName == null) { <BUGE> throw new ZipException("file name is null, cannot assign file name to local file header"); }  if (fileName.contains(":" + System.getProperty("file.separator"))) { fileName = fileName.substring(fileName.indexOf(":" + System.getProperty("file.separator")) + 2); }  localFileHeader.setFileName(fileName); localFileHeader.setDirectory(fileName.endsWith("/") || fileName.endsWith("\\")); } else { localFileHeader.setFileName(null); }  readExtraDataRecords(inputStream, localFileHeader);
return null; }  private void setFilePointerToReadZip64EndCentralDirLoc(RandomAccessFile zip4jRaf, long offsetEndOfCentralDirectoryRecord) throws IOException { /* Now the file pointer is at the end of signature of Central Dir Rec*/ /* Seek back with the following values*/ /* 4 -> total number of disks*/ /* 8 -> relative offset of the zip64 end of central directory record*/ /* 4 -> number of the disk with the start of the zip64 end of central directory*/ /* 4 -> zip64 end of central dir locator signature*/ /* Refer to Appnote for more information*/ seekInCurrentPart(zip4jRaf, offsetEndOfCentralDirectoryRecord - 4 - 8 - 4 - 4); }  <BUGS> if (fileName.contains(":" + System.getProperty("file.separator"))) { <BUGE> fileName = fileName.substring(fileName.indexOf(":" + System.getProperty("file.separator")) + 2); }  localFileHeader.setFileName(fileName); localFileHeader.setDirectory(fileName.endsWith("/") || fileName.endsWith("\\")); } else { localFileHeader.setFileName(null); }  readExtraDataRecords(inputStream, localFileHeader); readZip64ExtendedInfo(localFileHeader, rawIO); readAesExtraDataRecord(localFileHeader, rawIO);  if (localFileHeader.isEncrypted()) {
}  private void setFilePointerToReadZip64EndCentralDirLoc(RandomAccessFile zip4jRaf, long offsetEndOfCentralDirectoryRecord) throws IOException { /* Now the file pointer is at the end of signature of Central Dir Rec*/ /* Seek back with the following values*/ /* 4 -> total number of disks*/ /* 8 -> relative offset of the zip64 end of central directory record*/ /* 4 -> number of the disk with the start of the zip64 end of central directory*/ /* 4 -> zip64 end of central dir locator signature*/ /* Refer to Appnote for more information*/ seekInCurrentPart(zip4jRaf, offsetEndOfCentralDirectoryRecord - 4 - 8 - 4 - 4); }  <BUGS> localFileHeader.setFileName(fileName); localFileHeader.setDirectory(fileName.endsWith("/") || fileName.endsWith("\\")); } else { <BUGE> localFileHeader.setFileName(null); }  readExtraDataRecords(inputStream, localFileHeader); readZip64ExtendedInfo(localFileHeader, rawIO); readAesExtraDataRecord(localFileHeader, rawIO);  if (localFileHeader.isEncrypted()) {  if (localFileHeader.getEncryptionMethod() == EncryptionMethod.AES) { /*Do nothing*/ } else { if (BigInteger.valueOf(localFileHeader.getGeneralPurposeFlag()[0]).testBit(6)) {
}  private void setFilePointerToReadZip64EndCentralDirLoc(RandomAccessFile zip4jRaf, long offsetEndOfCentralDirectoryRecord) throws IOException { /* Now the file pointer is at the end of signature of Central Dir Rec*/ /* Seek back with the following values*/ /* 4 -> total number of disks*/ /* 8 -> relative offset of the zip64 end of central directory record*/ /* 4 -> number of the disk with the start of the zip64 end of central directory*/ /* 4 -> zip64 end of central dir locator signature*/ /* Refer to Appnote for more information*/ seekInCurrentPart(zip4jRaf, offsetEndOfCentralDirectoryRecord - 4 - 8 - 4 - 4); }  <BUGS> readExtraDataRecords(inputStream, localFileHeader); readZip64ExtendedInfo(localFileHeader, rawIO); readAesExtraDataRecord(localFileHeader, rawIO); <BUGE>  if (localFileHeader.isEncrypted()) {  if (localFileHeader.getEncryptionMethod() == EncryptionMethod.AES) { /*Do nothing*/ } else { if (BigInteger.valueOf(localFileHeader.getGeneralPurposeFlag()[0]).testBit(6)) { localFileHeader.setEncryptionMethod(EncryptionMethod.ZIP_STANDARD_VARIANT_STRONG); } else { localFileHeader.setEncryptionMethod(EncryptionMethod.ZIP_STANDARD); } }
return null; }  private void setFilePointerToReadZip64EndCentralDirLoc(RandomAccessFile zip4jRaf, long offsetEndOfCentralDirectoryRecord) throws IOException { /* Now the file pointer is at the end of signature of Central Dir Rec*/ /* Seek back with the following values*/ /* 4 -> total number of disks*/ /* 8 -> relative offset of the zip64 end of central directory record*/ /* 4 -> number of the disk with the start of the zip64 end of central directory*/ /* 4 -> zip64 end of central dir locator signature*/ /* Refer to Appnote for more information*/ seekInCurrentPart(zip4jRaf, offsetEndOfCentralDirectoryRecord - 4 - 8 - 4 - 4); }  <BUGS> if (localFileHeader.isEncrypted()) { <BUGE>  if (localFileHeader.getEncryptionMethod() == EncryptionMethod.AES) { /*Do nothing*/ } else { if (BigInteger.valueOf(localFileHeader.getGeneralPurposeFlag()[0]).testBit(6)) { localFileHeader.setEncryptionMethod(EncryptionMethod.ZIP_STANDARD_VARIANT_STRONG); } else { localFileHeader.setEncryptionMethod(EncryptionMethod.ZIP_STANDARD); } }  }  return localFileHeader;
return null; }  private void setFilePointerToReadZip64EndCentralDirLoc(RandomAccessFile zip4jRaf, long offsetEndOfCentralDirectoryRecord) throws IOException { /* Now the file pointer is at the end of signature of Central Dir Rec*/ /* Seek back with the following values*/ /* 4 -> total number of disks*/ /* 8 -> relative offset of the zip64 end of central directory record*/ /* 4 -> number of the disk with the start of the zip64 end of central directory*/ /* 4 -> zip64 end of central dir locator signature*/ /* Refer to Appnote for more information*/ seekInCurrentPart(zip4jRaf, offsetEndOfCentralDirectoryRecord - 4 - 8 - 4 - 4); }  <BUGS> if (localFileHeader.getEncryptionMethod() == EncryptionMethod.AES) { <BUGE> /*Do nothing*/ } else { if (BigInteger.valueOf(localFileHeader.getGeneralPurposeFlag()[0]).testBit(6)) { localFileHeader.setEncryptionMethod(EncryptionMethod.ZIP_STANDARD_VARIANT_STRONG); } else { localFileHeader.setEncryptionMethod(EncryptionMethod.ZIP_STANDARD); } }  }  return localFileHeader; }
return null; }  private void setFilePointerToReadZip64EndCentralDirLoc(RandomAccessFile zip4jRaf, long offsetEndOfCentralDirectoryRecord) throws IOException { /* Now the file pointer is at the end of signature of Central Dir Rec*/ /* Seek back with the following values*/ /* 4 -> total number of disks*/ /* 8 -> relative offset of the zip64 end of central directory record*/ /* 4 -> number of the disk with the start of the zip64 end of central directory*/ /* 4 -> zip64 end of central dir locator signature*/ /* Refer to Appnote for more information*/ seekInCurrentPart(zip4jRaf, offsetEndOfCentralDirectoryRecord - 4 - 8 - 4 - 4); } } else { <BUGS> if (BigInteger.valueOf(localFileHeader.getGeneralPurposeFlag()[0]).testBit(6)) { localFileHeader.setEncryptionMethod(EncryptionMethod.ZIP_STANDARD_VARIANT_STRONG); <BUGE> } else { localFileHeader.setEncryptionMethod(EncryptionMethod.ZIP_STANDARD); } }  }  return localFileHeader; }  public DataDescriptor readDataDescriptor(InputStream inputStream, boolean isZip64Format) throws IOException {  DataDescriptor dataDescriptor = new DataDescriptor();
return null; }  private void setFilePointerToReadZip64EndCentralDirLoc(RandomAccessFile zip4jRaf, long offsetEndOfCentralDirectoryRecord) throws IOException { /* Now the file pointer is at the end of signature of Central Dir Rec*/ /* Seek back with the following values*/ /* 4 -> total number of disks*/ /* 8 -> relative offset of the zip64 end of central directory record*/ /* 4 -> number of the disk with the start of the zip64 end of central directory*/ /* 4 -> zip64 end of central dir locator signature*/ /* Refer to Appnote for more information*/ seekInCurrentPart(zip4jRaf, offsetEndOfCentralDirectoryRecord - 4 - 8 - 4 - 4); }  <BUGS> return localFileHeader; <BUGE> }  public DataDescriptor readDataDescriptor(InputStream inputStream, boolean isZip64Format) throws IOException {  DataDescriptor dataDescriptor = new DataDescriptor();  byte[] intBuff = new byte[4]; readFully(inputStream, intBuff); long sigOrCrc = rawIO.readLongLittleEndian(intBuff, 0);  /*According to zip specification, presence of extra data record header signature is optional.*/ /*If this signature is present, read it and read the next 4 bytes for crc*/ /*If signature not present, assign the read 4 bytes for crc*/ if (sigOrCrc == HeaderSignature.EXTRA_DATA_RECORD.getValue()) {
private void performTaskWithErrorHandling(T taskParameters, ProgressMonitor progressMonitor) throws ZipException { try { <BUGS> executeTask(taskParameters, progressMonitor); <BUGE> progressMonitor.endProgressMonitor(); } catch (ZipException e) { progressMonitor.endProgressMonitor(e); throw e; } catch (Exception e) { progressMonitor.endProgressMonitor(e); throw new ZipException(e); } }
private void performTaskWithErrorHandling(T taskParameters, ProgressMonitor progressMonitor) throws ZipException { try { executeTask(taskParameters, progressMonitor); progressMonitor.endProgressMonitor(); } catch (ZipException e) { progressMonitor.endProgressMonitor(e); throw e; <BUGS> } catch (Exception e) { progressMonitor.endProgressMonitor(e); throw new ZipException(e); <BUGE> } }
public static byte[] convertCharArrayToByteArray(char[] charArray) { <BUGS> byte[] bytes = new byte[charArray.length]; for (int i = 0; i < charArray.length; i++) { bytes[i] = (byte) charArray[i]; <BUGE> } return bytes; }
public static byte[] convertCharArrayToByteArray(char[] charArray) { byte[] bytes = new byte[charArray.length]; for (int i = 0; i < charArray.length; i++) { bytes[i] = (byte) charArray[i]; } <BUGS> return bytes; <BUGE> }
public static byte[] getFileAttributes(File file) { try { <BUGS> if (file == null || (!Files.isSymbolicLink(file.toPath()) && !file.exists())) { <BUGE> return new byte[4]; }  Path path = file.toPath();  if (isWindows()) { return getWindowsFileAttributes(path); } else if (isMac() || isUnix()) { return getPosixFileAttributes(path); } else { return new byte[4]; } } catch (NoSuchMethodError e) { return new byte[4]; } }
public static byte[] getFileAttributes(File file) { try { if (file == null || (!Files.isSymbolicLink(file.toPath()) && !file.exists())) { return new byte[4]; }  <BUGS> Path path = file.toPath(); <BUGE>  if (isWindows()) { return getWindowsFileAttributes(path); } else if (isMac() || isUnix()) { return getPosixFileAttributes(path); } else { return new byte[4]; } } catch (NoSuchMethodError e) { return new byte[4]; } }
public static byte[] getFileAttributes(File file) { try { if (file == null || (!Files.isSymbolicLink(file.toPath()) && !file.exists())) { return new byte[4]; }  Path path = file.toPath();  <BUGS> if (isWindows()) { return getWindowsFileAttributes(path); <BUGE> } else if (isMac() || isUnix()) { return getPosixFileAttributes(path); } else { return new byte[4]; } } catch (NoSuchMethodError e) { return new byte[4]; } }
public ZipModel readAllHeaders(RandomAccessFile zip4jRaf, Zip4jConfig zip4jConfig) throws IOException {  <BUGS> if (zip4jRaf.length() < ENDHDR) { <BUGE> throw new ZipException("Zip file size less than minimum expected zip file size. " + "Probably not a zip file or a corrupted zip file"); }  zipModel = new ZipModel();  try { zipModel.setEndOfCentralDirectoryRecord( readEndOfCentralDirectoryRecord(zip4jRaf, rawIO, zip4jConfig)); } catch (ZipException e) { throw e; } catch (IOException e) { throw new ZipException("Zip headers not found. Probably not a zip file or a corrupted zip file", e); }  if (zipModel.getEndOfCentralDirectoryRecord().getTotalNumberOfEntriesInCentralDirectory() == 0) { return zipModel; }  /* If file is Zip64 format, Zip64 headers have to be read before reading central directory*/ zipModel.setZip64EndOfCentralDirectoryLocator(readZip64EndOfCentralDirectoryLocator(zip4jRaf, rawIO, zipModel.getEndOfCentralDirectoryRecord().getOffsetOfEndOfCentralDirectory()));  if (zipModel.isZip64Format()) { zipModel.setZip64EndOfCentralDirectoryRecord(readZip64EndCentralDirRec(zip4jRaf, rawIO)); if (zipModel.getZip64EndOfCentralDirectoryRecord() != null
public ZipModel readAllHeaders(RandomAccessFile zip4jRaf, Zip4jConfig zip4jConfig) throws IOException {  if (zip4jRaf.length() < ENDHDR) { throw new ZipException("Zip file size less than minimum expected zip file size. " + "Probably not a zip file or a corrupted zip file"); }  <BUGS> zipModel = new ZipModel(); <BUGE>  try { zipModel.setEndOfCentralDirectoryRecord( readEndOfCentralDirectoryRecord(zip4jRaf, rawIO, zip4jConfig)); } catch (ZipException e) { throw e; } catch (IOException e) { throw new ZipException("Zip headers not found. Probably not a zip file or a corrupted zip file", e); }  if (zipModel.getEndOfCentralDirectoryRecord().getTotalNumberOfEntriesInCentralDirectory() == 0) { return zipModel; }  /* If file is Zip64 format, Zip64 headers have to be read before reading central directory*/ zipModel.setZip64EndOfCentralDirectoryLocator(readZip64EndOfCentralDirectoryLocator(zip4jRaf, rawIO, zipModel.getEndOfCentralDirectoryRecord().getOffsetOfEndOfCentralDirectory()));  if (zipModel.isZip64Format()) { zipModel.setZip64EndOfCentralDirectoryRecord(readZip64EndCentralDirRec(zip4jRaf, rawIO)); if (zipModel.getZip64EndOfCentralDirectoryRecord() != null
public ZipModel readAllHeaders(RandomAccessFile zip4jRaf, Zip4jConfig zip4jConfig) throws IOException {  if (zip4jRaf.length() < ENDHDR) { throw new ZipException("Zip file size less than minimum expected zip file size. " + "Probably not a zip file or a corrupted zip file"); }  zipModel = new ZipModel();  try { <BUGS> zipModel.setEndOfCentralDirectoryRecord( readEndOfCentralDirectoryRecord(zip4jRaf, rawIO, zip4jConfig)); <BUGE> } catch (ZipException e) { throw e; } catch (IOException e) { throw new ZipException("Zip headers not found. Probably not a zip file or a corrupted zip file", e); }  if (zipModel.getEndOfCentralDirectoryRecord().getTotalNumberOfEntriesInCentralDirectory() == 0) { return zipModel; }  /* If file is Zip64 format, Zip64 headers have to be read before reading central directory*/ zipModel.setZip64EndOfCentralDirectoryLocator(readZip64EndOfCentralDirectoryLocator(zip4jRaf, rawIO, zipModel.getEndOfCentralDirectoryRecord().getOffsetOfEndOfCentralDirectory()));  if (zipModel.isZip64Format()) { zipModel.setZip64EndOfCentralDirectoryRecord(readZip64EndCentralDirRec(zip4jRaf, rawIO)); if (zipModel.getZip64EndOfCentralDirectoryRecord() != null
public ZipModel readAllHeaders(RandomAccessFile zip4jRaf, Zip4jConfig zip4jConfig) throws IOException {  if (zip4jRaf.length() < ENDHDR) { throw new ZipException("Zip file size less than minimum expected zip file size. " + "Probably not a zip file or a corrupted zip file"); }  zipModel = new ZipModel();  try { zipModel.setEndOfCentralDirectoryRecord( readEndOfCentralDirectoryRecord(zip4jRaf, rawIO, zip4jConfig)); } catch (ZipException e) { throw e; <BUGS> } catch (IOException e) { throw new ZipException("Zip headers not found. Probably not a zip file or a corrupted zip file", e); <BUGE> }  if (zipModel.getEndOfCentralDirectoryRecord().getTotalNumberOfEntriesInCentralDirectory() == 0) { return zipModel; }  /* If file is Zip64 format, Zip64 headers have to be read before reading central directory*/ zipModel.setZip64EndOfCentralDirectoryLocator(readZip64EndOfCentralDirectoryLocator(zip4jRaf, rawIO, zipModel.getEndOfCentralDirectoryRecord().getOffsetOfEndOfCentralDirectory()));  if (zipModel.isZip64Format()) { zipModel.setZip64EndOfCentralDirectoryRecord(readZip64EndCentralDirRec(zip4jRaf, rawIO)); if (zipModel.getZip64EndOfCentralDirectoryRecord() != null
public ZipInputStream(InputStream inputStream) { <BUGS> this(inputStream, null, (Charset) null); } <BUGE>
public ZipModel readAllHeaders(RandomAccessFile zip4jRaf, Zip4jConfig zip4jConfig) throws IOException {  <BUGS> if (zip4jRaf.length() < ENDHDR) { <BUGE> throw new ZipException("Zip file size less than minimum expected zip file size. " + "Probably not a zip file or a corrupted zip file"); }  zipModel = new ZipModel();  try { zipModel.setEndOfCentralDirectoryRecord(readEndOfCentralDirectoryRecord(zip4jRaf, rawIO, zip4jConfig)); } catch (ZipException e) { throw e; } catch (IOException e) { e.printStackTrace(); throw new ZipException("Zip headers not found. Probably not a zip file or a corrupted zip file", e); }  if (zipModel.getEndOfCentralDirectoryRecord().getTotalNumberOfEntriesInCentralDirectory() == 0) { return zipModel; }  /* If file is Zip64 format, Zip64 headers have to be read before reading central directory*/ zipModel.setZip64EndOfCentralDirectoryLocator(readZip64EndOfCentralDirectoryLocator(zip4jRaf, rawIO, zipModel.getEndOfCentralDirectoryRecord().getOffsetOfEndOfCentralDirectory()));  if (zipModel.isZip64Format()) { zipModel.setZip64EndOfCentralDirectoryRecord(readZip64EndCentralDirRec(zip4jRaf, rawIO)); if (zipModel.getZip64EndOfCentralDirectoryRecord() != null
public ZipModel readAllHeaders(RandomAccessFile zip4jRaf, Zip4jConfig zip4jConfig) throws IOException {  if (zip4jRaf.length() < ENDHDR) { throw new ZipException("Zip file size less than minimum expected zip file size. " + "Probably not a zip file or a corrupted zip file"); }  <BUGS> zipModel = new ZipModel(); <BUGE>  try { zipModel.setEndOfCentralDirectoryRecord(readEndOfCentralDirectoryRecord(zip4jRaf, rawIO, zip4jConfig)); } catch (ZipException e) { throw e; } catch (IOException e) { e.printStackTrace(); throw new ZipException("Zip headers not found. Probably not a zip file or a corrupted zip file", e); }  if (zipModel.getEndOfCentralDirectoryRecord().getTotalNumberOfEntriesInCentralDirectory() == 0) { return zipModel; }  /* If file is Zip64 format, Zip64 headers have to be read before reading central directory*/ zipModel.setZip64EndOfCentralDirectoryLocator(readZip64EndOfCentralDirectoryLocator(zip4jRaf, rawIO, zipModel.getEndOfCentralDirectoryRecord().getOffsetOfEndOfCentralDirectory()));  if (zipModel.isZip64Format()) { zipModel.setZip64EndOfCentralDirectoryRecord(readZip64EndCentralDirRec(zip4jRaf, rawIO)); if (zipModel.getZip64EndOfCentralDirectoryRecord() != null
public ZipModel readAllHeaders(RandomAccessFile zip4jRaf, Zip4jConfig zip4jConfig) throws IOException {  if (zip4jRaf.length() < ENDHDR) { throw new ZipException("Zip file size less than minimum expected zip file size. " + "Probably not a zip file or a corrupted zip file"); }  zipModel = new ZipModel();  try { <BUGS> zipModel.setEndOfCentralDirectoryRecord(readEndOfCentralDirectoryRecord(zip4jRaf, rawIO, zip4jConfig)); <BUGE> } catch (ZipException e) { throw e; } catch (IOException e) { e.printStackTrace(); throw new ZipException("Zip headers not found. Probably not a zip file or a corrupted zip file", e); }  if (zipModel.getEndOfCentralDirectoryRecord().getTotalNumberOfEntriesInCentralDirectory() == 0) { return zipModel; }  /* If file is Zip64 format, Zip64 headers have to be read before reading central directory*/ zipModel.setZip64EndOfCentralDirectoryLocator(readZip64EndOfCentralDirectoryLocator(zip4jRaf, rawIO, zipModel.getEndOfCentralDirectoryRecord().getOffsetOfEndOfCentralDirectory()));  if (zipModel.isZip64Format()) { zipModel.setZip64EndOfCentralDirectoryRecord(readZip64EndCentralDirRec(zip4jRaf, rawIO)); if (zipModel.getZip64EndOfCentralDirectoryRecord() != null
public ZipModel readAllHeaders(RandomAccessFile zip4jRaf, Zip4jConfig zip4jConfig) throws IOException {  if (zip4jRaf.length() < ENDHDR) { throw new ZipException("Zip file size less than minimum expected zip file size. " + "Probably not a zip file or a corrupted zip file"); }  zipModel = new ZipModel();  try { zipModel.setEndOfCentralDirectoryRecord(readEndOfCentralDirectoryRecord(zip4jRaf, rawIO, zip4jConfig)); } catch (ZipException e) { throw e; } catch (IOException e) { e.printStackTrace(); throw new ZipException("Zip headers not found. Probably not a zip file or a corrupted zip file", e); <BUGS> } <BUGE>  if (zipModel.getEndOfCentralDirectoryRecord().getTotalNumberOfEntriesInCentralDirectory() == 0) { return zipModel; }  /* If file is Zip64 format, Zip64 headers have to be read before reading central directory*/ zipModel.setZip64EndOfCentralDirectoryLocator(readZip64EndOfCentralDirectoryLocator(zip4jRaf, rawIO, zipModel.getEndOfCentralDirectoryRecord().getOffsetOfEndOfCentralDirectory()));  if (zipModel.isZip64Format()) { zipModel.setZip64EndOfCentralDirectoryRecord(readZip64EndCentralDirRec(zip4jRaf, rawIO)); if (zipModel.getZip64EndOfCentralDirectoryRecord() != null
public ZipModel readAllHeaders(RandomAccessFile zip4jRaf, Zip4jConfig zip4jConfig) throws IOException {  if (zip4jRaf.length() < ENDHDR) { throw new ZipException("Zip file size less than minimum expected zip file size. " + "Probably not a zip file or a corrupted zip file"); }  zipModel = new ZipModel();  try { zipModel.setEndOfCentralDirectoryRecord(readEndOfCentralDirectoryRecord(zip4jRaf, rawIO, zip4jConfig)); } catch (ZipException e) { throw e; } catch (IOException e) { e.printStackTrace(); throw new ZipException("Zip headers not found. Probably not a zip file or a corrupted zip file", e); }  <BUGS> if (zipModel.getEndOfCentralDirectoryRecord().getTotalNumberOfEntriesInCentralDirectory() == 0) { return zipModel; <BUGE> }  /* If file is Zip64 format, Zip64 headers have to be read before reading central directory*/ zipModel.setZip64EndOfCentralDirectoryLocator(readZip64EndOfCentralDirectoryLocator(zip4jRaf, rawIO, zipModel.getEndOfCentralDirectoryRecord().getOffsetOfEndOfCentralDirectory()));  if (zipModel.isZip64Format()) { zipModel.setZip64EndOfCentralDirectoryRecord(readZip64EndCentralDirRec(zip4jRaf, rawIO)); if (zipModel.getZip64EndOfCentralDirectoryRecord() != null
private void verifyContent(byte[] storedMac) throws IOException { <BUGS> if (getLocalFileHeader().isDataDescriptorExists() && CompressionMethod.DEFLATE.equals(Zip4jUtil.getCompressionMethod(getLocalFileHeader()))) { <BUGE> /* Skip content verification in case of Deflate compression and if data descriptor exists.*/ /* In this case, we do not know the exact size of compressed data before hand and it is possible that we read*/ /* and pass more than required data into inflater, thereby corrupting the aes mac bytes.*/ /* See usage of PushBackInputStream in the project for how this push back of data is done*/ /* Unfortunately, in this case we cannot perform a content verification and have to skip*/ return; }  byte[] calculatedMac = getDecrypter().getCalculatedAuthenticationBytes(); byte[] first10BytesOfCalculatedMac = new byte[AES_AUTH_LENGTH]; System.arraycopy(calculatedMac, 0, first10BytesOfCalculatedMac, 0, InternalZipConstants.AES_AUTH_LENGTH);  if (!Arrays.equals(storedMac, first10BytesOfCalculatedMac)) { throw new IOException("Reached end of data for this entry, but aes verification failed"); } }
private void verifyContent(byte[] storedMac) throws IOException { if (getLocalFileHeader().isDataDescriptorExists() && CompressionMethod.DEFLATE.equals(Zip4jUtil.getCompressionMethod(getLocalFileHeader()))) { /* Skip content verification in case of Deflate compression and if data descriptor exists.*/ /* In this case, we do not know the exact size of compressed data before hand and it is possible that we read*/ /* and pass more than required data into inflater, thereby corrupting the aes mac bytes.*/ /* See usage of PushBackInputStream in the project for how this push back of data is done*/ /* Unfortunately, in this case we cannot perform a content verification and have to skip*/ return; }  <BUGS> byte[] calculatedMac = getDecrypter().getCalculatedAuthenticationBytes(); byte[] first10BytesOfCalculatedMac = new byte[AES_AUTH_LENGTH]; System.arraycopy(calculatedMac, 0, first10BytesOfCalculatedMac, 0, InternalZipConstants.AES_AUTH_LENGTH); <BUGE>  if (!Arrays.equals(storedMac, first10BytesOfCalculatedMac)) { throw new IOException("Reached end of data for this entry, but aes verification failed"); } }
private void verifyContent(byte[] storedMac) throws IOException { if (getLocalFileHeader().isDataDescriptorExists() && CompressionMethod.DEFLATE.equals(Zip4jUtil.getCompressionMethod(getLocalFileHeader()))) { /* Skip content verification in case of Deflate compression and if data descriptor exists.*/ /* In this case, we do not know the exact size of compressed data before hand and it is possible that we read*/ /* and pass more than required data into inflater, thereby corrupting the aes mac bytes.*/ /* See usage of PushBackInputStream in the project for how this push back of data is done*/ /* Unfortunately, in this case we cannot perform a content verification and have to skip*/ return; }  byte[] calculatedMac = getDecrypter().getCalculatedAuthenticationBytes(); byte[] first10BytesOfCalculatedMac = new byte[AES_AUTH_LENGTH]; System.arraycopy(calculatedMac, 0, first10BytesOfCalculatedMac, 0, InternalZipConstants.AES_AUTH_LENGTH);  <BUGS> if (!Arrays.equals(storedMac, first10BytesOfCalculatedMac)) { throw new IOException("Reached end of data for this entry, but aes verification failed"); <BUGE> } }
public ZipException(String message, Type type) { super(message); this.type = type; }
public ZipException(String message, Type type) { <BUGS> super(message); this.type = type; } <BUGE>
private void performTaskWithErrorHandling(T taskParameters, ProgressMonitor progressMonitor) throws ZipException { try { <BUGS> executeTask(taskParameters, progressMonitor); <BUGE> progressMonitor.endProgressMonitor(); } catch (ZipException e) { progressMonitor.endProgressMonitor(e); throw e; } catch (Exception e) { progressMonitor.endProgressMonitor(e); throw new ZipException(e); } }
private void performTaskWithErrorHandling(T taskParameters, ProgressMonitor progressMonitor) throws ZipException { try { executeTask(taskParameters, progressMonitor); progressMonitor.endProgressMonitor(); } catch (ZipException e) { progressMonitor.endProgressMonitor(e); throw e; <BUGS> } catch (Exception e) { progressMonitor.endProgressMonitor(e); throw new ZipException(e); <BUGE> } }
public static void copyFile(RandomAccessFile randomAccessFile, OutputStream outputStream, long start, long end, ProgressMonitor progressMonitor, int bufferSize) throws ZipException {  <BUGS> if (start < 0 || end < 0 || start > end) { throw new ZipException("invalid offsets"); <BUGE> }  if (start == end) { return; }  try { randomAccessFile.seek(start);  int readLen; byte[] buff; long bytesRead = 0; long bytesToRead = end - start;  if ((end - start) < bufferSize) { buff = new byte[(int) bytesToRead]; } else { buff = new byte[bufferSize]; }  while ((readLen = randomAccessFile.read(buff)) != -1) { outputStream.write(buff, 0, readLen);  progressMonitor.updateWorkCompleted(readLen);
public static void copyFile(RandomAccessFile randomAccessFile, OutputStream outputStream, long start, long end, ProgressMonitor progressMonitor, int bufferSize) throws ZipException {  if (start < 0 || end < 0 || start > end) { throw new ZipException("invalid offsets"); }  <BUGS> if (start == end) { <BUGE> return; }  try { randomAccessFile.seek(start);  int readLen; byte[] buff; long bytesRead = 0; long bytesToRead = end - start;  if ((end - start) < bufferSize) { buff = new byte[(int) bytesToRead]; } else { buff = new byte[bufferSize]; }  while ((readLen = randomAccessFile.read(buff)) != -1) { outputStream.write(buff, 0, readLen);  progressMonitor.updateWorkCompleted(readLen);
public static void copyFile(RandomAccessFile randomAccessFile, OutputStream outputStream, long start, long end, ProgressMonitor progressMonitor, int bufferSize) throws ZipException {  if (start < 0 || end < 0 || start > end) { throw new ZipException("invalid offsets"); }  if (start == end) { return; }  try { <BUGS> randomAccessFile.seek(start); <BUGE>  int readLen; byte[] buff; long bytesRead = 0; long bytesToRead = end - start;  if ((end - start) < bufferSize) { buff = new byte[(int) bytesToRead]; } else { buff = new byte[bufferSize]; }  while ((readLen = randomAccessFile.read(buff)) != -1) { outputStream.write(buff, 0, readLen);  progressMonitor.updateWorkCompleted(readLen);
public static void copyFile(RandomAccessFile randomAccessFile, OutputStream outputStream, long start, long end, ProgressMonitor progressMonitor, int bufferSize) throws ZipException {  if (start < 0 || end < 0 || start > end) { throw new ZipException("invalid offsets"); }  if (start == end) { return; }  try { randomAccessFile.seek(start);  int readLen; byte[] buff; <BUGS> long bytesRead = 0; long bytesToRead = end - start; <BUGE>  if ((end - start) < bufferSize) { buff = new byte[(int) bytesToRead]; } else { buff = new byte[bufferSize]; }  while ((readLen = randomAccessFile.read(buff)) != -1) { outputStream.write(buff, 0, readLen);  progressMonitor.updateWorkCompleted(readLen);
public static void copyFile(RandomAccessFile randomAccessFile, OutputStream outputStream, long start, long end, ProgressMonitor progressMonitor, int bufferSize) throws ZipException {  if (start < 0 || end < 0 || start > end) { throw new ZipException("invalid offsets"); }  if (start == end) { return; }  try { randomAccessFile.seek(start);  int readLen; byte[] buff; long bytesRead = 0; long bytesToRead = end - start;  <BUGS> if ((end - start) < bufferSize) { buff = new byte[(int) bytesToRead]; <BUGE> } else { buff = new byte[bufferSize]; }  while ((readLen = randomAccessFile.read(buff)) != -1) { outputStream.write(buff, 0, readLen);  progressMonitor.updateWorkCompleted(readLen);
public static void copyFile(RandomAccessFile randomAccessFile, OutputStream outputStream, long start, long end, ProgressMonitor progressMonitor, int bufferSize) throws ZipException {  if (start < 0 || end < 0 || start > end) { throw new ZipException("invalid offsets"); }  if (start == end) { return; }  try { randomAccessFile.seek(start);  int readLen; byte[] buff; long bytesRead = 0; long bytesToRead = end - start;  if ((end - start) < bufferSize) { buff = new byte[(int) bytesToRead]; } else { <BUGS> buff = new byte[bufferSize]; <BUGE> }  while ((readLen = randomAccessFile.read(buff)) != -1) { outputStream.write(buff, 0, readLen);  progressMonitor.updateWorkCompleted(readLen);
public static void copyFile(RandomAccessFile randomAccessFile, OutputStream outputStream, long start, long end, ProgressMonitor progressMonitor, int bufferSize) throws ZipException {  if (start < 0 || end < 0 || start > end) { throw new ZipException("invalid offsets"); }  if (start == end) { return; }  try { randomAccessFile.seek(start);  int readLen; byte[] buff; long bytesRead = 0; long bytesToRead = end - start;  if ((end - start) < bufferSize) { buff = new byte[(int) bytesToRead]; } else { buff = new byte[bufferSize]; }  <BUGS> while ((readLen = randomAccessFile.read(buff)) != -1) { outputStream.write(buff, 0, readLen); <BUGE>  progressMonitor.updateWorkCompleted(readLen);
public static void copyFile(RandomAccessFile randomAccessFile, OutputStream outputStream, long start, long end, ProgressMonitor progressMonitor, int bufferSize) throws ZipException {  if (start < 0 || end < 0 || start > end) { throw new ZipException("invalid offsets"); }  if (start == end) { return; }  try { randomAccessFile.seek(start);  int readLen; byte[] buff; long bytesRead = 0; long bytesToRead = end - start;  if ((end - start) < bufferSize) { buff = new byte[(int) bytesToRead]; } else { buff = new byte[bufferSize]; }  while ((readLen = randomAccessFile.read(buff)) != -1) { outputStream.write(buff, 0, readLen);  <BUGS> progressMonitor.updateWorkCompleted(readLen);
if (isStringNotNullAndNotEmpty(fileNameInZip)) { return fileNameInZip; }  if (isSymbolicLink(fileToAdd)) { return fileToAdd.toPath().toRealPath(LinkOption.NOFOLLOW_LINKS).getFileName().toString(); }  return fileToAdd.getName(); }  public static boolean isZipEntryDirectory(String fileNameInZip) { return fileNameInZip.endsWith("/") || fileNameInZip.endsWith("\\"); }  <BUGS> bytesRead += readLen; <BUGE>  if (bytesRead == bytesToRead) { break; } else if (bytesRead + buff.length > bytesToRead) { buff = new byte[(int) (bytesToRead - bytesRead)]; } }  } catch (IOException e) { throw new ZipException(e); } }  public static void assertFilesExist(List<File> files, ZipParameters.SymbolicLinkAction symLinkAction) throws ZipException {
return fileNameInZip; }  if (isSymbolicLink(fileToAdd)) { return fileToAdd.toPath().toRealPath(LinkOption.NOFOLLOW_LINKS).getFileName().toString(); }  return fileToAdd.getName(); }  public static boolean isZipEntryDirectory(String fileNameInZip) { return fileNameInZip.endsWith("/") || fileNameInZip.endsWith("\\"); }  <BUGS> if (bytesRead == bytesToRead) { break; } else if (bytesRead + buff.length > bytesToRead) { buff = new byte[(int) (bytesToRead - bytesRead)]; <BUGE> } }  } catch (IOException e) { throw new ZipException(e); } }  public static void assertFilesExist(List<File> files, ZipParameters.SymbolicLinkAction symLinkAction) throws ZipException { for (File file : files) { if (isSymbolicLink(file)) { /* If symlink is INCLUDE_LINK_ONLY, and if the above condition is true, it means that the link exists and there*/
if (isStringNotNullAndNotEmpty(fileNameInZip)) { return fileNameInZip; }  if (isSymbolicLink(fileToAdd)) { return fileToAdd.toPath().toRealPath(LinkOption.NOFOLLOW_LINKS).getFileName().toString(); }  return fileToAdd.getName(); }  public static boolean isZipEntryDirectory(String fileNameInZip) { return fileNameInZip.endsWith("/") || fileNameInZip.endsWith("\\"); } throw new ZipException(e); <BUGS> } } <BUGE>  public static void assertFilesExist(List<File> files, ZipParameters.SymbolicLinkAction symLinkAction) throws ZipException { for (File file : files) { if (isSymbolicLink(file)) { /* If symlink is INCLUDE_LINK_ONLY, and if the above condition is true, it means that the link exists and there*/ /* will be no need to check for link existence explicitly, check only for target file existence if required*/ if (symLinkAction.equals(ZipParameters.SymbolicLinkAction.INCLUDE_LINK_AND_LINKED_FILE) || symLinkAction.equals(ZipParameters.SymbolicLinkAction.INCLUDE_LINKED_FILE_ONLY)) { assertSymbolicLinkTargetExists(file); } } else { assertFileExists(file); }
private String validateAndGetFileName(String fileNameInZip) throws ZipException { <BUGS> if (!Zip4jUtil.isStringNotNullAndNotEmpty(fileNameInZip)) { throw new ZipException("fileNameInZip is null or empty"); <BUGE> } return fileNameInZip; }
@Override protected void executeTask(AddStreamToZipTaskParameters taskParameters, ProgressMonitor progressMonitor) throws IOException {  <BUGS> verifyZipParameters(taskParameters.zipParameters); <BUGE>  if (!Zip4jUtil.isStringNotNullAndNotEmpty(taskParameters.zipParameters.getFileNameInZip())) { throw new ZipException("fileNameInZip has to be set in zipParameters when adding stream"); }  removeFileIfExists(getZipModel(), taskParameters.zip4jConfig, taskParameters.zipParameters.getFileNameInZip(), progressMonitor);  if (taskParameters.zipParameters.getCompressionMethod().equals(CompressionMethod.STORE)) { /* Set some random value here. This will be updated again when closing entry*/ taskParameters.zipParameters.setEntrySize(0); taskParameters.zipParameters.setWriteExtendedLocalFileHeader(false); } else { /* For streams, it is necessary to write extended local file header because of Zip standard encryption.*/ /* If we do not write extended local file header, zip standard encryption needs a crc upfront for key,*/ /* which cannot be calculated until we read the complete stream. If we use extended local file header,*/ /* last modified file time is used, or current system time if not available.*/ taskParameters.zipParameters.setWriteExtendedLocalFileHeader(true); }  try(SplitOutputStream splitOutputStream = new SplitOutputStream(getZipModel().getZipFile(), getZipModel().getSplitLength()); ZipOutputStream zipOutputStream = initializeOutputStream(splitOutputStream, taskParameters.zip4jConfig)) {  byte[] readBuff = new byte[taskParameters.zip4jConfig.getBufferSize()]; int readLen;
@Override protected void executeTask(AddStreamToZipTaskParameters taskParameters, ProgressMonitor progressMonitor) throws IOException {  verifyZipParameters(taskParameters.zipParameters);  <BUGS> if (!Zip4jUtil.isStringNotNullAndNotEmpty(taskParameters.zipParameters.getFileNameInZip())) { <BUGE> throw new ZipException("fileNameInZip has to be set in zipParameters when adding stream"); }  removeFileIfExists(getZipModel(), taskParameters.zip4jConfig, taskParameters.zipParameters.getFileNameInZip(), progressMonitor);  if (taskParameters.zipParameters.getCompressionMethod().equals(CompressionMethod.STORE)) { /* Set some random value here. This will be updated again when closing entry*/ taskParameters.zipParameters.setEntrySize(0); taskParameters.zipParameters.setWriteExtendedLocalFileHeader(false); } else { /* For streams, it is necessary to write extended local file header because of Zip standard encryption.*/ /* If we do not write extended local file header, zip standard encryption needs a crc upfront for key,*/ /* which cannot be calculated until we read the complete stream. If we use extended local file header,*/ /* last modified file time is used, or current system time if not available.*/ taskParameters.zipParameters.setWriteExtendedLocalFileHeader(true); }  try(SplitOutputStream splitOutputStream = new SplitOutputStream(getZipModel().getZipFile(), getZipModel().getSplitLength()); ZipOutputStream zipOutputStream = initializeOutputStream(splitOutputStream, taskParameters.zip4jConfig)) {  byte[] readBuff = new byte[taskParameters.zip4jConfig.getBufferSize()]; int readLen;
@Override protected void executeTask(AddStreamToZipTaskParameters taskParameters, ProgressMonitor progressMonitor) throws IOException {  verifyZipParameters(taskParameters.zipParameters);  if (!Zip4jUtil.isStringNotNullAndNotEmpty(taskParameters.zipParameters.getFileNameInZip())) { throw new ZipException("fileNameInZip has to be set in zipParameters when adding stream"); }  <BUGS> removeFileIfExists(getZipModel(), taskParameters.zip4jConfig, taskParameters.zipParameters.getFileNameInZip(), <BUGE> progressMonitor);  if (taskParameters.zipParameters.getCompressionMethod().equals(CompressionMethod.STORE)) { /* Set some random value here. This will be updated again when closing entry*/ taskParameters.zipParameters.setEntrySize(0); taskParameters.zipParameters.setWriteExtendedLocalFileHeader(false); } else { /* For streams, it is necessary to write extended local file header because of Zip standard encryption.*/ /* If we do not write extended local file header, zip standard encryption needs a crc upfront for key,*/ /* which cannot be calculated until we read the complete stream. If we use extended local file header,*/ /* last modified file time is used, or current system time if not available.*/ taskParameters.zipParameters.setWriteExtendedLocalFileHeader(true); }  try(SplitOutputStream splitOutputStream = new SplitOutputStream(getZipModel().getZipFile(), getZipModel().getSplitLength()); ZipOutputStream zipOutputStream = initializeOutputStream(splitOutputStream, taskParameters.zip4jConfig)) {  byte[] readBuff = new byte[taskParameters.zip4jConfig.getBufferSize()]; int readLen;
@Override protected void executeTask(AddStreamToZipTaskParameters taskParameters, ProgressMonitor progressMonitor) throws IOException {  verifyZipParameters(taskParameters.zipParameters);  if (!Zip4jUtil.isStringNotNullAndNotEmpty(taskParameters.zipParameters.getFileNameInZip())) { throw new ZipException("fileNameInZip has to be set in zipParameters when adding stream"); }  removeFileIfExists(getZipModel(), taskParameters.zip4jConfig, taskParameters.zipParameters.getFileNameInZip(), progressMonitor);  <BUGS> if (taskParameters.zipParameters.getCompressionMethod().equals(CompressionMethod.STORE)) { <BUGE> /* Set some random value here. This will be updated again when closing entry*/ taskParameters.zipParameters.setEntrySize(0); taskParameters.zipParameters.setWriteExtendedLocalFileHeader(false); } else { /* For streams, it is necessary to write extended local file header because of Zip standard encryption.*/ /* If we do not write extended local file header, zip standard encryption needs a crc upfront for key,*/ /* which cannot be calculated until we read the complete stream. If we use extended local file header,*/ /* last modified file time is used, or current system time if not available.*/ taskParameters.zipParameters.setWriteExtendedLocalFileHeader(true); }  try(SplitOutputStream splitOutputStream = new SplitOutputStream(getZipModel().getZipFile(), getZipModel().getSplitLength()); ZipOutputStream zipOutputStream = initializeOutputStream(splitOutputStream, taskParameters.zip4jConfig)) {  byte[] readBuff = new byte[taskParameters.zip4jConfig.getBufferSize()]; int readLen;
@Override protected void executeTask(AddStreamToZipTaskParameters taskParameters, ProgressMonitor progressMonitor) throws IOException {  verifyZipParameters(taskParameters.zipParameters);  if (!Zip4jUtil.isStringNotNullAndNotEmpty(taskParameters.zipParameters.getFileNameInZip())) { throw new ZipException("fileNameInZip has to be set in zipParameters when adding stream"); }  removeFileIfExists(getZipModel(), taskParameters.zip4jConfig, taskParameters.zipParameters.getFileNameInZip(), progressMonitor);  if (taskParameters.zipParameters.getCompressionMethod().equals(CompressionMethod.STORE)) { /* Set some random value here. This will be updated again when closing entry*/ <BUGS> taskParameters.zipParameters.setEntrySize(0); taskParameters.zipParameters.setWriteExtendedLocalFileHeader(false); <BUGE> } else { /* For streams, it is necessary to write extended local file header because of Zip standard encryption.*/ /* If we do not write extended local file header, zip standard encryption needs a crc upfront for key,*/ /* which cannot be calculated until we read the complete stream. If we use extended local file header,*/ /* last modified file time is used, or current system time if not available.*/ taskParameters.zipParameters.setWriteExtendedLocalFileHeader(true); }  try(SplitOutputStream splitOutputStream = new SplitOutputStream(getZipModel().getZipFile(), getZipModel().getSplitLength()); ZipOutputStream zipOutputStream = initializeOutputStream(splitOutputStream, taskParameters.zip4jConfig)) {  byte[] readBuff = new byte[taskParameters.zip4jConfig.getBufferSize()]; int readLen;
@Override protected void executeTask(AddStreamToZipTaskParameters taskParameters, ProgressMonitor progressMonitor) throws IOException {  verifyZipParameters(taskParameters.zipParameters);  if (!Zip4jUtil.isStringNotNullAndNotEmpty(taskParameters.zipParameters.getFileNameInZip())) { throw new ZipException("fileNameInZip has to be set in zipParameters when adding stream"); }  removeFileIfExists(getZipModel(), taskParameters.zip4jConfig, taskParameters.zipParameters.getFileNameInZip(), progressMonitor);  if (taskParameters.zipParameters.getCompressionMethod().equals(CompressionMethod.STORE)) { /* Set some random value here. This will be updated again when closing entry*/ taskParameters.zipParameters.setEntrySize(0); taskParameters.zipParameters.setWriteExtendedLocalFileHeader(false); } else { /* For streams, it is necessary to write extended local file header because of Zip standard encryption.*/ /* If we do not write extended local file header, zip standard encryption needs a crc upfront for key,*/ /* which cannot be calculated until we read the complete stream. If we use extended local file header,*/ /* last modified file time is used, or current system time if not available.*/ taskParameters.zipParameters.setWriteExtendedLocalFileHeader(true); }  <BUGS> try(SplitOutputStream splitOutputStream = new SplitOutputStream(getZipModel().getZipFile(), getZipModel().getSplitLength()); ZipOutputStream zipOutputStream = initializeOutputStream(splitOutputStream, taskParameters.zip4jConfig)) { <BUGE>  byte[] readBuff = new byte[taskParameters.zip4jConfig.getBufferSize()]; int readLen;
@Override protected void executeTask(AddStreamToZipTaskParameters taskParameters, ProgressMonitor progressMonitor) throws IOException {  verifyZipParameters(taskParameters.zipParameters);  if (!Zip4jUtil.isStringNotNullAndNotEmpty(taskParameters.zipParameters.getFileNameInZip())) { throw new ZipException("fileNameInZip has to be set in zipParameters when adding stream"); }  removeFileIfExists(getZipModel(), taskParameters.zip4jConfig, taskParameters.zipParameters.getFileNameInZip(), progressMonitor);  if (taskParameters.zipParameters.getCompressionMethod().equals(CompressionMethod.STORE)) { /* Set some random value here. This will be updated again when closing entry*/ taskParameters.zipParameters.setEntrySize(0); taskParameters.zipParameters.setWriteExtendedLocalFileHeader(false); } else { /* For streams, it is necessary to write extended local file header because of Zip standard encryption.*/ /* If we do not write extended local file header, zip standard encryption needs a crc upfront for key,*/ /* which cannot be calculated until we read the complete stream. If we use extended local file header,*/ /* last modified file time is used, or current system time if not available.*/ taskParameters.zipParameters.setWriteExtendedLocalFileHeader(true); }  try(SplitOutputStream splitOutputStream = new SplitOutputStream(getZipModel().getZipFile(), getZipModel().getSplitLength()); ZipOutputStream zipOutputStream = initializeOutputStream(splitOutputStream, taskParameters.zip4jConfig)) {  <BUGS> byte[] readBuff = new byte[taskParameters.zip4jConfig.getBufferSize()]; <BUGE> int readLen;
import net.lingala.zip4j.tasks.AddStreamToZipTask.AddStreamToZipTaskParameters; import net.lingala.zip4j.util.Zip4jUtil;  import java.io.IOException; import java.io.InputStream;  import static net.lingala.zip4j.util.Zip4jUtil.getCompressionMethod;  public class AddStreamToZipTask extends AbstractAddFileToZipTask<AddStreamToZipTaskParameters> {  public AddStreamToZipTask(ZipModel zipModel, char[] password, HeaderWriter headerWriter, AsyncTaskParameters asyncTaskParameters) { super(zipModel, password, headerWriter, asyncTaskParameters); }   <BUGS> ZipParameters zipParameters = taskParameters.zipParameters; zipOutputStream.putNextEntry(zipParameters); <BUGE>  if (!zipParameters.getFileNameInZip().endsWith("/") && !zipParameters.getFileNameInZip().endsWith("\\")) { while ((readLen = taskParameters.inputStream.read(readBuff)) != -1) { zipOutputStream.write(readBuff, 0, readLen); } }  FileHeader fileHeader = zipOutputStream.closeEntry();  if (CompressionMethod.STORE.equals(getCompressionMethod(fileHeader))) { updateLocalFileHeader(fileHeader, splitOutputStream); }
import net.lingala.zip4j.util.Zip4jUtil;  import java.io.IOException; import java.io.InputStream;  import static net.lingala.zip4j.util.Zip4jUtil.getCompressionMethod;  public class AddStreamToZipTask extends AbstractAddFileToZipTask<AddStreamToZipTaskParameters> {  public AddStreamToZipTask(ZipModel zipModel, char[] password, HeaderWriter headerWriter, AsyncTaskParameters asyncTaskParameters) { super(zipModel, password, headerWriter, asyncTaskParameters); }   <BUGS> if (!zipParameters.getFileNameInZip().endsWith("/") && !zipParameters.getFileNameInZip().endsWith("\\")) { while ((readLen = taskParameters.inputStream.read(readBuff)) != -1) { zipOutputStream.write(readBuff, 0, readLen); <BUGE> } }  FileHeader fileHeader = zipOutputStream.closeEntry();  if (CompressionMethod.STORE.equals(getCompressionMethod(fileHeader))) { updateLocalFileHeader(fileHeader, splitOutputStream); } } }  @Override
import net.lingala.zip4j.tasks.AddStreamToZipTask.AddStreamToZipTaskParameters; import net.lingala.zip4j.util.Zip4jUtil;  import java.io.IOException; import java.io.InputStream;  import static net.lingala.zip4j.util.Zip4jUtil.getCompressionMethod;  public class AddStreamToZipTask extends AbstractAddFileToZipTask<AddStreamToZipTaskParameters> {  public AddStreamToZipTask(ZipModel zipModel, char[] password, HeaderWriter headerWriter, AsyncTaskParameters asyncTaskParameters) { super(zipModel, password, headerWriter, asyncTaskParameters); }   <BUGS> FileHeader fileHeader = zipOutputStream.closeEntry(); <BUGE>  if (CompressionMethod.STORE.equals(getCompressionMethod(fileHeader))) { updateLocalFileHeader(fileHeader, splitOutputStream); } } }  @Override protected long calculateTotalWork(AddStreamToZipTaskParameters taskParameters) { return 0; }  private void removeFileIfExists(ZipModel zipModel, Zip4jConfig zip4jConfig, String fileNameInZip, ProgressMonitor progressMonitor) throws ZipException {
import net.lingala.zip4j.tasks.AddStreamToZipTask.AddStreamToZipTaskParameters; import net.lingala.zip4j.util.Zip4jUtil;  import java.io.IOException; import java.io.InputStream;  import static net.lingala.zip4j.util.Zip4jUtil.getCompressionMethod;  public class AddStreamToZipTask extends AbstractAddFileToZipTask<AddStreamToZipTaskParameters> {  public AddStreamToZipTask(ZipModel zipModel, char[] password, HeaderWriter headerWriter, AsyncTaskParameters asyncTaskParameters) { super(zipModel, password, headerWriter, asyncTaskParameters); }   <BUGS> if (CompressionMethod.STORE.equals(getCompressionMethod(fileHeader))) { updateLocalFileHeader(fileHeader, splitOutputStream); <BUGE> } } }  @Override protected long calculateTotalWork(AddStreamToZipTaskParameters taskParameters) { return 0; }  private void removeFileIfExists(ZipModel zipModel, Zip4jConfig zip4jConfig, String fileNameInZip, ProgressMonitor progressMonitor) throws ZipException {  FileHeader fileHeader = HeaderUtil.getFileHeader(zipModel, fileNameInZip);
import net.lingala.zip4j.tasks.AddStreamToZipTask.AddStreamToZipTaskParameters; import net.lingala.zip4j.util.Zip4jUtil;  import java.io.IOException; import java.io.InputStream;  import static net.lingala.zip4j.util.Zip4jUtil.getCompressionMethod;  public class AddStreamToZipTask extends AbstractAddFileToZipTask<AddStreamToZipTaskParameters> {  public AddStreamToZipTask(ZipModel zipModel, char[] password, HeaderWriter headerWriter, AsyncTaskParameters asyncTaskParameters) { super(zipModel, password, headerWriter, asyncTaskParameters); }  } <BUGS> } } <BUGE>  @Override protected long calculateTotalWork(AddStreamToZipTaskParameters taskParameters) { return 0; }  private void removeFileIfExists(ZipModel zipModel, Zip4jConfig zip4jConfig, String fileNameInZip, ProgressMonitor progressMonitor) throws ZipException {  FileHeader fileHeader = HeaderUtil.getFileHeader(zipModel, fileNameInZip); if (fileHeader  != null) { removeFile(fileHeader, progressMonitor, zip4jConfig); }
@Override public void write(OutputStream outputStream, Storable obj) throws IOException { <BUGS> throw new RuntimeException("Not yet implemented"); <BUGE> }
*/ public int previousClearBit(int i) { <BUGS> if (i < 0) <BUGE> { if (i == -1) return -1; throw new IndexOutOfBoundsException("i=" + i); }  final long[][][] bits = this.bits; final int aLength = bits.length;  int w = i >> SHIFT3; int w3 = w & MASK3; int w2 = (w >> SHIFT2) & MASK2; int w1 = w >> SHIFT1; if (w1 > aLength - 1) return i; w1 = Math.min(w1, aLength - 1); final int maxBitIdx = Math.min(i % LENGTH4, LENGTH4);  long word; long[][] a2; long[] a3;  final int f3 = w3; final int f2 = w2; final int f1 = w1;
*/ public int previousClearBit(int i) { if (i < 0) { if (i == -1) return -1; throw new IndexOutOfBoundsException("i=" + i); }  <BUGS> final long[][][] bits = this.bits; final int aLength = bits.length; <BUGE>  int w = i >> SHIFT3; int w3 = w & MASK3; int w2 = (w >> SHIFT2) & MASK2; int w1 = w >> SHIFT1; if (w1 > aLength - 1) return i; w1 = Math.min(w1, aLength - 1); final int maxBitIdx = Math.min(i % LENGTH4, LENGTH4);  long word; long[][] a2; long[] a3;  final int f3 = w3; final int f2 = w2; final int f1 = w1;
*/ public int previousClearBit(int i) { if (i < 0) { if (i == -1) return -1; throw new IndexOutOfBoundsException("i=" + i); }  final long[][][] bits = this.bits; final int aLength = bits.length;  <BUGS> int w = i >> SHIFT3; int w3 = w & MASK3; int w2 = (w >> SHIFT2) & MASK2; int w1 = w >> SHIFT1; if (w1 > aLength - 1) <BUGE> return i; w1 = Math.min(w1, aLength - 1); final int maxBitIdx = Math.min(i % LENGTH4, LENGTH4);  long word; long[][] a2; long[] a3;  final int f3 = w3; final int f2 = w2; final int f1 = w1;
*/ public int previousClearBit(int i) { if (i < 0) { if (i == -1) return -1; throw new IndexOutOfBoundsException("i=" + i); }  final long[][][] bits = this.bits; final int aLength = bits.length;  int w = i >> SHIFT3; int w3 = w & MASK3; int w2 = (w >> SHIFT2) & MASK2; int w1 = w >> SHIFT1; if (w1 > aLength - 1) return i; <BUGS> w1 = Math.min(w1, aLength - 1); final int maxBitIdx = Math.min(i % LENGTH4, LENGTH4); <BUGE>  long word; long[][] a2; long[] a3;  final int f3 = w3; final int f2 = w2; final int f1 = w1;
*/ public int previousClearBit(int i) { if (i < 0) { if (i == -1) return -1; throw new IndexOutOfBoundsException("i=" + i); }  final long[][][] bits = this.bits; final int aLength = bits.length;  int w = i >> SHIFT3; int w3 = w & MASK3; int w2 = (w >> SHIFT2) & MASK2; int w1 = w >> SHIFT1; if (w1 > aLength - 1) return i; w1 = Math.min(w1, aLength - 1); final int maxBitIdx = Math.min(i % LENGTH4, LENGTH4);  long word; long[][] a2; long[] a3;  <BUGS> final int f3 = w3; final int f2 = w2; final int f1 = w1; <BUGE>
/** * Returns the index of the nearest bit that is set to {@code false} * that occurs on or before the specified starting index. * If no such bit exists, or if {@code -1} is given as the * starting index, then {@code -1} is returned. * * @param  i the index to start checking from (inclusive) * @return the index of the previous clear bit, or {@code -1} if there *         is no such bit * @throws IndexOutOfBoundsException if the specified index is less *         than {@code -1} * @since  1.2 * @see java.util.BitSet#previousClearBit { <BUGS> for (; w1 >= 0; --w1) <BUGE> { if ((a2 = bits[w1]) == null) break search; for (; w2 >= 0; --w2) { if ((a3 = a2[w2]) == null) break search; for (; w3 >= 0; --w3) { if ((word = a3[w3]) == 0) break search; for (int bitIdx = maxBitIdx; bitIdx >= 0; --bitIdx) { if ((word & (1L << bitIdx)) == 0)
/** * Returns the index of the nearest bit that is set to {@code false} * that occurs on or before the specified starting index. * If no such bit exists, or if {@code -1} is given as the * starting index, then {@code -1} is returned. * * @param  i the index to start checking from (inclusive) * @return the index of the previous clear bit, or {@code -1} if there *         is no such bit * @throws IndexOutOfBoundsException if the specified index is less *         than {@code -1} * @since  1.2 * @see java.util.BitSet#previousClearBit { <BUGS> if ((a2 = bits[w1]) == null) break search; for (; w2 >= 0; --w2) <BUGE> { if ((a3 = a2[w2]) == null) break search; for (; w3 >= 0; --w3) { if ((word = a3[w3]) == 0) break search; for (int bitIdx = maxBitIdx; bitIdx >= 0; --bitIdx) { if ((word & (1L << bitIdx)) == 0) return (((w1 << SHIFT1) + (w2 << SHIFT2) + w3) << SHIFT3) + bitIdx; } }
/** * Returns the index of the nearest bit that is set to {@code false} * that occurs on or before the specified starting index. * If no such bit exists, or if {@code -1} is given as the * starting index, then {@code -1} is returned. * * @param  i the index to start checking from (inclusive) * @return the index of the previous clear bit, or {@code -1} if there *         is no such bit * @throws IndexOutOfBoundsException if the specified index is less *         than {@code -1} * @since  1.2 * @see java.util.BitSet#previousClearBit { <BUGS> if ((a3 = a2[w2]) == null) break search; for (; w3 >= 0; --w3) <BUGE> { if ((word = a3[w3]) == 0) break search; for (int bitIdx = maxBitIdx; bitIdx >= 0; --bitIdx) { if ((word & (1L << bitIdx)) == 0) return (((w1 << SHIFT1) + (w2 << SHIFT2) + w3) << SHIFT3) + bitIdx; } } w3 = LENGTH3 - 1; } w2 = LENGTH2 - 1; w3 = LENGTH3 - 1;
/** * Returns the index of the nearest bit that is set to {@code false} * that occurs on or before the specified starting index. * If no such bit exists, or if {@code -1} is given as the * starting index, then {@code -1} is returned. * * @param  i the index to start checking from (inclusive) * @return the index of the previous clear bit, or {@code -1} if there *         is no such bit * @throws IndexOutOfBoundsException if the specified index is less *         than {@code -1} * @since  1.2 * @see java.util.BitSet#previousClearBit { <BUGS> if ((word = a3[w3]) == 0) break search; for (int bitIdx = maxBitIdx; bitIdx >= 0; --bitIdx) <BUGE> { if ((word & (1L << bitIdx)) == 0) return (((w1 << SHIFT1) + (w2 << SHIFT2) + w3) << SHIFT3) + bitIdx; } } w3 = LENGTH3 - 1; } w2 = LENGTH2 - 1; w3 = LENGTH3 - 1; } return -1; } return (((w1 << SHIFT1) + (w2 << SHIFT2) + w3) << SHIFT3) + maxBitIdx;
/** * Returns the index of the nearest bit that is set to {@code false} * that occurs on or before the specified starting index. * If no such bit exists, or if {@code -1} is given as the * starting index, then {@code -1} is returned. * * @param  i the index to start checking from (inclusive) * @return the index of the previous clear bit, or {@code -1} if there *         is no such bit * @throws IndexOutOfBoundsException if the specified index is less *         than {@code -1} * @since  1.2 * @see java.util.BitSet#previousClearBit { <BUGS> if ((word & (1L << bitIdx)) == 0) <BUGE> return (((w1 << SHIFT1) + (w2 << SHIFT2) + w3) << SHIFT3) + bitIdx; } } w3 = LENGTH3 - 1; } w2 = LENGTH2 - 1; w3 = LENGTH3 - 1; } return -1; } return (((w1 << SHIFT1) + (w2 << SHIFT2) + w3) << SHIFT3) + maxBitIdx; }  /**
/** * Returns the index of the nearest bit that is set to {@code false} * that occurs on or before the specified starting index. * If no such bit exists, or if {@code -1} is given as the * starting index, then {@code -1} is returned. * * @param  i the index to start checking from (inclusive) * @return the index of the previous clear bit, or {@code -1} if there *         is no such bit * @throws IndexOutOfBoundsException if the specified index is less *         than {@code -1} * @since  1.2 * @see java.util.BitSet#previousClearBit } <BUGS> w3 = LENGTH3 - 1; <BUGE> } w2 = LENGTH2 - 1; w3 = LENGTH3 - 1; } return -1; } return (((w1 << SHIFT1) + (w2 << SHIFT2) + w3) << SHIFT3) + maxBitIdx; }  /** * Returns the index of the nearest bit that is set to {@code true} * that occurs on or before the specified starting index. * If no such bit exists, or if {@code -1} is given as the * starting index, then {@code -1} is returned.
/** * Returns the index of the nearest bit that is set to {@code false} * that occurs on or before the specified starting index. * If no such bit exists, or if {@code -1} is given as the * starting index, then {@code -1} is returned. * * @param  i the index to start checking from (inclusive) * @return the index of the previous clear bit, or {@code -1} if there *         is no such bit * @throws IndexOutOfBoundsException if the specified index is less *         than {@code -1} * @since  1.2 * @see java.util.BitSet#previousClearBit } <BUGS> w2 = LENGTH2 - 1; w3 = LENGTH3 - 1; <BUGE> } return -1; } return (((w1 << SHIFT1) + (w2 << SHIFT2) + w3) << SHIFT3) + maxBitIdx; }  /** * Returns the index of the nearest bit that is set to {@code true} * that occurs on or before the specified starting index. * If no such bit exists, or if {@code -1} is given as the * starting index, then {@code -1} is returned. * * @param  i the index to start checking from (inclusive)
/** * Returns the index of the nearest bit that is set to {@code false} * that occurs on or before the specified starting index. * If no such bit exists, or if {@code -1} is given as the * starting index, then {@code -1} is returned. * * @param  i the index to start checking from (inclusive) * @return the index of the previous clear bit, or {@code -1} if there *         is no such bit * @throws IndexOutOfBoundsException if the specified index is less *         than {@code -1} * @since  1.2 * @see java.util.BitSet#previousClearBit } <BUGS> return (((w1 << SHIFT1) + (w2 << SHIFT2) + w3) << SHIFT3) + maxBitIdx; <BUGE> }  /** * Returns the index of the nearest bit that is set to {@code true} * that occurs on or before the specified starting index. * If no such bit exists, or if {@code -1} is given as the * starting index, then {@code -1} is returned. * * @param  i the index to start checking from (inclusive) * @return the index of the previous set bit, or {@code -1} if there *         is no such bit * @throws IndexOutOfBoundsException if the specified index is less *         than {@code -1} * @since  1.2
*/ public int previousClearBit(int i) { <BUGS> if (i < 0) <BUGE> { if (i == -1) return -1; throw new IndexOutOfBoundsException("i=" + i); }  final long[][][] bits = this.bits; final int aSize = bits.length - 1;  int w = i >> SHIFT3; int w3 = w & MASK3; int w2 = (w >> SHIFT2) & MASK2; int w1 = w >> SHIFT1; if (w1 > aSize) return i; w1 = Math.min(w1, aSize); final int w4 = i % LENGTH4;  long word; long[][] a2; long[] a3;  final int f3 = w3; final int f2 = w2; final int f1 = w1;
*/ public int previousClearBit(int i) { if (i < 0) { if (i == -1) return -1; throw new IndexOutOfBoundsException("i=" + i); }  <BUGS> final long[][][] bits = this.bits; final int aSize = bits.length - 1; <BUGE>  int w = i >> SHIFT3; int w3 = w & MASK3; int w2 = (w >> SHIFT2) & MASK2; int w1 = w >> SHIFT1; if (w1 > aSize) return i; w1 = Math.min(w1, aSize); final int w4 = i % LENGTH4;  long word; long[][] a2; long[] a3;  final int f3 = w3; final int f2 = w2; final int f1 = w1;
*/ public int previousClearBit(int i) { if (i < 0) { if (i == -1) return -1; throw new IndexOutOfBoundsException("i=" + i); }  final long[][][] bits = this.bits; final int aSize = bits.length - 1;  <BUGS> int w = i >> SHIFT3; int w3 = w & MASK3; int w2 = (w >> SHIFT2) & MASK2; int w1 = w >> SHIFT1; if (w1 > aSize) <BUGE> return i; w1 = Math.min(w1, aSize); final int w4 = i % LENGTH4;  long word; long[][] a2; long[] a3;  final int f3 = w3; final int f2 = w2; final int f1 = w1;
*/ public int previousClearBit(int i) { if (i < 0) { if (i == -1) return -1; throw new IndexOutOfBoundsException("i=" + i); }  final long[][][] bits = this.bits; final int aSize = bits.length - 1;  int w = i >> SHIFT3; int w3 = w & MASK3; int w2 = (w >> SHIFT2) & MASK2; int w1 = w >> SHIFT1; if (w1 > aSize) return i; <BUGS> w1 = Math.min(w1, aSize); final int w4 = i % LENGTH4; <BUGE>  long word; long[][] a2; long[] a3;  final int f3 = w3; final int f2 = w2; final int f1 = w1;
*/ public int previousClearBit(int i) { if (i < 0) { if (i == -1) return -1; throw new IndexOutOfBoundsException("i=" + i); }  final long[][][] bits = this.bits; final int aSize = bits.length - 1;  int w = i >> SHIFT3; int w3 = w & MASK3; int w2 = (w >> SHIFT2) & MASK2; int w1 = w >> SHIFT1; if (w1 > aSize) return i; w1 = Math.min(w1, aSize); final int w4 = i % LENGTH4;  long word; long[][] a2; long[] a3;  <BUGS> final int f3 = w3; final int f2 = w2; final int f1 = w1; <BUGE>
*/ public int previousClearBit(int i) { if (i < 0) { if (i == -1) return -1; throw new IndexOutOfBoundsException("i=" + i); }  final long[][][] bits = this.bits; final int aSize = bits.length - 1;  int w = i >> SHIFT3; int w3 = w & MASK3; int w2 = (w >> SHIFT2) & MASK2; int w1 = w >> SHIFT1; if (w1 > aSize) return i; w1 = Math.min(w1, aSize); final int w4 = i % LENGTH4;  long word; long[][] a2; long[] a3;  final int f3 = w3; final int f2 = w2; final int f1 = w1;
/** * Returns the index of the nearest bit that is set to {@code false} * that occurs on or before the specified starting index. * If no such bit exists, or if {@code -1} is given as the * starting index, then {@code -1} is returned. * * @param  i the index to start checking from (inclusive) * @return the index of the previous clear bit, or {@code -1} if there *         is no such bit * @throws IndexOutOfBoundsException if the specified index is less *         than {@code -1} * @since  1.2 * @see java.util.BitSet#previousClearBit { <BUGS> if ((a2 = bits[w1]) == null) <BUGE> return (((w1 << SHIFT1) + (w2 << SHIFT2) + w3) << SHIFT3) + (f1 == w1 ? w4 : LENGTH4 - 1); for (; w2 >= 0; --w2) { if ((a3 = a2[w2]) == null) return (((w1 << SHIFT1) + (w2 << SHIFT2) + w3) << SHIFT3) + (f2 == w2 ? w4 : LENGTH4 - 1); for (; w3 >= 0; --w3) { if ((word = a3[w3]) == 0) return (((w1 << SHIFT1) + (w2 << SHIFT2) + w3) << SHIFT3) + (f3 == w3 ? w4 : LENGTH4 - 1); for (int bitIdx = w4; bitIdx >= 0; --bitIdx) { if ((word & (1L << bitIdx)) == 0) return (((w1 << SHIFT1) + (w2 << SHIFT2) + w3) << SHIFT3) + bitIdx; }
/** * Returns the index of the nearest bit that is set to {@code false} * that occurs on or before the specified starting index. * If no such bit exists, or if {@code -1} is given as the * starting index, then {@code -1} is returned. * * @param  i the index to start checking from (inclusive) * @return the index of the previous clear bit, or {@code -1} if there *         is no such bit * @throws IndexOutOfBoundsException if the specified index is less *         than {@code -1} * @since  1.2 * @see java.util.BitSet#previousClearBit return (((w1 << SHIFT1) + (w2 << SHIFT2) + w3) << SHIFT3) + (f1 == w1 ? w4 : LENGTH4 - 1); <BUGS> for (; w2 >= 0; --w2) <BUGE> { if ((a3 = a2[w2]) == null) return (((w1 << SHIFT1) + (w2 << SHIFT2) + w3) << SHIFT3) + (f2 == w2 ? w4 : LENGTH4 - 1); for (; w3 >= 0; --w3) { if ((word = a3[w3]) == 0) return (((w1 << SHIFT1) + (w2 << SHIFT2) + w3) << SHIFT3) + (f3 == w3 ? w4 : LENGTH4 - 1); for (int bitIdx = w4; bitIdx >= 0; --bitIdx) { if ((word & (1L << bitIdx)) == 0) return (((w1 << SHIFT1) + (w2 << SHIFT2) + w3) << SHIFT3) + bitIdx; } } w3 = LENGTH3_SIZE;
/** * Returns the index of the nearest bit that is set to {@code false} * that occurs on or before the specified starting index. * If no such bit exists, or if {@code -1} is given as the * starting index, then {@code -1} is returned. * * @param  i the index to start checking from (inclusive) * @return the index of the previous clear bit, or {@code -1} if there *         is no such bit * @throws IndexOutOfBoundsException if the specified index is less *         than {@code -1} * @since  1.2 * @see java.util.BitSet#previousClearBit { <BUGS> if ((a3 = a2[w2]) == null) <BUGE> return (((w1 << SHIFT1) + (w2 << SHIFT2) + w3) << SHIFT3) + (f2 == w2 ? w4 : LENGTH4 - 1); for (; w3 >= 0; --w3) { if ((word = a3[w3]) == 0) return (((w1 << SHIFT1) + (w2 << SHIFT2) + w3) << SHIFT3) + (f3 == w3 ? w4 : LENGTH4 - 1); for (int bitIdx = w4; bitIdx >= 0; --bitIdx) { if ((word & (1L << bitIdx)) == 0) return (((w1 << SHIFT1) + (w2 << SHIFT2) + w3) << SHIFT3) + bitIdx; } } w3 = LENGTH3_SIZE; } w2 = LENGTH2_SIZE;
/** * Returns the index of the nearest bit that is set to {@code false} * that occurs on or before the specified starting index. * If no such bit exists, or if {@code -1} is given as the * starting index, then {@code -1} is returned. * * @param  i the index to start checking from (inclusive) * @return the index of the previous clear bit, or {@code -1} if there *         is no such bit * @throws IndexOutOfBoundsException if the specified index is less *         than {@code -1} * @since  1.2 * @see java.util.BitSet#previousClearBit return (((w1 << SHIFT1) + (w2 << SHIFT2) + w3) << SHIFT3) + (f2 == w2 ? w4 : LENGTH4 - 1); <BUGS> for (; w3 >= 0; --w3) <BUGE> { if ((word = a3[w3]) == 0) return (((w1 << SHIFT1) + (w2 << SHIFT2) + w3) << SHIFT3) + (f3 == w3 ? w4 : LENGTH4 - 1); for (int bitIdx = w4; bitIdx >= 0; --bitIdx) { if ((word & (1L << bitIdx)) == 0) return (((w1 << SHIFT1) + (w2 << SHIFT2) + w3) << SHIFT3) + bitIdx; } } w3 = LENGTH3_SIZE; } w2 = LENGTH2_SIZE; w3 = LENGTH3 - 1; }
/** * Returns the index of the nearest bit that is set to {@code false} * that occurs on or before the specified starting index. * If no such bit exists, or if {@code -1} is given as the * starting index, then {@code -1} is returned. * * @param  i the index to start checking from (inclusive) * @return the index of the previous clear bit, or {@code -1} if there *         is no such bit * @throws IndexOutOfBoundsException if the specified index is less *         than {@code -1} * @since  1.2 * @see java.util.BitSet#previousClearBit { <BUGS> if ((word = a3[w3]) == 0) <BUGE> return (((w1 << SHIFT1) + (w2 << SHIFT2) + w3) << SHIFT3) + (f3 == w3 ? w4 : LENGTH4 - 1); for (int bitIdx = w4; bitIdx >= 0; --bitIdx) { if ((word & (1L << bitIdx)) == 0) return (((w1 << SHIFT1) + (w2 << SHIFT2) + w3) << SHIFT3) + bitIdx; } } w3 = LENGTH3_SIZE; } w2 = LENGTH2_SIZE; w3 = LENGTH3 - 1; } return -1; }
/** * Returns the index of the nearest bit that is set to {@code false} * that occurs on or before the specified starting index. * If no such bit exists, or if {@code -1} is given as the * starting index, then {@code -1} is returned. * * @param  i the index to start checking from (inclusive) * @return the index of the previous clear bit, or {@code -1} if there *         is no such bit * @throws IndexOutOfBoundsException if the specified index is less *         than {@code -1} * @since  1.2 * @see java.util.BitSet#previousClearBit return (((w1 << SHIFT1) + (w2 << SHIFT2) + w3) << SHIFT3) + (f3 == w3 ? w4 : LENGTH4 - 1); <BUGS> for (int bitIdx = w4; bitIdx >= 0; --bitIdx) <BUGE> { if ((word & (1L << bitIdx)) == 0) return (((w1 << SHIFT1) + (w2 << SHIFT2) + w3) << SHIFT3) + bitIdx; } } w3 = LENGTH3_SIZE; } w2 = LENGTH2_SIZE; w3 = LENGTH3 - 1; } return -1; }  /**
/** * Returns the index of the nearest bit that is set to {@code false} * that occurs on or before the specified starting index. * If no such bit exists, or if {@code -1} is given as the * starting index, then {@code -1} is returned. * * @param  i the index to start checking from (inclusive) * @return the index of the previous clear bit, or {@code -1} if there *         is no such bit * @throws IndexOutOfBoundsException if the specified index is less *         than {@code -1} * @since  1.2 * @see java.util.BitSet#previousClearBit { <BUGS> if ((word & (1L << bitIdx)) == 0) return (((w1 << SHIFT1) + (w2 << SHIFT2) + w3) << SHIFT3) + bitIdx; <BUGE> } } w3 = LENGTH3_SIZE; } w2 = LENGTH2_SIZE; w3 = LENGTH3 - 1; } return -1; }  /** * Returns the index of the nearest bit that is set to {@code true} * that occurs on or before the specified starting index.
protected String generateAssertionsForPublicFields(Set<FieldDescription> fields) { <BUGS> StringBuilder assertionsForPublicFields = new StringBuilder(); for (FieldDescription field : fields) { String assertionContent = assertionContentForField(field); assertionsForPublicFields.append(assertionContent).append(LINE_SEPARATOR); } return assertionsForPublicFields.toString(); <BUGE> }
private Set<GetterDescription> getterDescriptionsOf(Class<?> clazz) { <BUGS> Set<GetterDescription> getterDescriptions = new TreeSet<GetterDescription>(); List<Method> getters = getterMethodsOf(clazz); for (Method getter : getters) { Class<?> propertyType = getter.getReturnType(); TypeDescription typeDescription = new TypeDescription(new TypeName(propertyType)); if (propertyType.isArray()) { typeDescription.setElementTypeName(new TypeName(propertyType.getComponentType())); typeDescription.setArray(true); } else if (isIterable(propertyType)) { ParameterizedType parameterizedType = (ParameterizedType) getter.getGenericReturnType(); Class<?> parameterClass = (Class<?>) parameterizedType.getActualTypeArguments()[0]; typeDescription.setElementTypeName(new TypeName(parameterClass)); typeDescription.setIterable(true); <BUGE> } getterDescriptions.add(new GetterDescription(propertyNameOf(getter), typeDescription)); } return getterDescriptions; }
private Set<GetterDescription> getterDescriptionsOf(Class<?> clazz) { Set<GetterDescription> getterDescriptions = new TreeSet<GetterDescription>(); List<Method> getters = getterMethodsOf(clazz); for (Method getter : getters) { Class<?> propertyType = getter.getReturnType(); TypeDescription typeDescription = new TypeDescription(new TypeName(propertyType)); if (propertyType.isArray()) { typeDescription.setElementTypeName(new TypeName(propertyType.getComponentType())); typeDescription.setArray(true); } else if (isIterable(propertyType)) { ParameterizedType parameterizedType = (ParameterizedType) getter.getGenericReturnType(); Class<?> parameterClass = (Class<?>) parameterizedType.getActualTypeArguments()[0]; typeDescription.setElementTypeName(new TypeName(parameterClass)); typeDescription.setIterable(true); } <BUGS> getterDescriptions.add(new GetterDescription(propertyNameOf(getter), typeDescription)); } return getterDescriptions; <BUGE> }
@Override public String toString() { <BUGS> return "TypeDescription[typeName=" + typeName + ", array=" + isArray + ", iterable=" + isIterable + ", primitive=" + isPrimitive() + ", boolean=" + isBoolean() + ", elementTypeName=" + elementTypeName + "]"; <BUGE> }
@Override public int hashCode() { <BUGS> final int prime = 31; int result = 1; result = prime * result + ((packageName == null) ? 0 : packageName.hashCode()); result = prime * result + ((typeSimpleName == null) ? 0 : typeSimpleName.hashCode()); return result; <BUGE> }
public static List<Method> getterMethodsOf(Class<?> clazz) { <BUGS> Method[] declaredMethods = clazz.getDeclaredMethods(); List<Method> getters = new ArrayList<Method>(); for (int i = 0; i < declaredMethods.length; i++) { Method method = declaredMethods[i]; if (isStandardGetter(method) || isBooleanGetter(method)) { getters.add(method); <BUGE> } } return getters;  }
public static List<Method> getterMethodsOf(Class<?> clazz) { Method[] declaredMethods = clazz.getDeclaredMethods(); List<Method> getters = new ArrayList<Method>(); for (int i = 0; i < declaredMethods.length; i++) { Method method = declaredMethods[i]; if (isStandardGetter(method) || isBooleanGetter(method)) { getters.add(method); } } <BUGS> return getters; <BUGE>  }
public synchronized Object coerce(Class<?> clazz, String value) {         <BUGS> Coercer<?> coercer = getCoercerFor(coercibles, clazz); if (coercer == null) { coercer = getCoercerFor(DEFAULT_COERCIBLES, clazz); <BUGE>  if (coercer == null) { throw new IllegalStateException(String.format("Don't know how to handle a '%s' type for value '%s'", clazz.getName(), value)); } } return coercer.coerce(value); }
public synchronized Object coerce(Class<?> clazz, String value) {         Coercer<?> coercer = getCoercerFor(coercibles, clazz); if (coercer == null) { coercer = getCoercerFor(DEFAULT_COERCIBLES, clazz);  <BUGS> if (coercer == null) { throw new IllegalStateException(String.format("Don't know how to handle a '%s' type for value '%s'", clazz.getName(), value)); <BUGE> } } return coercer.coerce(value); }
public synchronized Object coerce(Class<?> clazz, String value) {         Coercer<?> coercer = getCoercerFor(coercibles, clazz); if (coercer == null) { coercer = getCoercerFor(DEFAULT_COERCIBLES, clazz);  if (coercer == null) { throw new IllegalStateException(String.format("Don't know how to handle a '%s' type for value '%s'", clazz.getName(), value)); } } <BUGS> return coercer.coerce(value); <BUGE> }
public JCodeModel () {}
public JCodeModel () {}
public JCodeModel () {}
public JCodeModel () {}
public JCodeModel () {}
public JCodeModel () {}
public JCodeModel () <BUGS> {} <BUGE>
public JCodeModel () {}
public JCodeModel () {}
public JCodeModel () {}
public JCodeModel () {}
public JCodeModel () {}
public JCodeModel () {}
public JCodeModel () <BUGS> {} <BUGE>
@Nonnull public AbstractJClass ref (@Nonnull final String fullyQualifiedClassName) { try { /* try the context class loader first*/ <BUGS> return ref (SecureLoader.getContextClassLoader ().loadClass (fullyQualifiedClassName)); <BUGE> } catch (final ClassNotFoundException e) { /* fall through*/ }  /* then the default mechanism.*/ try { return ref (Class.forName (fullyQualifiedClassName)); } catch (final ClassNotFoundException e1) { /* fall through*/ }  /* assume it's not visible to us.*/ return new JDirectClass (this, fullyQualifiedClassName); }
@Nonnull public AbstractJClass ref (@Nonnull final String fullyQualifiedClassName) { try { /* try the context class loader first*/ return ref (SecureLoader.getContextClassLoader ().loadClass (fullyQualifiedClassName)); } <BUGS> catch (final ClassNotFoundException e) <BUGE> { /* fall through*/ }  /* then the default mechanism.*/ try { return ref (Class.forName (fullyQualifiedClassName)); } catch (final ClassNotFoundException e1) { /* fall through*/ }  /* assume it's not visible to us.*/ return new JDirectClass (this, fullyQualifiedClassName); }
@Nonnull public AbstractJClass ref (@Nonnull final String fullyQualifiedClassName) { try { /* try the context class loader first*/ return ref (SecureLoader.getContextClassLoader ().loadClass (fullyQualifiedClassName)); } catch (final ClassNotFoundException e) { /* fall through*/ }  /* then the default mechanism.*/ try { <BUGS> return ref (Class.forName (fullyQualifiedClassName)); <BUGE> } catch (final ClassNotFoundException e1) { /* fall through*/ }  /* assume it's not visible to us.*/ return new JDirectClass (this, fullyQualifiedClassName); }
@Nonnull public AbstractJClass ref (@Nonnull final String fullyQualifiedClassName) { try { /* try the context class loader first*/ return ref (SecureLoader.getContextClassLoader ().loadClass (fullyQualifiedClassName)); } catch (final ClassNotFoundException e) { /* fall through*/ }  /* then the default mechanism.*/ try { return ref (Class.forName (fullyQualifiedClassName)); } <BUGS> catch (final ClassNotFoundException e1) <BUGE> { /* fall through*/ }  /* assume it's not visible to us.*/ return new JDirectClass (this, fullyQualifiedClassName); }
@Nonnull public AbstractJClass ref (@Nonnull final String fullyQualifiedClassName) { try { /* try the context class loader first*/ return ref (SecureLoader.getContextClassLoader ().loadClass (fullyQualifiedClassName)); } catch (final ClassNotFoundException e) { /* fall through*/ }  /* then the default mechanism.*/ try { return ref (Class.forName (fullyQualifiedClassName)); } catch (final ClassNotFoundException e1) { /* fall through*/ }  /* assume it's not visible to us.*/ <BUGS> return new JDirectClass (this, fullyQualifiedClassName); <BUGE> }
@Nonnull public String fullName () { <BUGS> return _typeName; <BUGE> }
@Nullable public JPackage parent () { <BUGS> if (m_sName.length () == 0) <BUGE> return null;  final int idx = m_sName.lastIndexOf ('.'); return m_aOwner._package (m_sName.substring (0, idx)); }
@Nullable public JPackage parent () { if (m_sName.length () == 0) return null;  <BUGS> final int idx = m_sName.lastIndexOf ('.'); return m_aOwner._package (m_sName.substring (0, idx)); <BUGE> }
@Nonnull public JDirectClass directClass (@Nonnull final String name) { <BUGS> return directClass (EClassType.CLASS, name); <BUGE> }
@Override public String name () { <BUGS> final StringBuilder buf = new StringBuilder (); buf.append (_basis.name ()).append ('<'); boolean first = true; for (final AbstractJClass c : _args) <BUGE> { if (first) first = false; else buf.append (','); buf.append (c.name ()); } buf.append ('>'); return buf.toString (); }
@Override public String name () { final StringBuilder buf = new StringBuilder (); buf.append (_basis.name ()).append ('<'); boolean first = true; for (final AbstractJClass c : _args) { <BUGS> if (first) first = false; <BUGE> else buf.append (','); buf.append (c.name ()); } buf.append ('>'); return buf.toString (); }
@Override public String name () { final StringBuilder buf = new StringBuilder (); buf.append (_basis.name ()).append ('<'); boolean first = true; for (final AbstractJClass c : _args) { if (first) first = false; else <BUGS> buf.append (','); buf.append (c.name ()); } buf.append ('>'); return buf.toString (); <BUGE> }
*/ public synchronized void close() { <BUGS> checkIfClosed(); <BUGE> try { _pageman.close(); _file.close(); if(deleteFilesAfterClose) _file.storage.deleteAllFiles();  _pageman = null;   _file = null;  } catch (IOException e) { throw new IOError(e); } }
*/ public synchronized void close() { checkIfClosed(); try { <BUGS> _pageman.close(); _file.close(); if(deleteFilesAfterClose) <BUGE> _file.storage.deleteAllFiles();  _pageman = null;   _file = null;  } catch (IOException e) { throw new IOError(e); } }
*/ public synchronized void close() { checkIfClosed(); try { _pageman.close(); _file.close(); if(deleteFilesAfterClose) _file.storage.deleteAllFiles();  <BUGS> _pageman = null; <BUGE>   _file = null;  } catch (IOException e) { throw new IOError(e); } }
*/ public synchronized void close() { checkIfClosed(); try { _pageman.close(); _file.close(); if(deleteFilesAfterClose) _file.storage.deleteAllFiles();  _pageman = null;   <BUGS> _file = null; <BUGE>  } catch (IOException e) { throw new IOError(e); } }
*/ public synchronized void close() { checkIfClosed(); try { _pageman.close(); _file.close(); if(deleteFilesAfterClose) _file.storage.deleteAllFiles();  _pageman = null;   _file = null;  <BUGS> } catch (IOException e) { throw new IOError(e); } } <BUGE>
*/ public Iterator<K> keys() throws IOException { <BUGS> lock.readLock().lock(); <BUGE> try{ return getRoot().keys(); }finally { lock.readLock().unlock(); } }
*/ public Iterator<K> keys() throws IOException { lock.readLock().lock(); try{ <BUGS> return getRoot().keys(); <BUGE> }finally { lock.readLock().unlock(); } }
*/ public Iterator<K> keys() throws IOException { lock.readLock().lock(); try{ return getRoot().keys(); }finally { <BUGS> lock.readLock().unlock(); } <BUGE> }
*/ public DBMaker readonly() { <BUGS> readonly = true; return this; <BUGE> }
public Object getFieldValue(FieldInfo fieldInfo, Object object) {  <BUGS> Object fieldAccessor = fieldInfo.getter; <BUGE> try { if (fieldAccessor instanceof Method) { Method m = (Method) fieldAccessor; return m.invoke(object); } else { Field f = (Field) fieldAccessor; return f.get(object); } } catch (Exception e) {  }  throw new NoSuchFieldError(object.getClass() + "." + fieldInfo.getName()); }
public Object getFieldValue(FieldInfo fieldInfo, Object object) {  Object fieldAccessor = fieldInfo.getter; try { <BUGS> if (fieldAccessor instanceof Method) { <BUGE> Method m = (Method) fieldAccessor; return m.invoke(object); } else { Field f = (Field) fieldAccessor; return f.get(object); } } catch (Exception e) {  }  throw new NoSuchFieldError(object.getClass() + "." + fieldInfo.getName()); }
public Object getFieldValue(FieldInfo fieldInfo, Object object) {  Object fieldAccessor = fieldInfo.getter; try { if (fieldAccessor instanceof Method) { Method m = (Method) fieldAccessor; return m.invoke(object); } else { <BUGS> Field f = (Field) fieldAccessor; return f.get(object); <BUGE> } } catch (Exception e) {  }  throw new NoSuchFieldError(object.getClass() + "." + fieldInfo.getName()); }
public Object getFieldValue(FieldInfo fieldInfo, Object object) {  Object fieldAccessor = fieldInfo.getter; try { if (fieldAccessor instanceof Method) { Method m = (Method) fieldAccessor; return m.invoke(object); } else { Field f = (Field) fieldAccessor; return f.get(object); } <BUGS> } catch (Exception e) { <BUGE>  }  throw new NoSuchFieldError(object.getClass() + "." + fieldInfo.getName()); }
public Object getFieldValue(FieldInfo fieldInfo, Object object) {  Object fieldAccessor = fieldInfo.getter; try { if (fieldAccessor instanceof Method) { Method m = (Method) fieldAccessor; return m.invoke(object); } else { Field f = (Field) fieldAccessor; return f.get(object); } } catch (Exception e) {  }  <BUGS> throw new NoSuchFieldError(object.getClass() + "." + fieldInfo.getName()); <BUGE> }
private void assertClassSerializable(Class clazz) throws NotSerializableException, InvalidClassException { <BUGS> if(containsClass(clazz)) return; <BUGE>  if (!Serializable.class.isAssignableFrom(clazz)) throw new NotSerializableException(clazz.getName()); }
private void assertClassSerializable(Class clazz) throws NotSerializableException, InvalidClassException { if(containsClass(clazz)) return;  <BUGS> if (!Serializable.class.isAssignableFrom(clazz)) <BUGE> throw new NotSerializableException(clazz.getName()); }
private void assertClassSerializable(Class clazz) throws NotSerializableException, InvalidClassException { if(containsClass(clazz)) return;  if (!Serializable.class.isAssignableFrom(clazz)) throw new NotSerializableException(clazz.getName()); <BUGS> } <BUGE>
public synchronized  void rollback(){ <BUGS> cachedDefaultSerializer = null; _hashDirties.clear(); super.rollback(); } <BUGE>
*/ public static void orderBy(String orderBy) { <BUGS> Page<?> page = getLocalPage(); if (page != null) { <BUGE> page.setOrderBy(orderBy); } else { page = new Page(); page.setOrderBy(orderBy); page.setOrderByOnly(true); setLocalPage(page); } }
*/ public static void orderBy(String orderBy) { Page<?> page = getLocalPage(); if (page != null) { page.setOrderBy(orderBy); } else { <BUGS> page = new Page(); page.setOrderBy(orderBy); page.setOrderByOnly(true); setLocalPage(page); <BUGE> } }
*/ public static void orderBy(String orderBy) { Page<?> page = getLocalPage(); if (page != null) { page.setOrderBy(orderBy); } else { page = new Page(); page.setOrderBy(orderBy); page.setOrderByOnly(true); setLocalPage(page); } <BUGS> } <BUGE>
*/ public static <E> Page<E> offsetPage(int offset, int limit) { <BUGS> return offsetPage(offset, limit, DEFAULT_COUNT); <BUGE> }
<BUGS> private boolean isFirstPage = false; <BUGE> /*是否为最后一页*/ private boolean isLastPage = false; /*是否有前一页*/ private boolean hasPreviousPage = false; /*是否有下一页*/ private boolean hasNextPage = false; /*导航页码数*/ private int navigatePages; /*所有导航页号*/ private int[] navigatepageNums; /*导航条上的第一页*/ private int navigateFirstPage; /*导航条上的最后一页*/ private int navigateLastPage;  public PageInfo() { }  /** * 包装Page对象 * * @param list */ public PageInfo(List<T> list) { this(list, 8); }  /** * 包装Page对象 * * @param list          page结果 * @param navigatePages 页码数量 */ public PageInfo(List<T> list, int navigatePages) { super(list); if (list instanceof Page) { Page page = (Page) list; this.pageNum = page.getPageNum(); this.pageSize = page.getPageSize();  this.pages = page.getPages(); this.size = page.size(); /*由于结果是>startRow的，所以实际的需要+1*/ if (this.size == 0) { this.startRow = 0; this.endRow = 0; } else { this.startRow = page.getStartRow() + 1; /*计算实际的endRow（最后一页的时候特殊）*/ this.endRow = this.startRow - 1 + this.size; } } else if (list instanceof Collection) { this.pageNum = 1; this.pageSize = list.size();  this.pages = this.pageSize > 0 ? 1 : 0; this.size = list.size(); this.startRow = 0; this.endRow = list.size() > 0 ? list.size() - 1 : 0; } if (list instanceof Collection) { this.navigatePages = navigatePages;
<BUGS> private boolean isLastPage = false; <BUGE> /*是否有前一页*/ private boolean hasPreviousPage = false; /*是否有下一页*/ private boolean hasNextPage = false; /*导航页码数*/ private int navigatePages; /*所有导航页号*/ private int[] navigatepageNums; /*导航条上的第一页*/ private int navigateFirstPage; /*导航条上的最后一页*/ private int navigateLastPage;  public PageInfo() { }  /** * 包装Page对象 * * @param list */ public PageInfo(List<T> list) { this(list, 8); }  /** * 包装Page对象 * * @param list          page结果 * @param navigatePages 页码数量 */ public PageInfo(List<T> list, int navigatePages) { super(list); if (list instanceof Page) { Page page = (Page) list; this.pageNum = page.getPageNum(); this.pageSize = page.getPageSize();  this.pages = page.getPages(); this.size = page.size(); /*由于结果是>startRow的，所以实际的需要+1*/ if (this.size == 0) { this.startRow = 0; this.endRow = 0; } else { this.startRow = page.getStartRow() + 1; /*计算实际的endRow（最后一页的时候特殊）*/ this.endRow = this.startRow - 1 + this.size; } } else if (list instanceof Collection) { this.pageNum = 1; this.pageSize = list.size();  this.pages = this.pageSize > 0 ? 1 : 0; this.size = list.size(); this.startRow = 0; this.endRow = list.size() > 0 ? list.size() - 1 : 0; } if (list instanceof Collection) { this.navigatePages = navigatePages;
<BUGS> private boolean hasPreviousPage = false; <BUGE> /*是否有下一页*/ private boolean hasNextPage = false; /*导航页码数*/ private int navigatePages; /*所有导航页号*/ private int[] navigatepageNums; /*导航条上的第一页*/ private int navigateFirstPage; /*导航条上的最后一页*/ private int navigateLastPage;  public PageInfo() { }  /** * 包装Page对象 * * @param list */ public PageInfo(List<T> list) { this(list, 8); }  /** * 包装Page对象 * * @param list          page结果 * @param navigatePages 页码数量 */ public PageInfo(List<T> list, int navigatePages) { super(list); if (list instanceof Page) { Page page = (Page) list; this.pageNum = page.getPageNum(); this.pageSize = page.getPageSize();  this.pages = page.getPages(); this.size = page.size(); /*由于结果是>startRow的，所以实际的需要+1*/ if (this.size == 0) { this.startRow = 0; this.endRow = 0; } else { this.startRow = page.getStartRow() + 1; /*计算实际的endRow（最后一页的时候特殊）*/ this.endRow = this.startRow - 1 + this.size; } } else if (list instanceof Collection) { this.pageNum = 1; this.pageSize = list.size();  this.pages = this.pageSize > 0 ? 1 : 0; this.size = list.size(); this.startRow = 0; this.endRow = list.size() > 0 ? list.size() - 1 : 0; } if (list instanceof Collection) { this.navigatePages = navigatePages;
<BUGS> private boolean hasNextPage = false; <BUGE> /*导航页码数*/ private int navigatePages; /*所有导航页号*/ private int[] navigatepageNums; /*导航条上的第一页*/ private int navigateFirstPage; /*导航条上的最后一页*/ private int navigateLastPage;  public PageInfo() { }  /** * 包装Page对象 * * @param list */ public PageInfo(List<T> list) { this(list, 8); }  /** * 包装Page对象 * * @param list          page结果 * @param navigatePages 页码数量 */ public PageInfo(List<T> list, int navigatePages) { super(list); if (list instanceof Page) { Page page = (Page) list; this.pageNum = page.getPageNum(); this.pageSize = page.getPageSize();  this.pages = page.getPages(); this.size = page.size(); /*由于结果是>startRow的，所以实际的需要+1*/ if (this.size == 0) { this.startRow = 0; this.endRow = 0; } else { this.startRow = page.getStartRow() + 1; /*计算实际的endRow（最后一页的时候特殊）*/ this.endRow = this.startRow - 1 + this.size; } } else if (list instanceof Collection) { this.pageNum = 1; this.pageSize = list.size();  this.pages = this.pageSize > 0 ? 1 : 0; this.size = list.size(); this.startRow = 0; this.endRow = list.size() > 0 ? list.size() - 1 : 0; } if (list instanceof Collection) { this.navigatePages = navigatePages;
*/ public PageInfo(List<T> list, int navigatePages) { <BUGS> super(list); if (list instanceof Page) { Page page = (Page) list; this.pageNum = page.getPageNum(); this.pageSize = page.getPageSize(); <BUGE>  this.pages = page.getPages(); this.size = page.size(); /*由于结果是>startRow的，所以实际的需要+1*/ if (this.size == 0) { this.startRow = 0; this.endRow = 0; } else { this.startRow = page.getStartRow() + 1; /*计算实际的endRow（最后一页的时候特殊）*/ this.endRow = this.startRow - 1 + this.size; } } else if (list instanceof Collection) { this.pageNum = 1; this.pageSize = list.size();  this.pages = this.pageSize > 0 ? 1 : 0; this.size = list.size(); this.startRow = 0; this.endRow = list.size() > 0 ? list.size() - 1 : 0; } if (list instanceof Collection) { this.navigatePages = navigatePages;
*/ public PageInfo(List<T> list, int navigatePages) { super(list); if (list instanceof Page) { Page page = (Page) list; this.pageNum = page.getPageNum(); this.pageSize = page.getPageSize();  <BUGS> this.pages = page.getPages(); this.size = page.size(); <BUGE> /*由于结果是>startRow的，所以实际的需要+1*/ if (this.size == 0) { this.startRow = 0; this.endRow = 0; } else { this.startRow = page.getStartRow() + 1; /*计算实际的endRow（最后一页的时候特殊）*/ this.endRow = this.startRow - 1 + this.size; } } else if (list instanceof Collection) { this.pageNum = 1; this.pageSize = list.size();  this.pages = this.pageSize > 0 ? 1 : 0; this.size = list.size(); this.startRow = 0; this.endRow = list.size() > 0 ? list.size() - 1 : 0; } if (list instanceof Collection) { this.navigatePages = navigatePages;
*/ public PageInfo(List<T> list, int navigatePages) { super(list); if (list instanceof Page) { Page page = (Page) list; this.pageNum = page.getPageNum(); this.pageSize = page.getPageSize();  this.pages = page.getPages(); this.size = page.size(); /*由于结果是>startRow的，所以实际的需要+1*/ <BUGS> if (this.size == 0) { this.startRow = 0; this.endRow = 0; <BUGE> } else { this.startRow = page.getStartRow() + 1; /*计算实际的endRow（最后一页的时候特殊）*/ this.endRow = this.startRow - 1 + this.size; } } else if (list instanceof Collection) { this.pageNum = 1; this.pageSize = list.size();  this.pages = this.pageSize > 0 ? 1 : 0; this.size = list.size(); this.startRow = 0; this.endRow = list.size() > 0 ? list.size() - 1 : 0; } if (list instanceof Collection) { this.navigatePages = navigatePages;
*/ public PageInfo(List<T> list, int navigatePages) { super(list); if (list instanceof Page) { Page page = (Page) list; this.pageNum = page.getPageNum(); this.pageSize = page.getPageSize();  this.pages = page.getPages(); this.size = page.size(); /*由于结果是>startRow的，所以实际的需要+1*/ if (this.size == 0) { this.startRow = 0; this.endRow = 0; } else { <BUGS> this.startRow = page.getStartRow() + 1; <BUGE> /*计算实际的endRow（最后一页的时候特殊）*/ this.endRow = this.startRow - 1 + this.size; } } else if (list instanceof Collection) { this.pageNum = 1; this.pageSize = list.size();  this.pages = this.pageSize > 0 ? 1 : 0; this.size = list.size(); this.startRow = 0; this.endRow = list.size() > 0 ? list.size() - 1 : 0; } if (list instanceof Collection) { this.navigatePages = navigatePages;
*/ public PageInfo(List<T> list, int navigatePages) { super(list); if (list instanceof Page) { Page page = (Page) list; this.pageNum = page.getPageNum(); this.pageSize = page.getPageSize();  this.pages = page.getPages(); this.size = page.size(); /*由于结果是>startRow的，所以实际的需要+1*/ if (this.size == 0) { this.startRow = 0; this.endRow = 0; } else { this.startRow = page.getStartRow() + 1; /*计算实际的endRow（最后一页的时候特殊）*/ <BUGS> this.endRow = this.startRow - 1 + this.size; <BUGE> } } else if (list instanceof Collection) { this.pageNum = 1; this.pageSize = list.size();  this.pages = this.pageSize > 0 ? 1 : 0; this.size = list.size(); this.startRow = 0; this.endRow = list.size() > 0 ? list.size() - 1 : 0; } if (list instanceof Collection) { this.navigatePages = navigatePages;
*/ public PageInfo(List<T> list, int navigatePages) { super(list); if (list instanceof Page) { Page page = (Page) list; this.pageNum = page.getPageNum(); this.pageSize = page.getPageSize();  this.pages = page.getPages(); this.size = page.size(); /*由于结果是>startRow的，所以实际的需要+1*/ if (this.size == 0) { this.startRow = 0; this.endRow = 0; } else { this.startRow = page.getStartRow() + 1; /*计算实际的endRow（最后一页的时候特殊）*/ this.endRow = this.startRow - 1 + this.size; } <BUGS> } else if (list instanceof Collection) { <BUGE> this.pageNum = 1; this.pageSize = list.size();  this.pages = this.pageSize > 0 ? 1 : 0; this.size = list.size(); this.startRow = 0; this.endRow = list.size() > 0 ? list.size() - 1 : 0; } if (list instanceof Collection) { this.navigatePages = navigatePages;
*/ public PageInfo(List<T> list, int navigatePages) { super(list); if (list instanceof Page) { Page page = (Page) list; this.pageNum = page.getPageNum(); this.pageSize = page.getPageSize();  this.pages = page.getPages(); this.size = page.size(); /*由于结果是>startRow的，所以实际的需要+1*/ if (this.size == 0) { this.startRow = 0; this.endRow = 0; } else { this.startRow = page.getStartRow() + 1; /*计算实际的endRow（最后一页的时候特殊）*/ this.endRow = this.startRow - 1 + this.size; } } else if (list instanceof Collection) { this.pageNum = 1; this.pageSize = list.size();  this.pages = this.pageSize > 0 ? 1 : 0; this.size = list.size(); this.startRow = 0; this.endRow = list.size() > 0 ? list.size() - 1 : 0; } <BUGS> if (list instanceof Collection) { this.navigatePages = navigatePages; <BUGE>
/** * 包装Page对象 * * @param list */ public PageInfo(List<T> list) { this(list, 8); }  /** * 包装Page对象 * * @param list          page结果 * @param navigatePages 页码数量 /*计算导航页*/ <BUGS> calcNavigatepageNums(); <BUGE> /*计算前后页，第一页，最后一页*/ calcPage(); /*判断页面边界*/ judgePageBoudary(); } }  public static <T> PageInfo<T> of(List<T> list) { return new PageInfo<T>(list); }  public static <T> PageInfo<T> of(List<T> list, int navigatePages) { return new PageInfo<T>(list, navigatePages); }
/** * 包装Page对象 * * @param list */ public PageInfo(List<T> list) { this(list, 8); }  /** * 包装Page对象 * * @param list          page结果 * @param navigatePages 页码数量 /*计算前后页，第一页，最后一页*/ <BUGS> calcPage(); <BUGE> /*判断页面边界*/ judgePageBoudary(); } }  public static <T> PageInfo<T> of(List<T> list) { return new PageInfo<T>(list); }  public static <T> PageInfo<T> of(List<T> list, int navigatePages) { return new PageInfo<T>(list, navigatePages); }  /**
/** * 包装Page对象 * * @param list */ public PageInfo(List<T> list) { this(list, 8); }  /** * 包装Page对象 * * @param list          page结果 * @param navigatePages 页码数量 /*判断页面边界*/ <BUGS> judgePageBoudary(); <BUGE> } }  public static <T> PageInfo<T> of(List<T> list) { return new PageInfo<T>(list); }  public static <T> PageInfo<T> of(List<T> list, int navigatePages) { return new PageInfo<T>(list, navigatePages); }  /** * 计算导航页 */
/** * 包装Page对象 * * @param list */ public PageInfo(List<T> list) { this(list, 8); }  /** * 包装Page对象 * * @param list          page结果 * @param navigatePages 页码数量 } <BUGS> } <BUGE>  public static <T> PageInfo<T> of(List<T> list) { return new PageInfo<T>(list); }  public static <T> PageInfo<T> of(List<T> list, int navigatePages) { return new PageInfo<T>(list, navigatePages); }  /** * 计算导航页 */ private void calcNavigatepageNums() { /*当总页数小于或等于导航页码数时*/
@Override public boolean beforePage(MappedStatement ms, Object parameterObject, RowBounds rowBounds) { <BUGS> Page page = getLocalPage(); if (page.isOrderByOnly() || page.getPageSize() > 0) { <BUGE> return true; } return false; }
@Override public boolean beforePage(MappedStatement ms, Object parameterObject, RowBounds rowBounds) { Page page = getLocalPage(); if (page.isOrderByOnly() || page.getPageSize() > 0) { return true; } <BUGS> return false; <BUGE> }
@Override public boolean exists(final String pathName) {  <BUGS> final Path path = Paths.get(basePath, pathName); return Files.exists(path) && Files.isDirectory(path); <BUGE> }
*/ protected String getUrl(final Repository repository, final String jenkinsBase, final String cloneType, final String customCloneUrl, final String strRef, final String strSha1, boolean omitHashCode, boolean omitBranchName) { <BUGS> String cloneUrl = customCloneUrl; <BUGE> /* Older installs won't have a cloneType value - treat as custom*/ if (cloneType != null && !cloneType.equals("custom")) { if (cloneType.equals("http")) { cloneUrl = httpScmProtocol.getCloneUrl(repository, null); } else if (cloneType.equals("ssh")) { /* The user just pushed to the repo, so must have had access*/ cloneUrl = securityService.withPermission(Permission.REPO_READ, "Retrieving SSH clone url") .call(() -> scmProtocol.getCloneUrl(repository, null)); } else { LOGGER.error("Unknown cloneType: {}", cloneType); throw new RuntimeException("Unknown cloneType: " + cloneType); } }  StringBuilder url = new StringBuilder(); url.append(String.format(BASE_URL, jenkinsBase, urlEncode(cloneUrl)));  if(strRef != null && !omitBranchName) url.append(String.format(BRANCH_URL_PARAMETER, urlEncode(strRef))); if(!omitHashCode) url.append(String.format(HASH_URL_PARAMETER, strSha1));  return url.toString(); }
*/ protected String getUrl(final Repository repository, final String jenkinsBase, final String cloneType, final String customCloneUrl, final String strRef, final String strSha1, boolean omitHashCode, boolean omitBranchName) { String cloneUrl = customCloneUrl; /* Older installs won't have a cloneType value - treat as custom*/ <BUGS> if (cloneType != null && !cloneType.equals("custom")) { if (cloneType.equals("http")) { cloneUrl = httpScmProtocol.getCloneUrl(repository, null); <BUGE> } else if (cloneType.equals("ssh")) { /* The user just pushed to the repo, so must have had access*/ cloneUrl = securityService.withPermission(Permission.REPO_READ, "Retrieving SSH clone url") .call(() -> scmProtocol.getCloneUrl(repository, null)); } else { LOGGER.error("Unknown cloneType: {}", cloneType); throw new RuntimeException("Unknown cloneType: " + cloneType); } }  StringBuilder url = new StringBuilder(); url.append(String.format(BASE_URL, jenkinsBase, urlEncode(cloneUrl)));  if(strRef != null && !omitBranchName) url.append(String.format(BRANCH_URL_PARAMETER, urlEncode(strRef))); if(!omitHashCode) url.append(String.format(HASH_URL_PARAMETER, strSha1));  return url.toString(); }
*/ protected String getUrl(final Repository repository, final String jenkinsBase, final String cloneType, final String customCloneUrl, final String strRef, final String strSha1, boolean omitHashCode, boolean omitBranchName) { String cloneUrl = customCloneUrl; /* Older installs won't have a cloneType value - treat as custom*/ if (cloneType != null && !cloneType.equals("custom")) { if (cloneType.equals("http")) { cloneUrl = httpScmProtocol.getCloneUrl(repository, null); } else if (cloneType.equals("ssh")) { /* The user just pushed to the repo, so must have had access*/ cloneUrl = securityService.withPermission(Permission.REPO_READ, "Retrieving SSH clone url") .call(() -> scmProtocol.getCloneUrl(repository, null)); } else { LOGGER.error("Unknown cloneType: {}", cloneType); throw new RuntimeException("Unknown cloneType: " + cloneType); } }  <BUGS> StringBuilder url = new StringBuilder(); url.append(String.format(BASE_URL, jenkinsBase, urlEncode(cloneUrl))); <BUGE>  if(strRef != null && !omitBranchName) url.append(String.format(BRANCH_URL_PARAMETER, urlEncode(strRef))); if(!omitHashCode) url.append(String.format(HASH_URL_PARAMETER, strSha1));  return url.toString(); }
*/ protected String getUrl(final Repository repository, final String jenkinsBase, final String cloneType, final String customCloneUrl, final String strRef, final String strSha1, boolean omitHashCode, boolean omitBranchName) { String cloneUrl = customCloneUrl; /* Older installs won't have a cloneType value - treat as custom*/ if (cloneType != null && !cloneType.equals("custom")) { if (cloneType.equals("http")) { cloneUrl = httpScmProtocol.getCloneUrl(repository, null); } else if (cloneType.equals("ssh")) { /* The user just pushed to the repo, so must have had access*/ cloneUrl = securityService.withPermission(Permission.REPO_READ, "Retrieving SSH clone url") .call(() -> scmProtocol.getCloneUrl(repository, null)); } else { LOGGER.error("Unknown cloneType: {}", cloneType); throw new RuntimeException("Unknown cloneType: " + cloneType); } }  StringBuilder url = new StringBuilder(); url.append(String.format(BASE_URL, jenkinsBase, urlEncode(cloneUrl)));  <BUGS> if(strRef != null && !omitBranchName) url.append(String.format(BRANCH_URL_PARAMETER, urlEncode(strRef))); if(!omitHashCode) url.append(String.format(HASH_URL_PARAMETER, strSha1)); <BUGE>  return url.toString(); }
*/ protected String getUrl(final Repository repository, final String jenkinsBase, final String cloneType, final String customCloneUrl, final String strRef, final String strSha1, boolean omitHashCode, boolean omitBranchName) { String cloneUrl = customCloneUrl; /* Older installs won't have a cloneType value - treat as custom*/ if (cloneType != null && !cloneType.equals("custom")) { if (cloneType.equals("http")) { cloneUrl = httpScmProtocol.getCloneUrl(repository, null); } else if (cloneType.equals("ssh")) { /* The user just pushed to the repo, so must have had access*/ cloneUrl = securityService.withPermission(Permission.REPO_READ, "Retrieving SSH clone url") .call(() -> scmProtocol.getCloneUrl(repository, null)); } else { LOGGER.error("Unknown cloneType: {}", cloneType); throw new RuntimeException("Unknown cloneType: " + cloneType); } }  StringBuilder url = new StringBuilder(); url.append(String.format(BASE_URL, jenkinsBase, urlEncode(cloneUrl)));  if(strRef != null && !omitBranchName) url.append(String.format(BRANCH_URL_PARAMETER, urlEncode(strRef))); if(!omitHashCode) url.append(String.format(HASH_URL_PARAMETER, strSha1));  <BUGS> return url.toString(); <BUGE> }
*/ public Collection<Integer> search(String word, int results) { <BUGS> Node tmpNode = searchNode(word); if (tmpNode == null) { return null; <BUGE> } return tmpNode.getData(results); }
*/ public Collection<Integer> search(String word, int results) { Node tmpNode = searchNode(word); if (tmpNode == null) { return null; } <BUGS> return tmpNode.getData(results); <BUGE> }
@Override public final double[] getElements() { <BUGS> return toDoubleArray(); <BUGE> }
public static Matrix createRandom(int rows, int cols) { <BUGS> Matrix m = create(rows, cols); double[] d = m.data; for (int i = 0; i < d.length; i++) { d[i] = Math.random(); <BUGE> } return m; }
public static Matrix createRandom(int rows, int cols) { Matrix m = create(rows, cols); double[] d = m.data; for (int i = 0; i < d.length; i++) { d[i] = Math.random(); } <BUGS> return m; <BUGE> }
@Override public void add(ASparseVector v) { <BUGS> includeIndices(v); for (int i=0; i<data.length; i++) { data[i]+=v.unsafeGet(index.get(i)); <BUGE> } }
@Override public void add(ASparseVector v) { includeIndices(v); for (int i=0; i<data.length; i++) { data[i]+=v.unsafeGet(index.get(i)); } <BUGS> } <BUGE>
public static int indexPosition(int[] data, int x, int min, int max) { <BUGS> if ((max-min)>20) { return indexPositionBig(data,x,0,max); <BUGE> } else { return indexPositionSmall(data,x, 0, max); } }
*/ public void setColumn(int i, AVector col) { <BUGS> getColumnView(i).set(col); } <BUGE>
public static ZeroVector create(int dimensions) { <BUGS> return new ZeroVector(dimensions); <BUGE> }
*/ public static List<String> parse(Object target, String[] args) { <BUGS> List<String> arguments = new ArrayList<String>(); arguments.addAll(Arrays.asList(args)); <BUGE> Class<?> clazz; if (target instanceof Class) { clazz = (Class) target; } else { clazz = target.getClass(); try { BeanInfo info = Introspector.getBeanInfo(clazz); for (PropertyDescriptor pd : info.getPropertyDescriptors()) { processProperty(target, pd, arguments); } } catch (IntrospectionException e) { /* If its not a JavaBean we ignore it*/ } }  /* Check fields of 'target' class and its superclasses*/ for (Field field : clazz.getDeclaredFields()) { processField(target, field, arguments); }  for (String argument : arguments) { if (argument.startsWith("-")) { throw new IllegalArgumentException("Invalid argument: " + argument); } } return arguments;
*/ public static List<String> parse(Object target, String[] args) { List<String> arguments = new ArrayList<String>(); arguments.addAll(Arrays.asList(args)); Class<?> clazz; <BUGS> if (target instanceof Class) { <BUGE> clazz = (Class) target; } else { clazz = target.getClass(); try { BeanInfo info = Introspector.getBeanInfo(clazz); for (PropertyDescriptor pd : info.getPropertyDescriptors()) { processProperty(target, pd, arguments); } } catch (IntrospectionException e) { /* If its not a JavaBean we ignore it*/ } }  /* Check fields of 'target' class and its superclasses*/ for (Field field : clazz.getDeclaredFields()) { processField(target, field, arguments); }  for (String argument : arguments) { if (argument.startsWith("-")) { throw new IllegalArgumentException("Invalid argument: " + argument); } } return arguments;
*/ public static List<String> parse(Object target, String[] args) { List<String> arguments = new ArrayList<String>(); arguments.addAll(Arrays.asList(args)); Class<?> clazz; if (target instanceof Class) { clazz = (Class) target; } else { <BUGS> clazz = target.getClass(); <BUGE> try { BeanInfo info = Introspector.getBeanInfo(clazz); for (PropertyDescriptor pd : info.getPropertyDescriptors()) { processProperty(target, pd, arguments); } } catch (IntrospectionException e) { /* If its not a JavaBean we ignore it*/ } }  /* Check fields of 'target' class and its superclasses*/ for (Field field : clazz.getDeclaredFields()) { processField(target, field, arguments); }  for (String argument : arguments) { if (argument.startsWith("-")) { throw new IllegalArgumentException("Invalid argument: " + argument); } } return arguments;
*/ public static List<String> parse(Object target, String[] args) { List<String> arguments = new ArrayList<String>(); arguments.addAll(Arrays.asList(args)); Class<?> clazz; if (target instanceof Class) { clazz = (Class) target; } else { clazz = target.getClass(); try { <BUGS> BeanInfo info = Introspector.getBeanInfo(clazz); for (PropertyDescriptor pd : info.getPropertyDescriptors()) { processProperty(target, pd, arguments); <BUGE> } } catch (IntrospectionException e) { /* If its not a JavaBean we ignore it*/ } }  /* Check fields of 'target' class and its superclasses*/ for (Field field : clazz.getDeclaredFields()) { processField(target, field, arguments); }  for (String argument : arguments) { if (argument.startsWith("-")) { throw new IllegalArgumentException("Invalid argument: " + argument); } } return arguments;
*/ public static List<String> parse(Object target, String[] args) { List<String> arguments = new ArrayList<String>(); arguments.addAll(Arrays.asList(args)); Class<?> clazz; if (target instanceof Class) { clazz = (Class) target; } else { clazz = target.getClass(); try { BeanInfo info = Introspector.getBeanInfo(clazz); for (PropertyDescriptor pd : info.getPropertyDescriptors()) { processProperty(target, pd, arguments); } } catch (IntrospectionException e) { /* If its not a JavaBean we ignore it*/ <BUGS> } <BUGE> }  /* Check fields of 'target' class and its superclasses*/ for (Field field : clazz.getDeclaredFields()) { processField(target, field, arguments); }  for (String argument : arguments) { if (argument.startsWith("-")) { throw new IllegalArgumentException("Invalid argument: " + argument); } } return arguments;
*/ public static List<String> parse(Object target, String[] args) { List<String> arguments = new ArrayList<String>(); arguments.addAll(Arrays.asList(args)); Class<?> clazz; if (target instanceof Class) { clazz = (Class) target; } else { clazz = target.getClass(); try { BeanInfo info = Introspector.getBeanInfo(clazz); for (PropertyDescriptor pd : info.getPropertyDescriptors()) { processProperty(target, pd, arguments); } } catch (IntrospectionException e) { /* If its not a JavaBean we ignore it*/ } }  /* Check fields of 'target' class and its superclasses*/ <BUGS> for (Field field : clazz.getDeclaredFields()) { processField(target, field, arguments); <BUGE> }  for (String argument : arguments) { if (argument.startsWith("-")) { throw new IllegalArgumentException("Invalid argument: " + argument); } } return arguments;
*/ public static List<String> parse(Object target, String[] args) { List<String> arguments = new ArrayList<String>(); arguments.addAll(Arrays.asList(args)); Class<?> clazz; if (target instanceof Class) { clazz = (Class) target; } else { clazz = target.getClass(); try { BeanInfo info = Introspector.getBeanInfo(clazz); for (PropertyDescriptor pd : info.getPropertyDescriptors()) { processProperty(target, pd, arguments); } } catch (IntrospectionException e) { /* If its not a JavaBean we ignore it*/ } }  /* Check fields of 'target' class and its superclasses*/ for (Field field : clazz.getDeclaredFields()) { processField(target, field, arguments); }  <BUGS> for (String argument : arguments) { if (argument.startsWith("-")) { throw new IllegalArgumentException("Invalid argument: " + argument); <BUGE> } } return arguments;
protected static SimulationParser getVersionSpecificParser(File file, Float apdexT) throws IOException { <BUGS> List<String> header = getHeaderLine(file); <BUGE> /* System.out.println(header.size() + " " + header);*/ if (header.size() == 6) { String version = header.get(5); if (version.startsWith("3.2")) { return new SimulationParserV32(file, apdexT); } if (version.startsWith("3.0")) { return new SimulationParserV3(file, apdexT); } if (version.startsWith("2.")) { return new SimulationParserV2(file, apdexT); } } else if (header.size() == 7) { String version = header.get(6); if (version.startsWith("2.")) { return new SimulationParserV23(file, apdexT); } } throw new IllegalArgumentException("Unknown Gatling simulation version: " + header); }
protected static SimulationParser getVersionSpecificParser(File file, Float apdexT) throws IOException { List<String> header = getHeaderLine(file); /* System.out.println(header.size() + " " + header);*/ <BUGS> if (header.size() == 6) { String version = header.get(5); if (version.startsWith("3.2")) { <BUGE> return new SimulationParserV32(file, apdexT); } if (version.startsWith("3.0")) { return new SimulationParserV3(file, apdexT); } if (version.startsWith("2.")) { return new SimulationParserV2(file, apdexT); } } else if (header.size() == 7) { String version = header.get(6); if (version.startsWith("2.")) { return new SimulationParserV23(file, apdexT); } } throw new IllegalArgumentException("Unknown Gatling simulation version: " + header); }
protected static SimulationParser getVersionSpecificParser(File file, Float apdexT) throws IOException { List<String> header = getHeaderLine(file); /* System.out.println(header.size() + " " + header);*/ if (header.size() == 6) { String version = header.get(5); if (version.startsWith("3.2")) { return new SimulationParserV32(file, apdexT); } <BUGS> if (version.startsWith("3.0")) { return new SimulationParserV3(file, apdexT); <BUGE> } if (version.startsWith("2.")) { return new SimulationParserV2(file, apdexT); } } else if (header.size() == 7) { String version = header.get(6); if (version.startsWith("2.")) { return new SimulationParserV23(file, apdexT); } } throw new IllegalArgumentException("Unknown Gatling simulation version: " + header); }
@Override public List<String> readNext() throws IOException { <BUGS> List<String> ret = super.readNext(); if (ret != null && !ret.isEmpty() && ret.get(0).toLowerCase().startsWith(ASSERTION)) { return readNext(); <BUGE> } return ret; }
@Override public List<String> readNext() throws IOException { List<String> ret = super.readNext(); if (ret != null && !ret.isEmpty() && ret.get(0).toLowerCase().startsWith(ASSERTION)) { return readNext(); } <BUGS> return ret; <BUGE> }
protected static SimulationParser getVersionSpecificParser(File file, Float apdexT) throws IOException { <BUGS> List<String> header = getHeaderLine(file); if (header.size() == 6) { String version = header.get(5); if (version.matches("3\\.[2-3].*")) { <BUGE> return new SimulationParserV32(file, apdexT); } if (version.startsWith("3.4")) { return new SimulationParserV34(file, apdexT); } if (version.startsWith("3.0")) { return new SimulationParserV3(file, apdexT); } if (version.startsWith("2.")) { return new SimulationParserV2(file, apdexT); } } else if (header.size() == 7) { String version = header.get(6); if (version.startsWith("2.")) { return new SimulationParserV23(file, apdexT); } } throw new IllegalArgumentException("Unknown Gatling simulation version: " + header); }
protected static SimulationParser getVersionSpecificParser(File file, Float apdexT) throws IOException { List<String> header = getHeaderLine(file); if (header.size() == 6) { String version = header.get(5); if (version.matches("3\\.[2-3].*")) { return new SimulationParserV32(file, apdexT); } <BUGS> if (version.startsWith("3.4")) { <BUGE> return new SimulationParserV34(file, apdexT); } if (version.startsWith("3.0")) { return new SimulationParserV3(file, apdexT); } if (version.startsWith("2.")) { return new SimulationParserV2(file, apdexT); } } else if (header.size() == 7) { String version = header.get(6); if (version.startsWith("2.")) { return new SimulationParserV23(file, apdexT); } } throw new IllegalArgumentException("Unknown Gatling simulation version: " + header); }
protected static SimulationParser getVersionSpecificParser(File file, Float apdexT) throws IOException { List<String> header = getHeaderLine(file); if (header.size() == 6) { String version = header.get(5); if (version.matches("3\\.[2-3].*")) { return new SimulationParserV32(file, apdexT); } if (version.startsWith("3.4")) { return new SimulationParserV34(file, apdexT); } <BUGS> if (version.startsWith("3.0")) { <BUGE> return new SimulationParserV3(file, apdexT); } if (version.startsWith("2.")) { return new SimulationParserV2(file, apdexT); } } else if (header.size() == 7) { String version = header.get(6); if (version.startsWith("2.")) { return new SimulationParserV23(file, apdexT); } } throw new IllegalArgumentException("Unknown Gatling simulation version: " + header); }
protected static SimulationParser getVersionSpecificParser(File file, Float apdexT) throws IOException { List<String> header = getHeaderLine(file); if (header.size() == 6) { String version = header.get(5); if (version.matches("3\\.[2-3].*")) { return new SimulationParserV32(file, apdexT); } if (version.startsWith("3.4")) { return new SimulationParserV34(file, apdexT); } if (version.startsWith("3.0")) { return new SimulationParserV3(file, apdexT); } <BUGS> if (version.startsWith("2.")) { <BUGE> return new SimulationParserV2(file, apdexT); } } else if (header.size() == 7) { String version = header.get(6); if (version.startsWith("2.")) { return new SimulationParserV23(file, apdexT); } } throw new IllegalArgumentException("Unknown Gatling simulation version: " + header); }
protected static SimulationParser getVersionSpecificParser(File file, Float apdexT) throws IOException { List<String> header = getHeaderLine(file); if (header.size() == 6) { String version = header.get(5); if (version.matches("3\\.[2-3].*")) { return new SimulationParserV32(file, apdexT); } if (version.startsWith("3.4")) { return new SimulationParserV34(file, apdexT); } if (version.startsWith("3.0")) { return new SimulationParserV3(file, apdexT); } if (version.startsWith("2.")) { return new SimulationParserV2(file, apdexT); } <BUGS> } else if (header.size() == 7) { <BUGE> String version = header.get(6); if (version.startsWith("2.")) { return new SimulationParserV23(file, apdexT); } } throw new IllegalArgumentException("Unknown Gatling simulation version: " + header); }
protected static SimulationParser getVersionSpecificParser(File file, Float apdexT) throws IOException { List<String> header = getHeaderLine(file); if (header.size() == 6) { String version = header.get(5); if (version.matches("3\\.[2-3].*")) { return new SimulationParserV32(file, apdexT); } if (version.startsWith("3.4")) { return new SimulationParserV34(file, apdexT); } if (version.startsWith("3.0")) { return new SimulationParserV3(file, apdexT); } if (version.startsWith("2.")) { return new SimulationParserV2(file, apdexT); } } else if (header.size() == 7) { String version = header.get(6); if (version.startsWith("2.")) { return new SimulationParserV23(file, apdexT); } } <BUGS> throw new IllegalArgumentException("Unknown Gatling simulation version: " + header); <BUGE> }
*/ public static String formatValue(long nano, boolean withUnit) { <BUGS> return formatNumber(nano / (double) Unit.SEM, 3) + (withUnit ? " SEM" : ""); <BUGE> }
*/ public static GregorianCalendar[] calculateSunriseTransitSet(final GregorianCalendar day, final double latitude, final double longitude, final double deltaT) { <BUGS> final GregorianCalendar dayStart = startOfDayUT(day); final JulianDate jd = new JulianDate(dayStart, 0); <BUGE>  final double phi = toRadians(latitude);  /* A.2.1. Calculate the apparent sidereal time at Greenwich at 0 UT, nu (in degrees)*/ final double jce = jd.getJulianEphemerisCentury(); final double xTerms[] = calculateNutationTerms(jce); final double[] deltaPsiI = calculateDeltaPsiI(jce, xTerms); final double[] deltaEpsilonI = calculateDeltaEpsilonI(jce, xTerms); final double deltaPsi = calculateDeltaPsiEpsilon(deltaPsiI); final double deltaEpsilon = calculateDeltaPsiEpsilon(deltaEpsilonI); final double epsilonDegrees = calculateTrueObliquityOfEcliptic(jd, deltaEpsilon);  final double nuDegrees = calculateApparentSiderealTimeAtGreenwich(jd, deltaPsi, epsilonDegrees);  /* A.2.2. Calculate the geocentric right ascension and declination at 0 TT for day before, same day, next day*/ final AlphaDelta[] alphaDeltas = new AlphaDelta[3]; for (int i = 0; i < alphaDeltas.length; i++) { JulianDate currentJd = new JulianDate(jd.getJulianDate() + i - 1, 0); double currentJme = currentJd.getJulianEphemerisMillennium(); AlphaDelta ad = calculateAlphaDelta(currentJme, deltaPsi, epsilonDegrees); alphaDeltas[i] = ad; }
*/ public static GregorianCalendar[] calculateSunriseTransitSet(final GregorianCalendar day, final double latitude, final double longitude, final double deltaT) { final GregorianCalendar dayStart = startOfDayUT(day); final JulianDate jd = new JulianDate(dayStart, 0);  <BUGS> final double phi = toRadians(latitude); <BUGE>  /* A.2.1. Calculate the apparent sidereal time at Greenwich at 0 UT, nu (in degrees)*/ final double jce = jd.getJulianEphemerisCentury(); final double xTerms[] = calculateNutationTerms(jce); final double[] deltaPsiI = calculateDeltaPsiI(jce, xTerms); final double[] deltaEpsilonI = calculateDeltaEpsilonI(jce, xTerms); final double deltaPsi = calculateDeltaPsiEpsilon(deltaPsiI); final double deltaEpsilon = calculateDeltaPsiEpsilon(deltaEpsilonI); final double epsilonDegrees = calculateTrueObliquityOfEcliptic(jd, deltaEpsilon);  final double nuDegrees = calculateApparentSiderealTimeAtGreenwich(jd, deltaPsi, epsilonDegrees);  /* A.2.2. Calculate the geocentric right ascension and declination at 0 TT for day before, same day, next day*/ final AlphaDelta[] alphaDeltas = new AlphaDelta[3]; for (int i = 0; i < alphaDeltas.length; i++) { JulianDate currentJd = new JulianDate(jd.getJulianDate() + i - 1, 0); double currentJme = currentJd.getJulianEphemerisMillennium(); AlphaDelta ad = calculateAlphaDelta(currentJme, deltaPsi, epsilonDegrees); alphaDeltas[i] = ad; }
*/ public static GregorianCalendar[] calculateSunriseTransitSet(final GregorianCalendar day, final double latitude, final double longitude, final double deltaT) { final GregorianCalendar dayStart = startOfDayUT(day); final JulianDate jd = new JulianDate(dayStart, 0);  final double phi = toRadians(latitude);  /* A.2.1. Calculate the apparent sidereal time at Greenwich at 0 UT, nu (in degrees)*/ <BUGS> final double jce = jd.getJulianEphemerisCentury(); final double xTerms[] = calculateNutationTerms(jce); final double[] deltaPsiI = calculateDeltaPsiI(jce, xTerms); final double[] deltaEpsilonI = calculateDeltaEpsilonI(jce, xTerms); final double deltaPsi = calculateDeltaPsiEpsilon(deltaPsiI); final double deltaEpsilon = calculateDeltaPsiEpsilon(deltaEpsilonI); final double epsilonDegrees = calculateTrueObliquityOfEcliptic(jd, deltaEpsilon); <BUGE>  final double nuDegrees = calculateApparentSiderealTimeAtGreenwich(jd, deltaPsi, epsilonDegrees);  /* A.2.2. Calculate the geocentric right ascension and declination at 0 TT for day before, same day, next day*/ final AlphaDelta[] alphaDeltas = new AlphaDelta[3]; for (int i = 0; i < alphaDeltas.length; i++) { JulianDate currentJd = new JulianDate(jd.getJulianDate() + i - 1, 0); double currentJme = currentJd.getJulianEphemerisMillennium(); AlphaDelta ad = calculateAlphaDelta(currentJme, deltaPsi, epsilonDegrees); alphaDeltas[i] = ad; }
*/ public static GregorianCalendar[] calculateSunriseTransitSet(final GregorianCalendar day, final double latitude, final double longitude, final double deltaT) { final GregorianCalendar dayStart = startOfDayUT(day); final JulianDate jd = new JulianDate(dayStart, 0);  final double phi = toRadians(latitude);  /* A.2.1. Calculate the apparent sidereal time at Greenwich at 0 UT, nu (in degrees)*/ final double jce = jd.getJulianEphemerisCentury(); final double xTerms[] = calculateNutationTerms(jce); final double[] deltaPsiI = calculateDeltaPsiI(jce, xTerms); final double[] deltaEpsilonI = calculateDeltaEpsilonI(jce, xTerms); final double deltaPsi = calculateDeltaPsiEpsilon(deltaPsiI); final double deltaEpsilon = calculateDeltaPsiEpsilon(deltaEpsilonI); final double epsilonDegrees = calculateTrueObliquityOfEcliptic(jd, deltaEpsilon);  <BUGS> final double nuDegrees = calculateApparentSiderealTimeAtGreenwich(jd, deltaPsi, epsilonDegrees); <BUGE>  /* A.2.2. Calculate the geocentric right ascension and declination at 0 TT for day before, same day, next day*/ final AlphaDelta[] alphaDeltas = new AlphaDelta[3]; for (int i = 0; i < alphaDeltas.length; i++) { JulianDate currentJd = new JulianDate(jd.getJulianDate() + i - 1, 0); double currentJme = currentJd.getJulianEphemerisMillennium(); AlphaDelta ad = calculateAlphaDelta(currentJme, deltaPsi, epsilonDegrees); alphaDeltas[i] = ad; }
*/ public static GregorianCalendar[] calculateSunriseTransitSet(final GregorianCalendar day, final double latitude, final double longitude, final double deltaT) { final GregorianCalendar dayStart = startOfDayUT(day); final JulianDate jd = new JulianDate(dayStart, 0);  final double phi = toRadians(latitude);  /* A.2.1. Calculate the apparent sidereal time at Greenwich at 0 UT, nu (in degrees)*/ final double jce = jd.getJulianEphemerisCentury(); final double xTerms[] = calculateNutationTerms(jce); final double[] deltaPsiI = calculateDeltaPsiI(jce, xTerms); final double[] deltaEpsilonI = calculateDeltaEpsilonI(jce, xTerms); final double deltaPsi = calculateDeltaPsiEpsilon(deltaPsiI); final double deltaEpsilon = calculateDeltaPsiEpsilon(deltaEpsilonI); final double epsilonDegrees = calculateTrueObliquityOfEcliptic(jd, deltaEpsilon);  final double nuDegrees = calculateApparentSiderealTimeAtGreenwich(jd, deltaPsi, epsilonDegrees);  /* A.2.2. Calculate the geocentric right ascension and declination at 0 TT for day before, same day, next day*/ <BUGS> final AlphaDelta[] alphaDeltas = new AlphaDelta[3]; for (int i = 0; i < alphaDeltas.length; i++) { JulianDate currentJd = new JulianDate(jd.getJulianDate() + i - 1, 0); double currentJme = currentJd.getJulianEphemerisMillennium(); AlphaDelta ad = calculateAlphaDelta(currentJme, deltaPsi, epsilonDegrees); alphaDeltas[i] = ad; <BUGE> }
*/ public static GregorianCalendar[] calculateSunriseTransitSet(final GregorianCalendar day, final double latitude, final double longitude, final double deltaT) { final GregorianCalendar dayStart = startOfDayUT(day); final JulianDate jd = new JulianDate(dayStart, 0);  final double phi = toRadians(latitude);  /* A.2.1. Calculate the apparent sidereal time at Greenwich at 0 UT, nu (in degrees)*/ final double jce = jd.getJulianEphemerisCentury(); final double xTerms[] = calculateNutationTerms(jce); final double[] deltaPsiI = calculateDeltaPsiI(jce, xTerms); final double[] deltaEpsilonI = calculateDeltaEpsilonI(jce, xTerms); final double deltaPsi = calculateDeltaPsiEpsilon(deltaPsiI); final double deltaEpsilon = calculateDeltaPsiEpsilon(deltaEpsilonI); final double epsilonDegrees = calculateTrueObliquityOfEcliptic(jd, deltaEpsilon);  final double nuDegrees = calculateApparentSiderealTimeAtGreenwich(jd, deltaPsi, epsilonDegrees);  /* A.2.2. Calculate the geocentric right ascension and declination at 0 TT for day before, same day, next day*/ final AlphaDelta[] alphaDeltas = new AlphaDelta[3]; for (int i = 0; i < alphaDeltas.length; i++) { JulianDate currentJd = new JulianDate(jd.getJulianDate() + i - 1, 0); double currentJme = currentJd.getJulianEphemerisMillennium(); AlphaDelta ad = calculateAlphaDelta(currentJme, deltaPsi, epsilonDegrees); alphaDeltas[i] = ad; }
* Calculate the times of sunrise, sun transit (solar noon), and sunset for a given day. The calculation is based * on the astronomical definition of sunrise and sunset, using a refraction correction of -0.8333°. * * @param day       GregorianCalendar of day for which sunrise/transit/sunset are to be calculated. *                  The time of day (hour, minute, second, millisecond) is ignored. * @param latitude  Observer's latitude, in degrees (negative south of equator). * @param longitude Observer's longitude, in degrees (negative west of Greenwich). * @param deltaT    Difference between earth rotation time and terrestrial time (or Universal Time and Terrestrial Time), *                  in seconds. See *                  <a href ="http://asa.usno.navy.mil/SecK/DeltaT.html">http:/*asa.usno.navy.mil/SecK/DeltaT.html</a>.*/ *                  For the year 2015, a reasonably accurate default would be 68. * @return An array of 3 GregorianCalendar values corresponding to the time of sunrise, sun transit, and sunset, * respectively. Note that the values for sunrise and sunset may be null: in this case, the sun stays above or * below the horizon all day. /* A.2.3. Calculate the approximate sun transit time, m0, in fraction of day*/ <BUGS> m[0] = (alphaDeltas[1].alpha - longitude - nuDegrees) / 360; <BUGE>  /* A.2.4. Calculate the local hour angle H0 corresponding to ...*/ final double acosArg = (SIN_HPRIME_0 - sin(phi * sin(toRadians(alphaDeltas[1].delta)))) / (cos(phi) * cos(toRadians(alphaDeltas[1].delta)));  final boolean noSunriseOrSet = (acosArg < -1.0) || (acosArg > 1.0);  final double h0 = acos(acosArg);  final double h0Degrees = limitTo(toDegrees(h0), 180.0);  /* A.2.5. Calculate the approximate sunrise time, m1, in fraction of day,*/ m[1] = limitTo(m[0] - h0Degrees / 360.0, 1);
* Calculate the times of sunrise, sun transit (solar noon), and sunset for a given day. The calculation is based * on the astronomical definition of sunrise and sunset, using a refraction correction of -0.8333°. * * @param day       GregorianCalendar of day for which sunrise/transit/sunset are to be calculated. *                  The time of day (hour, minute, second, millisecond) is ignored. * @param latitude  Observer's latitude, in degrees (negative south of equator). * @param longitude Observer's longitude, in degrees (negative west of Greenwich). * @param deltaT    Difference between earth rotation time and terrestrial time (or Universal Time and Terrestrial Time), *                  in seconds. See *                  <a href ="http://asa.usno.navy.mil/SecK/DeltaT.html">http:/*asa.usno.navy.mil/SecK/DeltaT.html</a>.*/ *                  For the year 2015, a reasonably accurate default would be 68. * @return An array of 3 GregorianCalendar values corresponding to the time of sunrise, sun transit, and sunset, * respectively. Note that the values for sunrise and sunset may be null: in this case, the sun stays above or * below the horizon all day. /* A.2.4. Calculate the local hour angle H0 corresponding to ...*/ <BUGS> final double acosArg = (SIN_HPRIME_0 - sin(phi * sin(toRadians(alphaDeltas[1].delta)))) / (cos(phi) * cos(toRadians(alphaDeltas[1].delta))); <BUGE>  final boolean noSunriseOrSet = (acosArg < -1.0) || (acosArg > 1.0);  final double h0 = acos(acosArg);  final double h0Degrees = limitTo(toDegrees(h0), 180.0);  /* A.2.5. Calculate the approximate sunrise time, m1, in fraction of day,*/ m[1] = limitTo(m[0] - h0Degrees / 360.0, 1);  /* A.2.6. Calculate the approximate sunset time, m2, in fraction of day,*/ m[2] = limitTo(m[0] + h0Degrees / 360.0, 1);
* Calculate the times of sunrise, sun transit (solar noon), and sunset for a given day. The calculation is based * on the astronomical definition of sunrise and sunset, using a refraction correction of -0.8333°. * * @param day       GregorianCalendar of day for which sunrise/transit/sunset are to be calculated. *                  The time of day (hour, minute, second, millisecond) is ignored. * @param latitude  Observer's latitude, in degrees (negative south of equator). * @param longitude Observer's longitude, in degrees (negative west of Greenwich). * @param deltaT    Difference between earth rotation time and terrestrial time (or Universal Time and Terrestrial Time), *                  in seconds. See *                  <a href ="http://asa.usno.navy.mil/SecK/DeltaT.html">http:/*asa.usno.navy.mil/SecK/DeltaT.html</a>.*/ *                  For the year 2015, a reasonably accurate default would be 68. * @return An array of 3 GregorianCalendar values corresponding to the time of sunrise, sun transit, and sunset, * respectively. Note that the values for sunrise and sunset may be null: in this case, the sun stays above or * below the horizon all day.  <BUGS> final boolean noSunriseOrSet = (acosArg < -1.0) || (acosArg > 1.0); <BUGE>  final double h0 = acos(acosArg);  final double h0Degrees = limitTo(toDegrees(h0), 180.0);  /* A.2.5. Calculate the approximate sunrise time, m1, in fraction of day,*/ m[1] = limitTo(m[0] - h0Degrees / 360.0, 1);  /* A.2.6. Calculate the approximate sunset time, m2, in fraction of day,*/ m[2] = limitTo(m[0] + h0Degrees / 360.0, 1);  m[0] = limitTo(m[0], 1);  /* A.2.8. Calculate the sidereal time at Greenwich, in degrees, for the sun transit, sunrise, and sunset*/
* Calculate the times of sunrise, sun transit (solar noon), and sunset for a given day. The calculation is based * on the astronomical definition of sunrise and sunset, using a refraction correction of -0.8333°. * * @param day       GregorianCalendar of day for which sunrise/transit/sunset are to be calculated. *                  The time of day (hour, minute, second, millisecond) is ignored. * @param latitude  Observer's latitude, in degrees (negative south of equator). * @param longitude Observer's longitude, in degrees (negative west of Greenwich). * @param deltaT    Difference between earth rotation time and terrestrial time (or Universal Time and Terrestrial Time), *                  in seconds. See *                  <a href ="http://asa.usno.navy.mil/SecK/DeltaT.html">http:/*asa.usno.navy.mil/SecK/DeltaT.html</a>.*/ *                  For the year 2015, a reasonably accurate default would be 68. * @return An array of 3 GregorianCalendar values corresponding to the time of sunrise, sun transit, and sunset, * respectively. Note that the values for sunrise and sunset may be null: in this case, the sun stays above or * below the horizon all day.  <BUGS> final double h0 = acos(acosArg); <BUGE>  final double h0Degrees = limitTo(toDegrees(h0), 180.0);  /* A.2.5. Calculate the approximate sunrise time, m1, in fraction of day,*/ m[1] = limitTo(m[0] - h0Degrees / 360.0, 1);  /* A.2.6. Calculate the approximate sunset time, m2, in fraction of day,*/ m[2] = limitTo(m[0] + h0Degrees / 360.0, 1);  m[0] = limitTo(m[0], 1);  /* A.2.8. Calculate the sidereal time at Greenwich, in degrees, for the sun transit, sunrise, and sunset*/ final double[] nu = new double[3]; for (int i = 0; i < m.length; i++) {
* Calculate the times of sunrise, sun transit (solar noon), and sunset for a given day. The calculation is based * on the astronomical definition of sunrise and sunset, using a refraction correction of -0.8333°. * * @param day       GregorianCalendar of day for which sunrise/transit/sunset are to be calculated. *                  The time of day (hour, minute, second, millisecond) is ignored. * @param latitude  Observer's latitude, in degrees (negative south of equator). * @param longitude Observer's longitude, in degrees (negative west of Greenwich). * @param deltaT    Difference between earth rotation time and terrestrial time (or Universal Time and Terrestrial Time), *                  in seconds. See *                  <a href ="http://asa.usno.navy.mil/SecK/DeltaT.html">http:/*asa.usno.navy.mil/SecK/DeltaT.html</a>.*/ *                  For the year 2015, a reasonably accurate default would be 68. * @return An array of 3 GregorianCalendar values corresponding to the time of sunrise, sun transit, and sunset, * respectively. Note that the values for sunrise and sunset may be null: in this case, the sun stays above or * below the horizon all day.  <BUGS> final double h0Degrees = limitTo(toDegrees(h0), 180.0); <BUGE>  /* A.2.5. Calculate the approximate sunrise time, m1, in fraction of day,*/ m[1] = limitTo(m[0] - h0Degrees / 360.0, 1);  /* A.2.6. Calculate the approximate sunset time, m2, in fraction of day,*/ m[2] = limitTo(m[0] + h0Degrees / 360.0, 1);  m[0] = limitTo(m[0], 1);  /* A.2.8. Calculate the sidereal time at Greenwich, in degrees, for the sun transit, sunrise, and sunset*/ final double[] nu = new double[3]; for (int i = 0; i < m.length; i++) { nu[i] = nuDegrees + 360.985647 * m[i]; }
* Calculate the times of sunrise, sun transit (solar noon), and sunset for a given day. The calculation is based * on the astronomical definition of sunrise and sunset, using a refraction correction of -0.8333°. * * @param day       GregorianCalendar of day for which sunrise/transit/sunset are to be calculated. *                  The time of day (hour, minute, second, millisecond) is ignored. * @param latitude  Observer's latitude, in degrees (negative south of equator). * @param longitude Observer's longitude, in degrees (negative west of Greenwich). * @param deltaT    Difference between earth rotation time and terrestrial time (or Universal Time and Terrestrial Time), *                  in seconds. See *                  <a href ="http://asa.usno.navy.mil/SecK/DeltaT.html">http:/*asa.usno.navy.mil/SecK/DeltaT.html</a>.*/ *                  For the year 2015, a reasonably accurate default would be 68. * @return An array of 3 GregorianCalendar values corresponding to the time of sunrise, sun transit, and sunset, * respectively. Note that the values for sunrise and sunset may be null: in this case, the sun stays above or * below the horizon all day. /* A.2.5. Calculate the approximate sunrise time, m1, in fraction of day,*/ <BUGS> m[1] = limitTo(m[0] - h0Degrees / 360.0, 1); <BUGE>  /* A.2.6. Calculate the approximate sunset time, m2, in fraction of day,*/ m[2] = limitTo(m[0] + h0Degrees / 360.0, 1);  m[0] = limitTo(m[0], 1);  /* A.2.8. Calculate the sidereal time at Greenwich, in degrees, for the sun transit, sunrise, and sunset*/ final double[] nu = new double[3]; for (int i = 0; i < m.length; i++) { nu[i] = nuDegrees + 360.985647 * m[i]; }  /* A.2.9. Calculate the terms ni*/ final double[] n = new double[3];
* Calculate the times of sunrise, sun transit (solar noon), and sunset for a given day. The calculation is based * on the astronomical definition of sunrise and sunset, using a refraction correction of -0.8333°. * * @param day       GregorianCalendar of day for which sunrise/transit/sunset are to be calculated. *                  The time of day (hour, minute, second, millisecond) is ignored. * @param latitude  Observer's latitude, in degrees (negative south of equator). * @param longitude Observer's longitude, in degrees (negative west of Greenwich). * @param deltaT    Difference between earth rotation time and terrestrial time (or Universal Time and Terrestrial Time), *                  in seconds. See *                  <a href ="http://asa.usno.navy.mil/SecK/DeltaT.html">http:/*asa.usno.navy.mil/SecK/DeltaT.html</a>.*/ *                  For the year 2015, a reasonably accurate default would be 68. * @return An array of 3 GregorianCalendar values corresponding to the time of sunrise, sun transit, and sunset, * respectively. Note that the values for sunrise and sunset may be null: in this case, the sun stays above or * below the horizon all day. /* A.2.6. Calculate the approximate sunset time, m2, in fraction of day,*/ <BUGS> m[2] = limitTo(m[0] + h0Degrees / 360.0, 1); <BUGE>  m[0] = limitTo(m[0], 1);  /* A.2.8. Calculate the sidereal time at Greenwich, in degrees, for the sun transit, sunrise, and sunset*/ final double[] nu = new double[3]; for (int i = 0; i < m.length; i++) { nu[i] = nuDegrees + 360.985647 * m[i]; }  /* A.2.9. Calculate the terms ni*/ final double[] n = new double[3]; for (int i = 0; i < m.length; i++) { n[i] = m[i] + deltaT / 86400.0; }
* Calculate the times of sunrise, sun transit (solar noon), and sunset for a given day. The calculation is based * on the astronomical definition of sunrise and sunset, using a refraction correction of -0.8333°. * * @param day       GregorianCalendar of day for which sunrise/transit/sunset are to be calculated. *                  The time of day (hour, minute, second, millisecond) is ignored. * @param latitude  Observer's latitude, in degrees (negative south of equator). * @param longitude Observer's longitude, in degrees (negative west of Greenwich). * @param deltaT    Difference between earth rotation time and terrestrial time (or Universal Time and Terrestrial Time), *                  in seconds. See *                  <a href ="http://asa.usno.navy.mil/SecK/DeltaT.html">http:/*asa.usno.navy.mil/SecK/DeltaT.html</a>.*/ *                  For the year 2015, a reasonably accurate default would be 68. * @return An array of 3 GregorianCalendar values corresponding to the time of sunrise, sun transit, and sunset, * respectively. Note that the values for sunrise and sunset may be null: in this case, the sun stays above or * below the horizon all day.  <BUGS> m[0] = limitTo(m[0], 1); <BUGE>  /* A.2.8. Calculate the sidereal time at Greenwich, in degrees, for the sun transit, sunrise, and sunset*/ final double[] nu = new double[3]; for (int i = 0; i < m.length; i++) { nu[i] = nuDegrees + 360.985647 * m[i]; }  /* A.2.9. Calculate the terms ni*/ final double[] n = new double[3]; for (int i = 0; i < m.length; i++) { n[i] = m[i] + deltaT / 86400.0; }  /* A.2.10. Calculate the values alpha'i and delta'i , in degrees*/
* on the astronomical definition of sunrise and sunset, using a refraction correction of -0.8333°. * * @param day       GregorianCalendar of day for which sunrise/transit/sunset are to be calculated. *                  The time of day (hour, minute, second, millisecond) is ignored. * @param latitude  Observer's latitude, in degrees (negative south of equator). * @param longitude Observer's longitude, in degrees (negative west of Greenwich). * @param deltaT    Difference between earth rotation time and terrestrial time (or Universal Time and Terrestrial Time), *                  in seconds. See *                  <a href ="http://asa.usno.navy.mil/SecK/DeltaT.html">http:/*asa.usno.navy.mil/SecK/DeltaT.html</a>.*/ *                  For the year 2015, a reasonably accurate default would be 68. * @return An array of 3 GregorianCalendar values corresponding to the time of sunrise, sun transit, and sunset, * respectively. Note that the values for sunrise and sunset may be null: in this case, the sun stays above or * below the horizon all day. /* A.2.8. Calculate the sidereal time at Greenwich, in degrees, for the sun transit, sunrise, and sunset*/ <BUGS> final double[] nu = new double[3]; for (int i = 0; i < m.length; i++) { nu[i] = nuDegrees + 360.985647 * m[i]; <BUGE> }  /* A.2.9. Calculate the terms ni*/ final double[] n = new double[3]; for (int i = 0; i < m.length; i++) { n[i] = m[i] + deltaT / 86400.0; }  /* A.2.10. Calculate the values alpha'i and delta'i , in degrees*/ final double a = limitIfNecessary(alphaDeltas[1].alpha - alphaDeltas[0].alpha); final double aPrime = limitIfNecessary(alphaDeltas[1].delta - alphaDeltas[0].delta);  final double b = limitIfNecessary(alphaDeltas[2].alpha - alphaDeltas[1].alpha);
* on the astronomical definition of sunrise and sunset, using a refraction correction of -0.8333°. * * @param day       GregorianCalendar of day for which sunrise/transit/sunset are to be calculated. *                  The time of day (hour, minute, second, millisecond) is ignored. * @param latitude  Observer's latitude, in degrees (negative south of equator). * @param longitude Observer's longitude, in degrees (negative west of Greenwich). * @param deltaT    Difference between earth rotation time and terrestrial time (or Universal Time and Terrestrial Time), *                  in seconds. See *                  <a href ="http://asa.usno.navy.mil/SecK/DeltaT.html">http:/*asa.usno.navy.mil/SecK/DeltaT.html</a>.*/ *                  For the year 2015, a reasonably accurate default would be 68. * @return An array of 3 GregorianCalendar values corresponding to the time of sunrise, sun transit, and sunset, * respectively. Note that the values for sunrise and sunset may be null: in this case, the sun stays above or * below the horizon all day. /* A.2.9. Calculate the terms ni*/ <BUGS> final double[] n = new double[3]; for (int i = 0; i < m.length; i++) { n[i] = m[i] + deltaT / 86400.0; <BUGE> }  /* A.2.10. Calculate the values alpha'i and delta'i , in degrees*/ final double a = limitIfNecessary(alphaDeltas[1].alpha - alphaDeltas[0].alpha); final double aPrime = limitIfNecessary(alphaDeltas[1].delta - alphaDeltas[0].delta);  final double b = limitIfNecessary(alphaDeltas[2].alpha - alphaDeltas[1].alpha); final double bPrime = limitIfNecessary(alphaDeltas[2].delta - alphaDeltas[1].delta);  final double c = b - a; final double cPrime = bPrime - aPrime;  final AlphaDelta[] alphaDeltaPrimes = new AlphaDelta[3];
* Calculate the times of sunrise, sun transit (solar noon), and sunset for a given day. The calculation is based * on the astronomical definition of sunrise and sunset, using a refraction correction of -0.8333°. * * @param day       GregorianCalendar of day for which sunrise/transit/sunset are to be calculated. *                  The time of day (hour, minute, second, millisecond) is ignored. * @param latitude  Observer's latitude, in degrees (negative south of equator). * @param longitude Observer's longitude, in degrees (negative west of Greenwich). * @param deltaT    Difference between earth rotation time and terrestrial time (or Universal Time and Terrestrial Time), *                  in seconds. See *                  <a href ="http://asa.usno.navy.mil/SecK/DeltaT.html">http:/*asa.usno.navy.mil/SecK/DeltaT.html</a>.*/ *                  For the year 2015, a reasonably accurate default would be 68. * @return An array of 3 GregorianCalendar values corresponding to the time of sunrise, sun transit, and sunset, * respectively. Note that the values for sunrise and sunset may be null: in this case, the sun stays above or * below the horizon all day. /* A.2.10. Calculate the values alpha'i and delta'i , in degrees*/ <BUGS> final double a = limitIfNecessary(alphaDeltas[1].alpha - alphaDeltas[0].alpha); final double aPrime = limitIfNecessary(alphaDeltas[1].delta - alphaDeltas[0].delta); <BUGE>  final double b = limitIfNecessary(alphaDeltas[2].alpha - alphaDeltas[1].alpha); final double bPrime = limitIfNecessary(alphaDeltas[2].delta - alphaDeltas[1].delta);  final double c = b - a; final double cPrime = bPrime - aPrime;  final AlphaDelta[] alphaDeltaPrimes = new AlphaDelta[3]; for (int i = 0; i < alphaDeltaPrimes.length; i++) { double alphaPrimeI = alphaDeltas[1].alpha + (n[i] * (a + b + c * n[i])) / 2.0; double deltaPrimeI =
* Calculate the times of sunrise, sun transit (solar noon), and sunset for a given day. The calculation is based * on the astronomical definition of sunrise and sunset, using a refraction correction of -0.8333°. * * @param day       GregorianCalendar of day for which sunrise/transit/sunset are to be calculated. *                  The time of day (hour, minute, second, millisecond) is ignored. * @param latitude  Observer's latitude, in degrees (negative south of equator). * @param longitude Observer's longitude, in degrees (negative west of Greenwich). * @param deltaT    Difference between earth rotation time and terrestrial time (or Universal Time and Terrestrial Time), *                  in seconds. See *                  <a href ="http://asa.usno.navy.mil/SecK/DeltaT.html">http:/*asa.usno.navy.mil/SecK/DeltaT.html</a>.*/ *                  For the year 2015, a reasonably accurate default would be 68. * @return An array of 3 GregorianCalendar values corresponding to the time of sunrise, sun transit, and sunset, * respectively. Note that the values for sunrise and sunset may be null: in this case, the sun stays above or * below the horizon all day.  <BUGS> final double b = limitIfNecessary(alphaDeltas[2].alpha - alphaDeltas[1].alpha); final double bPrime = limitIfNecessary(alphaDeltas[2].delta - alphaDeltas[1].delta); <BUGE>  final double c = b - a; final double cPrime = bPrime - aPrime;  final AlphaDelta[] alphaDeltaPrimes = new AlphaDelta[3]; for (int i = 0; i < alphaDeltaPrimes.length; i++) { double alphaPrimeI = alphaDeltas[1].alpha + (n[i] * (a + b + c * n[i])) / 2.0; double deltaPrimeI = alphaDeltas[1].delta + (n[i] * (aPrime + bPrime + cPrime * n[i])) / 2.0;
* Calculate the times of sunrise, sun transit (solar noon), and sunset for a given day. The calculation is based * on the astronomical definition of sunrise and sunset, using a refraction correction of -0.8333°. * * @param day       GregorianCalendar of day for which sunrise/transit/sunset are to be calculated. *                  The time of day (hour, minute, second, millisecond) is ignored. * @param latitude  Observer's latitude, in degrees (negative south of equator). * @param longitude Observer's longitude, in degrees (negative west of Greenwich). * @param deltaT    Difference between earth rotation time and terrestrial time (or Universal Time and Terrestrial Time), *                  in seconds. See *                  <a href ="http://asa.usno.navy.mil/SecK/DeltaT.html">http:/*asa.usno.navy.mil/SecK/DeltaT.html</a>.*/ *                  For the year 2015, a reasonably accurate default would be 68. * @return An array of 3 GregorianCalendar values corresponding to the time of sunrise, sun transit, and sunset, * respectively. Note that the values for sunrise and sunset may be null: in this case, the sun stays above or * below the horizon all day.  <BUGS> final double c = b - a; final double cPrime = bPrime - aPrime; <BUGE>  final AlphaDelta[] alphaDeltaPrimes = new AlphaDelta[3]; for (int i = 0; i < alphaDeltaPrimes.length; i++) { double alphaPrimeI = alphaDeltas[1].alpha + (n[i] * (a + b + c * n[i])) / 2.0; double deltaPrimeI = alphaDeltas[1].delta + (n[i] * (aPrime + bPrime + cPrime * n[i])) / 2.0;  alphaDeltaPrimes[i] = new AlphaDelta(alphaPrimeI, deltaPrimeI); }
* on the astronomical definition of sunrise and sunset, using a refraction correction of -0.8333°. * * @param day       GregorianCalendar of day for which sunrise/transit/sunset are to be calculated. *                  The time of day (hour, minute, second, millisecond) is ignored. * @param latitude  Observer's latitude, in degrees (negative south of equator). * @param longitude Observer's longitude, in degrees (negative west of Greenwich). * @param deltaT    Difference between earth rotation time and terrestrial time (or Universal Time and Terrestrial Time), *                  in seconds. See *                  <a href ="http://asa.usno.navy.mil/SecK/DeltaT.html">http:/*asa.usno.navy.mil/SecK/DeltaT.html</a>.*/ *                  For the year 2015, a reasonably accurate default would be 68. * @return An array of 3 GregorianCalendar values corresponding to the time of sunrise, sun transit, and sunset, * respectively. Note that the values for sunrise and sunset may be null: in this case, the sun stays above or * below the horizon all day.  <BUGS> final AlphaDelta[] alphaDeltaPrimes = new AlphaDelta[3]; for (int i = 0; i < alphaDeltaPrimes.length; i++) { double alphaPrimeI = <BUGE> alphaDeltas[1].alpha + (n[i] * (a + b + c * n[i])) / 2.0; double deltaPrimeI = alphaDeltas[1].delta + (n[i] * (aPrime + bPrime + cPrime * n[i])) / 2.0;  alphaDeltaPrimes[i] = new AlphaDelta(alphaPrimeI, deltaPrimeI); }  /* A.2.11. Calculate the local hour angle for the sun transit, sunrise, and sunset*/ final double[] hPrime = new double[3]; for (int i = 0; i < hPrime.length; i++) { double hPrimeI = nu[i] + longitude - alphaDeltaPrimes[i].alpha;
* Calculate the times of sunrise, sun transit (solar noon), and sunset for a given day. The calculation is based * on the astronomical definition of sunrise and sunset, using a refraction correction of -0.8333°. * * @param day       GregorianCalendar of day for which sunrise/transit/sunset are to be calculated. *                  The time of day (hour, minute, second, millisecond) is ignored. * @param latitude  Observer's latitude, in degrees (negative south of equator). * @param longitude Observer's longitude, in degrees (negative west of Greenwich). * @param deltaT    Difference between earth rotation time and terrestrial time (or Universal Time and Terrestrial Time), *                  in seconds. See *                  <a href ="http://asa.usno.navy.mil/SecK/DeltaT.html">http:/*asa.usno.navy.mil/SecK/DeltaT.html</a>.*/ *                  For the year 2015, a reasonably accurate default would be 68. * @return An array of 3 GregorianCalendar values corresponding to the time of sunrise, sun transit, and sunset, * respectively. Note that the values for sunrise and sunset may be null: in this case, the sun stays above or * below the horizon all day. (n[i] * (a + b + c * n[i])) / 2.0; <BUGS> double deltaPrimeI = <BUGE> alphaDeltas[1].delta + (n[i] * (aPrime + bPrime + cPrime * n[i])) / 2.0;  alphaDeltaPrimes[i] = new AlphaDelta(alphaPrimeI, deltaPrimeI); }  /* A.2.11. Calculate the local hour angle for the sun transit, sunrise, and sunset*/ final double[] hPrime = new double[3]; for (int i = 0; i < hPrime.length; i++) { double hPrimeI = nu[i] + longitude - alphaDeltaPrimes[i].alpha; hPrime[i] = limitHprime(hPrimeI); }  /* A.2.12. Calculate the sun altitude for the sun transit, sunrise, and sunset, hi*/
* Calculate the times of sunrise, sun transit (solar noon), and sunset for a given day. The calculation is based * on the astronomical definition of sunrise and sunset, using a refraction correction of -0.8333°. * * @param day       GregorianCalendar of day for which sunrise/transit/sunset are to be calculated. *                  The time of day (hour, minute, second, millisecond) is ignored. * @param latitude  Observer's latitude, in degrees (negative south of equator). * @param longitude Observer's longitude, in degrees (negative west of Greenwich). * @param deltaT    Difference between earth rotation time and terrestrial time (or Universal Time and Terrestrial Time), *                  in seconds. See *                  <a href ="http://asa.usno.navy.mil/SecK/DeltaT.html">http:/*asa.usno.navy.mil/SecK/DeltaT.html</a>.*/ *                  For the year 2015, a reasonably accurate default would be 68. * @return An array of 3 GregorianCalendar values corresponding to the time of sunrise, sun transit, and sunset, * respectively. Note that the values for sunrise and sunset may be null: in this case, the sun stays above or * below the horizon all day.  <BUGS> alphaDeltaPrimes[i] = new AlphaDelta(alphaPrimeI, deltaPrimeI); <BUGE> }  /* A.2.11. Calculate the local hour angle for the sun transit, sunrise, and sunset*/ final double[] hPrime = new double[3]; for (int i = 0; i < hPrime.length; i++) { double hPrimeI = nu[i] + longitude - alphaDeltaPrimes[i].alpha; hPrime[i] = limitHprime(hPrimeI); }  /* A.2.12. Calculate the sun altitude for the sun transit, sunrise, and sunset, hi*/ final double[] h = new double[3]; for (int i = 0; i < h.length; i++) { double deltaPrimeRad = toRadians(alphaDeltaPrimes[i].delta);
* on the astronomical definition of sunrise and sunset, using a refraction correction of -0.8333°. * * @param day       GregorianCalendar of day for which sunrise/transit/sunset are to be calculated. *                  The time of day (hour, minute, second, millisecond) is ignored. * @param latitude  Observer's latitude, in degrees (negative south of equator). * @param longitude Observer's longitude, in degrees (negative west of Greenwich). * @param deltaT    Difference between earth rotation time and terrestrial time (or Universal Time and Terrestrial Time), *                  in seconds. See *                  <a href ="http://asa.usno.navy.mil/SecK/DeltaT.html">http:/*asa.usno.navy.mil/SecK/DeltaT.html</a>.*/ *                  For the year 2015, a reasonably accurate default would be 68. * @return An array of 3 GregorianCalendar values corresponding to the time of sunrise, sun transit, and sunset, * respectively. Note that the values for sunrise and sunset may be null: in this case, the sun stays above or * below the horizon all day. /* A.2.11. Calculate the local hour angle for the sun transit, sunrise, and sunset*/ <BUGS> final double[] hPrime = new double[3]; for (int i = 0; i < hPrime.length; i++) { double hPrimeI = nu[i] + longitude - alphaDeltaPrimes[i].alpha; hPrime[i] = limitHprime(hPrimeI); <BUGE> }  /* A.2.12. Calculate the sun altitude for the sun transit, sunrise, and sunset, hi*/ final double[] h = new double[3]; for (int i = 0; i < h.length; i++) { double deltaPrimeRad = toRadians(alphaDeltaPrimes[i].delta);  h[i] = toDegrees(asin( sin(phi) * sin(deltaPrimeRad) + cos(phi) * cos(deltaPrimeRad) * cos(toRadians(hPrime[i])) )); }
* on the astronomical definition of sunrise and sunset, using a refraction correction of -0.8333°. * * @param day       GregorianCalendar of day for which sunrise/transit/sunset are to be calculated. *                  The time of day (hour, minute, second, millisecond) is ignored. * @param latitude  Observer's latitude, in degrees (negative south of equator). * @param longitude Observer's longitude, in degrees (negative west of Greenwich). * @param deltaT    Difference between earth rotation time and terrestrial time (or Universal Time and Terrestrial Time), *                  in seconds. See *                  <a href ="http://asa.usno.navy.mil/SecK/DeltaT.html">http:/*asa.usno.navy.mil/SecK/DeltaT.html</a>.*/ *                  For the year 2015, a reasonably accurate default would be 68. * @return An array of 3 GregorianCalendar values corresponding to the time of sunrise, sun transit, and sunset, * respectively. Note that the values for sunrise and sunset may be null: in this case, the sun stays above or * below the horizon all day. /* A.2.12. Calculate the sun altitude for the sun transit, sunrise, and sunset, hi*/ <BUGS> final double[] h = new double[3]; for (int i = 0; i < h.length; i++) { double deltaPrimeRad = toRadians(alphaDeltaPrimes[i].delta); <BUGE>  h[i] = toDegrees(asin( sin(phi) * sin(deltaPrimeRad) + cos(phi) * cos(deltaPrimeRad) * cos(toRadians(hPrime[i])) )); }  /* A.2.13. Calculate the sun transit, T (in fraction of day)*/ final double t = m[0] - hPrime[0] / 360.0;  /* A.2.14. Calculate the sunrise, R (in fraction of day)*/ final double r = m[1] + (h[1] - HPRIME_0) /
* on the astronomical definition of sunrise and sunset, using a refraction correction of -0.8333°. * * @param day       GregorianCalendar of day for which sunrise/transit/sunset are to be calculated. *                  The time of day (hour, minute, second, millisecond) is ignored. * @param latitude  Observer's latitude, in degrees (negative south of equator). * @param longitude Observer's longitude, in degrees (negative west of Greenwich). * @param deltaT    Difference between earth rotation time and terrestrial time (or Universal Time and Terrestrial Time), *                  in seconds. See *                  <a href ="http://asa.usno.navy.mil/SecK/DeltaT.html">http:/*asa.usno.navy.mil/SecK/DeltaT.html</a>.*/ *                  For the year 2015, a reasonably accurate default would be 68. * @return An array of 3 GregorianCalendar values corresponding to the time of sunrise, sun transit, and sunset, * respectively. Note that the values for sunrise and sunset may be null: in this case, the sun stays above or * below the horizon all day.  <BUGS> h[i] = toDegrees(asin( sin(phi) * sin(deltaPrimeRad) + cos(phi) * cos(deltaPrimeRad) * cos(toRadians(hPrime[i])) <BUGE> )); }  /* A.2.13. Calculate the sun transit, T (in fraction of day)*/ final double t = m[0] - hPrime[0] / 360.0;  /* A.2.14. Calculate the sunrise, R (in fraction of day)*/ final double r = m[1] + (h[1] - HPRIME_0) / (360.0 * cos(toRadians(alphaDeltaPrimes[1].delta)) * cos(phi) * sin(toRadians(hPrime[1])));  /* A.2.15. Calculate the sunset, S (in fraction of day)*/ final double s = m[2] +
* Calculate the times of sunrise, sun transit (solar noon), and sunset for a given day. The calculation is based * on the astronomical definition of sunrise and sunset, using a refraction correction of -0.8333°. * * @param day       GregorianCalendar of day for which sunrise/transit/sunset are to be calculated. *                  The time of day (hour, minute, second, millisecond) is ignored. * @param latitude  Observer's latitude, in degrees (negative south of equator). * @param longitude Observer's longitude, in degrees (negative west of Greenwich). * @param deltaT    Difference between earth rotation time and terrestrial time (or Universal Time and Terrestrial Time), *                  in seconds. See *                  <a href ="http://asa.usno.navy.mil/SecK/DeltaT.html">http:/*asa.usno.navy.mil/SecK/DeltaT.html</a>.*/ *                  For the year 2015, a reasonably accurate default would be 68. * @return An array of 3 GregorianCalendar values corresponding to the time of sunrise, sun transit, and sunset, * respectively. Note that the values for sunrise and sunset may be null: in this case, the sun stays above or * below the horizon all day. /* A.2.13. Calculate the sun transit, T (in fraction of day)*/ <BUGS> final double t = m[0] - hPrime[0] / 360.0; <BUGE>  /* A.2.14. Calculate the sunrise, R (in fraction of day)*/ final double r = m[1] + (h[1] - HPRIME_0) / (360.0 * cos(toRadians(alphaDeltaPrimes[1].delta)) * cos(phi) * sin(toRadians(hPrime[1])));  /* A.2.15. Calculate the sunset, S (in fraction of day)*/ final double s = m[2] + (h[2] - HPRIME_0) / (360.0 * cos(toRadians(alphaDeltaPrimes[2].delta)) * cos(phi) * sin(toRadians(hPrime[2])));  return new GregorianCalendar[]{ noSunriseOrSet ? null : addFractionOfDay(day, r), addFractionOfDay(day, t),
* Calculate the times of sunrise, sun transit (solar noon), and sunset for a given day. The calculation is based * on the astronomical definition of sunrise and sunset, using a refraction correction of -0.8333°. * * @param day       GregorianCalendar of day for which sunrise/transit/sunset are to be calculated. *                  The time of day (hour, minute, second, millisecond) is ignored. * @param latitude  Observer's latitude, in degrees (negative south of equator). * @param longitude Observer's longitude, in degrees (negative west of Greenwich). * @param deltaT    Difference between earth rotation time and terrestrial time (or Universal Time and Terrestrial Time), *                  in seconds. See *                  <a href ="http://asa.usno.navy.mil/SecK/DeltaT.html">http:/*asa.usno.navy.mil/SecK/DeltaT.html</a>.*/ *                  For the year 2015, a reasonably accurate default would be 68. * @return An array of 3 GregorianCalendar values corresponding to the time of sunrise, sun transit, and sunset, * respectively. Note that the values for sunrise and sunset may be null: in this case, the sun stays above or * below the horizon all day. /* A.2.14. Calculate the sunrise, R (in fraction of day)*/ <BUGS> final double r = m[1] + <BUGE> (h[1] - HPRIME_0) / (360.0 * cos(toRadians(alphaDeltaPrimes[1].delta)) * cos(phi) * sin(toRadians(hPrime[1])));  /* A.2.15. Calculate the sunset, S (in fraction of day)*/ final double s = m[2] + (h[2] - HPRIME_0) / (360.0 * cos(toRadians(alphaDeltaPrimes[2].delta)) * cos(phi) * sin(toRadians(hPrime[2])));  return new GregorianCalendar[]{ noSunriseOrSet ? null : addFractionOfDay(day, r), addFractionOfDay(day, t), noSunriseOrSet ? null : addFractionOfDay(day, s) }; }
* Calculate the times of sunrise, sun transit (solar noon), and sunset for a given day. The calculation is based * on the astronomical definition of sunrise and sunset, using a refraction correction of -0.8333°. * * @param day       GregorianCalendar of day for which sunrise/transit/sunset are to be calculated. *                  The time of day (hour, minute, second, millisecond) is ignored. * @param latitude  Observer's latitude, in degrees (negative south of equator). * @param longitude Observer's longitude, in degrees (negative west of Greenwich). * @param deltaT    Difference between earth rotation time and terrestrial time (or Universal Time and Terrestrial Time), *                  in seconds. See *                  <a href ="http://asa.usno.navy.mil/SecK/DeltaT.html">http:/*asa.usno.navy.mil/SecK/DeltaT.html</a>.*/ *                  For the year 2015, a reasonably accurate default would be 68. * @return An array of 3 GregorianCalendar values corresponding to the time of sunrise, sun transit, and sunset, * respectively. Note that the values for sunrise and sunset may be null: in this case, the sun stays above or * below the horizon all day. (h[1] - HPRIME_0) / <BUGS> (360.0 * cos(toRadians(alphaDeltaPrimes[1].delta)) * cos(phi) * sin(toRadians(hPrime[1]))); <BUGE>  /* A.2.15. Calculate the sunset, S (in fraction of day)*/ final double s = m[2] + (h[2] - HPRIME_0) / (360.0 * cos(toRadians(alphaDeltaPrimes[2].delta)) * cos(phi) * sin(toRadians(hPrime[2])));  return new GregorianCalendar[]{ noSunriseOrSet ? null : addFractionOfDay(day, r), addFractionOfDay(day, t), noSunriseOrSet ? null : addFractionOfDay(day, s) }; }  private static GregorianCalendar addFractionOfDay(GregorianCalendar day, final double fraction) {
* Calculate the times of sunrise, sun transit (solar noon), and sunset for a given day. The calculation is based * on the astronomical definition of sunrise and sunset, using a refraction correction of -0.8333°. * * @param day       GregorianCalendar of day for which sunrise/transit/sunset are to be calculated. *                  The time of day (hour, minute, second, millisecond) is ignored. * @param latitude  Observer's latitude, in degrees (negative south of equator). * @param longitude Observer's longitude, in degrees (negative west of Greenwich). * @param deltaT    Difference between earth rotation time and terrestrial time (or Universal Time and Terrestrial Time), *                  in seconds. See *                  <a href ="http://asa.usno.navy.mil/SecK/DeltaT.html">http:/*asa.usno.navy.mil/SecK/DeltaT.html</a>.*/ *                  For the year 2015, a reasonably accurate default would be 68. * @return An array of 3 GregorianCalendar values corresponding to the time of sunrise, sun transit, and sunset, * respectively. Note that the values for sunrise and sunset may be null: in this case, the sun stays above or * below the horizon all day. /* A.2.15. Calculate the sunset, S (in fraction of day)*/ <BUGS> final double s = m[2] + <BUGE> (h[2] - HPRIME_0) / (360.0 * cos(toRadians(alphaDeltaPrimes[2].delta)) * cos(phi) * sin(toRadians(hPrime[2])));  return new GregorianCalendar[]{ noSunriseOrSet ? null : addFractionOfDay(day, r), addFractionOfDay(day, t), noSunriseOrSet ? null : addFractionOfDay(day, s) }; }  private static GregorianCalendar addFractionOfDay(GregorianCalendar day, final double fraction) { GregorianCalendar dayStart = (GregorianCalendar) day.clone(); dayStart.set(Calendar.MINUTE, 0); dayStart.set(Calendar.SECOND, 0);
* Calculate the times of sunrise, sun transit (solar noon), and sunset for a given day. The calculation is based * on the astronomical definition of sunrise and sunset, using a refraction correction of -0.8333°. * * @param day       GregorianCalendar of day for which sunrise/transit/sunset are to be calculated. *                  The time of day (hour, minute, second, millisecond) is ignored. * @param latitude  Observer's latitude, in degrees (negative south of equator). * @param longitude Observer's longitude, in degrees (negative west of Greenwich). * @param deltaT    Difference between earth rotation time and terrestrial time (or Universal Time and Terrestrial Time), *                  in seconds. See *                  <a href ="http://asa.usno.navy.mil/SecK/DeltaT.html">http:/*asa.usno.navy.mil/SecK/DeltaT.html</a>.*/ *                  For the year 2015, a reasonably accurate default would be 68. * @return An array of 3 GregorianCalendar values corresponding to the time of sunrise, sun transit, and sunset, * respectively. Note that the values for sunrise and sunset may be null: in this case, the sun stays above or * below the horizon all day. (h[2] - HPRIME_0) / <BUGS> (360.0 * cos(toRadians(alphaDeltaPrimes[2].delta)) * cos(phi) * sin(toRadians(hPrime[2]))); <BUGE>  return new GregorianCalendar[]{ noSunriseOrSet ? null : addFractionOfDay(day, r), addFractionOfDay(day, t), noSunriseOrSet ? null : addFractionOfDay(day, s) }; }  private static GregorianCalendar addFractionOfDay(GregorianCalendar day, final double fraction) { GregorianCalendar dayStart = (GregorianCalendar) day.clone(); dayStart.set(Calendar.MINUTE, 0); dayStart.set(Calendar.SECOND, 0); dayStart.set(Calendar.MILLISECOND, 0); dayStart.set(Calendar.HOUR_OF_DAY, 12);
* on the astronomical definition of sunrise and sunset, using a refraction correction of -0.8333°. * * @param day       GregorianCalendar of day for which sunrise/transit/sunset are to be calculated. *                  The time of day (hour, minute, second, millisecond) is ignored. * @param latitude  Observer's latitude, in degrees (negative south of equator). * @param longitude Observer's longitude, in degrees (negative west of Greenwich). * @param deltaT    Difference between earth rotation time and terrestrial time (or Universal Time and Terrestrial Time), *                  in seconds. See *                  <a href ="http://asa.usno.navy.mil/SecK/DeltaT.html">http:/*asa.usno.navy.mil/SecK/DeltaT.html</a>.*/ *                  For the year 2015, a reasonably accurate default would be 68. * @return An array of 3 GregorianCalendar values corresponding to the time of sunrise, sun transit, and sunset, * respectively. Note that the values for sunrise and sunset may be null: in this case, the sun stays above or * below the horizon all day.  <BUGS> return new GregorianCalendar[]{ noSunriseOrSet ? null : addFractionOfDay(day, r), addFractionOfDay(day, t), noSunriseOrSet ? null : addFractionOfDay(day, s) <BUGE> }; }  private static GregorianCalendar addFractionOfDay(GregorianCalendar day, final double fraction) { GregorianCalendar dayStart = (GregorianCalendar) day.clone(); dayStart.set(Calendar.MINUTE, 0); dayStart.set(Calendar.SECOND, 0); dayStart.set(Calendar.MILLISECOND, 0); dayStart.set(Calendar.HOUR_OF_DAY, 12); final int offset = day.getTimeZone().getOffset(dayStart.getTimeInMillis());  dayStart.set(Calendar.HOUR_OF_DAY, 0);
*/ public static GregorianCalendar[] calculateSunriseTransitSet(final GregorianCalendar day, final double latitude, final double longitude, final double deltaT) { <BUGS> final GregorianCalendar dayStart = startOfDayUT(day); final JulianDate jd = new JulianDate(dayStart, 0); <BUGE>  final double phi = toRadians(latitude);  /* A.2.1. Calculate the apparent sidereal time at Greenwich at 0 UT, nu (in degrees)*/ final double jce = jd.getJulianEphemerisCentury(); final double xTerms[] = calculateNutationTerms(jce); final double[] deltaPsiI = calculateDeltaPsiI(jce, xTerms); final double[] deltaEpsilonI = calculateDeltaEpsilonI(jce, xTerms); final double deltaPsi = calculateDeltaPsiEpsilon(deltaPsiI); final double deltaEpsilon = calculateDeltaPsiEpsilon(deltaEpsilonI); final double epsilonDegrees = calculateTrueObliquityOfEcliptic(jd, deltaEpsilon);  final double nuDegrees = calculateApparentSiderealTimeAtGreenwich(jd, deltaPsi, epsilonDegrees);  /* A.2.2. Calculate the geocentric right ascension and declination at 0 TT for day before, same day, next day*/ final AlphaDelta[] alphaDeltas = new AlphaDelta[3]; for (int i = 0; i < alphaDeltas.length; i++) { JulianDate currentJd = new JulianDate(jd.getJulianDate() + i - 1, 0); double currentJme = currentJd.getJulianEphemerisMillennium(); AlphaDelta ad = calculateAlphaDelta(currentJme, deltaPsi, epsilonDegrees); alphaDeltas[i] = ad; }
*/ public static GregorianCalendar[] calculateSunriseTransitSet(final GregorianCalendar day, final double latitude, final double longitude, final double deltaT) { final GregorianCalendar dayStart = startOfDayUT(day); final JulianDate jd = new JulianDate(dayStart, 0);  <BUGS> final double phi = toRadians(latitude); <BUGE>  /* A.2.1. Calculate the apparent sidereal time at Greenwich at 0 UT, nu (in degrees)*/ final double jce = jd.getJulianEphemerisCentury(); final double xTerms[] = calculateNutationTerms(jce); final double[] deltaPsiI = calculateDeltaPsiI(jce, xTerms); final double[] deltaEpsilonI = calculateDeltaEpsilonI(jce, xTerms); final double deltaPsi = calculateDeltaPsiEpsilon(deltaPsiI); final double deltaEpsilon = calculateDeltaPsiEpsilon(deltaEpsilonI); final double epsilonDegrees = calculateTrueObliquityOfEcliptic(jd, deltaEpsilon);  final double nuDegrees = calculateApparentSiderealTimeAtGreenwich(jd, deltaPsi, epsilonDegrees);  /* A.2.2. Calculate the geocentric right ascension and declination at 0 TT for day before, same day, next day*/ final AlphaDelta[] alphaDeltas = new AlphaDelta[3]; for (int i = 0; i < alphaDeltas.length; i++) { JulianDate currentJd = new JulianDate(jd.getJulianDate() + i - 1, 0); double currentJme = currentJd.getJulianEphemerisMillennium(); AlphaDelta ad = calculateAlphaDelta(currentJme, deltaPsi, epsilonDegrees); alphaDeltas[i] = ad; }
*/ public static GregorianCalendar[] calculateSunriseTransitSet(final GregorianCalendar day, final double latitude, final double longitude, final double deltaT) { final GregorianCalendar dayStart = startOfDayUT(day); final JulianDate jd = new JulianDate(dayStart, 0);  final double phi = toRadians(latitude);  /* A.2.1. Calculate the apparent sidereal time at Greenwich at 0 UT, nu (in degrees)*/ <BUGS> final double jce = jd.getJulianEphemerisCentury(); final double xTerms[] = calculateNutationTerms(jce); final double[] deltaPsiI = calculateDeltaPsiI(jce, xTerms); final double[] deltaEpsilonI = calculateDeltaEpsilonI(jce, xTerms); final double deltaPsi = calculateDeltaPsiEpsilon(deltaPsiI); final double deltaEpsilon = calculateDeltaPsiEpsilon(deltaEpsilonI); final double epsilonDegrees = calculateTrueObliquityOfEcliptic(jd, deltaEpsilon); <BUGE>  final double nuDegrees = calculateApparentSiderealTimeAtGreenwich(jd, deltaPsi, epsilonDegrees);  /* A.2.2. Calculate the geocentric right ascension and declination at 0 TT for day before, same day, next day*/ final AlphaDelta[] alphaDeltas = new AlphaDelta[3]; for (int i = 0; i < alphaDeltas.length; i++) { JulianDate currentJd = new JulianDate(jd.getJulianDate() + i - 1, 0); double currentJme = currentJd.getJulianEphemerisMillennium(); AlphaDelta ad = calculateAlphaDelta(currentJme, deltaPsi, epsilonDegrees); alphaDeltas[i] = ad; }
*/ public static GregorianCalendar[] calculateSunriseTransitSet(final GregorianCalendar day, final double latitude, final double longitude, final double deltaT) { final GregorianCalendar dayStart = startOfDayUT(day); final JulianDate jd = new JulianDate(dayStart, 0);  final double phi = toRadians(latitude);  /* A.2.1. Calculate the apparent sidereal time at Greenwich at 0 UT, nu (in degrees)*/ final double jce = jd.getJulianEphemerisCentury(); final double xTerms[] = calculateNutationTerms(jce); final double[] deltaPsiI = calculateDeltaPsiI(jce, xTerms); final double[] deltaEpsilonI = calculateDeltaEpsilonI(jce, xTerms); final double deltaPsi = calculateDeltaPsiEpsilon(deltaPsiI); final double deltaEpsilon = calculateDeltaPsiEpsilon(deltaEpsilonI); final double epsilonDegrees = calculateTrueObliquityOfEcliptic(jd, deltaEpsilon);  <BUGS> final double nuDegrees = calculateApparentSiderealTimeAtGreenwich(jd, deltaPsi, epsilonDegrees); <BUGE>  /* A.2.2. Calculate the geocentric right ascension and declination at 0 TT for day before, same day, next day*/ final AlphaDelta[] alphaDeltas = new AlphaDelta[3]; for (int i = 0; i < alphaDeltas.length; i++) { JulianDate currentJd = new JulianDate(jd.getJulianDate() + i - 1, 0); double currentJme = currentJd.getJulianEphemerisMillennium(); AlphaDelta ad = calculateAlphaDelta(currentJme, deltaPsi, epsilonDegrees); alphaDeltas[i] = ad; }
*/ public static GregorianCalendar[] calculateSunriseTransitSet(final GregorianCalendar day, final double latitude, final double longitude, final double deltaT) { final GregorianCalendar dayStart = startOfDayUT(day); final JulianDate jd = new JulianDate(dayStart, 0);  final double phi = toRadians(latitude);  /* A.2.1. Calculate the apparent sidereal time at Greenwich at 0 UT, nu (in degrees)*/ final double jce = jd.getJulianEphemerisCentury(); final double xTerms[] = calculateNutationTerms(jce); final double[] deltaPsiI = calculateDeltaPsiI(jce, xTerms); final double[] deltaEpsilonI = calculateDeltaEpsilonI(jce, xTerms); final double deltaPsi = calculateDeltaPsiEpsilon(deltaPsiI); final double deltaEpsilon = calculateDeltaPsiEpsilon(deltaEpsilonI); final double epsilonDegrees = calculateTrueObliquityOfEcliptic(jd, deltaEpsilon);  final double nuDegrees = calculateApparentSiderealTimeAtGreenwich(jd, deltaPsi, epsilonDegrees);  /* A.2.2. Calculate the geocentric right ascension and declination at 0 TT for day before, same day, next day*/ <BUGS> final AlphaDelta[] alphaDeltas = new AlphaDelta[3]; for (int i = 0; i < alphaDeltas.length; i++) { JulianDate currentJd = new JulianDate(jd.getJulianDate() + i - 1, 0); double currentJme = currentJd.getJulianEphemerisMillennium(); AlphaDelta ad = calculateAlphaDelta(currentJme, deltaPsi, epsilonDegrees); alphaDeltas[i] = ad; <BUGE> }
*/ public static GregorianCalendar[] calculateSunriseTransitSet(final GregorianCalendar day, final double latitude, final double longitude, final double deltaT) { final GregorianCalendar dayStart = startOfDayUT(day); final JulianDate jd = new JulianDate(dayStart, 0);  final double phi = toRadians(latitude);  /* A.2.1. Calculate the apparent sidereal time at Greenwich at 0 UT, nu (in degrees)*/ final double jce = jd.getJulianEphemerisCentury(); final double xTerms[] = calculateNutationTerms(jce); final double[] deltaPsiI = calculateDeltaPsiI(jce, xTerms); final double[] deltaEpsilonI = calculateDeltaEpsilonI(jce, xTerms); final double deltaPsi = calculateDeltaPsiEpsilon(deltaPsiI); final double deltaEpsilon = calculateDeltaPsiEpsilon(deltaEpsilonI); final double epsilonDegrees = calculateTrueObliquityOfEcliptic(jd, deltaEpsilon);  final double nuDegrees = calculateApparentSiderealTimeAtGreenwich(jd, deltaPsi, epsilonDegrees);  /* A.2.2. Calculate the geocentric right ascension and declination at 0 TT for day before, same day, next day*/ final AlphaDelta[] alphaDeltas = new AlphaDelta[3]; for (int i = 0; i < alphaDeltas.length; i++) { JulianDate currentJd = new JulianDate(jd.getJulianDate() + i - 1, 0); double currentJme = currentJd.getJulianEphemerisMillennium(); AlphaDelta ad = calculateAlphaDelta(currentJme, deltaPsi, epsilonDegrees); alphaDeltas[i] = ad; }
* Calculate the times of sunrise, sun transit (solar noon), and sunset for a given day. The calculation is based * on the astronomical definition of sunrise and sunset, using a refraction correction of -0.8333°. * * @param day       GregorianCalendar of day for which sunrise/transit/sunset are to be calculated. *                  The time of day (hour, minute, second, millisecond) is ignored. * @param latitude  Observer's latitude, in degrees (negative south of equator). * @param longitude Observer's longitude, in degrees (negative west of Greenwich). * @param deltaT    Difference between earth rotation time and terrestrial time (or Universal Time and Terrestrial Time), *                  in seconds. See *                  <a href ="http://asa.usno.navy.mil/SecK/DeltaT.html">http:/*asa.usno.navy.mil/SecK/DeltaT.html</a>.*/ *                  For the year 2015, a reasonably accurate default would be 68. * @return An array of 3 GregorianCalendar values corresponding to the time of sunrise, sun transit, and sunset, * respectively. Note that the values for sunrise and sunset may be null: in this case, the sun stays above or * below the horizon all day. /* A.2.3. Calculate the approximate sun transit time, m0, in fraction of day*/ <BUGS> m[0] = (alphaDeltas[1].alpha - longitude - nuDegrees) / 360; <BUGE>  /* A.2.4. Calculate the local hour angle H0 corresponding to ...*/ final double acosArg = (SIN_HPRIME_0 - sin(phi * sin(toRadians(alphaDeltas[1].delta)))) / (cos(phi) * cos(toRadians(alphaDeltas[1].delta)));  final boolean noSunriseOrSet = (acosArg < -1.0) || (acosArg > 1.0);  final double h0 = acos(acosArg);  final double h0Degrees = limitTo(toDegrees(h0), 180.0);  /* A.2.5. Calculate the approximate sunrise time, m1, in fraction of day,*/ m[1] = limitTo(m[0] - h0Degrees / 360.0, 1);
* Calculate the times of sunrise, sun transit (solar noon), and sunset for a given day. The calculation is based * on the astronomical definition of sunrise and sunset, using a refraction correction of -0.8333°. * * @param day       GregorianCalendar of day for which sunrise/transit/sunset are to be calculated. *                  The time of day (hour, minute, second, millisecond) is ignored. * @param latitude  Observer's latitude, in degrees (negative south of equator). * @param longitude Observer's longitude, in degrees (negative west of Greenwich). * @param deltaT    Difference between earth rotation time and terrestrial time (or Universal Time and Terrestrial Time), *                  in seconds. See *                  <a href ="http://asa.usno.navy.mil/SecK/DeltaT.html">http:/*asa.usno.navy.mil/SecK/DeltaT.html</a>.*/ *                  For the year 2015, a reasonably accurate default would be 68. * @return An array of 3 GregorianCalendar values corresponding to the time of sunrise, sun transit, and sunset, * respectively. Note that the values for sunrise and sunset may be null: in this case, the sun stays above or * below the horizon all day. /* A.2.4. Calculate the local hour angle H0 corresponding to ...*/ <BUGS> final double acosArg = (SIN_HPRIME_0 - sin(phi * sin(toRadians(alphaDeltas[1].delta)))) / (cos(phi) * cos(toRadians(alphaDeltas[1].delta))); <BUGE>  final boolean noSunriseOrSet = (acosArg < -1.0) || (acosArg > 1.0);  final double h0 = acos(acosArg);  final double h0Degrees = limitTo(toDegrees(h0), 180.0);  /* A.2.5. Calculate the approximate sunrise time, m1, in fraction of day,*/ m[1] = limitTo(m[0] - h0Degrees / 360.0, 1);  /* A.2.6. Calculate the approximate sunset time, m2, in fraction of day,*/ m[2] = limitTo(m[0] + h0Degrees / 360.0, 1);
* Calculate the times of sunrise, sun transit (solar noon), and sunset for a given day. The calculation is based * on the astronomical definition of sunrise and sunset, using a refraction correction of -0.8333°. * * @param day       GregorianCalendar of day for which sunrise/transit/sunset are to be calculated. *                  The time of day (hour, minute, second, millisecond) is ignored. * @param latitude  Observer's latitude, in degrees (negative south of equator). * @param longitude Observer's longitude, in degrees (negative west of Greenwich). * @param deltaT    Difference between earth rotation time and terrestrial time (or Universal Time and Terrestrial Time), *                  in seconds. See *                  <a href ="http://asa.usno.navy.mil/SecK/DeltaT.html">http:/*asa.usno.navy.mil/SecK/DeltaT.html</a>.*/ *                  For the year 2015, a reasonably accurate default would be 68. * @return An array of 3 GregorianCalendar values corresponding to the time of sunrise, sun transit, and sunset, * respectively. Note that the values for sunrise and sunset may be null: in this case, the sun stays above or * below the horizon all day.  <BUGS> final boolean noSunriseOrSet = (acosArg < -1.0) || (acosArg > 1.0); <BUGE>  final double h0 = acos(acosArg);  final double h0Degrees = limitTo(toDegrees(h0), 180.0);  /* A.2.5. Calculate the approximate sunrise time, m1, in fraction of day,*/ m[1] = limitTo(m[0] - h0Degrees / 360.0, 1);  /* A.2.6. Calculate the approximate sunset time, m2, in fraction of day,*/ m[2] = limitTo(m[0] + h0Degrees / 360.0, 1);  m[0] = limitTo(m[0], 1);  /* A.2.8. Calculate the sidereal time at Greenwich, in degrees, for the sun transit, sunrise, and sunset*/
* Calculate the times of sunrise, sun transit (solar noon), and sunset for a given day. The calculation is based * on the astronomical definition of sunrise and sunset, using a refraction correction of -0.8333°. * * @param day       GregorianCalendar of day for which sunrise/transit/sunset are to be calculated. *                  The time of day (hour, minute, second, millisecond) is ignored. * @param latitude  Observer's latitude, in degrees (negative south of equator). * @param longitude Observer's longitude, in degrees (negative west of Greenwich). * @param deltaT    Difference between earth rotation time and terrestrial time (or Universal Time and Terrestrial Time), *                  in seconds. See *                  <a href ="http://asa.usno.navy.mil/SecK/DeltaT.html">http:/*asa.usno.navy.mil/SecK/DeltaT.html</a>.*/ *                  For the year 2015, a reasonably accurate default would be 68. * @return An array of 3 GregorianCalendar values corresponding to the time of sunrise, sun transit, and sunset, * respectively. Note that the values for sunrise and sunset may be null: in this case, the sun stays above or * below the horizon all day.  <BUGS> final double h0 = acos(acosArg); <BUGE>  final double h0Degrees = limitTo(toDegrees(h0), 180.0);  /* A.2.5. Calculate the approximate sunrise time, m1, in fraction of day,*/ m[1] = limitTo(m[0] - h0Degrees / 360.0, 1);  /* A.2.6. Calculate the approximate sunset time, m2, in fraction of day,*/ m[2] = limitTo(m[0] + h0Degrees / 360.0, 1);  m[0] = limitTo(m[0], 1);  /* A.2.8. Calculate the sidereal time at Greenwich, in degrees, for the sun transit, sunrise, and sunset*/ final double[] nu = new double[3]; for (int i = 0; i < m.length; i++) {
* Calculate the times of sunrise, sun transit (solar noon), and sunset for a given day. The calculation is based * on the astronomical definition of sunrise and sunset, using a refraction correction of -0.8333°. * * @param day       GregorianCalendar of day for which sunrise/transit/sunset are to be calculated. *                  The time of day (hour, minute, second, millisecond) is ignored. * @param latitude  Observer's latitude, in degrees (negative south of equator). * @param longitude Observer's longitude, in degrees (negative west of Greenwich). * @param deltaT    Difference between earth rotation time and terrestrial time (or Universal Time and Terrestrial Time), *                  in seconds. See *                  <a href ="http://asa.usno.navy.mil/SecK/DeltaT.html">http:/*asa.usno.navy.mil/SecK/DeltaT.html</a>.*/ *                  For the year 2015, a reasonably accurate default would be 68. * @return An array of 3 GregorianCalendar values corresponding to the time of sunrise, sun transit, and sunset, * respectively. Note that the values for sunrise and sunset may be null: in this case, the sun stays above or * below the horizon all day.  <BUGS> final double h0Degrees = limitTo(toDegrees(h0), 180.0); <BUGE>  /* A.2.5. Calculate the approximate sunrise time, m1, in fraction of day,*/ m[1] = limitTo(m[0] - h0Degrees / 360.0, 1);  /* A.2.6. Calculate the approximate sunset time, m2, in fraction of day,*/ m[2] = limitTo(m[0] + h0Degrees / 360.0, 1);  m[0] = limitTo(m[0], 1);  /* A.2.8. Calculate the sidereal time at Greenwich, in degrees, for the sun transit, sunrise, and sunset*/ final double[] nu = new double[3]; for (int i = 0; i < m.length; i++) { nu[i] = nuDegrees + 360.985647 * m[i]; }
* Calculate the times of sunrise, sun transit (solar noon), and sunset for a given day. The calculation is based * on the astronomical definition of sunrise and sunset, using a refraction correction of -0.8333°. * * @param day       GregorianCalendar of day for which sunrise/transit/sunset are to be calculated. *                  The time of day (hour, minute, second, millisecond) is ignored. * @param latitude  Observer's latitude, in degrees (negative south of equator). * @param longitude Observer's longitude, in degrees (negative west of Greenwich). * @param deltaT    Difference between earth rotation time and terrestrial time (or Universal Time and Terrestrial Time), *                  in seconds. See *                  <a href ="http://asa.usno.navy.mil/SecK/DeltaT.html">http:/*asa.usno.navy.mil/SecK/DeltaT.html</a>.*/ *                  For the year 2015, a reasonably accurate default would be 68. * @return An array of 3 GregorianCalendar values corresponding to the time of sunrise, sun transit, and sunset, * respectively. Note that the values for sunrise and sunset may be null: in this case, the sun stays above or * below the horizon all day. /* A.2.5. Calculate the approximate sunrise time, m1, in fraction of day,*/ <BUGS> m[1] = limitTo(m[0] - h0Degrees / 360.0, 1); <BUGE>  /* A.2.6. Calculate the approximate sunset time, m2, in fraction of day,*/ m[2] = limitTo(m[0] + h0Degrees / 360.0, 1);  m[0] = limitTo(m[0], 1);  /* A.2.8. Calculate the sidereal time at Greenwich, in degrees, for the sun transit, sunrise, and sunset*/ final double[] nu = new double[3]; for (int i = 0; i < m.length; i++) { nu[i] = nuDegrees + 360.985647 * m[i]; }  /* A.2.9. Calculate the terms ni*/ final double[] n = new double[3];
* Calculate the times of sunrise, sun transit (solar noon), and sunset for a given day. The calculation is based * on the astronomical definition of sunrise and sunset, using a refraction correction of -0.8333°. * * @param day       GregorianCalendar of day for which sunrise/transit/sunset are to be calculated. *                  The time of day (hour, minute, second, millisecond) is ignored. * @param latitude  Observer's latitude, in degrees (negative south of equator). * @param longitude Observer's longitude, in degrees (negative west of Greenwich). * @param deltaT    Difference between earth rotation time and terrestrial time (or Universal Time and Terrestrial Time), *                  in seconds. See *                  <a href ="http://asa.usno.navy.mil/SecK/DeltaT.html">http:/*asa.usno.navy.mil/SecK/DeltaT.html</a>.*/ *                  For the year 2015, a reasonably accurate default would be 68. * @return An array of 3 GregorianCalendar values corresponding to the time of sunrise, sun transit, and sunset, * respectively. Note that the values for sunrise and sunset may be null: in this case, the sun stays above or * below the horizon all day. /* A.2.6. Calculate the approximate sunset time, m2, in fraction of day,*/ <BUGS> m[2] = limitTo(m[0] + h0Degrees / 360.0, 1); <BUGE>  m[0] = limitTo(m[0], 1);  /* A.2.8. Calculate the sidereal time at Greenwich, in degrees, for the sun transit, sunrise, and sunset*/ final double[] nu = new double[3]; for (int i = 0; i < m.length; i++) { nu[i] = nuDegrees + 360.985647 * m[i]; }  /* A.2.9. Calculate the terms ni*/ final double[] n = new double[3]; for (int i = 0; i < m.length; i++) { n[i] = m[i] + deltaT / 86400.0; }
* Calculate the times of sunrise, sun transit (solar noon), and sunset for a given day. The calculation is based * on the astronomical definition of sunrise and sunset, using a refraction correction of -0.8333°. * * @param day       GregorianCalendar of day for which sunrise/transit/sunset are to be calculated. *                  The time of day (hour, minute, second, millisecond) is ignored. * @param latitude  Observer's latitude, in degrees (negative south of equator). * @param longitude Observer's longitude, in degrees (negative west of Greenwich). * @param deltaT    Difference between earth rotation time and terrestrial time (or Universal Time and Terrestrial Time), *                  in seconds. See *                  <a href ="http://asa.usno.navy.mil/SecK/DeltaT.html">http:/*asa.usno.navy.mil/SecK/DeltaT.html</a>.*/ *                  For the year 2015, a reasonably accurate default would be 68. * @return An array of 3 GregorianCalendar values corresponding to the time of sunrise, sun transit, and sunset, * respectively. Note that the values for sunrise and sunset may be null: in this case, the sun stays above or * below the horizon all day.  <BUGS> m[0] = limitTo(m[0], 1); <BUGE>  /* A.2.8. Calculate the sidereal time at Greenwich, in degrees, for the sun transit, sunrise, and sunset*/ final double[] nu = new double[3]; for (int i = 0; i < m.length; i++) { nu[i] = nuDegrees + 360.985647 * m[i]; }  /* A.2.9. Calculate the terms ni*/ final double[] n = new double[3]; for (int i = 0; i < m.length; i++) { n[i] = m[i] + deltaT / 86400.0; }  /* A.2.10. Calculate the values alpha'i and delta'i , in degrees*/
* on the astronomical definition of sunrise and sunset, using a refraction correction of -0.8333°. * * @param day       GregorianCalendar of day for which sunrise/transit/sunset are to be calculated. *                  The time of day (hour, minute, second, millisecond) is ignored. * @param latitude  Observer's latitude, in degrees (negative south of equator). * @param longitude Observer's longitude, in degrees (negative west of Greenwich). * @param deltaT    Difference between earth rotation time and terrestrial time (or Universal Time and Terrestrial Time), *                  in seconds. See *                  <a href ="http://asa.usno.navy.mil/SecK/DeltaT.html">http:/*asa.usno.navy.mil/SecK/DeltaT.html</a>.*/ *                  For the year 2015, a reasonably accurate default would be 68. * @return An array of 3 GregorianCalendar values corresponding to the time of sunrise, sun transit, and sunset, * respectively. Note that the values for sunrise and sunset may be null: in this case, the sun stays above or * below the horizon all day. /* A.2.8. Calculate the sidereal time at Greenwich, in degrees, for the sun transit, sunrise, and sunset*/ <BUGS> final double[] nu = new double[3]; for (int i = 0; i < m.length; i++) { nu[i] = nuDegrees + 360.985647 * m[i]; <BUGE> }  /* A.2.9. Calculate the terms ni*/ final double[] n = new double[3]; for (int i = 0; i < m.length; i++) { n[i] = m[i] + deltaT / 86400.0; }  /* A.2.10. Calculate the values alpha'i and delta'i , in degrees*/ final double a = limitIfNecessary(alphaDeltas[1].alpha - alphaDeltas[0].alpha); final double aPrime = limitIfNecessary(alphaDeltas[1].delta - alphaDeltas[0].delta);  final double b = limitIfNecessary(alphaDeltas[2].alpha - alphaDeltas[1].alpha);
* on the astronomical definition of sunrise and sunset, using a refraction correction of -0.8333°. * * @param day       GregorianCalendar of day for which sunrise/transit/sunset are to be calculated. *                  The time of day (hour, minute, second, millisecond) is ignored. * @param latitude  Observer's latitude, in degrees (negative south of equator). * @param longitude Observer's longitude, in degrees (negative west of Greenwich). * @param deltaT    Difference between earth rotation time and terrestrial time (or Universal Time and Terrestrial Time), *                  in seconds. See *                  <a href ="http://asa.usno.navy.mil/SecK/DeltaT.html">http:/*asa.usno.navy.mil/SecK/DeltaT.html</a>.*/ *                  For the year 2015, a reasonably accurate default would be 68. * @return An array of 3 GregorianCalendar values corresponding to the time of sunrise, sun transit, and sunset, * respectively. Note that the values for sunrise and sunset may be null: in this case, the sun stays above or * below the horizon all day. /* A.2.9. Calculate the terms ni*/ <BUGS> final double[] n = new double[3]; for (int i = 0; i < m.length; i++) { n[i] = m[i] + deltaT / 86400.0; <BUGE> }  /* A.2.10. Calculate the values alpha'i and delta'i , in degrees*/ final double a = limitIfNecessary(alphaDeltas[1].alpha - alphaDeltas[0].alpha); final double aPrime = limitIfNecessary(alphaDeltas[1].delta - alphaDeltas[0].delta);  final double b = limitIfNecessary(alphaDeltas[2].alpha - alphaDeltas[1].alpha); final double bPrime = limitIfNecessary(alphaDeltas[2].delta - alphaDeltas[1].delta);  final double c = b - a; final double cPrime = bPrime - aPrime;  final AlphaDelta[] alphaDeltaPrimes = new AlphaDelta[3];
* Calculate the times of sunrise, sun transit (solar noon), and sunset for a given day. The calculation is based * on the astronomical definition of sunrise and sunset, using a refraction correction of -0.8333°. * * @param day       GregorianCalendar of day for which sunrise/transit/sunset are to be calculated. *                  The time of day (hour, minute, second, millisecond) is ignored. * @param latitude  Observer's latitude, in degrees (negative south of equator). * @param longitude Observer's longitude, in degrees (negative west of Greenwich). * @param deltaT    Difference between earth rotation time and terrestrial time (or Universal Time and Terrestrial Time), *                  in seconds. See *                  <a href ="http://asa.usno.navy.mil/SecK/DeltaT.html">http:/*asa.usno.navy.mil/SecK/DeltaT.html</a>.*/ *                  For the year 2015, a reasonably accurate default would be 68. * @return An array of 3 GregorianCalendar values corresponding to the time of sunrise, sun transit, and sunset, * respectively. Note that the values for sunrise and sunset may be null: in this case, the sun stays above or * below the horizon all day. /* A.2.10. Calculate the values alpha'i and delta'i , in degrees*/ <BUGS> final double a = limitIfNecessary(alphaDeltas[1].alpha - alphaDeltas[0].alpha); final double aPrime = limitIfNecessary(alphaDeltas[1].delta - alphaDeltas[0].delta); <BUGE>  final double b = limitIfNecessary(alphaDeltas[2].alpha - alphaDeltas[1].alpha); final double bPrime = limitIfNecessary(alphaDeltas[2].delta - alphaDeltas[1].delta);  final double c = b - a; final double cPrime = bPrime - aPrime;  final AlphaDelta[] alphaDeltaPrimes = new AlphaDelta[3]; for (int i = 0; i < alphaDeltaPrimes.length; i++) { double alphaPrimeI = alphaDeltas[1].alpha + (n[i] * (a + b + c * n[i])) / 2.0; double deltaPrimeI =
* Calculate the times of sunrise, sun transit (solar noon), and sunset for a given day. The calculation is based * on the astronomical definition of sunrise and sunset, using a refraction correction of -0.8333°. * * @param day       GregorianCalendar of day for which sunrise/transit/sunset are to be calculated. *                  The time of day (hour, minute, second, millisecond) is ignored. * @param latitude  Observer's latitude, in degrees (negative south of equator). * @param longitude Observer's longitude, in degrees (negative west of Greenwich). * @param deltaT    Difference between earth rotation time and terrestrial time (or Universal Time and Terrestrial Time), *                  in seconds. See *                  <a href ="http://asa.usno.navy.mil/SecK/DeltaT.html">http:/*asa.usno.navy.mil/SecK/DeltaT.html</a>.*/ *                  For the year 2015, a reasonably accurate default would be 68. * @return An array of 3 GregorianCalendar values corresponding to the time of sunrise, sun transit, and sunset, * respectively. Note that the values for sunrise and sunset may be null: in this case, the sun stays above or * below the horizon all day.  <BUGS> final double b = limitIfNecessary(alphaDeltas[2].alpha - alphaDeltas[1].alpha); final double bPrime = limitIfNecessary(alphaDeltas[2].delta - alphaDeltas[1].delta); <BUGE>  final double c = b - a; final double cPrime = bPrime - aPrime;  final AlphaDelta[] alphaDeltaPrimes = new AlphaDelta[3]; for (int i = 0; i < alphaDeltaPrimes.length; i++) { double alphaPrimeI = alphaDeltas[1].alpha + (n[i] * (a + b + c * n[i])) / 2.0; double deltaPrimeI = alphaDeltas[1].delta + (n[i] * (aPrime + bPrime + cPrime * n[i])) / 2.0;
* Calculate the times of sunrise, sun transit (solar noon), and sunset for a given day. The calculation is based * on the astronomical definition of sunrise and sunset, using a refraction correction of -0.8333°. * * @param day       GregorianCalendar of day for which sunrise/transit/sunset are to be calculated. *                  The time of day (hour, minute, second, millisecond) is ignored. * @param latitude  Observer's latitude, in degrees (negative south of equator). * @param longitude Observer's longitude, in degrees (negative west of Greenwich). * @param deltaT    Difference between earth rotation time and terrestrial time (or Universal Time and Terrestrial Time), *                  in seconds. See *                  <a href ="http://asa.usno.navy.mil/SecK/DeltaT.html">http:/*asa.usno.navy.mil/SecK/DeltaT.html</a>.*/ *                  For the year 2015, a reasonably accurate default would be 68. * @return An array of 3 GregorianCalendar values corresponding to the time of sunrise, sun transit, and sunset, * respectively. Note that the values for sunrise and sunset may be null: in this case, the sun stays above or * below the horizon all day.  <BUGS> final double c = b - a; final double cPrime = bPrime - aPrime; <BUGE>  final AlphaDelta[] alphaDeltaPrimes = new AlphaDelta[3]; for (int i = 0; i < alphaDeltaPrimes.length; i++) { double alphaPrimeI = alphaDeltas[1].alpha + (n[i] * (a + b + c * n[i])) / 2.0; double deltaPrimeI = alphaDeltas[1].delta + (n[i] * (aPrime + bPrime + cPrime * n[i])) / 2.0;  alphaDeltaPrimes[i] = new AlphaDelta(alphaPrimeI, deltaPrimeI); }
* on the astronomical definition of sunrise and sunset, using a refraction correction of -0.8333°. * * @param day       GregorianCalendar of day for which sunrise/transit/sunset are to be calculated. *                  The time of day (hour, minute, second, millisecond) is ignored. * @param latitude  Observer's latitude, in degrees (negative south of equator). * @param longitude Observer's longitude, in degrees (negative west of Greenwich). * @param deltaT    Difference between earth rotation time and terrestrial time (or Universal Time and Terrestrial Time), *                  in seconds. See *                  <a href ="http://asa.usno.navy.mil/SecK/DeltaT.html">http:/*asa.usno.navy.mil/SecK/DeltaT.html</a>.*/ *                  For the year 2015, a reasonably accurate default would be 68. * @return An array of 3 GregorianCalendar values corresponding to the time of sunrise, sun transit, and sunset, * respectively. Note that the values for sunrise and sunset may be null: in this case, the sun stays above or * below the horizon all day.  <BUGS> final AlphaDelta[] alphaDeltaPrimes = new AlphaDelta[3]; for (int i = 0; i < alphaDeltaPrimes.length; i++) { double alphaPrimeI = <BUGE> alphaDeltas[1].alpha + (n[i] * (a + b + c * n[i])) / 2.0; double deltaPrimeI = alphaDeltas[1].delta + (n[i] * (aPrime + bPrime + cPrime * n[i])) / 2.0;  alphaDeltaPrimes[i] = new AlphaDelta(alphaPrimeI, deltaPrimeI); }  /* A.2.11. Calculate the local hour angle for the sun transit, sunrise, and sunset*/ final double[] hPrime = new double[3]; for (int i = 0; i < hPrime.length; i++) { double hPrimeI = nu[i] + longitude - alphaDeltaPrimes[i].alpha;
* Calculate the times of sunrise, sun transit (solar noon), and sunset for a given day. The calculation is based * on the astronomical definition of sunrise and sunset, using a refraction correction of -0.8333°. * * @param day       GregorianCalendar of day for which sunrise/transit/sunset are to be calculated. *                  The time of day (hour, minute, second, millisecond) is ignored. * @param latitude  Observer's latitude, in degrees (negative south of equator). * @param longitude Observer's longitude, in degrees (negative west of Greenwich). * @param deltaT    Difference between earth rotation time and terrestrial time (or Universal Time and Terrestrial Time), *                  in seconds. See *                  <a href ="http://asa.usno.navy.mil/SecK/DeltaT.html">http:/*asa.usno.navy.mil/SecK/DeltaT.html</a>.*/ *                  For the year 2015, a reasonably accurate default would be 68. * @return An array of 3 GregorianCalendar values corresponding to the time of sunrise, sun transit, and sunset, * respectively. Note that the values for sunrise and sunset may be null: in this case, the sun stays above or * below the horizon all day. (n[i] * (a + b + c * n[i])) / 2.0; <BUGS> double deltaPrimeI = <BUGE> alphaDeltas[1].delta + (n[i] * (aPrime + bPrime + cPrime * n[i])) / 2.0;  alphaDeltaPrimes[i] = new AlphaDelta(alphaPrimeI, deltaPrimeI); }  /* A.2.11. Calculate the local hour angle for the sun transit, sunrise, and sunset*/ final double[] hPrime = new double[3]; for (int i = 0; i < hPrime.length; i++) { double hPrimeI = nu[i] + longitude - alphaDeltaPrimes[i].alpha; hPrime[i] = limitHprime(hPrimeI); }  /* A.2.12. Calculate the sun altitude for the sun transit, sunrise, and sunset, hi*/
* Calculate the times of sunrise, sun transit (solar noon), and sunset for a given day. The calculation is based * on the astronomical definition of sunrise and sunset, using a refraction correction of -0.8333°. * * @param day       GregorianCalendar of day for which sunrise/transit/sunset are to be calculated. *                  The time of day (hour, minute, second, millisecond) is ignored. * @param latitude  Observer's latitude, in degrees (negative south of equator). * @param longitude Observer's longitude, in degrees (negative west of Greenwich). * @param deltaT    Difference between earth rotation time and terrestrial time (or Universal Time and Terrestrial Time), *                  in seconds. See *                  <a href ="http://asa.usno.navy.mil/SecK/DeltaT.html">http:/*asa.usno.navy.mil/SecK/DeltaT.html</a>.*/ *                  For the year 2015, a reasonably accurate default would be 68. * @return An array of 3 GregorianCalendar values corresponding to the time of sunrise, sun transit, and sunset, * respectively. Note that the values for sunrise and sunset may be null: in this case, the sun stays above or * below the horizon all day.  <BUGS> alphaDeltaPrimes[i] = new AlphaDelta(alphaPrimeI, deltaPrimeI); <BUGE> }  /* A.2.11. Calculate the local hour angle for the sun transit, sunrise, and sunset*/ final double[] hPrime = new double[3]; for (int i = 0; i < hPrime.length; i++) { double hPrimeI = nu[i] + longitude - alphaDeltaPrimes[i].alpha; hPrime[i] = limitHprime(hPrimeI); }  /* A.2.12. Calculate the sun altitude for the sun transit, sunrise, and sunset, hi*/ final double[] h = new double[3]; for (int i = 0; i < h.length; i++) { double deltaPrimeRad = toRadians(alphaDeltaPrimes[i].delta);
* on the astronomical definition of sunrise and sunset, using a refraction correction of -0.8333°. * * @param day       GregorianCalendar of day for which sunrise/transit/sunset are to be calculated. *                  The time of day (hour, minute, second, millisecond) is ignored. * @param latitude  Observer's latitude, in degrees (negative south of equator). * @param longitude Observer's longitude, in degrees (negative west of Greenwich). * @param deltaT    Difference between earth rotation time and terrestrial time (or Universal Time and Terrestrial Time), *                  in seconds. See *                  <a href ="http://asa.usno.navy.mil/SecK/DeltaT.html">http:/*asa.usno.navy.mil/SecK/DeltaT.html</a>.*/ *                  For the year 2015, a reasonably accurate default would be 68. * @return An array of 3 GregorianCalendar values corresponding to the time of sunrise, sun transit, and sunset, * respectively. Note that the values for sunrise and sunset may be null: in this case, the sun stays above or * below the horizon all day. /* A.2.11. Calculate the local hour angle for the sun transit, sunrise, and sunset*/ <BUGS> final double[] hPrime = new double[3]; for (int i = 0; i < hPrime.length; i++) { double hPrimeI = nu[i] + longitude - alphaDeltaPrimes[i].alpha; hPrime[i] = limitHprime(hPrimeI); <BUGE> }  /* A.2.12. Calculate the sun altitude for the sun transit, sunrise, and sunset, hi*/ final double[] h = new double[3]; for (int i = 0; i < h.length; i++) { double deltaPrimeRad = toRadians(alphaDeltaPrimes[i].delta);  h[i] = toDegrees(asin( sin(phi) * sin(deltaPrimeRad) + cos(phi) * cos(deltaPrimeRad) * cos(toRadians(hPrime[i])) )); }
* on the astronomical definition of sunrise and sunset, using a refraction correction of -0.8333°. * * @param day       GregorianCalendar of day for which sunrise/transit/sunset are to be calculated. *                  The time of day (hour, minute, second, millisecond) is ignored. * @param latitude  Observer's latitude, in degrees (negative south of equator). * @param longitude Observer's longitude, in degrees (negative west of Greenwich). * @param deltaT    Difference between earth rotation time and terrestrial time (or Universal Time and Terrestrial Time), *                  in seconds. See *                  <a href ="http://asa.usno.navy.mil/SecK/DeltaT.html">http:/*asa.usno.navy.mil/SecK/DeltaT.html</a>.*/ *                  For the year 2015, a reasonably accurate default would be 68. * @return An array of 3 GregorianCalendar values corresponding to the time of sunrise, sun transit, and sunset, * respectively. Note that the values for sunrise and sunset may be null: in this case, the sun stays above or * below the horizon all day. /* A.2.12. Calculate the sun altitude for the sun transit, sunrise, and sunset, hi*/ <BUGS> final double[] h = new double[3]; for (int i = 0; i < h.length; i++) { double deltaPrimeRad = toRadians(alphaDeltaPrimes[i].delta); <BUGE>  h[i] = toDegrees(asin( sin(phi) * sin(deltaPrimeRad) + cos(phi) * cos(deltaPrimeRad) * cos(toRadians(hPrime[i])) )); }  /* A.2.13. Calculate the sun transit, T (in fraction of day)*/ final double t = m[0] - hPrime[0] / 360.0;  /* A.2.14. Calculate the sunrise, R (in fraction of day)*/ final double r = m[1] + (h[1] - HPRIME_0) /
* on the astronomical definition of sunrise and sunset, using a refraction correction of -0.8333°. * * @param day       GregorianCalendar of day for which sunrise/transit/sunset are to be calculated. *                  The time of day (hour, minute, second, millisecond) is ignored. * @param latitude  Observer's latitude, in degrees (negative south of equator). * @param longitude Observer's longitude, in degrees (negative west of Greenwich). * @param deltaT    Difference between earth rotation time and terrestrial time (or Universal Time and Terrestrial Time), *                  in seconds. See *                  <a href ="http://asa.usno.navy.mil/SecK/DeltaT.html">http:/*asa.usno.navy.mil/SecK/DeltaT.html</a>.*/ *                  For the year 2015, a reasonably accurate default would be 68. * @return An array of 3 GregorianCalendar values corresponding to the time of sunrise, sun transit, and sunset, * respectively. Note that the values for sunrise and sunset may be null: in this case, the sun stays above or * below the horizon all day.  <BUGS> h[i] = toDegrees(asin( sin(phi) * sin(deltaPrimeRad) + cos(phi) * cos(deltaPrimeRad) * cos(toRadians(hPrime[i])) <BUGE> )); }  /* A.2.13. Calculate the sun transit, T (in fraction of day)*/ final double t = m[0] - hPrime[0] / 360.0;  /* A.2.14. Calculate the sunrise, R (in fraction of day)*/ final double r = m[1] + (h[1] - HPRIME_0) / (360.0 * cos(toRadians(alphaDeltaPrimes[1].delta)) * cos(phi) * sin(toRadians(hPrime[1])));  /* A.2.15. Calculate the sunset, S (in fraction of day)*/ final double s = m[2] +
* Calculate the times of sunrise, sun transit (solar noon), and sunset for a given day. The calculation is based * on the astronomical definition of sunrise and sunset, using a refraction correction of -0.8333°. * * @param day       GregorianCalendar of day for which sunrise/transit/sunset are to be calculated. *                  The time of day (hour, minute, second, millisecond) is ignored. * @param latitude  Observer's latitude, in degrees (negative south of equator). * @param longitude Observer's longitude, in degrees (negative west of Greenwich). * @param deltaT    Difference between earth rotation time and terrestrial time (or Universal Time and Terrestrial Time), *                  in seconds. See *                  <a href ="http://asa.usno.navy.mil/SecK/DeltaT.html">http:/*asa.usno.navy.mil/SecK/DeltaT.html</a>.*/ *                  For the year 2015, a reasonably accurate default would be 68. * @return An array of 3 GregorianCalendar values corresponding to the time of sunrise, sun transit, and sunset, * respectively. Note that the values for sunrise and sunset may be null: in this case, the sun stays above or * below the horizon all day. /* A.2.13. Calculate the sun transit, T (in fraction of day)*/ <BUGS> final double t = m[0] - hPrime[0] / 360.0; <BUGE>  /* A.2.14. Calculate the sunrise, R (in fraction of day)*/ final double r = m[1] + (h[1] - HPRIME_0) / (360.0 * cos(toRadians(alphaDeltaPrimes[1].delta)) * cos(phi) * sin(toRadians(hPrime[1])));  /* A.2.15. Calculate the sunset, S (in fraction of day)*/ final double s = m[2] + (h[2] - HPRIME_0) / (360.0 * cos(toRadians(alphaDeltaPrimes[2].delta)) * cos(phi) * sin(toRadians(hPrime[2])));  return new GregorianCalendar[]{ noSunriseOrSet ? null : addFractionOfDay(day, r), addFractionOfDay(day, t),
* Calculate the times of sunrise, sun transit (solar noon), and sunset for a given day. The calculation is based * on the astronomical definition of sunrise and sunset, using a refraction correction of -0.8333°. * * @param day       GregorianCalendar of day for which sunrise/transit/sunset are to be calculated. *                  The time of day (hour, minute, second, millisecond) is ignored. * @param latitude  Observer's latitude, in degrees (negative south of equator). * @param longitude Observer's longitude, in degrees (negative west of Greenwich). * @param deltaT    Difference between earth rotation time and terrestrial time (or Universal Time and Terrestrial Time), *                  in seconds. See *                  <a href ="http://asa.usno.navy.mil/SecK/DeltaT.html">http:/*asa.usno.navy.mil/SecK/DeltaT.html</a>.*/ *                  For the year 2015, a reasonably accurate default would be 68. * @return An array of 3 GregorianCalendar values corresponding to the time of sunrise, sun transit, and sunset, * respectively. Note that the values for sunrise and sunset may be null: in this case, the sun stays above or * below the horizon all day. /* A.2.14. Calculate the sunrise, R (in fraction of day)*/ <BUGS> final double r = m[1] + <BUGE> (h[1] - HPRIME_0) / (360.0 * cos(toRadians(alphaDeltaPrimes[1].delta)) * cos(phi) * sin(toRadians(hPrime[1])));  /* A.2.15. Calculate the sunset, S (in fraction of day)*/ final double s = m[2] + (h[2] - HPRIME_0) / (360.0 * cos(toRadians(alphaDeltaPrimes[2].delta)) * cos(phi) * sin(toRadians(hPrime[2])));  return new GregorianCalendar[]{ noSunriseOrSet ? null : addFractionOfDay(day, r), addFractionOfDay(day, t), noSunriseOrSet ? null : addFractionOfDay(day, s) }; }
* Calculate the times of sunrise, sun transit (solar noon), and sunset for a given day. The calculation is based * on the astronomical definition of sunrise and sunset, using a refraction correction of -0.8333°. * * @param day       GregorianCalendar of day for which sunrise/transit/sunset are to be calculated. *                  The time of day (hour, minute, second, millisecond) is ignored. * @param latitude  Observer's latitude, in degrees (negative south of equator). * @param longitude Observer's longitude, in degrees (negative west of Greenwich). * @param deltaT    Difference between earth rotation time and terrestrial time (or Universal Time and Terrestrial Time), *                  in seconds. See *                  <a href ="http://asa.usno.navy.mil/SecK/DeltaT.html">http:/*asa.usno.navy.mil/SecK/DeltaT.html</a>.*/ *                  For the year 2015, a reasonably accurate default would be 68. * @return An array of 3 GregorianCalendar values corresponding to the time of sunrise, sun transit, and sunset, * respectively. Note that the values for sunrise and sunset may be null: in this case, the sun stays above or * below the horizon all day. (h[1] - HPRIME_0) / <BUGS> (360.0 * cos(toRadians(alphaDeltaPrimes[1].delta)) * cos(phi) * sin(toRadians(hPrime[1]))); <BUGE>  /* A.2.15. Calculate the sunset, S (in fraction of day)*/ final double s = m[2] + (h[2] - HPRIME_0) / (360.0 * cos(toRadians(alphaDeltaPrimes[2].delta)) * cos(phi) * sin(toRadians(hPrime[2])));  return new GregorianCalendar[]{ noSunriseOrSet ? null : addFractionOfDay(day, r), addFractionOfDay(day, t), noSunriseOrSet ? null : addFractionOfDay(day, s) }; }  private static GregorianCalendar addFractionOfDay(GregorianCalendar day, final double fraction) {
* Calculate the times of sunrise, sun transit (solar noon), and sunset for a given day. The calculation is based * on the astronomical definition of sunrise and sunset, using a refraction correction of -0.8333°. * * @param day       GregorianCalendar of day for which sunrise/transit/sunset are to be calculated. *                  The time of day (hour, minute, second, millisecond) is ignored. * @param latitude  Observer's latitude, in degrees (negative south of equator). * @param longitude Observer's longitude, in degrees (negative west of Greenwich). * @param deltaT    Difference between earth rotation time and terrestrial time (or Universal Time and Terrestrial Time), *                  in seconds. See *                  <a href ="http://asa.usno.navy.mil/SecK/DeltaT.html">http:/*asa.usno.navy.mil/SecK/DeltaT.html</a>.*/ *                  For the year 2015, a reasonably accurate default would be 68. * @return An array of 3 GregorianCalendar values corresponding to the time of sunrise, sun transit, and sunset, * respectively. Note that the values for sunrise and sunset may be null: in this case, the sun stays above or * below the horizon all day. /* A.2.15. Calculate the sunset, S (in fraction of day)*/ <BUGS> final double s = m[2] + <BUGE> (h[2] - HPRIME_0) / (360.0 * cos(toRadians(alphaDeltaPrimes[2].delta)) * cos(phi) * sin(toRadians(hPrime[2])));  return new GregorianCalendar[]{ noSunriseOrSet ? null : addFractionOfDay(day, r), addFractionOfDay(day, t), noSunriseOrSet ? null : addFractionOfDay(day, s) }; }  private static GregorianCalendar addFractionOfDay(GregorianCalendar day, final double fraction) { GregorianCalendar dayStart = (GregorianCalendar) day.clone(); dayStart.set(Calendar.MINUTE, 0); dayStart.set(Calendar.SECOND, 0);
* Calculate the times of sunrise, sun transit (solar noon), and sunset for a given day. The calculation is based * on the astronomical definition of sunrise and sunset, using a refraction correction of -0.8333°. * * @param day       GregorianCalendar of day for which sunrise/transit/sunset are to be calculated. *                  The time of day (hour, minute, second, millisecond) is ignored. * @param latitude  Observer's latitude, in degrees (negative south of equator). * @param longitude Observer's longitude, in degrees (negative west of Greenwich). * @param deltaT    Difference between earth rotation time and terrestrial time (or Universal Time and Terrestrial Time), *                  in seconds. See *                  <a href ="http://asa.usno.navy.mil/SecK/DeltaT.html">http:/*asa.usno.navy.mil/SecK/DeltaT.html</a>.*/ *                  For the year 2015, a reasonably accurate default would be 68. * @return An array of 3 GregorianCalendar values corresponding to the time of sunrise, sun transit, and sunset, * respectively. Note that the values for sunrise and sunset may be null: in this case, the sun stays above or * below the horizon all day. (h[2] - HPRIME_0) / <BUGS> (360.0 * cos(toRadians(alphaDeltaPrimes[2].delta)) * cos(phi) * sin(toRadians(hPrime[2]))); <BUGE>  return new GregorianCalendar[]{ noSunriseOrSet ? null : addFractionOfDay(day, r), addFractionOfDay(day, t), noSunriseOrSet ? null : addFractionOfDay(day, s) }; }  private static GregorianCalendar addFractionOfDay(GregorianCalendar day, final double fraction) { GregorianCalendar dayStart = (GregorianCalendar) day.clone(); dayStart.set(Calendar.MINUTE, 0); dayStart.set(Calendar.SECOND, 0); dayStart.set(Calendar.MILLISECOND, 0); dayStart.set(Calendar.HOUR_OF_DAY, 12);
* on the astronomical definition of sunrise and sunset, using a refraction correction of -0.8333°. * * @param day       GregorianCalendar of day for which sunrise/transit/sunset are to be calculated. *                  The time of day (hour, minute, second, millisecond) is ignored. * @param latitude  Observer's latitude, in degrees (negative south of equator). * @param longitude Observer's longitude, in degrees (negative west of Greenwich). * @param deltaT    Difference between earth rotation time and terrestrial time (or Universal Time and Terrestrial Time), *                  in seconds. See *                  <a href ="http://asa.usno.navy.mil/SecK/DeltaT.html">http:/*asa.usno.navy.mil/SecK/DeltaT.html</a>.*/ *                  For the year 2015, a reasonably accurate default would be 68. * @return An array of 3 GregorianCalendar values corresponding to the time of sunrise, sun transit, and sunset, * respectively. Note that the values for sunrise and sunset may be null: in this case, the sun stays above or * below the horizon all day.  <BUGS> return new GregorianCalendar[]{ noSunriseOrSet ? null : addFractionOfDay(day, r), addFractionOfDay(day, t), noSunriseOrSet ? null : addFractionOfDay(day, s) <BUGE> }; }  private static GregorianCalendar addFractionOfDay(GregorianCalendar day, final double fraction) { GregorianCalendar dayStart = (GregorianCalendar) day.clone(); dayStart.set(Calendar.MINUTE, 0); dayStart.set(Calendar.SECOND, 0); dayStart.set(Calendar.MILLISECOND, 0); dayStart.set(Calendar.HOUR_OF_DAY, 12); final int offset = day.getTimeZone().getOffset(dayStart.getTimeInMillis());  dayStart.set(Calendar.HOUR_OF_DAY, 0);
*/ public static GregorianCalendar[] calculateSunriseTransitSet(final GregorianCalendar day, final double latitude, final double longitude, final double deltaT) { <BUGS> final GregorianCalendar dayStart = startOfDayUT(day); final JulianDate jd = new JulianDate(dayStart, 0); <BUGE>  final double phi = toRadians(latitude);  /* A.2.1. Calculate the apparent sidereal time at Greenwich at 0 UT, nu (in degrees)*/ final double jce = jd.getJulianEphemerisCentury(); final double xTerms[] = calculateNutationTerms(jce); final double[] deltaPsiI = calculateDeltaPsiI(jce, xTerms); final double[] deltaEpsilonI = calculateDeltaEpsilonI(jce, xTerms); final double deltaPsi = calculateDeltaPsiEpsilon(deltaPsiI); final double deltaEpsilon = calculateDeltaPsiEpsilon(deltaEpsilonI); final double epsilonDegrees = calculateTrueObliquityOfEcliptic(jd, deltaEpsilon);  final double nuDegrees = calculateApparentSiderealTimeAtGreenwich(jd, deltaPsi, epsilonDegrees);  /* A.2.2. Calculate the geocentric right ascension and declination at 0 TT for day before, same day, next day*/ final AlphaDelta[] alphaDeltas = new AlphaDelta[3]; for (int i = 0; i < alphaDeltas.length; i++) { JulianDate currentJd = new JulianDate(jd.getJulianDate() + i - 1, 0); double currentJme = currentJd.getJulianEphemerisMillennium(); AlphaDelta ad = calculateAlphaDelta(currentJme, deltaPsi, epsilonDegrees); alphaDeltas[i] = ad; }
*/ public static GregorianCalendar[] calculateSunriseTransitSet(final GregorianCalendar day, final double latitude, final double longitude, final double deltaT) { final GregorianCalendar dayStart = startOfDayUT(day); final JulianDate jd = new JulianDate(dayStart, 0);  <BUGS> final double phi = toRadians(latitude); <BUGE>  /* A.2.1. Calculate the apparent sidereal time at Greenwich at 0 UT, nu (in degrees)*/ final double jce = jd.getJulianEphemerisCentury(); final double xTerms[] = calculateNutationTerms(jce); final double[] deltaPsiI = calculateDeltaPsiI(jce, xTerms); final double[] deltaEpsilonI = calculateDeltaEpsilonI(jce, xTerms); final double deltaPsi = calculateDeltaPsiEpsilon(deltaPsiI); final double deltaEpsilon = calculateDeltaPsiEpsilon(deltaEpsilonI); final double epsilonDegrees = calculateTrueObliquityOfEcliptic(jd, deltaEpsilon);  final double nuDegrees = calculateApparentSiderealTimeAtGreenwich(jd, deltaPsi, epsilonDegrees);  /* A.2.2. Calculate the geocentric right ascension and declination at 0 TT for day before, same day, next day*/ final AlphaDelta[] alphaDeltas = new AlphaDelta[3]; for (int i = 0; i < alphaDeltas.length; i++) { JulianDate currentJd = new JulianDate(jd.getJulianDate() + i - 1, 0); double currentJme = currentJd.getJulianEphemerisMillennium(); AlphaDelta ad = calculateAlphaDelta(currentJme, deltaPsi, epsilonDegrees); alphaDeltas[i] = ad; }
*/ public static GregorianCalendar[] calculateSunriseTransitSet(final GregorianCalendar day, final double latitude, final double longitude, final double deltaT) { final GregorianCalendar dayStart = startOfDayUT(day); final JulianDate jd = new JulianDate(dayStart, 0);  final double phi = toRadians(latitude);  /* A.2.1. Calculate the apparent sidereal time at Greenwich at 0 UT, nu (in degrees)*/ <BUGS> final double jce = jd.getJulianEphemerisCentury(); final double xTerms[] = calculateNutationTerms(jce); final double[] deltaPsiI = calculateDeltaPsiI(jce, xTerms); final double[] deltaEpsilonI = calculateDeltaEpsilonI(jce, xTerms); final double deltaPsi = calculateDeltaPsiEpsilon(deltaPsiI); final double deltaEpsilon = calculateDeltaPsiEpsilon(deltaEpsilonI); final double epsilonDegrees = calculateTrueObliquityOfEcliptic(jd, deltaEpsilon); <BUGE>  final double nuDegrees = calculateApparentSiderealTimeAtGreenwich(jd, deltaPsi, epsilonDegrees);  /* A.2.2. Calculate the geocentric right ascension and declination at 0 TT for day before, same day, next day*/ final AlphaDelta[] alphaDeltas = new AlphaDelta[3]; for (int i = 0; i < alphaDeltas.length; i++) { JulianDate currentJd = new JulianDate(jd.getJulianDate() + i - 1, 0); double currentJme = currentJd.getJulianEphemerisMillennium(); AlphaDelta ad = calculateAlphaDelta(currentJme, deltaPsi, epsilonDegrees); alphaDeltas[i] = ad; }
*/ public static GregorianCalendar[] calculateSunriseTransitSet(final GregorianCalendar day, final double latitude, final double longitude, final double deltaT) { final GregorianCalendar dayStart = startOfDayUT(day); final JulianDate jd = new JulianDate(dayStart, 0);  final double phi = toRadians(latitude);  /* A.2.1. Calculate the apparent sidereal time at Greenwich at 0 UT, nu (in degrees)*/ final double jce = jd.getJulianEphemerisCentury(); final double xTerms[] = calculateNutationTerms(jce); final double[] deltaPsiI = calculateDeltaPsiI(jce, xTerms); final double[] deltaEpsilonI = calculateDeltaEpsilonI(jce, xTerms); final double deltaPsi = calculateDeltaPsiEpsilon(deltaPsiI); final double deltaEpsilon = calculateDeltaPsiEpsilon(deltaEpsilonI); final double epsilonDegrees = calculateTrueObliquityOfEcliptic(jd, deltaEpsilon);  <BUGS> final double nuDegrees = calculateApparentSiderealTimeAtGreenwich(jd, deltaPsi, epsilonDegrees); <BUGE>  /* A.2.2. Calculate the geocentric right ascension and declination at 0 TT for day before, same day, next day*/ final AlphaDelta[] alphaDeltas = new AlphaDelta[3]; for (int i = 0; i < alphaDeltas.length; i++) { JulianDate currentJd = new JulianDate(jd.getJulianDate() + i - 1, 0); double currentJme = currentJd.getJulianEphemerisMillennium(); AlphaDelta ad = calculateAlphaDelta(currentJme, deltaPsi, epsilonDegrees); alphaDeltas[i] = ad; }
*/ public static GregorianCalendar[] calculateSunriseTransitSet(final GregorianCalendar day, final double latitude, final double longitude, final double deltaT) { final GregorianCalendar dayStart = startOfDayUT(day); final JulianDate jd = new JulianDate(dayStart, 0);  final double phi = toRadians(latitude);  /* A.2.1. Calculate the apparent sidereal time at Greenwich at 0 UT, nu (in degrees)*/ final double jce = jd.getJulianEphemerisCentury(); final double xTerms[] = calculateNutationTerms(jce); final double[] deltaPsiI = calculateDeltaPsiI(jce, xTerms); final double[] deltaEpsilonI = calculateDeltaEpsilonI(jce, xTerms); final double deltaPsi = calculateDeltaPsiEpsilon(deltaPsiI); final double deltaEpsilon = calculateDeltaPsiEpsilon(deltaEpsilonI); final double epsilonDegrees = calculateTrueObliquityOfEcliptic(jd, deltaEpsilon);  final double nuDegrees = calculateApparentSiderealTimeAtGreenwich(jd, deltaPsi, epsilonDegrees);  /* A.2.2. Calculate the geocentric right ascension and declination at 0 TT for day before, same day, next day*/ <BUGS> final AlphaDelta[] alphaDeltas = new AlphaDelta[3]; for (int i = 0; i < alphaDeltas.length; i++) { JulianDate currentJd = new JulianDate(jd.getJulianDate() + i - 1, 0); double currentJme = currentJd.getJulianEphemerisMillennium(); AlphaDelta ad = calculateAlphaDelta(currentJme, deltaPsi, epsilonDegrees); alphaDeltas[i] = ad; <BUGE> }
*/ public static GregorianCalendar[] calculateSunriseTransitSet(final GregorianCalendar day, final double latitude, final double longitude, final double deltaT) { final GregorianCalendar dayStart = startOfDayUT(day); final JulianDate jd = new JulianDate(dayStart, 0);  final double phi = toRadians(latitude);  /* A.2.1. Calculate the apparent sidereal time at Greenwich at 0 UT, nu (in degrees)*/ final double jce = jd.getJulianEphemerisCentury(); final double xTerms[] = calculateNutationTerms(jce); final double[] deltaPsiI = calculateDeltaPsiI(jce, xTerms); final double[] deltaEpsilonI = calculateDeltaEpsilonI(jce, xTerms); final double deltaPsi = calculateDeltaPsiEpsilon(deltaPsiI); final double deltaEpsilon = calculateDeltaPsiEpsilon(deltaEpsilonI); final double epsilonDegrees = calculateTrueObliquityOfEcliptic(jd, deltaEpsilon);  final double nuDegrees = calculateApparentSiderealTimeAtGreenwich(jd, deltaPsi, epsilonDegrees);  /* A.2.2. Calculate the geocentric right ascension and declination at 0 TT for day before, same day, next day*/ final AlphaDelta[] alphaDeltas = new AlphaDelta[3]; for (int i = 0; i < alphaDeltas.length; i++) { JulianDate currentJd = new JulianDate(jd.getJulianDate() + i - 1, 0); double currentJme = currentJd.getJulianEphemerisMillennium(); AlphaDelta ad = calculateAlphaDelta(currentJme, deltaPsi, epsilonDegrees); alphaDeltas[i] = ad; }
* @param day GregorianCalendar of day for which sunrise/transit/sunset are to be calculated. *            The time of day (hour, minute, second, millisecond) is ignored. * @param latitude *            Observer's latitude, in degrees (negative south of equator). * @param longitude *            Observer's longitude, in degrees (negative west of Greenwich). * @param deltaT *            Difference between earth rotation time and terrestrial time (or Universal Time and Terrestrial Time), *            in seconds. See *            <a href ="http://asa.usno.navy.mil/SecK/DeltaT.html">http:/*asa.usno.navy.mil/SecK/DeltaT.html</a>.*/ *            For the year 2015, a reasonably accurate default would be 68. * @return An array of 3 GregorianCalendar values corresponding to the time of sunrise, sun transit, and sunset, * respectively. Note that the values for sunrise and sunset may be null: in this case, the sun stays above or * below the horizon all day. /* A.2.3. Calculate the approximate sun transit time, m0, in fraction of day*/ <BUGS> m[0] = (alphaDeltas[1].alpha - longitude - nuDegrees) / 360; <BUGE>  /* A.2.4. Calculate the local hour angle H0 corresponding to ...*/ final double acosArg = (SIN_HPRIME_0 - sin(phi * sin(toRadians(alphaDeltas[1].delta)))) / (cos(phi) * cos(toRadians(alphaDeltas[1].delta)));  final boolean noSunriseOrSet = (acosArg < -1.0) || (acosArg > 1.0);  final double h0 = acos(acosArg);  final double h0Degrees = limitTo(toDegrees(h0), 180.0);  /* A.2.5. Calculate the approximate sunrise time, m1, in fraction of day,*/ m[1] = limitTo(m[0] - h0Degrees / 360.0, 1);
* @param day GregorianCalendar of day for which sunrise/transit/sunset are to be calculated. *            The time of day (hour, minute, second, millisecond) is ignored. * @param latitude *            Observer's latitude, in degrees (negative south of equator). * @param longitude *            Observer's longitude, in degrees (negative west of Greenwich). * @param deltaT *            Difference between earth rotation time and terrestrial time (or Universal Time and Terrestrial Time), *            in seconds. See *            <a href ="http://asa.usno.navy.mil/SecK/DeltaT.html">http:/*asa.usno.navy.mil/SecK/DeltaT.html</a>.*/ *            For the year 2015, a reasonably accurate default would be 68. * @return An array of 3 GregorianCalendar values corresponding to the time of sunrise, sun transit, and sunset, * respectively. Note that the values for sunrise and sunset may be null: in this case, the sun stays above or * below the horizon all day. /* A.2.4. Calculate the local hour angle H0 corresponding to ...*/ <BUGS> final double acosArg = (SIN_HPRIME_0 - sin(phi * sin(toRadians(alphaDeltas[1].delta)))) / (cos(phi) * cos(toRadians(alphaDeltas[1].delta))); <BUGE>  final boolean noSunriseOrSet = (acosArg < -1.0) || (acosArg > 1.0);  final double h0 = acos(acosArg);  final double h0Degrees = limitTo(toDegrees(h0), 180.0);  /* A.2.5. Calculate the approximate sunrise time, m1, in fraction of day,*/ m[1] = limitTo(m[0] - h0Degrees / 360.0, 1);  /* A.2.6. Calculate the approximate sunset time, m2, in fraction of day,*/ m[2] = limitTo(m[0] + h0Degrees / 360.0, 1);
* @param day GregorianCalendar of day for which sunrise/transit/sunset are to be calculated. *            The time of day (hour, minute, second, millisecond) is ignored. * @param latitude *            Observer's latitude, in degrees (negative south of equator). * @param longitude *            Observer's longitude, in degrees (negative west of Greenwich). * @param deltaT *            Difference between earth rotation time and terrestrial time (or Universal Time and Terrestrial Time), *            in seconds. See *            <a href ="http://asa.usno.navy.mil/SecK/DeltaT.html">http:/*asa.usno.navy.mil/SecK/DeltaT.html</a>.*/ *            For the year 2015, a reasonably accurate default would be 68. * @return An array of 3 GregorianCalendar values corresponding to the time of sunrise, sun transit, and sunset, * respectively. Note that the values for sunrise and sunset may be null: in this case, the sun stays above or * below the horizon all day.  <BUGS> final boolean noSunriseOrSet = (acosArg < -1.0) || (acosArg > 1.0); <BUGE>  final double h0 = acos(acosArg);  final double h0Degrees = limitTo(toDegrees(h0), 180.0);  /* A.2.5. Calculate the approximate sunrise time, m1, in fraction of day,*/ m[1] = limitTo(m[0] - h0Degrees / 360.0, 1);  /* A.2.6. Calculate the approximate sunset time, m2, in fraction of day,*/ m[2] = limitTo(m[0] + h0Degrees / 360.0, 1);  m[0] = limitTo(m[0], 1);  /* A.2.8. Calculate the sidereal time at Greenwich, in degrees, for the sun transit, sunrise, and sunset*/
* @param day GregorianCalendar of day for which sunrise/transit/sunset are to be calculated. *            The time of day (hour, minute, second, millisecond) is ignored. * @param latitude *            Observer's latitude, in degrees (negative south of equator). * @param longitude *            Observer's longitude, in degrees (negative west of Greenwich). * @param deltaT *            Difference between earth rotation time and terrestrial time (or Universal Time and Terrestrial Time), *            in seconds. See *            <a href ="http://asa.usno.navy.mil/SecK/DeltaT.html">http:/*asa.usno.navy.mil/SecK/DeltaT.html</a>.*/ *            For the year 2015, a reasonably accurate default would be 68. * @return An array of 3 GregorianCalendar values corresponding to the time of sunrise, sun transit, and sunset, * respectively. Note that the values for sunrise and sunset may be null: in this case, the sun stays above or * below the horizon all day.  <BUGS> final double h0 = acos(acosArg); <BUGE>  final double h0Degrees = limitTo(toDegrees(h0), 180.0);  /* A.2.5. Calculate the approximate sunrise time, m1, in fraction of day,*/ m[1] = limitTo(m[0] - h0Degrees / 360.0, 1);  /* A.2.6. Calculate the approximate sunset time, m2, in fraction of day,*/ m[2] = limitTo(m[0] + h0Degrees / 360.0, 1);  m[0] = limitTo(m[0], 1);  /* A.2.8. Calculate the sidereal time at Greenwich, in degrees, for the sun transit, sunrise, and sunset*/ final double[] nu = new double[3]; for (int i = 0; i < m.length; i++) {
* @param day GregorianCalendar of day for which sunrise/transit/sunset are to be calculated. *            The time of day (hour, minute, second, millisecond) is ignored. * @param latitude *            Observer's latitude, in degrees (negative south of equator). * @param longitude *            Observer's longitude, in degrees (negative west of Greenwich). * @param deltaT *            Difference between earth rotation time and terrestrial time (or Universal Time and Terrestrial Time), *            in seconds. See *            <a href ="http://asa.usno.navy.mil/SecK/DeltaT.html">http:/*asa.usno.navy.mil/SecK/DeltaT.html</a>.*/ *            For the year 2015, a reasonably accurate default would be 68. * @return An array of 3 GregorianCalendar values corresponding to the time of sunrise, sun transit, and sunset, * respectively. Note that the values for sunrise and sunset may be null: in this case, the sun stays above or * below the horizon all day.  <BUGS> final double h0Degrees = limitTo(toDegrees(h0), 180.0); <BUGE>  /* A.2.5. Calculate the approximate sunrise time, m1, in fraction of day,*/ m[1] = limitTo(m[0] - h0Degrees / 360.0, 1);  /* A.2.6. Calculate the approximate sunset time, m2, in fraction of day,*/ m[2] = limitTo(m[0] + h0Degrees / 360.0, 1);  m[0] = limitTo(m[0], 1);  /* A.2.8. Calculate the sidereal time at Greenwich, in degrees, for the sun transit, sunrise, and sunset*/ final double[] nu = new double[3]; for (int i = 0; i < m.length; i++) { nu[i] = nuDegrees + 360.985647 * m[i]; }
* @param day GregorianCalendar of day for which sunrise/transit/sunset are to be calculated. *            The time of day (hour, minute, second, millisecond) is ignored. * @param latitude *            Observer's latitude, in degrees (negative south of equator). * @param longitude *            Observer's longitude, in degrees (negative west of Greenwich). * @param deltaT *            Difference between earth rotation time and terrestrial time (or Universal Time and Terrestrial Time), *            in seconds. See *            <a href ="http://asa.usno.navy.mil/SecK/DeltaT.html">http:/*asa.usno.navy.mil/SecK/DeltaT.html</a>.*/ *            For the year 2015, a reasonably accurate default would be 68. * @return An array of 3 GregorianCalendar values corresponding to the time of sunrise, sun transit, and sunset, * respectively. Note that the values for sunrise and sunset may be null: in this case, the sun stays above or * below the horizon all day. /* A.2.5. Calculate the approximate sunrise time, m1, in fraction of day,*/ <BUGS> m[1] = limitTo(m[0] - h0Degrees / 360.0, 1); <BUGE>  /* A.2.6. Calculate the approximate sunset time, m2, in fraction of day,*/ m[2] = limitTo(m[0] + h0Degrees / 360.0, 1);  m[0] = limitTo(m[0], 1);  /* A.2.8. Calculate the sidereal time at Greenwich, in degrees, for the sun transit, sunrise, and sunset*/ final double[] nu = new double[3]; for (int i = 0; i < m.length; i++) { nu[i] = nuDegrees + 360.985647 * m[i]; }  /* A.2.9. Calculate the terms ni*/ final double[] n = new double[3];
* @param day GregorianCalendar of day for which sunrise/transit/sunset are to be calculated. *            The time of day (hour, minute, second, millisecond) is ignored. * @param latitude *            Observer's latitude, in degrees (negative south of equator). * @param longitude *            Observer's longitude, in degrees (negative west of Greenwich). * @param deltaT *            Difference between earth rotation time and terrestrial time (or Universal Time and Terrestrial Time), *            in seconds. See *            <a href ="http://asa.usno.navy.mil/SecK/DeltaT.html">http:/*asa.usno.navy.mil/SecK/DeltaT.html</a>.*/ *            For the year 2015, a reasonably accurate default would be 68. * @return An array of 3 GregorianCalendar values corresponding to the time of sunrise, sun transit, and sunset, * respectively. Note that the values for sunrise and sunset may be null: in this case, the sun stays above or * below the horizon all day. /* A.2.6. Calculate the approximate sunset time, m2, in fraction of day,*/ <BUGS> m[2] = limitTo(m[0] + h0Degrees / 360.0, 1); <BUGE>  m[0] = limitTo(m[0], 1);  /* A.2.8. Calculate the sidereal time at Greenwich, in degrees, for the sun transit, sunrise, and sunset*/ final double[] nu = new double[3]; for (int i = 0; i < m.length; i++) { nu[i] = nuDegrees + 360.985647 * m[i]; }  /* A.2.9. Calculate the terms ni*/ final double[] n = new double[3]; for (int i = 0; i < m.length; i++) { n[i] = m[i] + deltaT / 86400.0; }
* @param day GregorianCalendar of day for which sunrise/transit/sunset are to be calculated. *            The time of day (hour, minute, second, millisecond) is ignored. * @param latitude *            Observer's latitude, in degrees (negative south of equator). * @param longitude *            Observer's longitude, in degrees (negative west of Greenwich). * @param deltaT *            Difference between earth rotation time and terrestrial time (or Universal Time and Terrestrial Time), *            in seconds. See *            <a href ="http://asa.usno.navy.mil/SecK/DeltaT.html">http:/*asa.usno.navy.mil/SecK/DeltaT.html</a>.*/ *            For the year 2015, a reasonably accurate default would be 68. * @return An array of 3 GregorianCalendar values corresponding to the time of sunrise, sun transit, and sunset, * respectively. Note that the values for sunrise and sunset may be null: in this case, the sun stays above or * below the horizon all day.  <BUGS> m[0] = limitTo(m[0], 1); <BUGE>  /* A.2.8. Calculate the sidereal time at Greenwich, in degrees, for the sun transit, sunrise, and sunset*/ final double[] nu = new double[3]; for (int i = 0; i < m.length; i++) { nu[i] = nuDegrees + 360.985647 * m[i]; }  /* A.2.9. Calculate the terms ni*/ final double[] n = new double[3]; for (int i = 0; i < m.length; i++) { n[i] = m[i] + deltaT / 86400.0; }  /* A.2.10. Calculate the values alpha'i and delta'i , in degrees*/
*            The time of day (hour, minute, second, millisecond) is ignored. * @param latitude *            Observer's latitude, in degrees (negative south of equator). * @param longitude *            Observer's longitude, in degrees (negative west of Greenwich). * @param deltaT *            Difference between earth rotation time and terrestrial time (or Universal Time and Terrestrial Time), *            in seconds. See *            <a href ="http://asa.usno.navy.mil/SecK/DeltaT.html">http:/*asa.usno.navy.mil/SecK/DeltaT.html</a>.*/ *            For the year 2015, a reasonably accurate default would be 68. * @return An array of 3 GregorianCalendar values corresponding to the time of sunrise, sun transit, and sunset, * respectively. Note that the values for sunrise and sunset may be null: in this case, the sun stays above or * below the horizon all day. /* A.2.8. Calculate the sidereal time at Greenwich, in degrees, for the sun transit, sunrise, and sunset*/ <BUGS> final double[] nu = new double[3]; for (int i = 0; i < m.length; i++) { nu[i] = nuDegrees + 360.985647 * m[i]; <BUGE> }  /* A.2.9. Calculate the terms ni*/ final double[] n = new double[3]; for (int i = 0; i < m.length; i++) { n[i] = m[i] + deltaT / 86400.0; }  /* A.2.10. Calculate the values alpha'i and delta'i , in degrees*/ final double a = limitIfNecessary(alphaDeltas[1].alpha - alphaDeltas[0].alpha); final double aPrime = limitIfNecessary(alphaDeltas[1].delta - alphaDeltas[0].delta);  final double b = limitIfNecessary(alphaDeltas[2].alpha - alphaDeltas[1].alpha);
*            The time of day (hour, minute, second, millisecond) is ignored. * @param latitude *            Observer's latitude, in degrees (negative south of equator). * @param longitude *            Observer's longitude, in degrees (negative west of Greenwich). * @param deltaT *            Difference between earth rotation time and terrestrial time (or Universal Time and Terrestrial Time), *            in seconds. See *            <a href ="http://asa.usno.navy.mil/SecK/DeltaT.html">http:/*asa.usno.navy.mil/SecK/DeltaT.html</a>.*/ *            For the year 2015, a reasonably accurate default would be 68. * @return An array of 3 GregorianCalendar values corresponding to the time of sunrise, sun transit, and sunset, * respectively. Note that the values for sunrise and sunset may be null: in this case, the sun stays above or * below the horizon all day. /* A.2.9. Calculate the terms ni*/ <BUGS> final double[] n = new double[3]; for (int i = 0; i < m.length; i++) { n[i] = m[i] + deltaT / 86400.0; <BUGE> }  /* A.2.10. Calculate the values alpha'i and delta'i , in degrees*/ final double a = limitIfNecessary(alphaDeltas[1].alpha - alphaDeltas[0].alpha); final double aPrime = limitIfNecessary(alphaDeltas[1].delta - alphaDeltas[0].delta);  final double b = limitIfNecessary(alphaDeltas[2].alpha - alphaDeltas[1].alpha); final double bPrime = limitIfNecessary(alphaDeltas[2].delta - alphaDeltas[1].delta);  final double c = b - a; final double cPrime = bPrime - aPrime;  final AlphaDelta[] alphaDeltaPrimes = new AlphaDelta[3];
* @param day GregorianCalendar of day for which sunrise/transit/sunset are to be calculated. *            The time of day (hour, minute, second, millisecond) is ignored. * @param latitude *            Observer's latitude, in degrees (negative south of equator). * @param longitude *            Observer's longitude, in degrees (negative west of Greenwich). * @param deltaT *            Difference between earth rotation time and terrestrial time (or Universal Time and Terrestrial Time), *            in seconds. See *            <a href ="http://asa.usno.navy.mil/SecK/DeltaT.html">http:/*asa.usno.navy.mil/SecK/DeltaT.html</a>.*/ *            For the year 2015, a reasonably accurate default would be 68. * @return An array of 3 GregorianCalendar values corresponding to the time of sunrise, sun transit, and sunset, * respectively. Note that the values for sunrise and sunset may be null: in this case, the sun stays above or * below the horizon all day. /* A.2.10. Calculate the values alpha'i and delta'i , in degrees*/ <BUGS> final double a = limitIfNecessary(alphaDeltas[1].alpha - alphaDeltas[0].alpha); final double aPrime = limitIfNecessary(alphaDeltas[1].delta - alphaDeltas[0].delta); <BUGE>  final double b = limitIfNecessary(alphaDeltas[2].alpha - alphaDeltas[1].alpha); final double bPrime = limitIfNecessary(alphaDeltas[2].delta - alphaDeltas[1].delta);  final double c = b - a; final double cPrime = bPrime - aPrime;  final AlphaDelta[] alphaDeltaPrimes = new AlphaDelta[3]; for (int i = 0; i < alphaDeltaPrimes.length; i++) { double alphaPrimeI = alphaDeltas[1].alpha + (n[i] * (a + b + c * n[i])) / 2.0; double deltaPrimeI =
* @param day GregorianCalendar of day for which sunrise/transit/sunset are to be calculated. *            The time of day (hour, minute, second, millisecond) is ignored. * @param latitude *            Observer's latitude, in degrees (negative south of equator). * @param longitude *            Observer's longitude, in degrees (negative west of Greenwich). * @param deltaT *            Difference between earth rotation time and terrestrial time (or Universal Time and Terrestrial Time), *            in seconds. See *            <a href ="http://asa.usno.navy.mil/SecK/DeltaT.html">http:/*asa.usno.navy.mil/SecK/DeltaT.html</a>.*/ *            For the year 2015, a reasonably accurate default would be 68. * @return An array of 3 GregorianCalendar values corresponding to the time of sunrise, sun transit, and sunset, * respectively. Note that the values for sunrise and sunset may be null: in this case, the sun stays above or * below the horizon all day.  <BUGS> final double b = limitIfNecessary(alphaDeltas[2].alpha - alphaDeltas[1].alpha); final double bPrime = limitIfNecessary(alphaDeltas[2].delta - alphaDeltas[1].delta); <BUGE>  final double c = b - a; final double cPrime = bPrime - aPrime;  final AlphaDelta[] alphaDeltaPrimes = new AlphaDelta[3]; for (int i = 0; i < alphaDeltaPrimes.length; i++) { double alphaPrimeI = alphaDeltas[1].alpha + (n[i] * (a + b + c * n[i])) / 2.0; double deltaPrimeI = alphaDeltas[1].delta + (n[i] * (aPrime + bPrime + cPrime * n[i])) / 2.0;
* @param day GregorianCalendar of day for which sunrise/transit/sunset are to be calculated. *            The time of day (hour, minute, second, millisecond) is ignored. * @param latitude *            Observer's latitude, in degrees (negative south of equator). * @param longitude *            Observer's longitude, in degrees (negative west of Greenwich). * @param deltaT *            Difference between earth rotation time and terrestrial time (or Universal Time and Terrestrial Time), *            in seconds. See *            <a href ="http://asa.usno.navy.mil/SecK/DeltaT.html">http:/*asa.usno.navy.mil/SecK/DeltaT.html</a>.*/ *            For the year 2015, a reasonably accurate default would be 68. * @return An array of 3 GregorianCalendar values corresponding to the time of sunrise, sun transit, and sunset, * respectively. Note that the values for sunrise and sunset may be null: in this case, the sun stays above or * below the horizon all day.  <BUGS> final double c = b - a; final double cPrime = bPrime - aPrime; <BUGE>  final AlphaDelta[] alphaDeltaPrimes = new AlphaDelta[3]; for (int i = 0; i < alphaDeltaPrimes.length; i++) { double alphaPrimeI = alphaDeltas[1].alpha + (n[i] * (a + b + c * n[i])) / 2.0; double deltaPrimeI = alphaDeltas[1].delta + (n[i] * (aPrime + bPrime + cPrime * n[i])) / 2.0;  alphaDeltaPrimes[i] = new AlphaDelta(alphaPrimeI, deltaPrimeI); }
*            The time of day (hour, minute, second, millisecond) is ignored. * @param latitude *            Observer's latitude, in degrees (negative south of equator). * @param longitude *            Observer's longitude, in degrees (negative west of Greenwich). * @param deltaT *            Difference between earth rotation time and terrestrial time (or Universal Time and Terrestrial Time), *            in seconds. See *            <a href ="http://asa.usno.navy.mil/SecK/DeltaT.html">http:/*asa.usno.navy.mil/SecK/DeltaT.html</a>.*/ *            For the year 2015, a reasonably accurate default would be 68. * @return An array of 3 GregorianCalendar values corresponding to the time of sunrise, sun transit, and sunset, * respectively. Note that the values for sunrise and sunset may be null: in this case, the sun stays above or * below the horizon all day.  <BUGS> final AlphaDelta[] alphaDeltaPrimes = new AlphaDelta[3]; for (int i = 0; i < alphaDeltaPrimes.length; i++) { double alphaPrimeI = <BUGE> alphaDeltas[1].alpha + (n[i] * (a + b + c * n[i])) / 2.0; double deltaPrimeI = alphaDeltas[1].delta + (n[i] * (aPrime + bPrime + cPrime * n[i])) / 2.0;  alphaDeltaPrimes[i] = new AlphaDelta(alphaPrimeI, deltaPrimeI); }  /* A.2.11. Calculate the local hour angle for the sun transit, sunrise, and sunset*/ final double[] hPrime = new double[3]; for (int i = 0; i < hPrime.length; i++) { double hPrimeI = nu[i] + longitude - alphaDeltaPrimes[i].alpha;
* @param day GregorianCalendar of day for which sunrise/transit/sunset are to be calculated. *            The time of day (hour, minute, second, millisecond) is ignored. * @param latitude *            Observer's latitude, in degrees (negative south of equator). * @param longitude *            Observer's longitude, in degrees (negative west of Greenwich). * @param deltaT *            Difference between earth rotation time and terrestrial time (or Universal Time and Terrestrial Time), *            in seconds. See *            <a href ="http://asa.usno.navy.mil/SecK/DeltaT.html">http:/*asa.usno.navy.mil/SecK/DeltaT.html</a>.*/ *            For the year 2015, a reasonably accurate default would be 68. * @return An array of 3 GregorianCalendar values corresponding to the time of sunrise, sun transit, and sunset, * respectively. Note that the values for sunrise and sunset may be null: in this case, the sun stays above or * below the horizon all day. (n[i] * (a + b + c * n[i])) / 2.0; <BUGS> double deltaPrimeI = <BUGE> alphaDeltas[1].delta + (n[i] * (aPrime + bPrime + cPrime * n[i])) / 2.0;  alphaDeltaPrimes[i] = new AlphaDelta(alphaPrimeI, deltaPrimeI); }  /* A.2.11. Calculate the local hour angle for the sun transit, sunrise, and sunset*/ final double[] hPrime = new double[3]; for (int i = 0; i < hPrime.length; i++) { double hPrimeI = nu[i] + longitude - alphaDeltaPrimes[i].alpha; hPrime[i] = limitHprime(hPrimeI); }  /* A.2.12. Calculate the sun altitude for the sun transit, sunrise, and sunset, hi*/
* @param day GregorianCalendar of day for which sunrise/transit/sunset are to be calculated. *            The time of day (hour, minute, second, millisecond) is ignored. * @param latitude *            Observer's latitude, in degrees (negative south of equator). * @param longitude *            Observer's longitude, in degrees (negative west of Greenwich). * @param deltaT *            Difference between earth rotation time and terrestrial time (or Universal Time and Terrestrial Time), *            in seconds. See *            <a href ="http://asa.usno.navy.mil/SecK/DeltaT.html">http:/*asa.usno.navy.mil/SecK/DeltaT.html</a>.*/ *            For the year 2015, a reasonably accurate default would be 68. * @return An array of 3 GregorianCalendar values corresponding to the time of sunrise, sun transit, and sunset, * respectively. Note that the values for sunrise and sunset may be null: in this case, the sun stays above or * below the horizon all day.  <BUGS> alphaDeltaPrimes[i] = new AlphaDelta(alphaPrimeI, deltaPrimeI); <BUGE> }  /* A.2.11. Calculate the local hour angle for the sun transit, sunrise, and sunset*/ final double[] hPrime = new double[3]; for (int i = 0; i < hPrime.length; i++) { double hPrimeI = nu[i] + longitude - alphaDeltaPrimes[i].alpha; hPrime[i] = limitHprime(hPrimeI); }  /* A.2.12. Calculate the sun altitude for the sun transit, sunrise, and sunset, hi*/ final double[] h = new double[3]; for (int i = 0; i < h.length; i++) { double deltaPrimeRad = toRadians(alphaDeltaPrimes[i].delta);
*            The time of day (hour, minute, second, millisecond) is ignored. * @param latitude *            Observer's latitude, in degrees (negative south of equator). * @param longitude *            Observer's longitude, in degrees (negative west of Greenwich). * @param deltaT *            Difference between earth rotation time and terrestrial time (or Universal Time and Terrestrial Time), *            in seconds. See *            <a href ="http://asa.usno.navy.mil/SecK/DeltaT.html">http:/*asa.usno.navy.mil/SecK/DeltaT.html</a>.*/ *            For the year 2015, a reasonably accurate default would be 68. * @return An array of 3 GregorianCalendar values corresponding to the time of sunrise, sun transit, and sunset, * respectively. Note that the values for sunrise and sunset may be null: in this case, the sun stays above or * below the horizon all day. /* A.2.11. Calculate the local hour angle for the sun transit, sunrise, and sunset*/ <BUGS> final double[] hPrime = new double[3]; for (int i = 0; i < hPrime.length; i++) { double hPrimeI = nu[i] + longitude - alphaDeltaPrimes[i].alpha; hPrime[i] = limitHprime(hPrimeI); <BUGE> }  /* A.2.12. Calculate the sun altitude for the sun transit, sunrise, and sunset, hi*/ final double[] h = new double[3]; for (int i = 0; i < h.length; i++) { double deltaPrimeRad = toRadians(alphaDeltaPrimes[i].delta);  h[i] = toDegrees(asin( sin(phi) * sin(deltaPrimeRad) + cos(phi) * cos(deltaPrimeRad) * cos(toRadians(hPrime[i])) )); }
*            The time of day (hour, minute, second, millisecond) is ignored. * @param latitude *            Observer's latitude, in degrees (negative south of equator). * @param longitude *            Observer's longitude, in degrees (negative west of Greenwich). * @param deltaT *            Difference between earth rotation time and terrestrial time (or Universal Time and Terrestrial Time), *            in seconds. See *            <a href ="http://asa.usno.navy.mil/SecK/DeltaT.html">http:/*asa.usno.navy.mil/SecK/DeltaT.html</a>.*/ *            For the year 2015, a reasonably accurate default would be 68. * @return An array of 3 GregorianCalendar values corresponding to the time of sunrise, sun transit, and sunset, * respectively. Note that the values for sunrise and sunset may be null: in this case, the sun stays above or * below the horizon all day. /* A.2.12. Calculate the sun altitude for the sun transit, sunrise, and sunset, hi*/ <BUGS> final double[] h = new double[3]; for (int i = 0; i < h.length; i++) { double deltaPrimeRad = toRadians(alphaDeltaPrimes[i].delta); <BUGE>  h[i] = toDegrees(asin( sin(phi) * sin(deltaPrimeRad) + cos(phi) * cos(deltaPrimeRad) * cos(toRadians(hPrime[i])) )); }  /* A.2.13. Calculate the sun transit, T (in fraction of day)*/ final double t = m[0] - hPrime[0] / 360.0;  /* A.2.14. Calculate the sunrise, R (in fraction of day)*/ final double r = m[1] + (h[1] - HPRIME_0) /
*            The time of day (hour, minute, second, millisecond) is ignored. * @param latitude *            Observer's latitude, in degrees (negative south of equator). * @param longitude *            Observer's longitude, in degrees (negative west of Greenwich). * @param deltaT *            Difference between earth rotation time and terrestrial time (or Universal Time and Terrestrial Time), *            in seconds. See *            <a href ="http://asa.usno.navy.mil/SecK/DeltaT.html">http:/*asa.usno.navy.mil/SecK/DeltaT.html</a>.*/ *            For the year 2015, a reasonably accurate default would be 68. * @return An array of 3 GregorianCalendar values corresponding to the time of sunrise, sun transit, and sunset, * respectively. Note that the values for sunrise and sunset may be null: in this case, the sun stays above or * below the horizon all day.  <BUGS> h[i] = toDegrees(asin( sin(phi) * sin(deltaPrimeRad) + cos(phi) * cos(deltaPrimeRad) * cos(toRadians(hPrime[i])) <BUGE> )); }  /* A.2.13. Calculate the sun transit, T (in fraction of day)*/ final double t = m[0] - hPrime[0] / 360.0;  /* A.2.14. Calculate the sunrise, R (in fraction of day)*/ final double r = m[1] + (h[1] - HPRIME_0) / (360.0 * cos(toRadians(alphaDeltaPrimes[1].delta)) * cos(phi) * sin(toRadians(hPrime[1])));  /* A.2.15. Calculate the sunset, S (in fraction of day)*/ final double s = m[2] +
* @param day GregorianCalendar of day for which sunrise/transit/sunset are to be calculated. *            The time of day (hour, minute, second, millisecond) is ignored. * @param latitude *            Observer's latitude, in degrees (negative south of equator). * @param longitude *            Observer's longitude, in degrees (negative west of Greenwich). * @param deltaT *            Difference between earth rotation time and terrestrial time (or Universal Time and Terrestrial Time), *            in seconds. See *            <a href ="http://asa.usno.navy.mil/SecK/DeltaT.html">http:/*asa.usno.navy.mil/SecK/DeltaT.html</a>.*/ *            For the year 2015, a reasonably accurate default would be 68. * @return An array of 3 GregorianCalendar values corresponding to the time of sunrise, sun transit, and sunset, * respectively. Note that the values for sunrise and sunset may be null: in this case, the sun stays above or * below the horizon all day. /* A.2.13. Calculate the sun transit, T (in fraction of day)*/ <BUGS> final double t = m[0] - hPrime[0] / 360.0; <BUGE>  /* A.2.14. Calculate the sunrise, R (in fraction of day)*/ final double r = m[1] + (h[1] - HPRIME_0) / (360.0 * cos(toRadians(alphaDeltaPrimes[1].delta)) * cos(phi) * sin(toRadians(hPrime[1])));  /* A.2.15. Calculate the sunset, S (in fraction of day)*/ final double s = m[2] + (h[2] - HPRIME_0) / (360.0 * cos(toRadians(alphaDeltaPrimes[2].delta)) * cos(phi) * sin(toRadians(hPrime[2])));  final long baseTime = dayStart.getTimeInMillis(); return new GregorianCalendar[]{ noSunriseOrSet ? null : addFractionOfDay(baseTime, r, day.getTimeZone()),
* @param day GregorianCalendar of day for which sunrise/transit/sunset are to be calculated. *            The time of day (hour, minute, second, millisecond) is ignored. * @param latitude *            Observer's latitude, in degrees (negative south of equator). * @param longitude *            Observer's longitude, in degrees (negative west of Greenwich). * @param deltaT *            Difference between earth rotation time and terrestrial time (or Universal Time and Terrestrial Time), *            in seconds. See *            <a href ="http://asa.usno.navy.mil/SecK/DeltaT.html">http:/*asa.usno.navy.mil/SecK/DeltaT.html</a>.*/ *            For the year 2015, a reasonably accurate default would be 68. * @return An array of 3 GregorianCalendar values corresponding to the time of sunrise, sun transit, and sunset, * respectively. Note that the values for sunrise and sunset may be null: in this case, the sun stays above or * below the horizon all day. /* A.2.14. Calculate the sunrise, R (in fraction of day)*/ <BUGS> final double r = m[1] + <BUGE> (h[1] - HPRIME_0) / (360.0 * cos(toRadians(alphaDeltaPrimes[1].delta)) * cos(phi) * sin(toRadians(hPrime[1])));  /* A.2.15. Calculate the sunset, S (in fraction of day)*/ final double s = m[2] + (h[2] - HPRIME_0) / (360.0 * cos(toRadians(alphaDeltaPrimes[2].delta)) * cos(phi) * sin(toRadians(hPrime[2])));  final long baseTime = dayStart.getTimeInMillis(); return new GregorianCalendar[]{ noSunriseOrSet ? null : addFractionOfDay(baseTime, r, day.getTimeZone()), addFractionOfDay(baseTime, t, day.getTimeZone()), noSunriseOrSet ? null : addFractionOfDay(baseTime, s, day.getTimeZone()) };
* @param day GregorianCalendar of day for which sunrise/transit/sunset are to be calculated. *            The time of day (hour, minute, second, millisecond) is ignored. * @param latitude *            Observer's latitude, in degrees (negative south of equator). * @param longitude *            Observer's longitude, in degrees (negative west of Greenwich). * @param deltaT *            Difference between earth rotation time and terrestrial time (or Universal Time and Terrestrial Time), *            in seconds. See *            <a href ="http://asa.usno.navy.mil/SecK/DeltaT.html">http:/*asa.usno.navy.mil/SecK/DeltaT.html</a>.*/ *            For the year 2015, a reasonably accurate default would be 68. * @return An array of 3 GregorianCalendar values corresponding to the time of sunrise, sun transit, and sunset, * respectively. Note that the values for sunrise and sunset may be null: in this case, the sun stays above or * below the horizon all day. (h[1] - HPRIME_0) / <BUGS> (360.0 * cos(toRadians(alphaDeltaPrimes[1].delta)) * cos(phi) * sin(toRadians(hPrime[1]))); <BUGE>  /* A.2.15. Calculate the sunset, S (in fraction of day)*/ final double s = m[2] + (h[2] - HPRIME_0) / (360.0 * cos(toRadians(alphaDeltaPrimes[2].delta)) * cos(phi) * sin(toRadians(hPrime[2])));  final long baseTime = dayStart.getTimeInMillis(); return new GregorianCalendar[]{ noSunriseOrSet ? null : addFractionOfDay(baseTime, r, day.getTimeZone()), addFractionOfDay(baseTime, t, day.getTimeZone()), noSunriseOrSet ? null : addFractionOfDay(baseTime, s, day.getTimeZone()) }; }
* @param day GregorianCalendar of day for which sunrise/transit/sunset are to be calculated. *            The time of day (hour, minute, second, millisecond) is ignored. * @param latitude *            Observer's latitude, in degrees (negative south of equator). * @param longitude *            Observer's longitude, in degrees (negative west of Greenwich). * @param deltaT *            Difference between earth rotation time and terrestrial time (or Universal Time and Terrestrial Time), *            in seconds. See *            <a href ="http://asa.usno.navy.mil/SecK/DeltaT.html">http:/*asa.usno.navy.mil/SecK/DeltaT.html</a>.*/ *            For the year 2015, a reasonably accurate default would be 68. * @return An array of 3 GregorianCalendar values corresponding to the time of sunrise, sun transit, and sunset, * respectively. Note that the values for sunrise and sunset may be null: in this case, the sun stays above or * below the horizon all day. /* A.2.15. Calculate the sunset, S (in fraction of day)*/ <BUGS> final double s = m[2] + <BUGE> (h[2] - HPRIME_0) / (360.0 * cos(toRadians(alphaDeltaPrimes[2].delta)) * cos(phi) * sin(toRadians(hPrime[2])));  final long baseTime = dayStart.getTimeInMillis(); return new GregorianCalendar[]{ noSunriseOrSet ? null : addFractionOfDay(baseTime, r, day.getTimeZone()), addFractionOfDay(baseTime, t, day.getTimeZone()), noSunriseOrSet ? null : addFractionOfDay(baseTime, s, day.getTimeZone()) }; }  private static GregorianCalendar addFractionOfDay(final long baseDate, final double fraction, final TimeZone tz) { long addMillis = (long) (fraction * (24 * 60 * 60 * 1000)); long newDate = baseDate + addMillis;
* @param day GregorianCalendar of day for which sunrise/transit/sunset are to be calculated. *            The time of day (hour, minute, second, millisecond) is ignored. * @param latitude *            Observer's latitude, in degrees (negative south of equator). * @param longitude *            Observer's longitude, in degrees (negative west of Greenwich). * @param deltaT *            Difference between earth rotation time and terrestrial time (or Universal Time and Terrestrial Time), *            in seconds. See *            <a href ="http://asa.usno.navy.mil/SecK/DeltaT.html">http:/*asa.usno.navy.mil/SecK/DeltaT.html</a>.*/ *            For the year 2015, a reasonably accurate default would be 68. * @return An array of 3 GregorianCalendar values corresponding to the time of sunrise, sun transit, and sunset, * respectively. Note that the values for sunrise and sunset may be null: in this case, the sun stays above or * below the horizon all day. (h[2] - HPRIME_0) / <BUGS> (360.0 * cos(toRadians(alphaDeltaPrimes[2].delta)) * cos(phi) * sin(toRadians(hPrime[2]))); <BUGE>  final long baseTime = dayStart.getTimeInMillis(); return new GregorianCalendar[]{ noSunriseOrSet ? null : addFractionOfDay(baseTime, r, day.getTimeZone()), addFractionOfDay(baseTime, t, day.getTimeZone()), noSunriseOrSet ? null : addFractionOfDay(baseTime, s, day.getTimeZone()) }; }  private static GregorianCalendar addFractionOfDay(final long baseDate, final double fraction, final TimeZone tz) { long addMillis = (long) (fraction * (24 * 60 * 60 * 1000)); long newDate = baseDate + addMillis; GregorianCalendar newCalendar = new GregorianCalendar(tz); newCalendar.setTimeInMillis(newDate);
* @param latitude *            Observer's latitude, in degrees (negative south of equator). * @param longitude *            Observer's longitude, in degrees (negative west of Greenwich). * @param deltaT *            Difference between earth rotation time and terrestrial time (or Universal Time and Terrestrial Time), *            in seconds. See *            <a href ="http://asa.usno.navy.mil/SecK/DeltaT.html">http:/*asa.usno.navy.mil/SecK/DeltaT.html</a>.*/ *            For the year 2015, a reasonably accurate default would be 68. * @return An array of 3 GregorianCalendar values corresponding to the time of sunrise, sun transit, and sunset, * respectively. Note that the values for sunrise and sunset may be null: in this case, the sun stays above or * below the horizon all day.  <BUGS> final long baseTime = dayStart.getTimeInMillis(); return new GregorianCalendar[]{ noSunriseOrSet ? null : addFractionOfDay(baseTime, r, day.getTimeZone()), addFractionOfDay(baseTime, t, day.getTimeZone()), noSunriseOrSet ? null : addFractionOfDay(baseTime, s, day.getTimeZone()) <BUGE> }; }  private static GregorianCalendar addFractionOfDay(final long baseDate, final double fraction, final TimeZone tz) { long addMillis = (long) (fraction * (24 * 60 * 60 * 1000)); long newDate = baseDate + addMillis; GregorianCalendar newCalendar = new GregorianCalendar(tz); newCalendar.setTimeInMillis(newDate);  /* use noon to get offset, assuming that any DST changes happen before sunrise and noon*/ /* FIXME: find a better solution, as this is potentially buggy*/
*/ public static File getIndexFile(File file) { <BUGS> return setEnding(file, ".spi"); <BUGE> }
@Override public void write(byte[] b) throws IOException { <BUGS> write(b, 0, b.length); <BUGE> }
private static void findPath(JsonElement jsonElement, String pathToFind, final List<String> pathSegments) { <BUGS> String field = headOf(pathSegments); if (jsonElement.isJsonArray()) { Iterator<JsonElement> iterator = jsonElement.getAsJsonArray().iterator(); while (iterator.hasNext()) { JsonElement arrayElement = (JsonElement) iterator.next(); if (arrayElement.isJsonNull()) { <BUGE> continue; } findPath(arrayElement, pathToFind, pathSegments); } } else { if (pathSegments.size() == 1) { ignorePath(jsonElement, pathToFind); } else { JsonElement child = jsonElement.getAsJsonObject().get(field); if (child == null) { child = jsonElement.getAsJsonObject().get(SET_MARKER + field); if (child == null) { return; } child = sortSet(child); jsonElement.getAsJsonObject().add(SET_MARKER + field, child); } List<String> tail = pathSegments.subList(1, pathSegments.size()); findPath(child, pathToFind, tail); } } }
private static void findPath(JsonElement jsonElement, String pathToFind, final List<String> pathSegments) { String field = headOf(pathSegments); if (jsonElement.isJsonArray()) { Iterator<JsonElement> iterator = jsonElement.getAsJsonArray().iterator(); while (iterator.hasNext()) { JsonElement arrayElement = (JsonElement) iterator.next(); if (arrayElement.isJsonNull()) { continue; } <BUGS> findPath(arrayElement, pathToFind, pathSegments); } } else { if (pathSegments.size() == 1) { ignorePath(jsonElement, pathToFind); <BUGE> } else { JsonElement child = jsonElement.getAsJsonObject().get(field); if (child == null) { child = jsonElement.getAsJsonObject().get(SET_MARKER + field); if (child == null) { return; } child = sortSet(child); jsonElement.getAsJsonObject().add(SET_MARKER + field, child); } List<String> tail = pathSegments.subList(1, pathSegments.size()); findPath(child, pathToFind, tail); } } }
private static void findPath(JsonElement jsonElement, String pathToFind, final List<String> pathSegments) { String field = headOf(pathSegments); if (jsonElement.isJsonArray()) { Iterator<JsonElement> iterator = jsonElement.getAsJsonArray().iterator(); while (iterator.hasNext()) { JsonElement arrayElement = (JsonElement) iterator.next(); if (arrayElement.isJsonNull()) { continue; } findPath(arrayElement, pathToFind, pathSegments); } } else { if (pathSegments.size() == 1) { ignorePath(jsonElement, pathToFind); } else { <BUGS> JsonElement child = jsonElement.getAsJsonObject().get(field); if (child == null) { child = jsonElement.getAsJsonObject().get(SET_MARKER + field); if (child == null) { return; <BUGE> } child = sortSet(child); jsonElement.getAsJsonObject().add(SET_MARKER + field, child); } List<String> tail = pathSegments.subList(1, pathSegments.size()); findPath(child, pathToFind, tail); } } }
private static void findPath(JsonElement jsonElement, String pathToFind, final List<String> pathSegments) { String field = headOf(pathSegments); if (jsonElement.isJsonArray()) { Iterator<JsonElement> iterator = jsonElement.getAsJsonArray().iterator(); while (iterator.hasNext()) { JsonElement arrayElement = (JsonElement) iterator.next(); if (arrayElement.isJsonNull()) { continue; } findPath(arrayElement, pathToFind, pathSegments); } } else { if (pathSegments.size() == 1) { ignorePath(jsonElement, pathToFind); } else { JsonElement child = jsonElement.getAsJsonObject().get(field); if (child == null) { child = jsonElement.getAsJsonObject().get(SET_MARKER + field); if (child == null) { return; } child = sortSet(child); jsonElement.getAsJsonObject().add(SET_MARKER + field, child); } <BUGS> List<String> tail = pathSegments.subList(1, pathSegments.size()); findPath(child, pathToFind, tail); <BUGE> } } }
private static void findPath(JsonElement jsonElement, String pathToFind, final List<String> pathSegments) { String field = headOf(pathSegments); if (jsonElement.isJsonArray()) { Iterator<JsonElement> iterator = jsonElement.getAsJsonArray().iterator(); while (iterator.hasNext()) { JsonElement arrayElement = (JsonElement) iterator.next(); if (arrayElement.isJsonNull()) { continue; } findPath(arrayElement, pathToFind, pathSegments); } } else { if (pathSegments.size() == 1) { ignorePath(jsonElement, pathToFind); } else { JsonElement child = jsonElement.getAsJsonObject().get(field); if (child == null) { child = jsonElement.getAsJsonObject().get(SET_MARKER + field); if (child == null) { return; } child = sortSet(child); jsonElement.getAsJsonObject().add(SET_MARKER + field, child); } List<String> tail = pathSegments.subList(1, pathSegments.size()); findPath(child, pathToFind, tail); } } <BUGS> } <BUGE>
private boolean assertEquals(final String expectedJson, String actualJson, Description mismatchDescription) { try { <BUGS> JSONAssert.assertEquals(expectedJson, actualJson, true); } catch (AssertionError e) { return appendMismatchDescription(mismatchDescription, expectedJson, actualJson, e.getMessage()); <BUGE> } catch (JSONException e) { return appendMismatchDescription(mismatchDescription, expectedJson, actualJson, e.getMessage()); }  return true; }
private boolean assertEquals(final String expectedJson, String actualJson, Description mismatchDescription) { try { JSONAssert.assertEquals(expectedJson, actualJson, true); } catch (AssertionError e) { return appendMismatchDescription(mismatchDescription, expectedJson, actualJson, e.getMessage()); } catch (JSONException e) { return appendMismatchDescription(mismatchDescription, expectedJson, actualJson, e.getMessage()); <BUGS> } <BUGE>  return true; }
private boolean assertEquals(final String expectedJson, String actualJson, Description mismatchDescription) { try { JSONAssert.assertEquals(expectedJson, actualJson, true); } catch (AssertionError e) { return appendMismatchDescription(mismatchDescription, expectedJson, actualJson, e.getMessage()); } catch (JSONException e) { return appendMismatchDescription(mismatchDescription, expectedJson, actualJson, e.getMessage()); }  <BUGS> return true; <BUGE> }
@Override public void body(String string) { <BUGS> cell = string; } <BUGE>
@SuppressWarnings({ "rawtypes", "unchecked" })
@SuppressWarnings({ "rawtypes", "unchecked" })
@SuppressWarnings({ "rawtypes", "unchecked" })
@SuppressWarnings({ "rawtypes", "unchecked" })
@SuppressWarnings({ "rawtypes", "unchecked" })
*/ public final String substitute(String text) { <BUGS> if (text == null) { <BUGE> return null; } Matcher m = VARIABLES_PATTERN.matcher(text); Map<String, String> replacements = new HashMap<String, String>(); while (m.find()) { int gc = m.groupCount(); if (gc == 1) { String g0 = m.group(0); String g1 = m.group(1); String value = get(g1); if (FIT_NULL_VALUE.equals(value)) { value = nullValue; } replacements.put(g0, value); } } String newText = text; for (Entry<String, String> en : replacements.entrySet()) { String k = en.getKey(); String replacement = replacements.get(k); if (replacement != null) { /* this fixes issue #118*/ String sanitisedReplacement = SPECIAL_REGEX_CHARS.matcher(replacement).replaceAll("\\\\$0");; newText = newText.replaceAll(k, sanitisedReplacement); } } return newText;
*/ public final String substitute(String text) { if (text == null) { return null; } <BUGS> Matcher m = VARIABLES_PATTERN.matcher(text); Map<String, String> replacements = new HashMap<String, String>(); while (m.find()) { int gc = m.groupCount(); if (gc == 1) { String g0 = m.group(0); String g1 = m.group(1); String value = get(g1); if (FIT_NULL_VALUE.equals(value)) { <BUGE> value = nullValue; } replacements.put(g0, value); } } String newText = text; for (Entry<String, String> en : replacements.entrySet()) { String k = en.getKey(); String replacement = replacements.get(k); if (replacement != null) { /* this fixes issue #118*/ String sanitisedReplacement = SPECIAL_REGEX_CHARS.matcher(replacement).replaceAll("\\\\$0");; newText = newText.replaceAll(k, sanitisedReplacement); } } return newText;
*/ public final String substitute(String text) { if (text == null) { return null; } Matcher m = VARIABLES_PATTERN.matcher(text); Map<String, String> replacements = new HashMap<String, String>(); while (m.find()) { int gc = m.groupCount(); if (gc == 1) { String g0 = m.group(0); String g1 = m.group(1); String value = get(g1); if (FIT_NULL_VALUE.equals(value)) { value = nullValue; } <BUGS> replacements.put(g0, value); <BUGE> } } String newText = text; for (Entry<String, String> en : replacements.entrySet()) { String k = en.getKey(); String replacement = replacements.get(k); if (replacement != null) { /* this fixes issue #118*/ String sanitisedReplacement = SPECIAL_REGEX_CHARS.matcher(replacement).replaceAll("\\\\$0");; newText = newText.replaceAll(k, sanitisedReplacement); } } return newText;
*/ public final String substitute(String text) { if (text == null) { return null; } Matcher m = VARIABLES_PATTERN.matcher(text); Map<String, String> replacements = new HashMap<String, String>(); while (m.find()) { int gc = m.groupCount(); if (gc == 1) { String g0 = m.group(0); String g1 = m.group(1); String value = get(g1); if (FIT_NULL_VALUE.equals(value)) { value = nullValue; } replacements.put(g0, value); } <BUGS> } String newText = text; for (Entry<String, String> en : replacements.entrySet()) { String k = en.getKey(); String replacement = replacements.get(k); if (replacement != null) { <BUGE> /* this fixes issue #118*/ String sanitisedReplacement = SPECIAL_REGEX_CHARS.matcher(replacement).replaceAll("\\\\$0");; newText = newText.replaceAll(k, sanitisedReplacement); } } return newText;
*/ public final String substitute(String text) { if (text == null) { return null; } Matcher m = VARIABLES_PATTERN.matcher(text); Map<String, String> replacements = new HashMap<String, String>(); while (m.find()) { int gc = m.groupCount(); if (gc == 1) { String g0 = m.group(0); String g1 = m.group(1); String value = get(g1); if (FIT_NULL_VALUE.equals(value)) { value = nullValue; } replacements.put(g0, value); } } String newText = text; for (Entry<String, String> en : replacements.entrySet()) { String k = en.getKey(); String replacement = replacements.get(k); if (replacement != null) { /* this fixes issue #118*/ <BUGS> String sanitisedReplacement = SPECIAL_REGEX_CHARS.matcher(replacement).replaceAll("\\\\$0");; newText = newText.replaceAll(k, sanitisedReplacement); <BUGE> } } return newText;
*/ public final String substitute(String text) { if (text == null) { return null; } Matcher m = VARIABLES_PATTERN.matcher(text); Map<String, String> replacements = new HashMap<String, String>(); while (m.find()) { int gc = m.groupCount(); if (gc == 1) { String g0 = m.group(0); String g1 = m.group(1); String value = get(g1); if (FIT_NULL_VALUE.equals(value)) { value = nullValue; } replacements.put(g0, value); } } String newText = text; for (Entry<String, String> en : replacements.entrySet()) { String k = en.getKey(); String replacement = replacements.get(k); if (replacement != null) { /* this fixes issue #118*/ String sanitisedReplacement = SPECIAL_REGEX_CHARS.matcher(replacement).replaceAll("\\\\$0");; newText = newText.replaceAll(k, sanitisedReplacement); } <BUGS> } return newText; <BUGE>
*/ public static XPathExpression toExpression(Map<String, String> ns, String xpathExpression) { try { <BUGS> XPathFactory xpathFactory = XPathFactory.newInstance(); XPath xpath = xpathFactory.newXPath(); if (ns.size() > 0) { xpath.setNamespaceContext(toNsContext(ns)); <BUGE> } XPathExpression expr = xpath.compile(xpathExpression); return expr; } catch (XPathExpressionException e) { throw new IllegalArgumentException( "xPath expression can not be compiled: " + xpathExpression, e); } }
*/ public static XPathExpression toExpression(Map<String, String> ns, String xpathExpression) { try { XPathFactory xpathFactory = XPathFactory.newInstance(); XPath xpath = xpathFactory.newXPath(); if (ns.size() > 0) { xpath.setNamespaceContext(toNsContext(ns)); } <BUGS> XPathExpression expr = xpath.compile(xpathExpression); <BUGE> return expr; } catch (XPathExpressionException e) { throw new IllegalArgumentException( "xPath expression can not be compiled: " + xpathExpression, e); } }
<BUGS> public ConnectionDetails(String id, String hostNameDescription) { this.id = id; this.hostNameDescription = hostNameDescription; } <BUGE>
private void writeToTable() { <BUGS> assert sharedTableWire.startUse(); <BUGE> try { sharedTableWire.clear(); sharedTableWire.writeAllAsMap(String.class, ProcessScopedMapping.class, allMappings); } finally { assert sharedTableWire.endUse(); } }
private void writeToTable() { assert sharedTableWire.startUse(); try { <BUGS> sharedTableWire.clear(); sharedTableWire.writeAllAsMap(String.class, ProcessScopedMapping.class, allMappings); <BUGE> } finally { assert sharedTableWire.endUse(); } }
private void writeToTable() { assert sharedTableWire.startUse(); try { sharedTableWire.clear(); sharedTableWire.writeAllAsMap(String.class, ProcessScopedMapping.class, allMappings); } finally { <BUGS> assert sharedTableWire.endUse(); } } <BUGE>
private void writeToTable() { <BUGS> assert sharedTableWire.startUse(); <BUGE> try { sharedTableWire.clear(); sharedTableWire.writeAllAsMap(String.class, ProcessScopedMapping.class, allMappings); } finally { assert sharedTableWire.endUse(); } }
private void writeToTable() { assert sharedTableWire.startUse(); try { <BUGS> sharedTableWire.clear(); sharedTableWire.writeAllAsMap(String.class, ProcessScopedMapping.class, allMappings); <BUGE> } finally { assert sharedTableWire.endUse(); } }
private void writeToTable() { assert sharedTableWire.startUse(); try { sharedTableWire.clear(); sharedTableWire.writeAllAsMap(String.class, ProcessScopedMapping.class, allMappings); } finally { <BUGS> assert sharedTableWire.endUse(); } } <BUGE>
public GoPluginApiResponse handle(GoPluginApiRequest goPluginApiRequest) { <BUGS> String requestName = goPluginApiRequest.requestName(); if (goPluginApiRequest.requestName().equals(REQUEST_NOTIFICATIONS_INTERESTED_IN)) { <BUGE> return handleNotificationsInterestedIn(); } else if (goPluginApiRequest.requestName().equals(REQUEST_STAGE_STATUS)) { return handleStageNotification(goPluginApiRequest); } return null; }
public GoPluginApiResponse handle(GoPluginApiRequest goPluginApiRequest) { String requestName = goPluginApiRequest.requestName(); if (goPluginApiRequest.requestName().equals(REQUEST_NOTIFICATIONS_INTERESTED_IN)) { return handleNotificationsInterestedIn(); <BUGS> } else if (goPluginApiRequest.requestName().equals(REQUEST_STAGE_STATUS)) { <BUGE> return handleStageNotification(goPluginApiRequest); } return null; }
public GoPluginApiResponse handle(GoPluginApiRequest goPluginApiRequest) { String requestName = goPluginApiRequest.requestName(); if (goPluginApiRequest.requestName().equals(REQUEST_NOTIFICATIONS_INTERESTED_IN)) { return handleNotificationsInterestedIn(); } else if (goPluginApiRequest.requestName().equals(REQUEST_STAGE_STATUS)) { return handleStageNotification(goPluginApiRequest); } <BUGS> return null; <BUGE> }
@Override public String toString() { <BUGS> return "PipelineRule{" + <BUGE> "nameRegex='" + nameRegex + '\'' + ", stageRegex='" + stageRegex + '\'' + ", channel='" + channel + '\'' + ", status=" + status + '}'; }
public static Rules read(String file) { <BUGS> return new RulesReader().load(ConfigFactory.parseResources(file)); <BUGE> }
public static Duration days(long days) { <BUGS> return hours(days * 24); <BUGE> }
@Override public boolean matches(MetricName name, Metric metric) { <BUGS> String metricName = sanitizeName(name); <BUGE>  boolean isVersionMetric = APPVERSION_PATTERN.matcher(metricName).matches();  if (isVersionMetric || cleanInvalidGauge(name, metric, metricName)) { return false; }  if (pattern != null) { return !pattern.matcher(metricName).matches(); }  return true; }
@Override public boolean matches(MetricName name, Metric metric) { String metricName = sanitizeName(name);  <BUGS> boolean isVersionMetric = APPVERSION_PATTERN.matcher(metricName).matches(); <BUGE>  if (isVersionMetric || cleanInvalidGauge(name, metric, metricName)) { return false; }  if (pattern != null) { return !pattern.matcher(metricName).matches(); }  return true; }
@Override public boolean matches(MetricName name, Metric metric) { String metricName = sanitizeName(name);  boolean isVersionMetric = APPVERSION_PATTERN.matcher(metricName).matches();  <BUGS> if (isVersionMetric || cleanInvalidGauge(name, metric, metricName)) { <BUGE> return false; }  if (pattern != null) { return !pattern.matcher(metricName).matches(); }  return true; }
@Override public boolean matches(MetricName name, Metric metric) { String metricName = sanitizeName(name);  boolean isVersionMetric = APPVERSION_PATTERN.matcher(metricName).matches();  if (isVersionMetric || cleanInvalidGauge(name, metric, metricName)) { return false; }  <BUGS> if (pattern != null) { return !pattern.matcher(metricName).matches(); <BUGE> }  return true; }
@Override protected boolean matchesSafely(Row actual, Description mismatch) { <BUGS> if (expected.getLastCellNum() != actual.getLastCellNum()) { <BUGE> mismatch.appendText("got ") .appendValue(numberOfCellsIn(actual)) .appendText(" cell(s) on row ") .appendValue(asExcelRow(expected)) .appendText(" expected ") .appendValue(numberOfCellsIn(expected)) .appendText(" sheet ") .appendValue(expected.getSheet().getSheetName()); return false; }  return true; }
@Override protected boolean matchesSafely(Row actual, Description mismatch) { if (expected.getLastCellNum() != actual.getLastCellNum()) { mismatch.appendText("got ") .appendValue(numberOfCellsIn(actual)) .appendText(" cell(s) on row ") .appendValue(asExcelRow(expected)) .appendText(" expected ") .appendValue(numberOfCellsIn(expected)) .appendText(" sheet ") .appendValue(expected.getSheet().getSheetName()); return false; }  <BUGS> return true; <BUGE> }
@SuppressWarnings("unchecked") public static List<List<Object>> toKeys(Object singleKey) { <BUGS> List<List<Object>> keys = Arrays.asList(Arrays.asList(singleKey)); return keys; <BUGE> }
@Override public Promise<T> whenCompleteAsync(BiConsumer<? super T, ? super Throwable> action) { <BUGS> return whenCompleteAsync(action, this.defaultExecutor); <BUGE> }
@Override public Promise<T> whenCompleteAsync(BiConsumer<? super T, ? super Throwable> action) { <BUGS> return whenCompleteAsync(action, this.defaultExecutor); <BUGE> }
*/ public MkGithub() throws IOException { <BUGS> this("jeff"); } <BUGE>
*/ public MkGithub() throws IOException { <BUGS> this("jeff"); } <BUGE>
*/ public MkGithub() throws IOException { <BUGS> this("jeff"); } <BUGE>
*/ public MkGithub() throws IOException { <BUGS> this("jeff"); } <BUGE>
@Override public String toString() { <BUGS> return this.entry.uri().get().toString(); <BUGE> }
@Override public String toString() { <BUGS> return this.entry.uri().get().toString(); <BUGE> }
*/ public MkGithub() throws IOException { <BUGS> this("jeff"); } <BUGE>
@Override public String toString() { <BUGS> return this.request.uri().get().toString(); <BUGE> }
*/ public MkGithub() throws IOException { <BUGS> this("jeff"); } <BUGE>
@Override public Repos repos() { try { <BUGS> return new MkRepos(this.storage, this.self); <BUGE> } catch (IOException ex) { throw new IllegalStateException(ex); } }
*/ public MkGithub() throws IOException { <BUGS> this("jeff"); } <BUGE>
@Override public Repo create(@NotNull(message = "JSON can't be NULL") final JsonObject json) throws IOException { <BUGS> throw new UnsupportedOperationException("#create()"); <BUGE> }
@Override public void apply(final Iterable<Directive> dirs) throws IOException { try { <BUGS> FileUtils.write( <BUGE> new File(this.name), new XMLDocument( new Xembler(dirs).apply(this.xml().node()) ).toString(), Charsets.UTF_8 ); } catch (ImpossibleModificationException ex) { throw new IllegalArgumentException(ex); } }
@Override public String name() { <BUGS> return this.json().getString("name"); <BUGE> }
@Override public Iterable<Release> iterate() { <BUGS> return Collections.emptyList(); <BUGE> }
*/ public MkGithub() throws IOException { <BUGS> this("jeff"); } <BUGE>
*/ public MkGithub() throws IOException { <BUGS> this("jeff"); } <BUGE>
*/ public MkGithub(final String login) throws IOException { <BUGS> this(new MkStorage.InFile(), login); } <BUGE>
*/ public MkGithub(final String login) throws IOException { <BUGS> this(new MkStorage.InFile(), login); } <BUGE>
@Override public Iterable<PublicKey> iterate() { <BUGS> throw new UnsupportedOperationException("Iterate not yet implemented."); <BUGE> }
*/ public String key() throws IOException { <BUGS> return new SmartJson(this).text("title"); <BUGE> }
@Override public Iterable<PublicKey> iterate() { <BUGS> throw new UnsupportedOperationException("Iterate not yet implemented."); <BUGE> }
*/ public MkGithub() throws IOException { <BUGS> this("jeff"); } <BUGE>
@Override public void unstar() throws IOException { <BUGS> throw new UnsupportedOperationException("unstar not yet implemented."); <BUGE> }
*/ public MkGithub(final String login) throws IOException { <BUGS> this(new MkStorage.InFile(), login); } <BUGE>
*/ public MkGithub() throws IOException { <BUGS> this("jeff"); } <BUGE>
*/ public MkGithub() throws IOException { <BUGS> this("jeff"); } <BUGE>
*/ public MkGithub() throws IOException { <BUGS> this("jeff"); } <BUGE>
*/ public RtGithub( <BUGS> @NotNull(message = "request can't be NULL") final Request req) { this.request = req; } <BUGE>
*/ public MkGithub(final String login) throws IOException { <BUGS> this(new MkStorage.InFile(), login); } <BUGE>
@Override public Iterable<Hook> iterate() { /* @checkstyle MultipleStringLiterals (1 line)*/ <BUGS> return Collections.emptyList(); <BUGE> }
@Override public void apply(final Iterable<Directive> dirs) throws IOException { try { <BUGS> FileUtils.write( <BUGE> new File(this.name), new XMLDocument( new Xembler(dirs).apply(this.xml().node()) ).toString(), Charsets.UTF_8 ); } catch (ImpossibleModificationException ex) { throw new IllegalArgumentException(ex); } }
*/ public MkGithub() throws IOException { <BUGS> this("jeff"); } <BUGE>
*/ public MkGithub() throws IOException { <BUGS> this("jeff"); } <BUGE>
@Override public void unstar() throws IOException { <BUGS> throw new UnsupportedOperationException("unstar not yet implemented."); <BUGE> }
*/ public MkGithub(final String login) throws IOException { <BUGS> this(new MkStorage.InFile(), login); } <BUGE>
*/ public MkGithub(final String login) throws IOException { <BUGS> this(new MkStorage.InFile(), login); } <BUGE>
*/ public MkGithub() throws IOException { <BUGS> this("jeff"); } <BUGE>
*/ public MkGithub() throws IOException { <BUGS> this("jeff"); } <BUGE>
*/ public MkGithub() throws IOException { <BUGS> this("jeff"); } <BUGE>
@Override public Gists gists() { try { <BUGS> return new MkGists(this.storage, this.self); <BUGE> } catch (final IOException ex) { throw new IllegalStateException(ex); } }
@Override public Gists gists() { try { <BUGS> return new MkGists(this.storage, this.self); <BUGE> } catch (final IOException ex) { throw new IllegalStateException(ex); } }
*/ public MkGithub() throws IOException { <BUGS> this("jeff"); } <BUGE>
*/ public MkGithub() throws IOException { <BUGS> this("jeff"); } <BUGE>
@Override public Iterable<Hook> iterate() { <BUGS> return Collections.emptyList(); <BUGE> /* @checkstyle MultipleStringLiterals (1 line)*/ }
@Override public void apply(final Iterable<Directive> dirs) throws IOException { try { <BUGS> FileUtils.write( <BUGE> new File(this.name), new XMLDocument( new Xembler(dirs).apply(this.xml().node()) ).toString(), Charsets.UTF_8 ); } catch (ImpossibleModificationException ex) { throw new IllegalArgumentException(ex); } }
@Override public void apply(final Iterable<Directive> dirs) throws IOException { try { <BUGS> FileUtils.write( <BUGE> new File(this.name), new XMLDocument( new Xembler(dirs).apply(this.xml().node()) ).toString(), Charsets.UTF_8 ); } catch (ImpossibleModificationException ex) { throw new IllegalArgumentException(ex); } }
@Override public void apply(final Iterable<Directive> dirs) throws IOException { try { <BUGS> FileUtils.write( <BUGE> new File(this.name), new XMLDocument( new Xembler(dirs).apply(this.xml().node()) ).toString(), Charsets.UTF_8 ); } catch (ImpossibleModificationException ex) { throw new IllegalArgumentException(ex); } }
@Override public void apply(final Iterable<Directive> dirs) throws IOException { try { <BUGS> FileUtils.write( <BUGE> new File(this.name), new XMLDocument( new Xembler(dirs).apply(this.xml().node()) ).toString(), Charsets.UTF_8 ); } catch (ImpossibleModificationException ex) { throw new IllegalArgumentException(ex); } }
*/ public MkGithub( @NotNull(message = "login can't be NULL") final String login ) throws IOException { <BUGS> this(new MkStorage.InFile(), login); } <BUGE>
*/ public MkGithub( @NotNull(message = "login can't be NULL") final String login ) throws IOException { <BUGS> this(new MkStorage.InFile(), login); } <BUGE>
*/ public MkGithub( @NotNull(message = "stg can't be NULL") final MkStorage stg, @NotNull(message = "login should not be NULL") final String login <BUGS> ) { this.storage = stg; this.self = login; } <BUGE>
*/ public MkGithub( @NotNull(message = "stg can't be NULL") final MkStorage stg, @NotNull(message = "login should not be NULL") final String login <BUGS> ) { this.storage = stg; this.self = login; } <BUGE>
*/ public MkGithub( @NotNull(message = "stg can't be NULL") final MkStorage stg, @NotNull(message = "login should not be NULL") final String login <BUGS> ) { this.storage = stg; this.self = login; } <BUGE>
*/ public MkGithub( @NotNull(message = "stg can't be NULL") final MkStorage stg, @NotNull(message = "login should not be NULL") final String login <BUGS> ) { this.storage = stg; this.self = login; } <BUGE>
@Override public void lock() throws IOException { <BUGS> this.lock.lock(); } <BUGE>
*/ public MkGithub( @NotNull(message = "stg can't be NULL") final MkStorage stg, @NotNull(message = "login should not be NULL") final String login <BUGS> ) { this.storage = stg; this.self = login; } <BUGE>
@NotNull(message = "Content can't be NULL") public Content get( @NotNull(message = "path can't be NULL") final String path, @NotNull(message = "ref can't be NULL") final String ref ) throws IOException { <BUGS> return this.content(path, ref); <BUGE> }
*/ public MkGithub( @NotNull(message = "login can't be NULL") final String login ) throws IOException { <BUGS> this(new MkStorage.InFile(), login); } <BUGE>
*/ public MkGithub( final MkStorage stg, final String login <BUGS> ) { this.storage = stg; this.self = login; } <BUGE>
*/ public MkGithub() throws IOException { <BUGS> this("jeff"); } <BUGE>
@Override public <T> T manufacturePojo(Class<T> pojoClass, Type... genericTypeArgs) { <BUGS> Map<Class<?>, Integer> pojos = new HashMap<Class<?>, Integer>(); pojos.put(pojoClass, 0); <BUGE> try { return this.manufacturePojoInternal(pojoClass, pojos, genericTypeArgs); } catch (InstantiationException e) { throw new PodamMockeryException("", e); } catch (IllegalAccessException e) { throw new PodamMockeryException("", e); } catch (InvocationTargetException e) { throw new PodamMockeryException("", e); } catch (ClassNotFoundException e) { throw new PodamMockeryException("", e); } }
@Override public <T> T manufacturePojo(Class<T> pojoClass, Type... genericTypeArgs) { Map<Class<?>, Integer> pojos = new HashMap<Class<?>, Integer>(); pojos.put(pojoClass, 0); try { <BUGS> return this.manufacturePojoInternal(pojoClass, pojos, <BUGE> genericTypeArgs); } catch (InstantiationException e) { throw new PodamMockeryException("", e); } catch (IllegalAccessException e) { throw new PodamMockeryException("", e); } catch (InvocationTargetException e) { throw new PodamMockeryException("", e); } catch (ClassNotFoundException e) { throw new PodamMockeryException("", e); } }
@Override public <T> T manufacturePojo(Class<T> pojoClass, Type... genericTypeArgs) { Map<Class<?>, Integer> pojos = new HashMap<Class<?>, Integer>(); pojos.put(pojoClass, 0); try { return this.manufacturePojoInternal(pojoClass, pojos, genericTypeArgs); } catch (InstantiationException e) { throw new PodamMockeryException("", e); <BUGS> } catch (IllegalAccessException e) { throw new PodamMockeryException("", e); <BUGE> } catch (InvocationTargetException e) { throw new PodamMockeryException("", e); } catch (ClassNotFoundException e) { throw new PodamMockeryException("", e); } }
public static Introspected getIntrospected(Class<?> clazz) { <BUGS> Introspected introspected = descriptorMap.get(clazz); if (introspected != null) { <BUGE> return introspected; }  /* Introspection should only occur once per class.*/ synchronized (clazz) { /* Double check.  This avoids multiple introspections of the same class.*/ introspected = descriptorMap.get(clazz); if (introspected != null) { return introspected; }  introspected = new Introspected(clazz); descriptorMap.put(clazz, introspected); return introspected; } }
public static Introspected getIntrospected(Class<?> clazz) { Introspected introspected = descriptorMap.get(clazz); if (introspected != null) { return introspected; }  /* Introspection should only occur once per class.*/ <BUGS> synchronized (clazz) { <BUGE> /* Double check.  This avoids multiple introspections of the same class.*/ introspected = descriptorMap.get(clazz); if (introspected != null) { return introspected; }  introspected = new Introspected(clazz); descriptorMap.put(clazz, introspected); return introspected; } }
public static Introspected getIntrospected(Class<?> clazz) { Introspected introspected = descriptorMap.get(clazz); if (introspected != null) { return introspected; }  /* Introspection should only occur once per class.*/ synchronized (clazz) { /* Double check.  This avoids multiple introspections of the same class.*/ <BUGS> introspected = descriptorMap.get(clazz); if (introspected != null) { <BUGE> return introspected; }  introspected = new Introspected(clazz); descriptorMap.put(clazz, introspected); return introspected; } }
public static Introspected getIntrospected(Class<?> clazz) { Introspected introspected = descriptorMap.get(clazz); if (introspected != null) { return introspected; }  /* Introspection should only occur once per class.*/ synchronized (clazz) { /* Double check.  This avoids multiple introspections of the same class.*/ introspected = descriptorMap.get(clazz); if (introspected != null) { return introspected; }  <BUGS> introspected = new Introspected(clazz); <BUGE> descriptorMap.put(clazz, introspected); return introspected; } }
public static Introspected getIntrospected(Class<?> clazz) { Introspected introspected = descriptorMap.get(clazz); if (introspected != null) { return introspected; }  /* Introspection should only occur once per class.*/ synchronized (clazz) { /* Double check.  This avoids multiple introspections of the same class.*/ introspected = descriptorMap.get(clazz); if (introspected != null) { return introspected; }  introspected = new Introspected(clazz); descriptorMap.put(clazz, introspected); return introspected; <BUGS> } <BUGE> }
*/ public String[] getColumnNames() { <BUGS> return columnNames; <BUGE> }
*/ public final T execute() { <BUGS> boolean owner = TransactionElf.beginOrJoinTransaction(); <BUGE>  Connection connection = null; try { connection = ConnectionProxy.wrapConnection(dataSource.getConnection());  if (args != null) { return execute(connection, args); } else { return execute(connection); } } catch (SQLException e) { if (e.getNextException() != null) { e = e.getNextException(); }  if (owner) { /* set the owner to false as we no longer own the transaction and we shouldn't try to commit it later*/ owner = false;  rollback(connection); }  throw new RuntimeException(e); }
*/ public final T execute() { boolean owner = TransactionElf.beginOrJoinTransaction();  <BUGS> Connection connection = null; <BUGE> try { connection = ConnectionProxy.wrapConnection(dataSource.getConnection());  if (args != null) { return execute(connection, args); } else { return execute(connection); } } catch (SQLException e) { if (e.getNextException() != null) { e = e.getNextException(); }  if (owner) { /* set the owner to false as we no longer own the transaction and we shouldn't try to commit it later*/ owner = false;  rollback(connection); }  throw new RuntimeException(e); }
*/ public final T execute() { boolean owner = TransactionElf.beginOrJoinTransaction();  Connection connection = null; try { <BUGS> connection = ConnectionProxy.wrapConnection(dataSource.getConnection()); <BUGE>  if (args != null) { return execute(connection, args); } else { return execute(connection); } } catch (SQLException e) { if (e.getNextException() != null) { e = e.getNextException(); }  if (owner) { /* set the owner to false as we no longer own the transaction and we shouldn't try to commit it later*/ owner = false;  rollback(connection); }  throw new RuntimeException(e); }
*/ public final T execute() { boolean owner = TransactionElf.beginOrJoinTransaction();  Connection connection = null; try { connection = ConnectionProxy.wrapConnection(dataSource.getConnection());  <BUGS> if (args != null) { <BUGE> return execute(connection, args); } else { return execute(connection); } } catch (SQLException e) { if (e.getNextException() != null) { e = e.getNextException(); }  if (owner) { /* set the owner to false as we no longer own the transaction and we shouldn't try to commit it later*/ owner = false;  rollback(connection); }  throw new RuntimeException(e); }
*/ public final T execute() { boolean owner = TransactionElf.beginOrJoinTransaction();  Connection connection = null; try { connection = ConnectionProxy.wrapConnection(dataSource.getConnection());  if (args != null) { return execute(connection, args); } else { <BUGS> return execute(connection); <BUGE> } } catch (SQLException e) { if (e.getNextException() != null) { e = e.getNextException(); }  if (owner) { /* set the owner to false as we no longer own the transaction and we shouldn't try to commit it later*/ owner = false;  rollback(connection); }  throw new RuntimeException(e); }
{ return new SqlClosure<V>(this) { @Override public V execute(Connection connection, Object... params) throws SQLException { return functional.execute(connection, params); } }.executeWith(args); }  /** * Execute the closure. * * @return the template return type of the closure finally { <BUGS> for (ResultSet rs : closeResultSets) { <BUGE> quietClose(rs); }  for (Statement stmt : closeStatements) { quietClose(stmt); }  closeResultSets.clear(); closeStatements.clear();  try { if (owner) { commit(connection); }
{ return new SqlClosure<V>(this) { @Override public V execute(Connection connection, Object... params) throws SQLException { return functional.execute(connection, params); } }.executeWith(args); }  /** * Execute the closure. * * @return the template return type of the closure  <BUGS> for (Statement stmt : closeStatements) { <BUGE> quietClose(stmt); }  closeResultSets.clear(); closeStatements.clear();  try { if (owner) { commit(connection); } } finally { quietClose(connection); }
{ return new SqlClosure<V>(this) { @Override public V execute(Connection connection, Object... params) throws SQLException { return functional.execute(connection, params); } }.executeWith(args); }  /** * Execute the closure. * * @return the template return type of the closure  <BUGS> closeResultSets.clear(); closeStatements.clear(); <BUGE>  try { if (owner) { commit(connection); } } finally { quietClose(connection); } } }  /**
{ return new SqlClosure<V>(this) { @Override public V execute(Connection connection, Object... params) throws SQLException { return functional.execute(connection, params); } }.executeWith(args); }  /** * Execute the closure. * * @return the template return type of the closure try { <BUGS> if (owner) { commit(connection); <BUGE> } } finally { quietClose(connection); } } }  /** * Execute the closure with the specified arguments.  Note using this method * does not create a true closure because the arguments are not encapsulated * within the closure itself.  Meaning you cannot create an instance of the * closure and pass it to another executor.
return new SqlClosure<V>(this) { @Override public V execute(Connection connection, Object... params) throws SQLException { return functional.execute(connection, params); } }.executeWith(args); }  /** * Execute the closure. * * @return the template return type of the closure finally { <BUGS> quietClose(connection); } } <BUGE> }  /** * Execute the closure with the specified arguments.  Note using this method * does not create a true closure because the arguments are not encapsulated * within the closure itself.  Meaning you cannot create an instance of the * closure and pass it to another executor. * * @param args arguments to be passed to the {@code execute(Connection connection, Object...args)} method * @return the result of the execution */ public final T executeWith(Object... args) {
@Override public void rollback() throws IllegalStateException, SecurityException, SystemException { <BUGS> final TxThreadContext threadContext = TxThreadContext.getThreadContext(); <BUGE>  final TxTransaction currentTx = threadContext.getTransaction(); if (currentTx != null) { threadContext.clearTransaction(); currentTx.rollback(); } else { throw new IllegalStateException("TransactionManager.rollback() called from a thread that never joined a transaction"); }  }
@Override public void rollback() throws IllegalStateException, SecurityException, SystemException { final TxThreadContext threadContext = TxThreadContext.getThreadContext();  <BUGS> final TxTransaction currentTx = threadContext.getTransaction(); if (currentTx != null) { threadContext.clearTransaction(); currentTx.rollback(); <BUGE> } else { throw new IllegalStateException("TransactionManager.rollback() called from a thread that never joined a transaction"); }  }
@Override public void rollback() throws IllegalStateException, SecurityException, SystemException { final TxThreadContext threadContext = TxThreadContext.getThreadContext();  final TxTransaction currentTx = threadContext.getTransaction(); if (currentTx != null) { threadContext.clearTransaction(); currentTx.rollback(); } else { throw new IllegalStateException("TransactionManager.rollback() called from a thread that never joined a transaction"); }  <BUGS> } <BUGE>
*/ public String[] getInsertableColumns() { <BUGS> if (insertableColumns != null) { return insertableColumns; <BUGE> }  List<String> columns = new LinkedList<>(); if (hasGeneratedId()) { columns.addAll(Arrays.asList(columnsSansIds)); } else { columns.addAll(Arrays.asList(columnNames)); }  columns.removeIf(s -> !isInsertableColumn(s)); insertableColumns = columns.toArray(new String[0]); return insertableColumns; }
*/ public String[] getInsertableColumns() { if (insertableColumns != null) { return insertableColumns; }  <BUGS> List<String> columns = new LinkedList<>(); if (hasGeneratedId()) { columns.addAll(Arrays.asList(columnsSansIds)); <BUGE> } else { columns.addAll(Arrays.asList(columnNames)); }  columns.removeIf(s -> !isInsertableColumn(s)); insertableColumns = columns.toArray(new String[0]); return insertableColumns; }
*/ public String[] getInsertableColumns() { if (insertableColumns != null) { return insertableColumns; }  List<String> columns = new LinkedList<>(); if (hasGeneratedId()) { columns.addAll(Arrays.asList(columnsSansIds)); } else { <BUGS> columns.addAll(Arrays.asList(columnNames)); <BUGE> }  columns.removeIf(s -> !isInsertableColumn(s)); insertableColumns = columns.toArray(new String[0]); return insertableColumns; }
*/ public String[] getInsertableColumns() { if (insertableColumns != null) { return insertableColumns; }  List<String> columns = new LinkedList<>(); if (hasGeneratedId()) { columns.addAll(Arrays.asList(columnsSansIds)); } else { columns.addAll(Arrays.asList(columnNames)); }  <BUGS> columns.removeIf(s -> !isInsertableColumn(s)); insertableColumns = columns.toArray(new String[0]); return insertableColumns; <BUGE> }
private void processFieldAnnotations(FieldColumnInfo fcInfo) { <BUGS> Field field = fcInfo.field; <BUGE>  Column columnAnnotation = field.getAnnotation(Column.class); if (columnAnnotation != null) { processColumnAnnotation(fcInfo); } else  { /* If there is no Column annotation, is there a JoinColumn annotation?*/ JoinColumn joinColumnAnnotation = field.getAnnotation(JoinColumn.class); if (joinColumnAnnotation != null) { processJoinColumnAnnotation(fcInfo); } else { Id idAnnotation = field.getAnnotation(Id.class); /* @Id without @Column annotation, so preserve case of property name.*/ /* CLARIFY Dead code? Never reached in tests.*/ fcInfo.columnName = field.getName().toLowerCase(); } }  Transient transientAnnotation = field.getAnnotation(Transient.class); if (transientAnnotation == null) { String keyName = !(fcInfo.columnName.startsWith("\"") && fcInfo.columnName.endsWith("\"")) ? fcInfo.columnName : fcInfo.columnName.substring(1, fcInfo.columnName.length() - 1); columnToField.put(keyName, fcInfo); delimitedColumnToField.put(fcInfo.columnName, fcInfo); } }
private void processFieldAnnotations(FieldColumnInfo fcInfo) { Field field = fcInfo.field;  <BUGS> Column columnAnnotation = field.getAnnotation(Column.class); if (columnAnnotation != null) { processColumnAnnotation(fcInfo); <BUGE> } else  { /* If there is no Column annotation, is there a JoinColumn annotation?*/ JoinColumn joinColumnAnnotation = field.getAnnotation(JoinColumn.class); if (joinColumnAnnotation != null) { processJoinColumnAnnotation(fcInfo); } else { Id idAnnotation = field.getAnnotation(Id.class); /* @Id without @Column annotation, so preserve case of property name.*/ /* CLARIFY Dead code? Never reached in tests.*/ fcInfo.columnName = field.getName().toLowerCase(); } }  Transient transientAnnotation = field.getAnnotation(Transient.class); if (transientAnnotation == null) { String keyName = !(fcInfo.columnName.startsWith("\"") && fcInfo.columnName.endsWith("\"")) ? fcInfo.columnName : fcInfo.columnName.substring(1, fcInfo.columnName.length() - 1); columnToField.put(keyName, fcInfo); delimitedColumnToField.put(fcInfo.columnName, fcInfo); } }
private void processFieldAnnotations(FieldColumnInfo fcInfo) { Field field = fcInfo.field;  Column columnAnnotation = field.getAnnotation(Column.class); if (columnAnnotation != null) { processColumnAnnotation(fcInfo); } else  { /* If there is no Column annotation, is there a JoinColumn annotation?*/ <BUGS> JoinColumn joinColumnAnnotation = field.getAnnotation(JoinColumn.class); if (joinColumnAnnotation != null) { <BUGE> processJoinColumnAnnotation(fcInfo); } else { Id idAnnotation = field.getAnnotation(Id.class); /* @Id without @Column annotation, so preserve case of property name.*/ /* CLARIFY Dead code? Never reached in tests.*/ fcInfo.columnName = field.getName().toLowerCase(); } }  Transient transientAnnotation = field.getAnnotation(Transient.class); if (transientAnnotation == null) { String keyName = !(fcInfo.columnName.startsWith("\"") && fcInfo.columnName.endsWith("\"")) ? fcInfo.columnName : fcInfo.columnName.substring(1, fcInfo.columnName.length() - 1); columnToField.put(keyName, fcInfo); delimitedColumnToField.put(fcInfo.columnName, fcInfo); } }
private void processFieldAnnotations(FieldColumnInfo fcInfo) { Field field = fcInfo.field;  Column columnAnnotation = field.getAnnotation(Column.class); if (columnAnnotation != null) { processColumnAnnotation(fcInfo); } else  { /* If there is no Column annotation, is there a JoinColumn annotation?*/ JoinColumn joinColumnAnnotation = field.getAnnotation(JoinColumn.class); if (joinColumnAnnotation != null) { processJoinColumnAnnotation(fcInfo); } else { <BUGS> Id idAnnotation = field.getAnnotation(Id.class); <BUGE> /* @Id without @Column annotation, so preserve case of property name.*/ /* CLARIFY Dead code? Never reached in tests.*/ fcInfo.columnName = field.getName().toLowerCase(); } }  Transient transientAnnotation = field.getAnnotation(Transient.class); if (transientAnnotation == null) { String keyName = !(fcInfo.columnName.startsWith("\"") && fcInfo.columnName.endsWith("\"")) ? fcInfo.columnName : fcInfo.columnName.substring(1, fcInfo.columnName.length() - 1); columnToField.put(keyName, fcInfo); delimitedColumnToField.put(fcInfo.columnName, fcInfo); } }
private void processFieldAnnotations(FieldColumnInfo fcInfo) { Field field = fcInfo.field;  Column columnAnnotation = field.getAnnotation(Column.class); if (columnAnnotation != null) { processColumnAnnotation(fcInfo); } else  { /* If there is no Column annotation, is there a JoinColumn annotation?*/ JoinColumn joinColumnAnnotation = field.getAnnotation(JoinColumn.class); if (joinColumnAnnotation != null) { processJoinColumnAnnotation(fcInfo); } else { Id idAnnotation = field.getAnnotation(Id.class); /* @Id without @Column annotation, so preserve case of property name.*/ /* CLARIFY Dead code? Never reached in tests.*/ <BUGS> fcInfo.columnName = field.getName().toLowerCase(); <BUGE> } }  Transient transientAnnotation = field.getAnnotation(Transient.class); if (transientAnnotation == null) { String keyName = !(fcInfo.columnName.startsWith("\"") && fcInfo.columnName.endsWith("\"")) ? fcInfo.columnName : fcInfo.columnName.substring(1, fcInfo.columnName.length() - 1); columnToField.put(keyName, fcInfo); delimitedColumnToField.put(fcInfo.columnName, fcInfo); } }
private void processFieldAnnotations(FieldColumnInfo fcInfo) { Field field = fcInfo.field;  Column columnAnnotation = field.getAnnotation(Column.class); if (columnAnnotation != null) { processColumnAnnotation(fcInfo); } else  { /* If there is no Column annotation, is there a JoinColumn annotation?*/ JoinColumn joinColumnAnnotation = field.getAnnotation(JoinColumn.class); if (joinColumnAnnotation != null) { processJoinColumnAnnotation(fcInfo); } else { Id idAnnotation = field.getAnnotation(Id.class); /* @Id without @Column annotation, so preserve case of property name.*/ /* CLARIFY Dead code? Never reached in tests.*/ fcInfo.columnName = field.getName().toLowerCase(); } }  <BUGS> Transient transientAnnotation = field.getAnnotation(Transient.class); if (transientAnnotation == null) { String keyName = !(fcInfo.columnName.startsWith("\"") && fcInfo.columnName.endsWith("\"")) ? fcInfo.columnName : fcInfo.columnName.substring(1, fcInfo.columnName.length() - 1); columnToField.put(keyName, fcInfo); delimitedColumnToField.put(fcInfo.columnName, fcInfo); <BUGE> } }
private void processFieldAnnotations(FieldColumnInfo fcInfo) { Field field = fcInfo.field;  Column columnAnnotation = field.getAnnotation(Column.class); if (columnAnnotation != null) { processColumnAnnotation(fcInfo); } else  { /* If there is no Column annotation, is there a JoinColumn annotation?*/ JoinColumn joinColumnAnnotation = field.getAnnotation(JoinColumn.class); if (joinColumnAnnotation != null) { processJoinColumnAnnotation(fcInfo); } else { Id idAnnotation = field.getAnnotation(Id.class); /* @Id without @Column annotation, so preserve case of property name.*/ /* CLARIFY Dead code? Never reached in tests.*/ fcInfo.columnName = field.getName().toLowerCase(); } }  Transient transientAnnotation = field.getAnnotation(Transient.class); if (transientAnnotation == null) { String keyName = !(fcInfo.columnName.startsWith("\"") && fcInfo.columnName.endsWith("\"")) ? fcInfo.columnName : fcInfo.columnName.substring(1, fcInfo.columnName.length() - 1); columnToField.put(keyName, fcInfo); delimitedColumnToField.put(fcInfo.columnName, fcInfo); } <BUGS> } <BUGE>
*/ public static MtContextRunnable get(Runnable runnable, boolean releaseMtContextAfterRun) { <BUGS> if (null == runnable) { <BUGE> return null; }  if (runnable instanceof MtContextRunnable) { /* avoid redundant decoration, and ensure idempotency*/ return (MtContextRunnable) runnable; } return new MtContextRunnable(runnable, releaseMtContextAfterRun); }
*/ public static MtContextRunnable get(Runnable runnable, boolean releaseMtContextAfterRun) { if (null == runnable) { return null; }  <BUGS> if (runnable instanceof MtContextRunnable) { /* avoid redundant decoration, and ensure idempotency*/ return (MtContextRunnable) runnable; <BUGE> } return new MtContextRunnable(runnable, releaseMtContextAfterRun); }
*/ public static MtContextRunnable get(Runnable runnable, boolean releaseMtContextAfterRun) { if (null == runnable) { return null; }  if (runnable instanceof MtContextRunnable) { /* avoid redundant decoration, and ensure idempotency*/ return (MtContextRunnable) runnable; } <BUGS> return new MtContextRunnable(runnable, releaseMtContextAfterRun); <BUGE> }
*/ protected T copy(T parentValue) { <BUGS> return parentValue; <BUGE> }
@Override public void run() { <BUGS> Map<MtContextThreadLocal<?>, Object> copied = copiedRef.get(); if (copied == null || releaseMtContextAfterRun && !copiedRef.compareAndSet(copied, null)) { <BUGE> throw new IllegalStateException("MtContext is released!"); }  Map<MtContextThreadLocal<?>, Object> backup = MtContextThreadLocal.backupAndSet(copied); try { runnable.run(); } finally { MtContextThreadLocal.restore(backup); } }
@Override public void run() { Map<MtContextThreadLocal<?>, Object> copied = copiedRef.get(); if (copied == null || releaseMtContextAfterRun && !copiedRef.compareAndSet(copied, null)) { throw new IllegalStateException("MtContext is released!"); }  <BUGS> Map<MtContextThreadLocal<?>, Object> backup = MtContextThreadLocal.backupAndSet(copied); <BUGE> try { runnable.run(); } finally { MtContextThreadLocal.restore(backup); } }
@Override public void run() { Map<MtContextThreadLocal<?>, Object> copied = copiedRef.get(); if (copied == null || releaseMtContextAfterRun && !copiedRef.compareAndSet(copied, null)) { throw new IllegalStateException("MtContext is released!"); }  Map<MtContextThreadLocal<?>, Object> backup = MtContextThreadLocal.backupAndSet(copied); try { <BUGS> runnable.run(); <BUGE> } finally { MtContextThreadLocal.restore(backup); } }
@Override public void run() { Map<MtContextThreadLocal<?>, Object> copied = copiedRef.get(); if (copied == null || releaseMtContextAfterRun && !copiedRef.compareAndSet(copied, null)) { throw new IllegalStateException("MtContext is released!"); }  Map<MtContextThreadLocal<?>, Object> backup = MtContextThreadLocal.backupAndSet(copied); try { runnable.run(); } finally { <BUGS> MtContextThreadLocal.restore(backup); } } <BUGE>
public class Time { public static Calendar construct(int year, int month) { <BUGS> if (year <= 1900) { throw new IllegalArgumentException("Illegal year '" + year + "'"); <BUGE> } Calendar cal = Calendar.getInstance(); cal.clear(); cal.set(Calendar.YEAR, year); cal.set(Calendar.MONTH, month - 1); return cal; }  public static Calendar construct(int year, int month, int day) { Calendar cal = Time.construct(year, month); cal.set(Calendar.DAY_OF_MONTH, day); return cal; }  public static Calendar construct(int year, int month, int day, int hour) { Calendar cal = Time.construct(year, month, day); cal.set(Calendar.HOUR_OF_DAY, hour); return cal; }  public static Calendar construct(int year, int month, int day, int hour, int minute) { Calendar cal = Time.construct(year, month, day, hour); cal.set(Calendar.MINUTE, minute); return cal; }
public class Time { public static Calendar construct(int year, int month) { if (year <= 1900) { throw new IllegalArgumentException("Illegal year '" + year + "'"); } <BUGS> Calendar cal = Calendar.getInstance(); cal.clear(); cal.set(Calendar.YEAR, year); cal.set(Calendar.MONTH, month - 1); return cal; <BUGE> }  public static Calendar construct(int year, int month, int day) { Calendar cal = Time.construct(year, month); cal.set(Calendar.DAY_OF_MONTH, day); return cal; }  public static Calendar construct(int year, int month, int day, int hour) { Calendar cal = Time.construct(year, month, day); cal.set(Calendar.HOUR_OF_DAY, hour); return cal; }  public static Calendar construct(int year, int month, int day, int hour, int minute) { Calendar cal = Time.construct(year, month, day, hour); cal.set(Calendar.MINUTE, minute); return cal; }
*/ public XadesVerificationProfile withPolicyDocumentProvider( SignaturePolicyDocumentProvider policyDocProvider) { <BUGS> return withBinding(SignaturePolicyDocumentProvider.class, policyDocProvider); <BUGE> }
public DirectKeyingDataProvider(X509Certificate certificate, PrivateKey key) <BUGS> { if (null == certificate || null == key) <BUGE> throw new NullPointerException("Null key or certificate"); this.certificates = Collections.singletonList(certificate); this.key = key; }
public DirectKeyingDataProvider(X509Certificate certificate, PrivateKey key) { if (null == certificate || null == key) throw new NullPointerException("Null key or certificate"); <BUGS> this.certificates = Collections.singletonList(certificate); this.key = key; } <BUGE>
@Override public String getMessage() { <BUGS> if (null == message) <BUGE> { message = String.format("Verification failed for property '%s': %s", getPropertyName(), getVerificationMessage()); } return message; }
@Override public String getMessage() { if (null == message) { <BUGS> message = String.format("Verification failed for property '%s': %s", getPropertyName(), getVerificationMessage()); <BUGE> } return message; }
@Override public String getMessage() { if (null == message) { message = String.format("Verification failed for property '%s': %s", getPropertyName(), getVerificationMessage()); } <BUGS> return message; <BUGE> }
} static KeyInfoRes processKeyInfo( KeyInfo keyInfo, X500NameStyleProvider x500NameStyleProvider) throws CertificateValidationException { <BUGS> if (null == keyInfo || !keyInfo.containsX509Data()) <BUGE> { throw new InvalidKeyInfoDataException("No X509Data to identify the leaf certificate"); } List<X509Certificate> keyInfoCerts = new ArrayList<X509Certificate>(1); XMLX509IssuerSerial issuerSerial = null; X509CertSelector certSelector = new X509CertSelector(); boolean hasSelectionCriteria = false; try { for (int i = 0; i < keyInfo.lengthX509Data(); ++i) { X509Data x509Data = keyInfo.itemX509Data(i); if(!hasSelectionCriteria) { if (x509Data.containsIssuerSerial()) { issuerSerial = x509Data.itemIssuerSerial(0); certSelector.setIssuer(x500NameStyleProvider.fromString(issuerSerial.getIssuerName())); certSelector.setSerialNumber(issuerSerial.getSerialNumber()); hasSelectionCriteria = true; } else if (x509Data.containsSubjectName()) { certSelector.setSubject(x500NameStyleProvider.fromString(x509Data.itemSubjectName(0).getSubjectName())); hasSelectionCriteria = true;
} static KeyInfoRes processKeyInfo( KeyInfo keyInfo, X500NameStyleProvider x500NameStyleProvider) throws CertificateValidationException { if (null == keyInfo || !keyInfo.containsX509Data()) { <BUGS> throw new InvalidKeyInfoDataException("No X509Data to identify the leaf certificate"); <BUGE> } List<X509Certificate> keyInfoCerts = new ArrayList<X509Certificate>(1); XMLX509IssuerSerial issuerSerial = null; X509CertSelector certSelector = new X509CertSelector(); boolean hasSelectionCriteria = false; try { for (int i = 0; i < keyInfo.lengthX509Data(); ++i) { X509Data x509Data = keyInfo.itemX509Data(i); if(!hasSelectionCriteria) { if (x509Data.containsIssuerSerial()) { issuerSerial = x509Data.itemIssuerSerial(0); certSelector.setIssuer(x500NameStyleProvider.fromString(issuerSerial.getIssuerName())); certSelector.setSerialNumber(issuerSerial.getSerialNumber()); hasSelectionCriteria = true; } else if (x509Data.containsSubjectName()) { certSelector.setSubject(x500NameStyleProvider.fromString(x509Data.itemSubjectName(0).getSubjectName())); hasSelectionCriteria = true;
public GeometryFactory getGeometryFactory() { <BUGS> return geometryFactory; <BUGE> }
/** Subclasses should simply construct the instance from the initialized configuration. */ public SpatialContext newSpatialContext() { <BUGS> return new SpatialContext(this); <BUGE> }
protected Shape readShape(JSONParser parser) throws IOException, ParseException { <BUGS> String type = null; <BUGE>  String key = null; int evt = parser.nextEvent(); while (evt != JSONParser.EOF) { switch (evt) { case JSONParser.STRING: if (parser.wasKey()) { key = parser.getString(); } else { if ("type".equals(key)) { type = parser.getString(); } else { throw new ParseException("Unexpected String Value for key: " + key, (int) parser.getPosition()); } } break;  case JSONParser.ARRAY_START: if ("coordinates".equals(key)) { Shape shape = readShapeFromCoordinates(type, parser); readUntilEvent(parser, JSONParser.OBJECT_END); return shape; } else if ("geometries".equals(key)) { List<Shape> shapes = new ArrayList<Shape>(); int sub = parser.nextEvent(); while (sub != JSONParser.EOF) {
protected Shape readShape(JSONParser parser) throws IOException, ParseException { String type = null;  <BUGS> String key = null; int evt = parser.nextEvent(); while (evt != JSONParser.EOF) { switch (evt) { <BUGE> case JSONParser.STRING: if (parser.wasKey()) { key = parser.getString(); } else { if ("type".equals(key)) { type = parser.getString(); } else { throw new ParseException("Unexpected String Value for key: " + key, (int) parser.getPosition()); } } break;  case JSONParser.ARRAY_START: if ("coordinates".equals(key)) { Shape shape = readShapeFromCoordinates(type, parser); readUntilEvent(parser, JSONParser.OBJECT_END); return shape; } else if ("geometries".equals(key)) { List<Shape> shapes = new ArrayList<Shape>(); int sub = parser.nextEvent(); while (sub != JSONParser.EOF) {
protected Shape readShape(JSONParser parser) throws IOException, ParseException { String type = null;  String key = null; int evt = parser.nextEvent(); while (evt != JSONParser.EOF) { switch (evt) { case JSONParser.STRING: <BUGS> if (parser.wasKey()) { key = parser.getString(); <BUGE> } else { if ("type".equals(key)) { type = parser.getString(); } else { throw new ParseException("Unexpected String Value for key: " + key, (int) parser.getPosition()); } } break;  case JSONParser.ARRAY_START: if ("coordinates".equals(key)) { Shape shape = readShapeFromCoordinates(type, parser); readUntilEvent(parser, JSONParser.OBJECT_END); return shape; } else if ("geometries".equals(key)) { List<Shape> shapes = new ArrayList<Shape>(); int sub = parser.nextEvent(); while (sub != JSONParser.EOF) {
protected Shape readShape(JSONParser parser) throws IOException, ParseException { String type = null;  String key = null; int evt = parser.nextEvent(); while (evt != JSONParser.EOF) { switch (evt) { case JSONParser.STRING: if (parser.wasKey()) { key = parser.getString(); } else { <BUGS> if ("type".equals(key)) { type = parser.getString(); <BUGE> } else { throw new ParseException("Unexpected String Value for key: " + key, (int) parser.getPosition()); } } break;  case JSONParser.ARRAY_START: if ("coordinates".equals(key)) { Shape shape = readShapeFromCoordinates(type, parser); readUntilEvent(parser, JSONParser.OBJECT_END); return shape; } else if ("geometries".equals(key)) { List<Shape> shapes = new ArrayList<Shape>(); int sub = parser.nextEvent(); while (sub != JSONParser.EOF) {
protected Shape readShape(JSONParser parser) throws IOException, ParseException { String type = null;  String key = null; int evt = parser.nextEvent(); while (evt != JSONParser.EOF) { switch (evt) { case JSONParser.STRING: if (parser.wasKey()) { key = parser.getString(); } else { if ("type".equals(key)) { type = parser.getString(); } else { throw new ParseException("Unexpected String Value for key: " + key, (int) parser.getPosition()); } } break;  case JSONParser.ARRAY_START: <BUGS> if ("coordinates".equals(key)) { Shape shape = readShapeFromCoordinates(type, parser); <BUGE> readUntilEvent(parser, JSONParser.OBJECT_END); return shape; } else if ("geometries".equals(key)) { List<Shape> shapes = new ArrayList<Shape>(); int sub = parser.nextEvent(); while (sub != JSONParser.EOF) {
protected Shape readShape(JSONParser parser) throws IOException, ParseException { String type = null;  String key = null; int evt = parser.nextEvent(); while (evt != JSONParser.EOF) { switch (evt) { case JSONParser.STRING: if (parser.wasKey()) { key = parser.getString(); } else { if ("type".equals(key)) { type = parser.getString(); } else { throw new ParseException("Unexpected String Value for key: " + key, (int) parser.getPosition()); } } break;  case JSONParser.ARRAY_START: if ("coordinates".equals(key)) { Shape shape = readShapeFromCoordinates(type, parser); readUntilEvent(parser, JSONParser.OBJECT_END); return shape; <BUGS> } else if ("geometries".equals(key)) { List<Shape> shapes = new ArrayList<Shape>(); int sub = parser.nextEvent(); while (sub != JSONParser.EOF) {
if(distUnitsProperty.equals(key)) { String units = parser.getString(); /*TODO: support for more units?*/ if("km".equals(units)) { /* Convert KM to degrees*/ dist = DistanceUtils.dist2Degrees(dist, DistanceUtils.EARTH_MEAN_RADIUS_KM); } } } }  return shapeFactory.normDist(dist); } } <BUGS> } else if (sub == JSONParser.OBJECT_END) { break; <BUGE> } sub = parser.nextEvent(); } if (shapes.isEmpty()) { throw new ParseException("Shape Collection with no geometries!", (int) parser.getPosition()); } return ctx.makeCollection(shapes); } else { throw new ParseException("Unknown type: "+type, (int) parser.getPosition()); }
if(distUnitsProperty.equals(key)) { String units = parser.getString(); /*TODO: support for more units?*/ if("km".equals(units)) { /* Convert KM to degrees*/ dist = DistanceUtils.dist2Degrees(dist, DistanceUtils.EARTH_MEAN_RADIUS_KM); } } } }  return shapeFactory.normDist(dist); } } <BUGS> sub = parser.nextEvent(); <BUGE> } if (shapes.isEmpty()) { throw new ParseException("Shape Collection with no geometries!", (int) parser.getPosition()); } return ctx.makeCollection(shapes); } else { throw new ParseException("Unknown type: "+type, (int) parser.getPosition()); }  case JSONParser.ARRAY_END: break;
String units = parser.getString(); /*TODO: support for more units?*/ if("km".equals(units)) { /* Convert KM to degrees*/ dist = DistanceUtils.dist2Degrees(dist, DistanceUtils.EARTH_MEAN_RADIUS_KM); } } } }  return shapeFactory.normDist(dist); } } <BUGS> if (shapes.isEmpty()) { throw new ParseException("Shape Collection with no geometries!", (int) parser.getPosition()); <BUGE> } return ctx.makeCollection(shapes); } else { throw new ParseException("Unknown type: "+type, (int) parser.getPosition()); }  case JSONParser.ARRAY_END: break;  case JSONParser.OBJECT_START: if (key != null) {
if(distUnitsProperty.equals(key)) { String units = parser.getString(); /*TODO: support for more units?*/ if("km".equals(units)) { /* Convert KM to degrees*/ dist = DistanceUtils.dist2Degrees(dist, DistanceUtils.EARTH_MEAN_RADIUS_KM); } } } }  return shapeFactory.normDist(dist); } case JSONParser.OBJECT_START: <BUGS> if (key != null) { <BUGE> /* System.out.println("Unexpected object: " + key);*/ } break;  case JSONParser.LONG: case JSONParser.NUMBER: case JSONParser.BIGNUMBER: case JSONParser.BOOLEAN: case JSONParser.NULL: case JSONParser.OBJECT_END: /* System.out.println(">>>>>" + JSONParser.getEventString(evt) + " :: " + key);*/ break;  default:
if(distUnitsProperty.equals(key)) { String units = parser.getString(); /*TODO: support for more units?*/ if("km".equals(units)) { /* Convert KM to degrees*/ dist = DistanceUtils.dist2Degrees(dist, DistanceUtils.EARTH_MEAN_RADIUS_KM); } } } }  return shapeFactory.normDist(dist); } } <BUGS> evt = parser.nextEvent(); <BUGE> } throw new RuntimeException("unable to parse shape"); }  protected Shape readShapeFromCoordinates(String type, JSONParser parser) throws IOException, ParseException { switch(type) { case "Point": return readPoint(parser); case "LineString": return readLineString(parser); case "Circle": return readCircle(parser); case "Polygon": return readPolygon(parser, shapeFactory.polygon()).buildOrRect();
*/ public static double normLonDEG(double lon_deg) { <BUGS> if (lon_deg >= -180 && lon_deg <= 180) return lon_deg;/*common case, and avoids slight double precision shifting*/ double off = (lon_deg + 180) % 360; if (off < 0) return 180 + off; <BUGE> else if (off == 0 && lon_deg > 0) return 180; else return -180 + off; }
@Override public void report(SortedMap<String, Gauge> gauges, SortedMap<String, Counter> counters, SortedMap<String, Histogram> histograms, SortedMap<String, Meter> meters, SortedMap<String, Timer> timers) {  <BUGS> final long timestamp = clock.getTime() / 1000; <BUGE>  final Set<OpenTsdbMetric> metrics = new HashSet<OpenTsdbMetric>();  for (Map.Entry<String, Gauge> g : gauges.entrySet()) { metrics.add(buildGauge(g.getKey(), g.getValue(), timestamp)); }  for (Map.Entry<String, Counter> entry : counters.entrySet()) { metrics.add(buildCounter(entry.getKey(), entry.getValue(), timestamp)); }  for (Map.Entry<String, Histogram> entry : histograms.entrySet()) { metrics.addAll(buildHistograms(entry.getKey(), entry.getValue(), timestamp)); }  for (Map.Entry<String, Meter> entry : meters.entrySet()) { metrics.addAll(buildMeters(entry.getKey(), entry.getValue(), timestamp)); }  for (Map.Entry<String, Timer> entry : timers.entrySet()) { metrics.addAll(buildTimers(entry.getKey(), entry.getValue(), timestamp)); }  opentsdb.send(metrics); }
@Override public void report(SortedMap<String, Gauge> gauges, SortedMap<String, Counter> counters, SortedMap<String, Histogram> histograms, SortedMap<String, Meter> meters, SortedMap<String, Timer> timers) {  final long timestamp = clock.getTime() / 1000;  <BUGS> final Set<OpenTsdbMetric> metrics = new HashSet<OpenTsdbMetric>(); <BUGE>  for (Map.Entry<String, Gauge> g : gauges.entrySet()) { metrics.add(buildGauge(g.getKey(), g.getValue(), timestamp)); }  for (Map.Entry<String, Counter> entry : counters.entrySet()) { metrics.add(buildCounter(entry.getKey(), entry.getValue(), timestamp)); }  for (Map.Entry<String, Histogram> entry : histograms.entrySet()) { metrics.addAll(buildHistograms(entry.getKey(), entry.getValue(), timestamp)); }  for (Map.Entry<String, Meter> entry : meters.entrySet()) { metrics.addAll(buildMeters(entry.getKey(), entry.getValue(), timestamp)); }  for (Map.Entry<String, Timer> entry : timers.entrySet()) { metrics.addAll(buildTimers(entry.getKey(), entry.getValue(), timestamp)); }  opentsdb.send(metrics); }
@Override public void report(SortedMap<String, Gauge> gauges, SortedMap<String, Counter> counters, SortedMap<String, Histogram> histograms, SortedMap<String, Meter> meters, SortedMap<String, Timer> timers) {  final long timestamp = clock.getTime() / 1000;  final Set<OpenTsdbMetric> metrics = new HashSet<OpenTsdbMetric>();  <BUGS> for (Map.Entry<String, Gauge> g : gauges.entrySet()) { metrics.add(buildGauge(g.getKey(), g.getValue(), timestamp)); } <BUGE>  for (Map.Entry<String, Counter> entry : counters.entrySet()) { metrics.add(buildCounter(entry.getKey(), entry.getValue(), timestamp)); }  for (Map.Entry<String, Histogram> entry : histograms.entrySet()) { metrics.addAll(buildHistograms(entry.getKey(), entry.getValue(), timestamp)); }  for (Map.Entry<String, Meter> entry : meters.entrySet()) { metrics.addAll(buildMeters(entry.getKey(), entry.getValue(), timestamp)); }  for (Map.Entry<String, Timer> entry : timers.entrySet()) { metrics.addAll(buildTimers(entry.getKey(), entry.getValue(), timestamp)); }  opentsdb.send(metrics); }
@Override public void report(SortedMap<String, Gauge> gauges, SortedMap<String, Counter> counters, SortedMap<String, Histogram> histograms, SortedMap<String, Meter> meters, SortedMap<String, Timer> timers) {  final long timestamp = clock.getTime() / 1000;  final Set<OpenTsdbMetric> metrics = new HashSet<OpenTsdbMetric>();  for (Map.Entry<String, Gauge> g : gauges.entrySet()) { metrics.add(buildGauge(g.getKey(), g.getValue(), timestamp)); }  <BUGS> for (Map.Entry<String, Counter> entry : counters.entrySet()) { <BUGE> metrics.add(buildCounter(entry.getKey(), entry.getValue(), timestamp)); }  for (Map.Entry<String, Histogram> entry : histograms.entrySet()) { metrics.addAll(buildHistograms(entry.getKey(), entry.getValue(), timestamp)); }  for (Map.Entry<String, Meter> entry : meters.entrySet()) { metrics.addAll(buildMeters(entry.getKey(), entry.getValue(), timestamp)); }  for (Map.Entry<String, Timer> entry : timers.entrySet()) { metrics.addAll(buildTimers(entry.getKey(), entry.getValue(), timestamp)); }  opentsdb.send(metrics); }
@Override public void report(SortedMap<String, Gauge> gauges, SortedMap<String, Counter> counters, SortedMap<String, Histogram> histograms, SortedMap<String, Meter> meters, SortedMap<String, Timer> timers) {  final long timestamp = clock.getTime() / 1000;  final Set<OpenTsdbMetric> metrics = new HashSet<OpenTsdbMetric>();  for (Map.Entry<String, Gauge> g : gauges.entrySet()) { metrics.add(buildGauge(g.getKey(), g.getValue(), timestamp)); }  for (Map.Entry<String, Counter> entry : counters.entrySet()) { metrics.add(buildCounter(entry.getKey(), entry.getValue(), timestamp)); }  <BUGS> for (Map.Entry<String, Histogram> entry : histograms.entrySet()) { <BUGE> metrics.addAll(buildHistograms(entry.getKey(), entry.getValue(), timestamp)); }  for (Map.Entry<String, Meter> entry : meters.entrySet()) { metrics.addAll(buildMeters(entry.getKey(), entry.getValue(), timestamp)); }  for (Map.Entry<String, Timer> entry : timers.entrySet()) { metrics.addAll(buildTimers(entry.getKey(), entry.getValue(), timestamp)); }  opentsdb.send(metrics); }
@Override public void report(SortedMap<String, Gauge> gauges, SortedMap<String, Counter> counters, SortedMap<String, Histogram> histograms, SortedMap<String, Meter> meters, SortedMap<String, Timer> timers) {  final long timestamp = clock.getTime() / 1000;  final Set<OpenTsdbMetric> metrics = new HashSet<OpenTsdbMetric>();  for (Map.Entry<String, Gauge> g : gauges.entrySet()) { metrics.add(buildGauge(g.getKey(), g.getValue(), timestamp)); }  for (Map.Entry<String, Counter> entry : counters.entrySet()) { metrics.add(buildCounter(entry.getKey(), entry.getValue(), timestamp)); }  for (Map.Entry<String, Histogram> entry : histograms.entrySet()) { metrics.addAll(buildHistograms(entry.getKey(), entry.getValue(), timestamp)); }  <BUGS> for (Map.Entry<String, Meter> entry : meters.entrySet()) { <BUGE> metrics.addAll(buildMeters(entry.getKey(), entry.getValue(), timestamp)); }  for (Map.Entry<String, Timer> entry : timers.entrySet()) { metrics.addAll(buildTimers(entry.getKey(), entry.getValue(), timestamp)); }  opentsdb.send(metrics); }
@Override public void report(SortedMap<String, Gauge> gauges, SortedMap<String, Counter> counters, SortedMap<String, Histogram> histograms, SortedMap<String, Meter> meters, SortedMap<String, Timer> timers) {  final long timestamp = clock.getTime() / 1000;  final Set<OpenTsdbMetric> metrics = new HashSet<OpenTsdbMetric>();  for (Map.Entry<String, Gauge> g : gauges.entrySet()) { metrics.add(buildGauge(g.getKey(), g.getValue(), timestamp)); }  for (Map.Entry<String, Counter> entry : counters.entrySet()) { metrics.add(buildCounter(entry.getKey(), entry.getValue(), timestamp)); }  for (Map.Entry<String, Histogram> entry : histograms.entrySet()) { metrics.addAll(buildHistograms(entry.getKey(), entry.getValue(), timestamp)); }  for (Map.Entry<String, Meter> entry : meters.entrySet()) { metrics.addAll(buildMeters(entry.getKey(), entry.getValue(), timestamp)); }  <BUGS> for (Map.Entry<String, Timer> entry : timers.entrySet()) { <BUGE> metrics.addAll(buildTimers(entry.getKey(), entry.getValue(), timestamp)); }  opentsdb.send(metrics); }
@Override public void report(SortedMap<String, Gauge> gauges, SortedMap<String, Counter> counters, SortedMap<String, Histogram> histograms, SortedMap<String, Meter> meters, SortedMap<String, Timer> timers) {  final long timestamp = clock.getTime() / 1000;  final Set<OpenTsdbMetric> metrics = new HashSet<OpenTsdbMetric>();  for (Map.Entry<String, Gauge> g : gauges.entrySet()) { metrics.add(buildGauge(g.getKey(), g.getValue(), timestamp)); }  for (Map.Entry<String, Counter> entry : counters.entrySet()) { metrics.add(buildCounter(entry.getKey(), entry.getValue(), timestamp)); }  for (Map.Entry<String, Histogram> entry : histograms.entrySet()) { metrics.addAll(buildHistograms(entry.getKey(), entry.getValue(), timestamp)); }  for (Map.Entry<String, Meter> entry : meters.entrySet()) { metrics.addAll(buildMeters(entry.getKey(), entry.getValue(), timestamp)); }  for (Map.Entry<String, Timer> entry : timers.entrySet()) { metrics.addAll(buildTimers(entry.getKey(), entry.getValue(), timestamp)); }  <BUGS> opentsdb.send(metrics); } <BUGE>
@Override public void report(SortedMap<String, Gauge> gauges, SortedMap<String, Counter> counters, SortedMap<String, Histogram> histograms, SortedMap<String, Meter> meters, SortedMap<String, Timer> timers) {  <BUGS> final long timestamp = clock.getTime() / 1000; <BUGE>  final Set<OpenTsdbMetric> metrics = new HashSet<OpenTsdbMetric>();  for (Map.Entry<String, Gauge> g : gauges.entrySet()) { if(g.getValue().getValue() instanceof Collection && ((Collection)g.getValue().getValue()).isEmpty()) { continue; } metrics.add(buildGauge(g.getKey(), g.getValue(), timestamp)); }  for (Map.Entry<String, Counter> entry : counters.entrySet()) { metrics.add(buildCounter(entry.getKey(), entry.getValue(), timestamp)); }  for (Map.Entry<String, Histogram> entry : histograms.entrySet()) { metrics.addAll(buildHistograms(entry.getKey(), entry.getValue(), timestamp)); }  for (Map.Entry<String, Meter> entry : meters.entrySet()) { metrics.addAll(buildMeters(entry.getKey(), entry.getValue(), timestamp)); }  for (Map.Entry<String, Timer> entry : timers.entrySet()) { metrics.addAll(buildTimers(entry.getKey(), entry.getValue(), timestamp)); }
@Override public void report(SortedMap<String, Gauge> gauges, SortedMap<String, Counter> counters, SortedMap<String, Histogram> histograms, SortedMap<String, Meter> meters, SortedMap<String, Timer> timers) {  final long timestamp = clock.getTime() / 1000;  <BUGS> final Set<OpenTsdbMetric> metrics = new HashSet<OpenTsdbMetric>(); <BUGE>  for (Map.Entry<String, Gauge> g : gauges.entrySet()) { if(g.getValue().getValue() instanceof Collection && ((Collection)g.getValue().getValue()).isEmpty()) { continue; } metrics.add(buildGauge(g.getKey(), g.getValue(), timestamp)); }  for (Map.Entry<String, Counter> entry : counters.entrySet()) { metrics.add(buildCounter(entry.getKey(), entry.getValue(), timestamp)); }  for (Map.Entry<String, Histogram> entry : histograms.entrySet()) { metrics.addAll(buildHistograms(entry.getKey(), entry.getValue(), timestamp)); }  for (Map.Entry<String, Meter> entry : meters.entrySet()) { metrics.addAll(buildMeters(entry.getKey(), entry.getValue(), timestamp)); }  for (Map.Entry<String, Timer> entry : timers.entrySet()) { metrics.addAll(buildTimers(entry.getKey(), entry.getValue(), timestamp)); }
@Override public void report(SortedMap<String, Gauge> gauges, SortedMap<String, Counter> counters, SortedMap<String, Histogram> histograms, SortedMap<String, Meter> meters, SortedMap<String, Timer> timers) {  final long timestamp = clock.getTime() / 1000;  final Set<OpenTsdbMetric> metrics = new HashSet<OpenTsdbMetric>();  <BUGS> for (Map.Entry<String, Gauge> g : gauges.entrySet()) { if(g.getValue().getValue() instanceof Collection && ((Collection)g.getValue().getValue()).isEmpty()) { <BUGE> continue; } metrics.add(buildGauge(g.getKey(), g.getValue(), timestamp)); }  for (Map.Entry<String, Counter> entry : counters.entrySet()) { metrics.add(buildCounter(entry.getKey(), entry.getValue(), timestamp)); }  for (Map.Entry<String, Histogram> entry : histograms.entrySet()) { metrics.addAll(buildHistograms(entry.getKey(), entry.getValue(), timestamp)); }  for (Map.Entry<String, Meter> entry : meters.entrySet()) { metrics.addAll(buildMeters(entry.getKey(), entry.getValue(), timestamp)); }  for (Map.Entry<String, Timer> entry : timers.entrySet()) { metrics.addAll(buildTimers(entry.getKey(), entry.getValue(), timestamp)); }
@Override public void report(SortedMap<String, Gauge> gauges, SortedMap<String, Counter> counters, SortedMap<String, Histogram> histograms, SortedMap<String, Meter> meters, SortedMap<String, Timer> timers) {  final long timestamp = clock.getTime() / 1000;  final Set<OpenTsdbMetric> metrics = new HashSet<OpenTsdbMetric>();  for (Map.Entry<String, Gauge> g : gauges.entrySet()) { if(g.getValue().getValue() instanceof Collection && ((Collection)g.getValue().getValue()).isEmpty()) { continue; } <BUGS> metrics.add(buildGauge(g.getKey(), g.getValue(), timestamp)); } <BUGE>  for (Map.Entry<String, Counter> entry : counters.entrySet()) { metrics.add(buildCounter(entry.getKey(), entry.getValue(), timestamp)); }  for (Map.Entry<String, Histogram> entry : histograms.entrySet()) { metrics.addAll(buildHistograms(entry.getKey(), entry.getValue(), timestamp)); }  for (Map.Entry<String, Meter> entry : meters.entrySet()) { metrics.addAll(buildMeters(entry.getKey(), entry.getValue(), timestamp)); }  for (Map.Entry<String, Timer> entry : timers.entrySet()) { metrics.addAll(buildTimers(entry.getKey(), entry.getValue(), timestamp)); }
@Override public void report(SortedMap<String, Gauge> gauges, SortedMap<String, Counter> counters, SortedMap<String, Histogram> histograms, SortedMap<String, Meter> meters, SortedMap<String, Timer> timers) {  final long timestamp = clock.getTime() / 1000;  final Set<OpenTsdbMetric> metrics = new HashSet<OpenTsdbMetric>();  for (Map.Entry<String, Gauge> g : gauges.entrySet()) { if(g.getValue().getValue() instanceof Collection && ((Collection)g.getValue().getValue()).isEmpty()) { continue; } metrics.add(buildGauge(g.getKey(), g.getValue(), timestamp)); }  <BUGS> for (Map.Entry<String, Counter> entry : counters.entrySet()) { <BUGE> metrics.add(buildCounter(entry.getKey(), entry.getValue(), timestamp)); }  for (Map.Entry<String, Histogram> entry : histograms.entrySet()) { metrics.addAll(buildHistograms(entry.getKey(), entry.getValue(), timestamp)); }  for (Map.Entry<String, Meter> entry : meters.entrySet()) { metrics.addAll(buildMeters(entry.getKey(), entry.getValue(), timestamp)); }  for (Map.Entry<String, Timer> entry : timers.entrySet()) { metrics.addAll(buildTimers(entry.getKey(), entry.getValue(), timestamp)); }
@Override public void report(SortedMap<String, Gauge> gauges, SortedMap<String, Counter> counters, SortedMap<String, Histogram> histograms, SortedMap<String, Meter> meters, SortedMap<String, Timer> timers) {  final long timestamp = clock.getTime() / 1000;  final Set<OpenTsdbMetric> metrics = new HashSet<OpenTsdbMetric>();  for (Map.Entry<String, Gauge> g : gauges.entrySet()) { if(g.getValue().getValue() instanceof Collection && ((Collection)g.getValue().getValue()).isEmpty()) { continue; } metrics.add(buildGauge(g.getKey(), g.getValue(), timestamp)); }  for (Map.Entry<String, Counter> entry : counters.entrySet()) { metrics.add(buildCounter(entry.getKey(), entry.getValue(), timestamp)); }  <BUGS> for (Map.Entry<String, Histogram> entry : histograms.entrySet()) { <BUGE> metrics.addAll(buildHistograms(entry.getKey(), entry.getValue(), timestamp)); }  for (Map.Entry<String, Meter> entry : meters.entrySet()) { metrics.addAll(buildMeters(entry.getKey(), entry.getValue(), timestamp)); }  for (Map.Entry<String, Timer> entry : timers.entrySet()) { metrics.addAll(buildTimers(entry.getKey(), entry.getValue(), timestamp)); }
@Override public void report(SortedMap<String, Gauge> gauges, SortedMap<String, Counter> counters, SortedMap<String, Histogram> histograms, SortedMap<String, Meter> meters, SortedMap<String, Timer> timers) {  final long timestamp = clock.getTime() / 1000;  final Set<OpenTsdbMetric> metrics = new HashSet<OpenTsdbMetric>();  for (Map.Entry<String, Gauge> g : gauges.entrySet()) { if(g.getValue().getValue() instanceof Collection && ((Collection)g.getValue().getValue()).isEmpty()) { continue; } metrics.add(buildGauge(g.getKey(), g.getValue(), timestamp)); }  for (Map.Entry<String, Counter> entry : counters.entrySet()) { metrics.add(buildCounter(entry.getKey(), entry.getValue(), timestamp)); }  for (Map.Entry<String, Histogram> entry : histograms.entrySet()) { metrics.addAll(buildHistograms(entry.getKey(), entry.getValue(), timestamp)); }  <BUGS> for (Map.Entry<String, Meter> entry : meters.entrySet()) { <BUGE> metrics.addAll(buildMeters(entry.getKey(), entry.getValue(), timestamp)); }  for (Map.Entry<String, Timer> entry : timers.entrySet()) { metrics.addAll(buildTimers(entry.getKey(), entry.getValue(), timestamp)); }
@Override public void report(SortedMap<String, Gauge> gauges, SortedMap<String, Counter> counters, SortedMap<String, Histogram> histograms, SortedMap<String, Meter> meters, SortedMap<String, Timer> timers) {  final long timestamp = clock.getTime() / 1000;  final Set<OpenTsdbMetric> metrics = new HashSet<OpenTsdbMetric>();  for (Map.Entry<String, Gauge> g : gauges.entrySet()) { if(g.getValue().getValue() instanceof Collection && ((Collection)g.getValue().getValue()).isEmpty()) { continue; } metrics.add(buildGauge(g.getKey(), g.getValue(), timestamp)); }  for (Map.Entry<String, Counter> entry : counters.entrySet()) { metrics.add(buildCounter(entry.getKey(), entry.getValue(), timestamp)); }  for (Map.Entry<String, Histogram> entry : histograms.entrySet()) { metrics.addAll(buildHistograms(entry.getKey(), entry.getValue(), timestamp)); }  for (Map.Entry<String, Meter> entry : meters.entrySet()) { metrics.addAll(buildMeters(entry.getKey(), entry.getValue(), timestamp)); }  <BUGS> for (Map.Entry<String, Timer> entry : timers.entrySet()) { <BUGE> metrics.addAll(buildTimers(entry.getKey(), entry.getValue(), timestamp)); }
public Set<OpenTsdbMetric> build() { return metrics; } }  private OpenTsdbReporter(MetricRegistry registry, OpenTsdb opentsdb, Clock clock, String prefix, TimeUnit rateUnit, TimeUnit durationUnit, MetricFilter filter, Map<String, String> tags) { super(registry, "opentsdb-reporter", filter, rateUnit, durationUnit); this.opentsdb = opentsdb; this.clock = clock; this.prefix = prefix; this.tags = tags; }   <BUGS> opentsdb.send(metrics); } <BUGE>  private Set<OpenTsdbMetric> buildTimers(String name, Timer timer, long timestamp) { final MetricsCollector collector = MetricsCollector.createNew(prefix(name), tags, timestamp); final Snapshot snapshot = timer.getSnapshot();  return collector.addMetric("count", timer.getCount()) /*convert rate*/ .addMetric("m15", convertRate(timer.getFifteenMinuteRate())) .addMetric("m5", convertRate(timer.getFiveMinuteRate())) .addMetric("m1", convertRate(timer.getOneMinuteRate())) .addMetric("mean_rate", convertRate(timer.getMeanRate())) /* convert duration*/ .addMetric("max", convertDuration(snapshot.getMax()))
*/ public static String[] getBeanNames(ListableBeanFactory beanFactory, Class<?> beanClass, boolean includingAncestors) { // Issue : https:/*github.com/alibaba/spring-context-support/issues/22*/ final BeanFactory actualBeanFactory; <BUGS> if (beanFactory instanceof ConfigurableApplicationContext) { ConfigurableApplicationContext applicationContext = ConfigurableApplicationContext.class.cast(beanFactory); actualBeanFactory = applicationContext.getBeanFactory(); } else { <BUGE> actualBeanFactory = beanFactory; } if (actualBeanFactory instanceof ConfigurableListableBeanFactory) { return getBeanNames((ConfigurableListableBeanFactory) actualBeanFactory, beanClass, includingAncestors); } return EMPTY_BEAN_NAMES; }
*/ public static String[] getBeanNames(ListableBeanFactory beanFactory, Class<?> beanClass, boolean includingAncestors) { // Issue : https:/*github.com/alibaba/spring-context-support/issues/22*/ final BeanFactory actualBeanFactory; if (beanFactory instanceof ConfigurableApplicationContext) { ConfigurableApplicationContext applicationContext = ConfigurableApplicationContext.class.cast(beanFactory); actualBeanFactory = applicationContext.getBeanFactory(); } else { actualBeanFactory = beanFactory; } <BUGS> if (actualBeanFactory instanceof ConfigurableListableBeanFactory) { return getBeanNames((ConfigurableListableBeanFactory) actualBeanFactory, beanClass, includingAncestors); <BUGE> } return EMPTY_BEAN_NAMES; }
*/ public Collection getSubMatches() { <BUGS> return subMatches; <BUGE> }
public void setBreaks(boolean breaks) { <BUGS> this.breaks = breaks; } <BUGE>
protected void token(String src, boolean top, boolean bq, LexerContext context){ <BUGS> while(src.length() > 0){ <BUGE> /* newline*/ { List<String> cap = rules.get("newline").exec(src); if(!cap.isEmpty()){ src = src.substring(cap.get(0).length()); if(cap.get(0).length() > 1){ context.pushToken(new SpaceToken()); } } }  /* code*/ { List<String> cap = rules.get("code").exec(src); if(!cap.isEmpty()){ src = src.substring(cap.get(0).length()); String code = cap.get(0).replaceAll("(?m)^ {4}", ""); if(!options.isPedantic()){ context.pushToken(new CodeToken(code.replaceAll("\\n+$", ""), null, false)); } else { context.pushToken(new CodeToken(code, null, false)); } continue; } }  /* fences (gfm)*/
protected void token(String src, boolean top, boolean bq, LexerContext context){ while(src.length() > 0){ /* newline*/ { <BUGS> List<String> cap = rules.get("newline").exec(src); if(!cap.isEmpty()){ <BUGE> src = src.substring(cap.get(0).length()); if(cap.get(0).length() > 1){ context.pushToken(new SpaceToken()); } } }  /* code*/ { List<String> cap = rules.get("code").exec(src); if(!cap.isEmpty()){ src = src.substring(cap.get(0).length()); String code = cap.get(0).replaceAll("(?m)^ {4}", ""); if(!options.isPedantic()){ context.pushToken(new CodeToken(code.replaceAll("\\n+$", ""), null, false)); } else { context.pushToken(new CodeToken(code, null, false)); } continue; } }  /* fences (gfm)*/
protected void token(String src, boolean top, boolean bq, LexerContext context){ while(src.length() > 0){ /* newline*/ { List<String> cap = rules.get("newline").exec(src); if(!cap.isEmpty()){ src = src.substring(cap.get(0).length()); if(cap.get(0).length() > 1){ context.pushToken(new SpaceToken()); } } }  /* code*/ { <BUGS> List<String> cap = rules.get("code").exec(src); if(!cap.isEmpty()){ <BUGE> src = src.substring(cap.get(0).length()); String code = cap.get(0).replaceAll("(?m)^ {4}", ""); if(!options.isPedantic()){ context.pushToken(new CodeToken(code.replaceAll("\\n+$", ""), null, false)); } else { context.pushToken(new CodeToken(code, null, false)); } continue; } }  /* fences (gfm)*/
public LexerResult lex(String src){ LexerContext context = new LexerContext();  token(src .replace("\r\n", "\n") .replace("\r", "\n") .replace("\t", "    ") .replace("\u00a0", " ") .replace("\u2424", "\n"), true, false, context);  return new LexerResult(context.getTokens(), context.getLinks()); } { <BUGS> List<String> cap = rules.get("fences").exec(src); if(!cap.isEmpty()){ <BUGE> src = src.substring(cap.get(0).length()); context.pushToken(new CodeToken(cap.get(3), cap.get(2), false)); continue; } }  /* heading*/ { List<String> cap = rules.get("heading").exec(src); if(!cap.isEmpty()){ src = src.substring(cap.get(0).length()); context.pushToken(new HeadingToken(cap.get(1).length(), cap.get(2))); continue;
public LexerResult lex(String src){ LexerContext context = new LexerContext();  token(src .replace("\r\n", "\n") .replace("\r", "\n") .replace("\t", "    ") .replace("\u00a0", " ") .replace("\u2424", "\n"), true, false, context);  return new LexerResult(context.getTokens(), context.getLinks()); } { <BUGS> List<String> cap = rules.get("heading").exec(src); if(!cap.isEmpty()){ <BUGE> src = src.substring(cap.get(0).length()); context.pushToken(new HeadingToken(cap.get(1).length(), cap.get(2))); continue; } }  /* table no leading pipe (gfm)*/ if(top){ List<String> cap = rules.get("nptable").exec(src); if(!cap.isEmpty()){ src = src.substring(cap.get(0).length());  String[] header = cap.get(1).replaceAll("^ *| *\\| *$", "").split(" *\\| *");
public LexerResult lex(String src){ LexerContext context = new LexerContext();  token(src .replace("\r\n", "\n") .replace("\r", "\n") .replace("\t", "    ") .replace("\u00a0", " ") .replace("\u2424", "\n"), true, false, context);  return new LexerResult(context.getTokens(), context.getLinks()); } /* table no leading pipe (gfm)*/ <BUGS> if(top){ List<String> cap = rules.get("nptable").exec(src); if(!cap.isEmpty()){ <BUGE> src = src.substring(cap.get(0).length());  String[] header = cap.get(1).replaceAll("^ *| *\\| *$", "").split(" *\\| *"); String[] align  = cap.get(2).replaceAll("^ *|\\| *$", "").split(" *\\| *"); String[] cells  = cap.get(3).replaceAll("\n$", "").split("\n");  List<String> header2 = Arrays.asList(header);  List<String> align2 = new ArrayList<>(); for (String s : align) { if(s.matches("^ *-+: *$")){ align2.add("right"); } else if(s.matches("^ *:-+: *$")){
public LexerResult lex(String src){ LexerContext context = new LexerContext();  token(src .replace("\r\n", "\n") .replace("\r", "\n") .replace("\t", "    ") .replace("\u00a0", " ") .replace("\u2424", "\n"), true, false, context);  return new LexerResult(context.getTokens(), context.getLinks()); } { <BUGS> List<String> cap = rules.get("lheading").exec(src); if(!cap.isEmpty()){ <BUGE> src = src.substring(cap.get(0).length()); if(cap.get(2).equals("=")){ context.pushToken(new HeadingToken(1, cap.get(1))); } else { context.pushToken(new HeadingToken(2, cap.get(1))); } continue; } }  /* hr*/ { List<String> cap = rules.get("hr").exec(src);
public LexerResult lex(String src){ LexerContext context = new LexerContext();  token(src .replace("\r\n", "\n") .replace("\r", "\n") .replace("\t", "    ") .replace("\u00a0", " ") .replace("\u2424", "\n"), true, false, context);  return new LexerResult(context.getTokens(), context.getLinks()); } { <BUGS> List<String> cap = rules.get("hr").exec(src); if(!cap.isEmpty()){ <BUGE> src = src.substring(cap.get(0).length()); context.pushToken(new HrToken()); continue; } }  /* blockquote*/ { List<String> cap = rules.get("blockquote").exec(src); if(!cap.isEmpty()){ src = src.substring(cap.get(0).length()); context.pushToken(new BlockquoteStartToken()); token(cap.get(0).replaceAll("(?m) *> ?", ""), top, true, context);
public LexerResult lex(String src){ LexerContext context = new LexerContext();  token(src .replace("\r\n", "\n") .replace("\r", "\n") .replace("\t", "    ") .replace("\u00a0", " ") .replace("\u2424", "\n"), true, false, context);  return new LexerResult(context.getTokens(), context.getLinks()); } { <BUGS> List<String> cap = rules.get("blockquote").exec(src); if(!cap.isEmpty()){ <BUGE> src = src.substring(cap.get(0).length()); context.pushToken(new BlockquoteStartToken()); token(cap.get(0).replaceAll("(?m) *> ?", ""), top, true, context); context.pushToken(new BlockquoteEndToken()); continue; } }  /* list*/ { List<String> cap = rules.get("list").exec(src); if(!cap.isEmpty()){ src = src.substring(cap.get(0).length());
public LexerResult lex(String src){ LexerContext context = new LexerContext();  token(src .replace("\r\n", "\n") .replace("\r", "\n") .replace("\t", "    ") .replace("\u00a0", " ") .replace("\u2424", "\n"), true, false, context);  return new LexerResult(context.getTokens(), context.getLinks()); } { <BUGS> List<String> cap = rules.get("list").exec(src); if(!cap.isEmpty()){ <BUGE> src = src.substring(cap.get(0).length()); String bull = cap.get(2);  context.pushToken(new ListStartToken(bull.matches("^[0-9]+\\.$"))); boolean next = false;  /* Get each top-level item.*/ cap = rules.get("item").exec(cap.get(0)); if(!cap.isEmpty()){ for(int i = 0; i < cap.size(); i++){ String item = cap.get(i);  /* Remove the list item's bullet*/
public LexerResult lex(String src){ LexerContext context = new LexerContext();  token(src .replace("\r\n", "\n") .replace("\r", "\n") .replace("\t", "    ") .replace("\u00a0", " ") .replace("\u2424", "\n"), true, false, context);  return new LexerResult(context.getTokens(), context.getLinks()); } { <BUGS> List<String> cap = rules.get("html").exec(src); if(!cap.isEmpty()){ <BUGE> src = src.substring(cap.get(0).length()); if(options.isSanitize()){ context.pushToken(new ParagraphToken(cap.get(0))); } else { context.pushToken(new HtmlToken(cap.get(0), !options.isSanitize() && (cap.get(0).equals("pre") || cap.get(0).equals("script") || cap.get(0).equals("style")))); } continue; } }  /* def*/ if(!bq && top){
public LexerResult lex(String src){ LexerContext context = new LexerContext();  token(src .replace("\r\n", "\n") .replace("\r", "\n") .replace("\t", "    ") .replace("\u00a0", " ") .replace("\u2424", "\n"), true, false, context);  return new LexerResult(context.getTokens(), context.getLinks()); } /* def*/ <BUGS> if(!bq && top){ List<String> cap = rules.get("def").exec(src); if(!cap.isEmpty()){ <BUGE> src = src.substring(cap.get(0).length()); context.defineLink(cap.get(1).toLowerCase(), new Link(cap.get(2), cap.get(3))); continue; } }  /* table (gfm)*/ if(top){ List<String> cap = rules.get("table").exec(src); if(!cap.isEmpty()){ src = src.substring(cap.get(0).length());  String[] header = cap.get(1).replaceAll("^ *| *\\| *$", "").split(" *\\| *");
public LexerResult lex(String src){ LexerContext context = new LexerContext();  token(src .replace("\r\n", "\n") .replace("\r", "\n") .replace("\t", "    ") .replace("\u00a0", " ") .replace("\u2424", "\n"), true, false, context);  return new LexerResult(context.getTokens(), context.getLinks()); } /* table (gfm)*/ <BUGS> if(top){ List<String> cap = rules.get("table").exec(src); if(!cap.isEmpty()){ <BUGE> src = src.substring(cap.get(0).length());  String[] header = cap.get(1).replaceAll("^ *| *\\| *$", "").split(" *\\| *"); String[] align  = cap.get(2).replaceAll("^ *|\\| *$", "").split(" *\\| *"); String[] cells  = cap.get(3).replaceAll("(?: *\\| *)?\\n$", "").split("\\n");  List<String> header2 = Arrays.asList(header);  List<String> align2 = new ArrayList<>(); for (String s : align) { if(s.matches("^ *-+: *$")){ align2.add("right"); } else if(s.matches("^ *:-+: *$")){
LexerContext context = new LexerContext();  token(src .replace("\r\n", "\n") .replace("\r", "\n") .replace("\t", "    ") .replace("\u00a0", " ") .replace("\u2424", "\n"), true, false, context);  return new LexerResult(context.getTokens(), context.getLinks()); } /* top-level paragraph*/ <BUGS> if(top){ List<String> cap = rules.get("paragraph").exec(src); if(!cap.isEmpty()){ src = src.substring(cap.get(0).length()); if(cap.get(1).charAt(cap.get(1).length() - 1) == '\n'){ <BUGE> context.pushToken(new ParagraphToken(cap.get(1).substring(0, cap.get(1).length() - 1))); } else { context.pushToken(new ParagraphToken(cap.get(1))); } continue; } }  /* text*/ { List<String> cap = rules.get("text").exec(src); if(!cap.isEmpty()){
public LexerResult lex(String src){ LexerContext context = new LexerContext();  token(src .replace("\r\n", "\n") .replace("\r", "\n") .replace("\t", "    ") .replace("\u00a0", " ") .replace("\u2424", "\n"), true, false, context);  return new LexerResult(context.getTokens(), context.getLinks()); } } else { <BUGS> context.pushToken(new ParagraphToken(cap.get(1))); <BUGE> } continue; } }  /* text*/ { List<String> cap = rules.get("text").exec(src); if(!cap.isEmpty()){ src = src.substring(cap.get(0).length()); context.pushToken(new TextToken((cap.get(0)))); continue; } }
public LexerResult lex(String src){ LexerContext context = new LexerContext();  token(src .replace("\r\n", "\n") .replace("\r", "\n") .replace("\t", "    ") .replace("\u00a0", " ") .replace("\u2424", "\n"), true, false, context);  return new LexerResult(context.getTokens(), context.getLinks()); } } <BUGS> continue; <BUGE> } }  /* text*/ { List<String> cap = rules.get("text").exec(src); if(!cap.isEmpty()){ src = src.substring(cap.get(0).length()); context.pushToken(new TextToken((cap.get(0)))); continue; } }  /* TODO Error*/
public LexerResult lex(String src){ LexerContext context = new LexerContext();  token(src .replace("\r\n", "\n") .replace("\r", "\n") .replace("\t", "    ") .replace("\u00a0", " ") .replace("\u2424", "\n"), true, false, context);  return new LexerResult(context.getTokens(), context.getLinks()); } } <BUGS> } <BUGE>  public static class LexerContext { private Stack<Token> tokens = new Stack<>(); private Map<String, Link> links = new HashMap<>();  public void pushToken(Token token){ this.tokens.push(token); }  public void defineLink(String key, Link link){ this.links.put(key, link); }  public Stack<Token> getTokens() {
public String tablecell(String content, TableCellFlags flags){ String cellType; <BUGS> if(flags.isHeader()){ cellType = "th"; <BUGE> } else { cellType = "td"; }  String align = flags.getAlign(); if(align != null){ return "<" + cellType + " style=\"text-align: " + align + "\">" + content + "</" + cellType + ">\n"; } else { return "<" + cellType + ">" + content + "</" + cellType + ">\n"; } }
public String tablecell(String content, TableCellFlags flags){ String cellType; if(flags.isHeader()){ cellType = "th"; } else { <BUGS> cellType = "td"; <BUGE> }  String align = flags.getAlign(); if(align != null){ return "<" + cellType + " style=\"text-align: " + align + "\">" + content + "</" + cellType + ">\n"; } else { return "<" + cellType + ">" + content + "</" + cellType + ">\n"; } }
public String tablecell(String content, TableCellFlags flags){ String cellType; if(flags.isHeader()){ cellType = "th"; } else { cellType = "td"; }  <BUGS> String align = flags.getAlign(); if(align != null){ return "<" + cellType + " style=\"text-align: " + align + "\">" + content + "</" + cellType + ">\n"; <BUGE> } else { return "<" + cellType + ">" + content + "</" + cellType + ">\n"; } }
public String tablecell(String content, TableCellFlags flags){ String cellType; if(flags.isHeader()){ cellType = "th"; } else { cellType = "td"; }  String align = flags.getAlign(); if(align != null){ return "<" + cellType + " style=\"text-align: " + align + "\">" + content + "</" + cellType + ">\n"; } else { <BUGS> return "<" + cellType + ">" + content + "</" + cellType + ">\n"; <BUGE> } }
public String codespan(String text){ <BUGS> return "<code>" + text + "</code>"; <BUGE> }
protected void token(String src, boolean top, boolean bq, LexerContext context){ <BUGS> while(src.length() > 0){ <BUGE> /* newline*/ { List<String> cap = rules.get("newline").exec(src); if(!cap.isEmpty()){ src = src.substring(cap.get(0).length()); if(cap.get(0).length() > 1){ context.pushToken(new SpaceToken()); } } }  /* code*/ { List<String> cap = rules.get("code").exec(src); if(!cap.isEmpty()){ src = src.substring(cap.get(0).length()); String code = cap.get(0).replaceAll("(?m)^ {4}", ""); if(!options.isPedantic()){ context.pushToken(new CodeToken(code.replaceAll("\\n+$", ""), null, false)); } else { context.pushToken(new CodeToken(code, null, false)); } continue; } }  /* fences (gfm)*/
protected void token(String src, boolean top, boolean bq, LexerContext context){ while(src.length() > 0){ /* newline*/ { <BUGS> List<String> cap = rules.get("newline").exec(src); if(!cap.isEmpty()){ <BUGE> src = src.substring(cap.get(0).length()); if(cap.get(0).length() > 1){ context.pushToken(new SpaceToken()); } } }  /* code*/ { List<String> cap = rules.get("code").exec(src); if(!cap.isEmpty()){ src = src.substring(cap.get(0).length()); String code = cap.get(0).replaceAll("(?m)^ {4}", ""); if(!options.isPedantic()){ context.pushToken(new CodeToken(code.replaceAll("\\n+$", ""), null, false)); } else { context.pushToken(new CodeToken(code, null, false)); } continue; } }  /* fences (gfm)*/
protected void token(String src, boolean top, boolean bq, LexerContext context){ while(src.length() > 0){ /* newline*/ { List<String> cap = rules.get("newline").exec(src); if(!cap.isEmpty()){ src = src.substring(cap.get(0).length()); if(cap.get(0).length() > 1){ context.pushToken(new SpaceToken()); } } }  /* code*/ { <BUGS> List<String> cap = rules.get("code").exec(src); if(!cap.isEmpty()){ src = src.substring(cap.get(0).length()); String code = cap.get(0).replaceAll("(?m)^ {4}", ""); if(!options.isPedantic()){ context.pushToken(new CodeToken(code.replaceAll("\\n+$", ""), null, false)); <BUGE> } else { context.pushToken(new CodeToken(code, null, false)); } continue; } }  /* fences (gfm)*/
public LexerResult lex(String src){ LexerContext context = new LexerContext();  token(src .replace("\r\n", "\n") .replace("\r", "\n") .replace("\t", "    ") .replace("\u00a0", " ") .replace("\u2424", "\n"), true, false, context);  return new LexerResult(context.getTokens(), context.getLinks()); } { <BUGS> List<String> cap = rules.get("fences").exec(src); if(!cap.isEmpty()){ <BUGE> src = src.substring(cap.get(0).length()); context.pushToken(new CodeToken(cap.get(3), cap.get(2), false)); continue; } }  /* heading*/ { List<String> cap = rules.get("heading").exec(src); if(!cap.isEmpty()){ src = src.substring(cap.get(0).length()); context.pushToken(new HeadingToken(cap.get(1).length(), cap.get(2))); continue;
public LexerResult lex(String src){ LexerContext context = new LexerContext();  token(src .replace("\r\n", "\n") .replace("\r", "\n") .replace("\t", "    ") .replace("\u00a0", " ") .replace("\u2424", "\n"), true, false, context);  return new LexerResult(context.getTokens(), context.getLinks()); } { <BUGS> List<String> cap = rules.get("heading").exec(src); if(!cap.isEmpty()){ <BUGE> src = src.substring(cap.get(0).length()); context.pushToken(new HeadingToken(cap.get(1).length(), cap.get(2))); continue; } }  /* table no leading pipe (gfm)*/ if(top){ List<String> cap = rules.get("nptable").exec(src); if(!cap.isEmpty()){ src = src.substring(cap.get(0).length());  String[] header = cap.get(1).replaceAll("^ *| *\\| *$", "").split(" *\\| *");
public LexerResult lex(String src){ LexerContext context = new LexerContext();  token(src .replace("\r\n", "\n") .replace("\r", "\n") .replace("\t", "    ") .replace("\u00a0", " ") .replace("\u2424", "\n"), true, false, context);  return new LexerResult(context.getTokens(), context.getLinks()); } /* table no leading pipe (gfm)*/ <BUGS> if(top){ List<String> cap = rules.get("nptable").exec(src); if(!cap.isEmpty()){ <BUGE> src = src.substring(cap.get(0).length());  String[] header = cap.get(1).replaceAll("^ *| *\\| *$", "").split(" *\\| *"); String[] align  = cap.get(2).replaceAll("^ *|\\| *$", "").split(" *\\| *"); String[] cells  = cap.get(3).replaceAll("\\n$", "").split(" \\n");  List<String> header2 = Arrays.asList(header);  List<String> align2 = new ArrayList<>(); for (String s : align) { if(s.matches("^ *-+: *$")){ align2.add("right"); } else if(s.matches("^ *:-+: *$")){
public LexerResult lex(String src){ LexerContext context = new LexerContext();  token(src .replace("\r\n", "\n") .replace("\r", "\n") .replace("\t", "    ") .replace("\u00a0", " ") .replace("\u2424", "\n"), true, false, context);  return new LexerResult(context.getTokens(), context.getLinks()); } { <BUGS> List<String> cap = rules.get("lheading").exec(src); if(!cap.isEmpty()){ <BUGE> src = src.substring(cap.get(0).length()); if(cap.get(2).equals("=")){ context.pushToken(new HeadingToken(1, cap.get(1))); } else { context.pushToken(new HeadingToken(2, cap.get(1))); } continue; } }  /* hr*/ { List<String> cap = rules.get("hr").exec(src);
public LexerResult lex(String src){ LexerContext context = new LexerContext();  token(src .replace("\r\n", "\n") .replace("\r", "\n") .replace("\t", "    ") .replace("\u00a0", " ") .replace("\u2424", "\n"), true, false, context);  return new LexerResult(context.getTokens(), context.getLinks()); } { <BUGS> List<String> cap = rules.get("hr").exec(src); if(!cap.isEmpty()){ <BUGE> src = src.substring(cap.get(0).length()); context.pushToken(new HrToken()); continue; } }  /* blockquote*/ { List<String> cap = rules.get("blockquote").exec(src); if(!cap.isEmpty()){ src = src.substring(cap.get(0).length()); context.pushToken(new BlockquoteStartToken()); token(cap.get(0).replaceAll("(?m) *> ?", ""), top, true, context);
public LexerResult lex(String src){ LexerContext context = new LexerContext();  token(src .replace("\r\n", "\n") .replace("\r", "\n") .replace("\t", "    ") .replace("\u00a0", " ") .replace("\u2424", "\n"), true, false, context);  return new LexerResult(context.getTokens(), context.getLinks()); } { <BUGS> List<String> cap = rules.get("blockquote").exec(src); if(!cap.isEmpty()){ <BUGE> src = src.substring(cap.get(0).length()); context.pushToken(new BlockquoteStartToken()); token(cap.get(0).replaceAll("(?m) *> ?", ""), top, true, context); context.pushToken(new BlockquoteEndToken()); continue; } }  /* list*/ { List<String> cap = rules.get("list").exec(src); if(!cap.isEmpty()){ src = src.substring(cap.get(0).length());
public LexerResult lex(String src){ LexerContext context = new LexerContext();  token(src .replace("\r\n", "\n") .replace("\r", "\n") .replace("\t", "    ") .replace("\u00a0", " ") .replace("\u2424", "\n"), true, false, context);  return new LexerResult(context.getTokens(), context.getLinks()); } { <BUGS> List<String> cap = rules.get("list").exec(src); if(!cap.isEmpty()){ <BUGE> src = src.substring(cap.get(0).length()); String bull = cap.get(2);  context.pushToken(new ListStartToken(bull.matches("^[0-9]+\\.$"))); boolean next = false;  /* Get each top-level item.*/ cap = rules.get("item").exec(cap.get(0)); if(!cap.isEmpty()){ for(int i = 0; i < cap.size(); i++){ String item = cap.get(i);  /* Remove the list item's bullet*/
public LexerResult lex(String src){ LexerContext context = new LexerContext();  token(src .replace("\r\n", "\n") .replace("\r", "\n") .replace("\t", "    ") .replace("\u00a0", " ") .replace("\u2424", "\n"), true, false, context);  return new LexerResult(context.getTokens(), context.getLinks()); } { <BUGS> List<String> cap = rules.get("html").exec(src); if(!cap.isEmpty()){ <BUGE> src = src.substring(cap.get(0).length()); if(options.isSanitize()){ context.pushToken(new ParagraphToken(cap.get(0))); } else { context.pushToken(new HtmlToken(cap.get(0), !options.isSanitize() && (cap.get(0).equals("pre") || cap.get(0).equals("script") || cap.get(0).equals("style")))); } continue; } }  /* def*/ if(!bq && top){
public LexerResult lex(String src){ LexerContext context = new LexerContext();  token(src .replace("\r\n", "\n") .replace("\r", "\n") .replace("\t", "    ") .replace("\u00a0", " ") .replace("\u2424", "\n"), true, false, context);  return new LexerResult(context.getTokens(), context.getLinks()); } /* def*/ <BUGS> if(!bq && top){ List<String> cap = rules.get("def").exec(src); if(!cap.isEmpty()){ <BUGE> src = src.substring(cap.get(0).length()); context.defineLink(cap.get(1).toLowerCase(), new Link(cap.get(2), cap.get(3))); continue; } }  /* table (gfm)*/ if(top){ List<String> cap = rules.get("table").exec(src); if(!cap.isEmpty()){ src = src.substring(cap.get(0).length());  String[] header = cap.get(1).replaceAll("^ *| *\\| *$", "").split(" *\\| *");
public LexerResult lex(String src){ LexerContext context = new LexerContext();  token(src .replace("\r\n", "\n") .replace("\r", "\n") .replace("\t", "    ") .replace("\u00a0", " ") .replace("\u2424", "\n"), true, false, context);  return new LexerResult(context.getTokens(), context.getLinks()); } /* table (gfm)*/ <BUGS> if(top){ List<String> cap = rules.get("table").exec(src); if(!cap.isEmpty()){ <BUGE> src = src.substring(cap.get(0).length());  String[] header = cap.get(1).replaceAll("^ *| *\\| *$", "").split(" *\\| *"); String[] align  = cap.get(2).replaceAll("^ *|\\| *$", "").split(" *\\| *"); String[] cells  = cap.get(3).replaceAll("(?: *\\| *)?\\n$", "").split("\\n");  List<String> header2 = Arrays.asList(header);  List<String> align2 = new ArrayList<>(); for (String s : align) { if(s.matches("^ *-+: *$")){ align2.add("right"); } else if(s.matches("^ *:-+: *$")){
LexerContext context = new LexerContext();  token(src .replace("\r\n", "\n") .replace("\r", "\n") .replace("\t", "    ") .replace("\u00a0", " ") .replace("\u2424", "\n"), true, false, context);  return new LexerResult(context.getTokens(), context.getLinks()); } /* top-level paragraph*/ <BUGS> if(top){ List<String> cap = rules.get("paragraph").exec(src); if(!cap.isEmpty()){ src = src.substring(cap.get(0).length()); if(cap.get(1).charAt(cap.get(1).length() - 1) == '\n'){ context.pushToken(new ParagraphToken(cap.get(1).substring(0, cap.get(1).length() - 1))); <BUGE> } else { context.pushToken(new ParagraphToken(cap.get(1))); } continue; } }  /* text*/ { List<String> cap = rules.get("text").exec(src); if(!cap.isEmpty()){
public LexerResult lex(String src){ LexerContext context = new LexerContext();  token(src .replace("\r\n", "\n") .replace("\r", "\n") .replace("\t", "    ") .replace("\u00a0", " ") .replace("\u2424", "\n"), true, false, context);  return new LexerResult(context.getTokens(), context.getLinks()); } } else { <BUGS> context.pushToken(new ParagraphToken(cap.get(1))); <BUGE> } continue; } }  /* text*/ { List<String> cap = rules.get("text").exec(src); if(!cap.isEmpty()){ src = src.substring(cap.get(0).length()); context.pushToken(new TextToken((cap.get(0)))); continue; } }
public LexerResult lex(String src){ LexerContext context = new LexerContext();  token(src .replace("\r\n", "\n") .replace("\r", "\n") .replace("\t", "    ") .replace("\u00a0", " ") .replace("\u2424", "\n"), true, false, context);  return new LexerResult(context.getTokens(), context.getLinks()); } } <BUGS> continue; <BUGE> } }  /* text*/ { List<String> cap = rules.get("text").exec(src); if(!cap.isEmpty()){ src = src.substring(cap.get(0).length()); context.pushToken(new TextToken((cap.get(0)))); continue; } }  /* TODO Error*/
public LexerResult lex(String src){ LexerContext context = new LexerContext();  token(src .replace("\r\n", "\n") .replace("\r", "\n") .replace("\t", "    ") .replace("\u00a0", " ") .replace("\u2424", "\n"), true, false, context);  return new LexerResult(context.getTokens(), context.getLinks()); } } <BUGS> } <BUGE>  public static class LexerContext { private Stack<Token> tokens = new Stack<>(); private Map<String, Link> links = new HashMap<>();  public void pushToken(Token token){ this.tokens.push(token); }  public void defineLink(String key, Link link){ this.links.put(key, link); }  public Stack<Token> getTokens() {
protected void token(String src, boolean top, boolean bq, LexerContext context){ <BUGS> while(src.length() > 0){ <BUGE> /* newline*/ { List<String> cap = rules.get("newline").exec(src); if(!cap.isEmpty()){ src = src.substring(cap.get(0).length()); if(cap.get(0).length() > 1){ context.pushToken(new SpaceToken()); } } }  /* code*/ { List<String> cap = rules.get("code").exec(src); if(!cap.isEmpty()){ src = src.substring(cap.get(0).length()); String code = cap.get(0).replaceAll("(?m)^ {4}", ""); if(!options.isPedantic()){ context.pushToken(new CodeToken(code.replaceAll("\\n+$", ""), null, false)); } else { context.pushToken(new CodeToken(code, null, false)); } continue; } }  /* fences (gfm)*/
protected void token(String src, boolean top, boolean bq, LexerContext context){ while(src.length() > 0){ /* newline*/ { <BUGS> List<String> cap = rules.get("newline").exec(src); if(!cap.isEmpty()){ <BUGE> src = src.substring(cap.get(0).length()); if(cap.get(0).length() > 1){ context.pushToken(new SpaceToken()); } } }  /* code*/ { List<String> cap = rules.get("code").exec(src); if(!cap.isEmpty()){ src = src.substring(cap.get(0).length()); String code = cap.get(0).replaceAll("(?m)^ {4}", ""); if(!options.isPedantic()){ context.pushToken(new CodeToken(code.replaceAll("\\n+$", ""), null, false)); } else { context.pushToken(new CodeToken(code, null, false)); } continue; } }  /* fences (gfm)*/
protected void token(String src, boolean top, boolean bq, LexerContext context){ while(src.length() > 0){ /* newline*/ { List<String> cap = rules.get("newline").exec(src); if(!cap.isEmpty()){ src = src.substring(cap.get(0).length()); if(cap.get(0).length() > 1){ context.pushToken(new SpaceToken()); } } }  /* code*/ { <BUGS> List<String> cap = rules.get("code").exec(src); if(!cap.isEmpty()){ <BUGE> src = src.substring(cap.get(0).length()); String code = cap.get(0).replaceAll("(?m)^ {4}", ""); if(!options.isPedantic()){ context.pushToken(new CodeToken(code.replaceAll("\\n+$", ""), null, false)); } else { context.pushToken(new CodeToken(code, null, false)); } continue; } }  /* fences (gfm)*/
public LexerResult lex(String src){ LexerContext context = new LexerContext();  token(src .replace("\r\n", "\n") .replace("\r", "\n") .replace("\t", "    ") .replace("\u00a0", " ") .replace("\u2424", "\n"), true, false, context);  return new LexerResult(context.getTokens(), context.getLinks()); } { <BUGS> List<String> cap = rules.get("fences").exec(src); if(!cap.isEmpty()){ <BUGE> src = src.substring(cap.get(0).length()); context.pushToken(new CodeToken(cap.get(3), cap.get(2), false)); continue; } }  /* heading*/ { List<String> cap = rules.get("heading").exec(src); if(!cap.isEmpty()){ src = src.substring(cap.get(0).length()); context.pushToken(new HeadingToken(cap.get(1).length(), cap.get(2))); continue;
public LexerResult lex(String src){ LexerContext context = new LexerContext();  token(src .replace("\r\n", "\n") .replace("\r", "\n") .replace("\t", "    ") .replace("\u00a0", " ") .replace("\u2424", "\n"), true, false, context);  return new LexerResult(context.getTokens(), context.getLinks()); } { <BUGS> List<String> cap = rules.get("heading").exec(src); if(!cap.isEmpty()){ <BUGE> src = src.substring(cap.get(0).length()); context.pushToken(new HeadingToken(cap.get(1).length(), cap.get(2))); continue; } }  /* table no leading pipe (gfm)*/ if(top){ List<String> cap = rules.get("nptable").exec(src); if(!cap.isEmpty()){ src = src.substring(cap.get(0).length());  String[] header = cap.get(1).replaceAll("^ *| *\\| *$", "").split(" *\\| *");
public LexerResult lex(String src){ LexerContext context = new LexerContext();  token(src .replace("\r\n", "\n") .replace("\r", "\n") .replace("\t", "    ") .replace("\u00a0", " ") .replace("\u2424", "\n"), true, false, context);  return new LexerResult(context.getTokens(), context.getLinks()); } /* table no leading pipe (gfm)*/ <BUGS> if(top){ List<String> cap = rules.get("nptable").exec(src); if(!cap.isEmpty()){ src = src.substring(cap.get(0).length()); <BUGE>  String[] header = cap.get(1).replaceAll("^ *| *\\| *$", "").split(" *\\| *"); String[] align  = cap.get(2).replaceAll("^ *|\\| *$", "").split(" *\\| *"); String[] cells  = cap.get(3).replaceAll("\\n$", "").split(" \\n");  List<String> header2 = Arrays.asList(header);  List<String> align2 = new ArrayList<>(); for (String s : align) { if(s.matches("^ *-+: *$")){ align2.add("right"); } else if(s.matches("^ *:-+: *$")){
public LexerResult lex(String src){ LexerContext context = new LexerContext();  token(src .replace("\r\n", "\n") .replace("\r", "\n") .replace("\t", "    ") .replace("\u00a0", " ") .replace("\u2424", "\n"), true, false, context);  return new LexerResult(context.getTokens(), context.getLinks()); }  <BUGS> String[] header = cap.get(1).replaceAll("^ *| *\\| *$", "").split(" *\\| *"); String[] align  = cap.get(2).replaceAll("^ *|\\| *$", "").split(" *\\| *"); String[] cells  = cap.get(3).replaceAll("\\n$", "").split(" \\n"); <BUGE>  List<String> header2 = Arrays.asList(header);  List<String> align2 = new ArrayList<>(); for (String s : align) { if(s.matches("^ *-+: *$")){ align2.add("right"); } else if(s.matches("^ *:-+: *$")){ align2.add("center"); } else if(s.matches("^ *:-+ *$")){ align2.add("left"); } else { align2.add(null);
public LexerResult lex(String src){ LexerContext context = new LexerContext();  token(src .replace("\r\n", "\n") .replace("\r", "\n") .replace("\t", "    ") .replace("\u00a0", " ") .replace("\u2424", "\n"), true, false, context);  return new LexerResult(context.getTokens(), context.getLinks()); }  <BUGS> List<String> header2 = Arrays.asList(header); <BUGE>  List<String> align2 = new ArrayList<>(); for (String s : align) { if(s.matches("^ *-+: *$")){ align2.add("right"); } else if(s.matches("^ *:-+: *$")){ align2.add("center"); } else if(s.matches("^ *:-+ *$")){ align2.add("left"); } else { align2.add(null); } }
public LexerResult lex(String src){ LexerContext context = new LexerContext();  token(src .replace("\r\n", "\n") .replace("\r", "\n") .replace("\t", "    ") .replace("\u00a0", " ") .replace("\u2424", "\n"), true, false, context);  return new LexerResult(context.getTokens(), context.getLinks()); }  <BUGS> List<String> align2 = new ArrayList<>(); for (String s : align) { if(s.matches("^ *-+: *$")){ <BUGE> align2.add("right"); } else if(s.matches("^ *:-+: *$")){ align2.add("center"); } else if(s.matches("^ *:-+ *$")){ align2.add("left"); } else { align2.add(null); } }  List<List<String>> cells2 = new ArrayList<>(); for (String cell : cells) { cells2.add(Arrays.asList(cell.split(" *\\| *")));
public LexerResult lex(String src){ LexerContext context = new LexerContext();  token(src .replace("\r\n", "\n") .replace("\r", "\n") .replace("\t", "    ") .replace("\u00a0", " ") .replace("\u2424", "\n"), true, false, context);  return new LexerResult(context.getTokens(), context.getLinks()); } align2.add("right"); <BUGS> } else if(s.matches("^ *:-+: *$")){ align2.add("center"); <BUGE> } else if(s.matches("^ *:-+ *$")){ align2.add("left"); } else { align2.add(null); } }  List<List<String>> cells2 = new ArrayList<>(); for (String cell : cells) { cells2.add(Arrays.asList(cell.split(" *\\| *"))); }  context.pushToken(new TableToken(header2, align2, cells2));
public LexerResult lex(String src){ LexerContext context = new LexerContext();  token(src .replace("\r\n", "\n") .replace("\r", "\n") .replace("\t", "    ") .replace("\u00a0", " ") .replace("\u2424", "\n"), true, false, context);  return new LexerResult(context.getTokens(), context.getLinks()); }  <BUGS> List<List<String>> cells2 = new ArrayList<>(); for (String cell : cells) { cells2.add(Arrays.asList(cell.split(" *\\| *"))); <BUGE> }  context.pushToken(new TableToken(header2, align2, cells2)); continue; } }  /* lheading*/ { List<String> cap = rules.get("lheading").exec(src); if(!cap.isEmpty()){ src = src.substring(cap.get(0).length()); if(cap.get(2).equals("=")){
public LexerResult lex(String src){ LexerContext context = new LexerContext();  token(src .replace("\r\n", "\n") .replace("\r", "\n") .replace("\t", "    ") .replace("\u00a0", " ") .replace("\u2424", "\n"), true, false, context);  return new LexerResult(context.getTokens(), context.getLinks()); }  <BUGS> context.pushToken(new TableToken(header2, align2, cells2)); continue; <BUGE> } }  /* lheading*/ { List<String> cap = rules.get("lheading").exec(src); if(!cap.isEmpty()){ src = src.substring(cap.get(0).length()); if(cap.get(2).equals("=")){ context.pushToken(new HeadingToken(1, cap.get(1))); } else { context.pushToken(new HeadingToken(2, cap.get(1))); }
public LexerResult lex(String src){ LexerContext context = new LexerContext();  token(src .replace("\r\n", "\n") .replace("\r", "\n") .replace("\t", "    ") .replace("\u00a0", " ") .replace("\u2424", "\n"), true, false, context);  return new LexerResult(context.getTokens(), context.getLinks()); } } <BUGS> } <BUGE>  public static class LexerContext { private Stack<Token> tokens = new Stack<>(); private Map<String, Link> links = new HashMap<>();  public void pushToken(Token token){ this.tokens.push(token); }  public void defineLink(String key, Link link){ this.links.put(key, link); }  public Stack<Token> getTokens() {
public String tablecell(String content, TableCellFlags flags){ String cellType; <BUGS> if(flags.isHeader()){ cellType = "th"; <BUGE> } else { cellType = "td"; }  String align = flags.getAlign(); if(align != null){ return "<" + cellType + " style=\"text-align: " + align + "\">" + content + "</" + cellType + ">\n"; } else { return "<" + cellType + ">" + content + "</" + cellType + ">\n"; } }
public String tablecell(String content, TableCellFlags flags){ String cellType; if(flags.isHeader()){ cellType = "th"; } else { <BUGS> cellType = "td"; <BUGE> }  String align = flags.getAlign(); if(align != null){ return "<" + cellType + " style=\"text-align: " + align + "\">" + content + "</" + cellType + ">\n"; } else { return "<" + cellType + ">" + content + "</" + cellType + ">\n"; } }
public String tablecell(String content, TableCellFlags flags){ String cellType; if(flags.isHeader()){ cellType = "th"; } else { cellType = "td"; }  <BUGS> String align = flags.getAlign(); if(align != null){ <BUGE> return "<" + cellType + " style=\"text-align: " + align + "\">" + content + "</" + cellType + ">\n"; } else { return "<" + cellType + ">" + content + "</" + cellType + ">\n"; } }
public String tablecell(String content, TableCellFlags flags){ String cellType; if(flags.isHeader()){ cellType = "th"; } else { cellType = "td"; }  String align = flags.getAlign(); if(align != null){ return "<" + cellType + " style=\"text-align: " + align + "\">" + content + "</" + cellType + ">\n"; } else { <BUGS> return "<" + cellType + ">" + content + "</" + cellType + ">\n"; <BUGE> } }
protected void token(String src, boolean top, boolean bq, LexerContext context){ <BUGS> while(src.length() > 0){ <BUGE> /* newline*/ { List<String> cap = rules.get("newline").exec(src); if(!cap.isEmpty()){ src = src.substring(cap.get(0).length()); if(cap.get(0).length() > 1){ context.pushToken(new SpaceToken()); } } }  /* code*/ { List<String> cap = rules.get("code").exec(src); if(!cap.isEmpty()){ src = src.substring(cap.get(0).length()); String code = cap.get(0).replaceAll("(?m)^ {4}", ""); if(!options.isPedantic()){ context.pushToken(new CodeToken(code.replaceAll("\\n+$", ""), null, false)); } else { context.pushToken(new CodeToken(code, null, false)); } continue; } }  /* fences (gfm)*/
protected void token(String src, boolean top, boolean bq, LexerContext context){ while(src.length() > 0){ /* newline*/ { <BUGS> List<String> cap = rules.get("newline").exec(src); if(!cap.isEmpty()){ <BUGE> src = src.substring(cap.get(0).length()); if(cap.get(0).length() > 1){ context.pushToken(new SpaceToken()); } } }  /* code*/ { List<String> cap = rules.get("code").exec(src); if(!cap.isEmpty()){ src = src.substring(cap.get(0).length()); String code = cap.get(0).replaceAll("(?m)^ {4}", ""); if(!options.isPedantic()){ context.pushToken(new CodeToken(code.replaceAll("\\n+$", ""), null, false)); } else { context.pushToken(new CodeToken(code, null, false)); } continue; } }  /* fences (gfm)*/
protected void token(String src, boolean top, boolean bq, LexerContext context){ while(src.length() > 0){ /* newline*/ { List<String> cap = rules.get("newline").exec(src); if(!cap.isEmpty()){ src = src.substring(cap.get(0).length()); if(cap.get(0).length() > 1){ context.pushToken(new SpaceToken()); } } }  /* code*/ { <BUGS> List<String> cap = rules.get("code").exec(src); if(!cap.isEmpty()){ <BUGE> src = src.substring(cap.get(0).length()); String code = cap.get(0).replaceAll("(?m)^ {4}", ""); if(!options.isPedantic()){ context.pushToken(new CodeToken(code.replaceAll("\\n+$", ""), null, false)); } else { context.pushToken(new CodeToken(code, null, false)); } continue; } }  /* fences (gfm)*/
public LexerResult lex(String src){ LexerContext context = new LexerContext();  token(src .replace("\r\n", "\n") .replace("\r", "\n") .replace("\t", "    ") .replace("\u00a0", " ") .replace("\u2424", "\n"), true, false, context);  return new LexerResult(context.getTokens(), context.getLinks()); } { <BUGS> List<String> cap = rules.get("fences").exec(src); if(!cap.isEmpty()){ <BUGE> src = src.substring(cap.get(0).length()); context.pushToken(new CodeToken(cap.get(3), cap.get(2), false)); continue; } }  /* heading*/ { List<String> cap = rules.get("heading").exec(src); if(!cap.isEmpty()){ src = src.substring(cap.get(0).length()); context.pushToken(new HeadingToken(cap.get(1).length(), cap.get(2))); continue;
public LexerResult lex(String src){ LexerContext context = new LexerContext();  token(src .replace("\r\n", "\n") .replace("\r", "\n") .replace("\t", "    ") .replace("\u00a0", " ") .replace("\u2424", "\n"), true, false, context);  return new LexerResult(context.getTokens(), context.getLinks()); } { <BUGS> List<String> cap = rules.get("heading").exec(src); if(!cap.isEmpty()){ <BUGE> src = src.substring(cap.get(0).length()); context.pushToken(new HeadingToken(cap.get(1).length(), cap.get(2))); continue; } }  /* table no leading pipe (gfm)*/ if(top){ List<String> cap = rules.get("nptable").exec(src); if(!cap.isEmpty()){ src = src.substring(cap.get(0).length());  String[] header = cap.get(1).replaceAll("^ *| *\\| *$", "").split(" *\\| *");
public LexerResult lex(String src){ LexerContext context = new LexerContext();  token(src .replace("\r\n", "\n") .replace("\r", "\n") .replace("\t", "    ") .replace("\u00a0", " ") .replace("\u2424", "\n"), true, false, context);  return new LexerResult(context.getTokens(), context.getLinks()); } /* table no leading pipe (gfm)*/ <BUGS> if(top){ List<String> cap = rules.get("nptable").exec(src); if(!cap.isEmpty()){ <BUGE> src = src.substring(cap.get(0).length());  String[] header = cap.get(1).replaceAll("^ *| *\\| *$", "").split(" *\\| *"); String[] align  = cap.get(2).replaceAll("^ *|\\| *$", "").split(" *\\| *"); String[] cells  = cap.get(3).replaceAll("\n$", "").split("\n");  List<String> header2 = Arrays.asList(header);  List<String> align2 = new ArrayList<>(); for (String s : align) { if(s.matches("^ *-+: *$")){ align2.add("right"); } else if(s.matches("^ *:-+: *$")){
public LexerResult lex(String src){ LexerContext context = new LexerContext();  token(src .replace("\r\n", "\n") .replace("\r", "\n") .replace("\t", "    ") .replace("\u00a0", " ") .replace("\u2424", "\n"), true, false, context);  return new LexerResult(context.getTokens(), context.getLinks()); } { <BUGS> List<String> cap = rules.get("lheading").exec(src); if(!cap.isEmpty()){ <BUGE> src = src.substring(cap.get(0).length()); if(cap.get(2).equals("=")){ context.pushToken(new HeadingToken(1, cap.get(1))); } else { context.pushToken(new HeadingToken(2, cap.get(1))); } continue; } }  /* hr*/ { List<String> cap = rules.get("hr").exec(src);
public LexerResult lex(String src){ LexerContext context = new LexerContext();  token(src .replace("\r\n", "\n") .replace("\r", "\n") .replace("\t", "    ") .replace("\u00a0", " ") .replace("\u2424", "\n"), true, false, context);  return new LexerResult(context.getTokens(), context.getLinks()); } { <BUGS> List<String> cap = rules.get("hr").exec(src); if(!cap.isEmpty()){ <BUGE> src = src.substring(cap.get(0).length()); context.pushToken(new HrToken()); continue; } }  /* blockquote*/ { List<String> cap = rules.get("blockquote").exec(src); if(!cap.isEmpty()){ src = src.substring(cap.get(0).length()); context.pushToken(new BlockquoteStartToken()); token(cap.get(0).replaceAll("(?m) *> ?", ""), top, true, context);
public LexerResult lex(String src){ LexerContext context = new LexerContext();  token(src .replace("\r\n", "\n") .replace("\r", "\n") .replace("\t", "    ") .replace("\u00a0", " ") .replace("\u2424", "\n"), true, false, context);  return new LexerResult(context.getTokens(), context.getLinks()); } { <BUGS> List<String> cap = rules.get("blockquote").exec(src); if(!cap.isEmpty()){ <BUGE> src = src.substring(cap.get(0).length()); context.pushToken(new BlockquoteStartToken()); token(cap.get(0).replaceAll("(?m) *> ?", ""), top, true, context); context.pushToken(new BlockquoteEndToken()); continue; } }  /* list*/ { List<String> cap = rules.get("list").exec(src); if(!cap.isEmpty()){ src = src.substring(cap.get(0).length());
public LexerResult lex(String src){ LexerContext context = new LexerContext();  token(src .replace("\r\n", "\n") .replace("\r", "\n") .replace("\t", "    ") .replace("\u00a0", " ") .replace("\u2424", "\n"), true, false, context);  return new LexerResult(context.getTokens(), context.getLinks()); } { <BUGS> List<String> cap = rules.get("list").exec(src); if(!cap.isEmpty()){ src = src.substring(cap.get(0).length()); String bull = cap.get(2); <BUGE>  context.pushToken(new ListStartToken(bull.matches("^[0-9]+\\.$"))); boolean next = false;  /* Get each top-level item.*/ cap = rules.get("item").exec(cap.get(0)); if(!cap.isEmpty()){ for(int i = 0; i < cap.size(); i++){ String item = cap.get(i);  /* Remove the list item's bullet*/ /* so it is seen as the nextToken token.*/
public LexerResult lex(String src){ LexerContext context = new LexerContext();  token(src .replace("\r\n", "\n") .replace("\r", "\n") .replace("\t", "    ") .replace("\u00a0", " ") .replace("\u2424", "\n"), true, false, context);  return new LexerResult(context.getTokens(), context.getLinks()); }  <BUGS> context.pushToken(new ListStartToken(bull.matches("^[0-9]+\\.$"))); boolean next = false; <BUGE>  /* Get each top-level item.*/ cap = rules.get("item").exec(cap.get(0)); if(!cap.isEmpty()){ for(int i = 0; i < cap.size(); i++){ String item = cap.get(i);  /* Remove the list item's bullet*/ /* so it is seen as the nextToken token.*/ int space = item.length(); item = item.replaceAll("^ *([*+-]|\\d+\\.) +", "");  /* Outdent whatever the*/
public LexerResult lex(String src){ LexerContext context = new LexerContext();  token(src .replace("\r\n", "\n") .replace("\r", "\n") .replace("\t", "    ") .replace("\u00a0", " ") .replace("\u2424", "\n"), true, false, context);  return new LexerResult(context.getTokens(), context.getLinks()); } /* Get each top-level item.*/ <BUGS> cap = rules.get("item").exec(cap.get(0)); if(!cap.isEmpty()){ for(int i = 0; i < cap.size(); i++){ String item = cap.get(i); <BUGE>  /* Remove the list item's bullet*/ /* so it is seen as the nextToken token.*/ int space = item.length(); item = item.replaceAll("^ *([*+-]|\\d+\\.) +", "");  /* Outdent whatever the*/ /* list item contains. Hacky.*/ if(item.indexOf("\n ") > 0){ space = space - item.length(); if(!options.isPedantic()){ item = item.replaceAll("(?m)^ {1," + space + "}", "");
public LexerResult lex(String src){ LexerContext context = new LexerContext();  token(src .replace("\r\n", "\n") .replace("\r", "\n") .replace("\t", "    ") .replace("\u00a0", " ") .replace("\u2424", "\n"), true, false, context);  return new LexerResult(context.getTokens(), context.getLinks()); } /* so it is seen as the nextToken token.*/ <BUGS> int space = item.length(); item = item.replaceAll("^ *([*+-]|\\d+\\.) +", ""); <BUGE>  /* Outdent whatever the*/ /* list item contains. Hacky.*/ if(item.indexOf("\n ") > 0){ space = space - item.length(); if(!options.isPedantic()){ item = item.replaceAll("(?m)^ {1," + space + "}", ""); } else { item = item.replaceAll("(?m)^ {1,4}", ""); } }  //                            /* Determine whether the nextToken list item belongs here.*/
public LexerResult lex(String src){ LexerContext context = new LexerContext();  token(src .replace("\r\n", "\n") .replace("\r", "\n") .replace("\t", "    ") .replace("\u00a0", " ") .replace("\u2424", "\n"), true, false, context);  return new LexerResult(context.getTokens(), context.getLinks()); } /* list item contains. Hacky.*/ <BUGS> if(item.indexOf("\n ") > 0){ <BUGE> space = space - item.length(); if(!options.isPedantic()){ item = item.replaceAll("(?m)^ {1," + space + "}", ""); } else { item = item.replaceAll("(?m)^ {1,4}", ""); } }  //                            /* Determine whether the nextToken list item belongs here.*/ //                            /* Backpedal if it does not belong in this list.*/ /*                            if(options.isSmartLists() && i != cap.size() - 1){*/ /*                                Pattern p = Pattern.compile(Grammer.BULLET);*/ /*                                if(p.matcher(cap.get(i + 1)).find()){*/ /*                                    src = String.join("\n", cap.subList(i + 1, cap.size())) + src;*/
LexerContext context = new LexerContext();  token(src .replace("\r\n", "\n") .replace("\r", "\n") .replace("\t", "    ") .replace("\u00a0", " ") .replace("\u2424", "\n"), true, false, context);  return new LexerResult(context.getTokens(), context.getLinks()); } /* for discount behavior.*/ <BUGS> boolean loose = next || item.matches("\\n\\n(?!\\s*$)"); if(i != cap.size() - 1){ next = item.charAt(item.length() - 1) == '\n'; if(!loose) { loose = next; <BUGE> } }  if(loose){ context.pushToken(new LooseItemStartToken()); } else { context.pushToken(new ListItemStartToken()); }  token(item, false, bq, context); context.pushToken(new ListItemEndToken()); }
public LexerResult lex(String src){ LexerContext context = new LexerContext();  token(src .replace("\r\n", "\n") .replace("\r", "\n") .replace("\t", "    ") .replace("\u00a0", " ") .replace("\u2424", "\n"), true, false, context);  return new LexerResult(context.getTokens(), context.getLinks()); }  <BUGS> if(loose){ <BUGE> context.pushToken(new LooseItemStartToken()); } else { context.pushToken(new ListItemStartToken()); }  token(item, false, bq, context); context.pushToken(new ListItemEndToken()); } } context.pushToken(new ListEndToken()); continue; } }
public LexerResult lex(String src){ LexerContext context = new LexerContext();  token(src .replace("\r\n", "\n") .replace("\r", "\n") .replace("\t", "    ") .replace("\u00a0", " ") .replace("\u2424", "\n"), true, false, context);  return new LexerResult(context.getTokens(), context.getLinks()); } } else { <BUGS> context.pushToken(new ListItemStartToken()); <BUGE> }  token(item, false, bq, context); context.pushToken(new ListItemEndToken()); } } context.pushToken(new ListEndToken()); continue; } }  /* html*/ { List<String> cap = rules.get("html").exec(src);
public LexerResult lex(String src){ LexerContext context = new LexerContext();  token(src .replace("\r\n", "\n") .replace("\r", "\n") .replace("\t", "    ") .replace("\u00a0", " ") .replace("\u2424", "\n"), true, false, context);  return new LexerResult(context.getTokens(), context.getLinks()); }  <BUGS> token(item, false, bq, context); context.pushToken(new ListItemEndToken()); <BUGE> } } context.pushToken(new ListEndToken()); continue; } }  /* html*/ { List<String> cap = rules.get("html").exec(src); if(!cap.isEmpty()){ src = src.substring(cap.get(0).length()); if(options.isSanitize()){
public LexerResult lex(String src){ LexerContext context = new LexerContext();  token(src .replace("\r\n", "\n") .replace("\r", "\n") .replace("\t", "    ") .replace("\u00a0", " ") .replace("\u2424", "\n"), true, false, context);  return new LexerResult(context.getTokens(), context.getLinks()); } { <BUGS> List<String> cap = rules.get("html").exec(src); if(!cap.isEmpty()){ <BUGE> src = src.substring(cap.get(0).length()); if(options.isSanitize()){ context.pushToken(new ParagraphToken(cap.get(0))); } else { context.pushToken(new HtmlToken(cap.get(0), !options.isSanitize() && (cap.get(0).equals("pre") || cap.get(0).equals("script") || cap.get(0).equals("style")))); } continue; } }  /* def*/ if(!bq && top){
public LexerResult lex(String src){ LexerContext context = new LexerContext();  token(src .replace("\r\n", "\n") .replace("\r", "\n") .replace("\t", "    ") .replace("\u00a0", " ") .replace("\u2424", "\n"), true, false, context);  return new LexerResult(context.getTokens(), context.getLinks()); } /* def*/ <BUGS> if(!bq && top){ <BUGE> List<String> cap = rules.get("def").exec(src); if(!cap.isEmpty()){ src = src.substring(cap.get(0).length()); context.defineLink(cap.get(1).toLowerCase(), new Link(cap.get(2), cap.get(3))); continue; } }  /* table (gfm)*/ if(top){ List<String> cap = rules.get("table").exec(src); if(!cap.isEmpty()){ src = src.substring(cap.get(0).length());
public LexerResult lex(String src){ LexerContext context = new LexerContext();  token(src .replace("\r\n", "\n") .replace("\r", "\n") .replace("\t", "    ") .replace("\u00a0", " ") .replace("\u2424", "\n"), true, false, context);  return new LexerResult(context.getTokens(), context.getLinks()); } /* table (gfm)*/ <BUGS> if(top){ <BUGE> List<String> cap = rules.get("table").exec(src); if(!cap.isEmpty()){ src = src.substring(cap.get(0).length());  String[] header = cap.get(1).replaceAll("^ *| *\\| *$", "").split(" *\\| *"); String[] align  = cap.get(2).replaceAll("^ *|\\| *$", "").split(" *\\| *"); String[] cells  = cap.get(3).replaceAll("(?: *\\| *)?\\n$", "").split("\\n");  List<String> header2 = Arrays.asList(header);  List<String> align2 = new ArrayList<>(); for (String s : align) { if(s.matches("^ *-+: *$")){ align2.add("right");
public LexerResult lex(String src){ LexerContext context = new LexerContext();  token(src .replace("\r\n", "\n") .replace("\r", "\n") .replace("\t", "    ") .replace("\u00a0", " ") .replace("\u2424", "\n"), true, false, context);  return new LexerResult(context.getTokens(), context.getLinks()); } /* top-level paragraph*/ <BUGS> if(top){ <BUGE> List<String> cap = rules.get("paragraph").exec(src); if(!cap.isEmpty()){ src = src.substring(cap.get(0).length()); if(cap.get(1).charAt(cap.get(1).length() - 1) == '\n'){ context.pushToken(new ParagraphToken(cap.get(1).substring(0, cap.get(1).length() - 1))); } else { context.pushToken(new ParagraphToken(cap.get(1))); } continue; } }  /* text*/ {
LexerContext context = new LexerContext();  token(src .replace("\r\n", "\n") .replace("\r", "\n") .replace("\t", "    ") .replace("\u00a0", " ") .replace("\u2424", "\n"), true, false, context);  return new LexerResult(context.getTokens(), context.getLinks()); } { <BUGS> List<String> cap = rules.get("text").exec(src); if(!cap.isEmpty()){ src = src.substring(cap.get(0).length()); context.pushToken(new TextToken((cap.get(0)))); continue; <BUGE> } }  /* TODO Error*/ /*println("Infinite loop on byte: " + source.charAt(0).toByte)*/ } }  public static class LexerContext { private Stack<Token> tokens = new Stack<>(); private Map<String, Link> links = new HashMap<>();
public LexerResult lex(String src){ LexerContext context = new LexerContext();  token(src .replace("\r\n", "\n") .replace("\r", "\n") .replace("\t", "    ") .replace("\u00a0", " ") .replace("\u2424", "\n"), true, false, context);  return new LexerResult(context.getTokens(), context.getLinks()); } } <BUGS> } <BUGE>  public static class LexerContext { private Stack<Token> tokens = new Stack<>(); private Map<String, Link> links = new HashMap<>();  public void pushToken(Token token){ this.tokens.push(token); }  public void defineLink(String key, Link link){ this.links.put(key, link); }  public Stack<Token> getTokens() {
public static String marked(String src){ <BUGS> Options options = new Options(); return marked(src, options, new Renderer(options)); <BUGE> }
public String blockquote(String quote){ <BUGS> return "<blockquote>\n" + quote + "</blockquote>\n"; <BUGE> }
public String blockquote(String quote){ <BUGS> return "<blockquote>\n" + quote + "</blockquote>\n"; <BUGE> }
public String tablecell(String content, TableCellFlags flags){ String cellType; <BUGS> if(flags.isHeader()){ cellType = "th"; <BUGE> } else { cellType = "td"; }   String align = flags.getAlign(); if(align != null){ return "<" + cellType + " style=\"text-align: " + align + "\">" + content + "</" + cellType + ">\n"; } else { return "<" + cellType + ">" + content + "</" + cellType + ">\n"; } }
public String tablecell(String content, TableCellFlags flags){ String cellType; if(flags.isHeader()){ cellType = "th"; } else { <BUGS> cellType = "td"; <BUGE> }   String align = flags.getAlign(); if(align != null){ return "<" + cellType + " style=\"text-align: " + align + "\">" + content + "</" + cellType + ">\n"; } else { return "<" + cellType + ">" + content + "</" + cellType + ">\n"; } }
public String tablecell(String content, TableCellFlags flags){ String cellType; if(flags.isHeader()){ cellType = "th"; } else { cellType = "td"; }   <BUGS> String align = flags.getAlign(); if(align != null){ return "<" + cellType + " style=\"text-align: " + align + "\">" + content + "</" + cellType + ">\n"; <BUGE> } else { return "<" + cellType + ">" + content + "</" + cellType + ">\n"; } }
public String tablecell(String content, TableCellFlags flags){ String cellType; if(flags.isHeader()){ cellType = "th"; } else { cellType = "td"; }   String align = flags.getAlign(); if(align != null){ return "<" + cellType + " style=\"text-align: " + align + "\">" + content + "</" + cellType + ">\n"; } else { <BUGS> return "<" + cellType + ">" + content + "</" + cellType + ">\n"; <BUGE> } }
public String tablecell(String content, TableCellFlags flags){ String cellType; <BUGS> if(flags.isHeader()){ cellType = "th"; <BUGE> } else { cellType = "td"; }  if(content.length() == 0){ content = "&nbsp;"; } String align = flags.getAlign(); if(align != null){ return "<" + cellType + " style=\"text-align: " + align + "\">" + content + "</" + cellType + ">\n"; } else { return "<" + cellType + ">" + content + "</" + cellType + ">\n"; } }
public String tablecell(String content, TableCellFlags flags){ String cellType; if(flags.isHeader()){ cellType = "th"; } else { <BUGS> cellType = "td"; <BUGE> }  if(content.length() == 0){ content = "&nbsp;"; } String align = flags.getAlign(); if(align != null){ return "<" + cellType + " style=\"text-align: " + align + "\">" + content + "</" + cellType + ">\n"; } else { return "<" + cellType + ">" + content + "</" + cellType + ">\n"; } }
public String tablecell(String content, TableCellFlags flags){ String cellType; if(flags.isHeader()){ cellType = "th"; } else { cellType = "td"; }  <BUGS> if(content.length() == 0){ content = "&nbsp;"; <BUGE> } String align = flags.getAlign(); if(align != null){ return "<" + cellType + " style=\"text-align: " + align + "\">" + content + "</" + cellType + ">\n"; } else { return "<" + cellType + ">" + content + "</" + cellType + ">\n"; } }
public String tablecell(String content, TableCellFlags flags){ String cellType; if(flags.isHeader()){ cellType = "th"; } else { cellType = "td"; }  if(content.length() == 0){ content = "&nbsp;"; } <BUGS> String align = flags.getAlign(); if(align != null){ return "<" + cellType + " style=\"text-align: " + align + "\">" + content + "</" + cellType + ">\n"; <BUGE> } else { return "<" + cellType + ">" + content + "</" + cellType + ">\n"; } }
public String tablecell(String content, TableCellFlags flags){ String cellType; if(flags.isHeader()){ cellType = "th"; } else { cellType = "td"; }  if(content.length() == 0){ content = "&nbsp;"; } String align = flags.getAlign(); if(align != null){ return "<" + cellType + " style=\"text-align: " + align + "\">" + content + "</" + cellType + ">\n"; } else { <BUGS> return "<" + cellType + ">" + content + "</" + cellType + ">\n"; <BUGE> } }
public String del(String text){ <BUGS> return "<del>" + text + "</del>"; <BUGE> }
@Override public void execute(SensorContext ctx) { <BUGS> if (!this.settings.getBoolean(TypeScriptPlugin.SETTING_TS_LINT_ENABLED)) { <BUGE> LOG.debug("Skipping tslint execution - " + TypeScriptPlugin.SETTING_TS_LINT_ENABLED + " set to false"); return; }  TsLintExecutorConfig config = TsLintExecutorConfig.fromSettings(this.settings, ctx, this.resolver);  if (config.getPathToTsLint() == null) { LOG.warn("Path to tslint not defined or not found. Skipping tslint analysis."); return; } else if (config.getConfigFile() == null && config.getPathToTsConfig() == null) { LOG.warn("Path to tslint.json and tsconfig.json configuration files either not defined or not found - at least one is required. Skipping tslint analysis."); return; }  boolean skipTypeDefFiles = settings.getBoolean(TypeScriptPlugin.SETTING_EXCLUDE_TYPE_DEFINITION_FILES);  Collection<ActiveRule> allRules = ctx.activeRules().findByRepository(TsRulesDefinition.REPOSITORY_NAME); HashSet<String> ruleNames = new HashSet<>(); for (ActiveRule rule : allRules) { ruleNames.add(rule.ruleKey().rule()); }  List<String> paths = new ArrayList<String>(); HashMap<String, InputFile> absoluteFileMap = new HashMap<String, InputFile>(); HashMap<String, InputFile> relativeFileMap = new HashMap<String, InputFile>();
@Override public void execute(SensorContext ctx) { if (!this.settings.getBoolean(TypeScriptPlugin.SETTING_TS_LINT_ENABLED)) { LOG.debug("Skipping tslint execution - " + TypeScriptPlugin.SETTING_TS_LINT_ENABLED + " set to false"); return; }  <BUGS> TsLintExecutorConfig config = TsLintExecutorConfig.fromSettings(this.settings, ctx, this.resolver); <BUGE>  if (config.getPathToTsLint() == null) { LOG.warn("Path to tslint not defined or not found. Skipping tslint analysis."); return; } else if (config.getConfigFile() == null && config.getPathToTsConfig() == null) { LOG.warn("Path to tslint.json and tsconfig.json configuration files either not defined or not found - at least one is required. Skipping tslint analysis."); return; }  boolean skipTypeDefFiles = settings.getBoolean(TypeScriptPlugin.SETTING_EXCLUDE_TYPE_DEFINITION_FILES);  Collection<ActiveRule> allRules = ctx.activeRules().findByRepository(TsRulesDefinition.REPOSITORY_NAME); HashSet<String> ruleNames = new HashSet<>(); for (ActiveRule rule : allRules) { ruleNames.add(rule.ruleKey().rule()); }  List<String> paths = new ArrayList<String>(); HashMap<String, InputFile> absoluteFileMap = new HashMap<String, InputFile>(); HashMap<String, InputFile> relativeFileMap = new HashMap<String, InputFile>();
@Override public void execute(SensorContext ctx) { if (!this.settings.getBoolean(TypeScriptPlugin.SETTING_TS_LINT_ENABLED)) { LOG.debug("Skipping tslint execution - " + TypeScriptPlugin.SETTING_TS_LINT_ENABLED + " set to false"); return; }  TsLintExecutorConfig config = TsLintExecutorConfig.fromSettings(this.settings, ctx, this.resolver);  <BUGS> if (config.getPathToTsLint() == null) { <BUGE> LOG.warn("Path to tslint not defined or not found. Skipping tslint analysis."); return; } else if (config.getConfigFile() == null && config.getPathToTsConfig() == null) { LOG.warn("Path to tslint.json and tsconfig.json configuration files either not defined or not found - at least one is required. Skipping tslint analysis."); return; }  boolean skipTypeDefFiles = settings.getBoolean(TypeScriptPlugin.SETTING_EXCLUDE_TYPE_DEFINITION_FILES);  Collection<ActiveRule> allRules = ctx.activeRules().findByRepository(TsRulesDefinition.REPOSITORY_NAME); HashSet<String> ruleNames = new HashSet<>(); for (ActiveRule rule : allRules) { ruleNames.add(rule.ruleKey().rule()); }  List<String> paths = new ArrayList<String>(); HashMap<String, InputFile> absoluteFileMap = new HashMap<String, InputFile>(); HashMap<String, InputFile> relativeFileMap = new HashMap<String, InputFile>();
@Override public void execute(SensorContext ctx) { if (!this.settings.getBoolean(TypeScriptPlugin.SETTING_TS_LINT_ENABLED)) { LOG.debug("Skipping tslint execution - " + TypeScriptPlugin.SETTING_TS_LINT_ENABLED + " set to false"); return; }  TsLintExecutorConfig config = TsLintExecutorConfig.fromSettings(this.settings, ctx, this.resolver);  if (config.getPathToTsLint() == null) { LOG.warn("Path to tslint not defined or not found. Skipping tslint analysis."); return; } <BUGS> else if (config.getConfigFile() == null && config.getPathToTsConfig() == null) { <BUGE> LOG.warn("Path to tslint.json and tsconfig.json configuration files either not defined or not found - at least one is required. Skipping tslint analysis."); return; }  boolean skipTypeDefFiles = settings.getBoolean(TypeScriptPlugin.SETTING_EXCLUDE_TYPE_DEFINITION_FILES);  Collection<ActiveRule> allRules = ctx.activeRules().findByRepository(TsRulesDefinition.REPOSITORY_NAME); HashSet<String> ruleNames = new HashSet<>(); for (ActiveRule rule : allRules) { ruleNames.add(rule.ruleKey().rule()); }  List<String> paths = new ArrayList<String>(); HashMap<String, InputFile> absoluteFileMap = new HashMap<String, InputFile>(); HashMap<String, InputFile> relativeFileMap = new HashMap<String, InputFile>();
@Override public void execute(SensorContext ctx) { if (!this.settings.getBoolean(TypeScriptPlugin.SETTING_TS_LINT_ENABLED)) { LOG.debug("Skipping tslint execution - " + TypeScriptPlugin.SETTING_TS_LINT_ENABLED + " set to false"); return; }  TsLintExecutorConfig config = TsLintExecutorConfig.fromSettings(this.settings, ctx, this.resolver);  if (config.getPathToTsLint() == null) { LOG.warn("Path to tslint not defined or not found. Skipping tslint analysis."); return; } else if (config.getConfigFile() == null && config.getPathToTsConfig() == null) { LOG.warn("Path to tslint.json and tsconfig.json configuration files either not defined or not found - at least one is required. Skipping tslint analysis."); return; }  <BUGS> boolean skipTypeDefFiles = settings.getBoolean(TypeScriptPlugin.SETTING_EXCLUDE_TYPE_DEFINITION_FILES); <BUGE>  Collection<ActiveRule> allRules = ctx.activeRules().findByRepository(TsRulesDefinition.REPOSITORY_NAME); HashSet<String> ruleNames = new HashSet<>(); for (ActiveRule rule : allRules) { ruleNames.add(rule.ruleKey().rule()); }  List<String> paths = new ArrayList<String>(); HashMap<String, InputFile> absoluteFileMap = new HashMap<String, InputFile>(); HashMap<String, InputFile> relativeFileMap = new HashMap<String, InputFile>();
@Override public void execute(SensorContext ctx) { if (!this.settings.getBoolean(TypeScriptPlugin.SETTING_TS_LINT_ENABLED)) { LOG.debug("Skipping tslint execution - " + TypeScriptPlugin.SETTING_TS_LINT_ENABLED + " set to false"); return; }  TsLintExecutorConfig config = TsLintExecutorConfig.fromSettings(this.settings, ctx, this.resolver);  if (config.getPathToTsLint() == null) { LOG.warn("Path to tslint not defined or not found. Skipping tslint analysis."); return; } else if (config.getConfigFile() == null && config.getPathToTsConfig() == null) { LOG.warn("Path to tslint.json and tsconfig.json configuration files either not defined or not found - at least one is required. Skipping tslint analysis."); return; }  boolean skipTypeDefFiles = settings.getBoolean(TypeScriptPlugin.SETTING_EXCLUDE_TYPE_DEFINITION_FILES);  <BUGS> Collection<ActiveRule> allRules = ctx.activeRules().findByRepository(TsRulesDefinition.REPOSITORY_NAME); HashSet<String> ruleNames = new HashSet<>(); for (ActiveRule rule : allRules) { ruleNames.add(rule.ruleKey().rule()); } <BUGE>  List<String> paths = new ArrayList<String>(); HashMap<String, InputFile> absoluteFileMap = new HashMap<String, InputFile>(); HashMap<String, InputFile> relativeFileMap = new HashMap<String, InputFile>();
@Override public void execute(SensorContext ctx) { if (!this.settings.getBoolean(TypeScriptPlugin.SETTING_TS_LINT_ENABLED)) { LOG.debug("Skipping tslint execution - " + TypeScriptPlugin.SETTING_TS_LINT_ENABLED + " set to false"); return; }  TsLintExecutorConfig config = TsLintExecutorConfig.fromSettings(this.settings, ctx, this.resolver);  if (config.getPathToTsLint() == null) { LOG.warn("Path to tslint not defined or not found. Skipping tslint analysis."); return; } else if (config.getConfigFile() == null && config.getPathToTsConfig() == null) { LOG.warn("Path to tslint.json and tsconfig.json configuration files either not defined or not found - at least one is required. Skipping tslint analysis."); return; }  boolean skipTypeDefFiles = settings.getBoolean(TypeScriptPlugin.SETTING_EXCLUDE_TYPE_DEFINITION_FILES);  Collection<ActiveRule> allRules = ctx.activeRules().findByRepository(TsRulesDefinition.REPOSITORY_NAME); HashSet<String> ruleNames = new HashSet<>(); for (ActiveRule rule : allRules) { ruleNames.add(rule.ruleKey().rule()); }  <BUGS> List<String> paths = new ArrayList<String>(); HashMap<String, InputFile> absoluteFileMap = new HashMap<String, InputFile>(); HashMap<String, InputFile> relativeFileMap = new HashMap<String, InputFile>(); <BUGE>
public TsLintSensor(Settings settings, PathResolver resolver, TsLintExecutor executor, TsLintParser parser) { this.settings = settings; this.resolver = resolver; this.executor = executor; this.parser = parser; }  @Override public void describe(SensorDescriptor desc) { desc .name("Linting sensor for TypeScript files") .onlyOnLanguage(TypeScriptLanguage.LANGUAGE_KEY); }   <BUGS> for (InputFile file : ctx.fileSystem().inputFiles(ctx.fileSystem().predicates().hasLanguage(TypeScriptLanguage.LANGUAGE_KEY))) { if (skipTypeDefFiles && file.file().getName().toLowerCase().endsWith("." + TypeScriptLanguage.LANGUAGE_DEFINITION_EXTENSION)) { <BUGE> continue; }  String pathAdjusted = file.absolutePath().replace('\\', '/'); paths.add(pathAdjusted); absoluteFileMap.put(pathAdjusted, file); relativeFileMap.put(file.relativePath().replace('\\', '/'), file); }  List<String> jsonResults = this.executor.execute(config, paths);  Map<String, List<TsLintIssue>> issues = this.parser.parse(jsonResults);
this.resolver = resolver; this.executor = executor; this.parser = parser; }  @Override public void describe(SensorDescriptor desc) { desc .name("Linting sensor for TypeScript files") .onlyOnLanguage(TypeScriptLanguage.LANGUAGE_KEY); }   <BUGS> String pathAdjusted = file.absolutePath().replace('\\', '/'); paths.add(pathAdjusted); absoluteFileMap.put(pathAdjusted, file); relativeFileMap.put(file.relativePath().replace('\\', '/'), file); } <BUGE>  List<String> jsonResults = this.executor.execute(config, paths);  Map<String, List<TsLintIssue>> issues = this.parser.parse(jsonResults);  if (issues == null) { LOG.warn("TsLint returned no result at all"); return; }  /* Each issue bucket will contain info about a single file*/ for (String filePath : issues.keySet()) {
public TsLintSensor(Settings settings, PathResolver resolver, TsLintExecutor executor, TsLintParser parser) { this.settings = settings; this.resolver = resolver; this.executor = executor; this.parser = parser; }  @Override public void describe(SensorDescriptor desc) { desc .name("Linting sensor for TypeScript files") .onlyOnLanguage(TypeScriptLanguage.LANGUAGE_KEY); }   <BUGS> List<String> jsonResults = this.executor.execute(config, paths); <BUGE>  Map<String, List<TsLintIssue>> issues = this.parser.parse(jsonResults);  if (issues == null) { LOG.warn("TsLint returned no result at all"); return; }  /* Each issue bucket will contain info about a single file*/ for (String filePath : issues.keySet()) { List<TsLintIssue> batchIssues = issues.get(filePath);  if (batchIssues == null || batchIssues.size() == 0) { continue;
public TsLintSensor(Settings settings, PathResolver resolver, TsLintExecutor executor, TsLintParser parser) { this.settings = settings; this.resolver = resolver; this.executor = executor; this.parser = parser; }  @Override public void describe(SensorDescriptor desc) { desc .name("Linting sensor for TypeScript files") .onlyOnLanguage(TypeScriptLanguage.LANGUAGE_KEY); }   <BUGS> Map<String, List<TsLintIssue>> issues = this.parser.parse(jsonResults); <BUGE>  if (issues == null) { LOG.warn("TsLint returned no result at all"); return; }  /* Each issue bucket will contain info about a single file*/ for (String filePath : issues.keySet()) { List<TsLintIssue> batchIssues = issues.get(filePath);  if (batchIssues == null || batchIssues.size() == 0) { continue; }
public TsLintSensor(Settings settings, PathResolver resolver, TsLintExecutor executor, TsLintParser parser) { this.settings = settings; this.resolver = resolver; this.executor = executor; this.parser = parser; }  @Override public void describe(SensorDescriptor desc) { desc .name("Linting sensor for TypeScript files") .onlyOnLanguage(TypeScriptLanguage.LANGUAGE_KEY); }   <BUGS> if (issues == null) { <BUGE> LOG.warn("TsLint returned no result at all"); return; }  /* Each issue bucket will contain info about a single file*/ for (String filePath : issues.keySet()) { List<TsLintIssue> batchIssues = issues.get(filePath);  if (batchIssues == null || batchIssues.size() == 0) { continue; }  InputFile matchingFile = absoluteFileMap.get(filePath); if (matchingFile == null) {
public TsLintSensor(Settings settings, PathResolver resolver, TsLintExecutor executor, TsLintParser parser) { this.settings = settings; this.resolver = resolver; this.executor = executor; this.parser = parser; }  @Override public void describe(SensorDescriptor desc) { desc .name("Linting sensor for TypeScript files") .onlyOnLanguage(TypeScriptLanguage.LANGUAGE_KEY); }  /* Each issue bucket will contain info about a single file*/ <BUGS> for (String filePath : issues.keySet()) { List<TsLintIssue> batchIssues = issues.get(filePath); <BUGE>  if (batchIssues == null || batchIssues.size() == 0) { continue; }  InputFile matchingFile = absoluteFileMap.get(filePath); if (matchingFile == null) { matchingFile = relativeFileMap.get(filePath); }  if (!absoluteFileMap.containsKey(filePath)) { LOG.warn("TsLint reported issues against a file that wasn't sent to it - will be ignored: " + filePath); continue;
public TsLintSensor(Settings settings, PathResolver resolver, TsLintExecutor executor, TsLintParser parser) { this.settings = settings; this.resolver = resolver; this.executor = executor; this.parser = parser; }  @Override public void describe(SensorDescriptor desc) { desc .name("Linting sensor for TypeScript files") .onlyOnLanguage(TypeScriptLanguage.LANGUAGE_KEY); }   <BUGS> if (batchIssues == null || batchIssues.size() == 0) { <BUGE> continue; }  InputFile matchingFile = absoluteFileMap.get(filePath); if (matchingFile == null) { matchingFile = relativeFileMap.get(filePath); }  if (!absoluteFileMap.containsKey(filePath)) { LOG.warn("TsLint reported issues against a file that wasn't sent to it - will be ignored: " + filePath); continue; }  InputFile file = absoluteFileMap.get(filePath);
this.settings = settings; this.resolver = resolver; this.executor = executor; this.parser = parser; }  @Override public void describe(SensorDescriptor desc) { desc .name("Linting sensor for TypeScript files") .onlyOnLanguage(TypeScriptLanguage.LANGUAGE_KEY); }   <BUGS> InputFile matchingFile = absoluteFileMap.get(filePath); if (matchingFile == null) { matchingFile = relativeFileMap.get(filePath); <BUGE> }  if (!absoluteFileMap.containsKey(filePath)) { LOG.warn("TsLint reported issues against a file that wasn't sent to it - will be ignored: " + filePath); continue; }  InputFile file = absoluteFileMap.get(filePath); for (TsLintIssue issue : batchIssues) { /* Make sure the rule we're violating is one we recognise - if not, we'll*/ /* fall back to the generic 'tslint-issue' rule*/ String ruleName = issue.getRuleName(); if (!ruleNames.contains(ruleName)) {
this.settings = settings; this.resolver = resolver; this.executor = executor; this.parser = parser; }  @Override public void describe(SensorDescriptor desc) { desc .name("Linting sensor for TypeScript files") .onlyOnLanguage(TypeScriptLanguage.LANGUAGE_KEY); }   <BUGS> if (!absoluteFileMap.containsKey(filePath)) { LOG.warn("TsLint reported issues against a file that wasn't sent to it - will be ignored: " + filePath); continue; <BUGE> }  InputFile file = absoluteFileMap.get(filePath); for (TsLintIssue issue : batchIssues) { /* Make sure the rule we're violating is one we recognise - if not, we'll*/ /* fall back to the generic 'tslint-issue' rule*/ String ruleName = issue.getRuleName(); if (!ruleNames.contains(ruleName)) { ruleName = TsRulesDefinition.TSLINT_UNKNOWN_RULE.key; }  NewIssue newIssue = ctx
public TsLintSensor(Settings settings, PathResolver resolver, TsLintExecutor executor, TsLintParser parser) { this.settings = settings; this.resolver = resolver; this.executor = executor; this.parser = parser; }  @Override public void describe(SensorDescriptor desc) { desc .name("Linting sensor for TypeScript files") .onlyOnLanguage(TypeScriptLanguage.LANGUAGE_KEY); }  } <BUGS> } <BUGE> }
@Override public void execute(SensorContext ctx) { <BUGS> if (!this.settings.getBoolean(TypeScriptPlugin.SETTING_TS_LINT_ENABLED)) { <BUGE> LOG.debug("Skipping tslint execution - " + TypeScriptPlugin.SETTING_TS_LINT_ENABLED + " set to false"); return; }  TsLintExecutorConfig config = TsLintExecutorConfig.fromSettings(this.settings, ctx, this.resolver);  if (config.getPathToTsLint() == null) { LOG.warn("Path to tslint not defined or not found. Skipping tslint analysis."); return; } else if (config.getConfigFile() == null && config.getPathToTsConfig() == null) { LOG.warn("Path to tslint.json and tsconfig.json configuration files either not defined or not found - at least one is required. Skipping tslint analysis."); return; }  boolean skipTypeDefFiles = settings.getBoolean(TypeScriptPlugin.SETTING_EXCLUDE_TYPE_DEFINITION_FILES);  Collection<ActiveRule> allRules = ctx.activeRules().findByRepository(TsRulesDefinition.REPOSITORY_NAME); HashSet<String> ruleNames = new HashSet<>(); for (ActiveRule rule : allRules) { ruleNames.add(rule.ruleKey().rule()); }  List<String> paths = new ArrayList<String>();  for (InputFile file : ctx.fileSystem().inputFiles(ctx.fileSystem().predicates().hasLanguage(TypeScriptLanguage.LANGUAGE_KEY))) { if (shouldSkipFile(file.file(), skipTypeDefFiles)) {
@Override public void execute(SensorContext ctx) { if (!this.settings.getBoolean(TypeScriptPlugin.SETTING_TS_LINT_ENABLED)) { LOG.debug("Skipping tslint execution - " + TypeScriptPlugin.SETTING_TS_LINT_ENABLED + " set to false"); return; }  <BUGS> TsLintExecutorConfig config = TsLintExecutorConfig.fromSettings(this.settings, ctx, this.resolver); <BUGE>  if (config.getPathToTsLint() == null) { LOG.warn("Path to tslint not defined or not found. Skipping tslint analysis."); return; } else if (config.getConfigFile() == null && config.getPathToTsConfig() == null) { LOG.warn("Path to tslint.json and tsconfig.json configuration files either not defined or not found - at least one is required. Skipping tslint analysis."); return; }  boolean skipTypeDefFiles = settings.getBoolean(TypeScriptPlugin.SETTING_EXCLUDE_TYPE_DEFINITION_FILES);  Collection<ActiveRule> allRules = ctx.activeRules().findByRepository(TsRulesDefinition.REPOSITORY_NAME); HashSet<String> ruleNames = new HashSet<>(); for (ActiveRule rule : allRules) { ruleNames.add(rule.ruleKey().rule()); }  List<String> paths = new ArrayList<String>();  for (InputFile file : ctx.fileSystem().inputFiles(ctx.fileSystem().predicates().hasLanguage(TypeScriptLanguage.LANGUAGE_KEY))) { if (shouldSkipFile(file.file(), skipTypeDefFiles)) {
@Override public void execute(SensorContext ctx) { if (!this.settings.getBoolean(TypeScriptPlugin.SETTING_TS_LINT_ENABLED)) { LOG.debug("Skipping tslint execution - " + TypeScriptPlugin.SETTING_TS_LINT_ENABLED + " set to false"); return; }  TsLintExecutorConfig config = TsLintExecutorConfig.fromSettings(this.settings, ctx, this.resolver);  <BUGS> if (config.getPathToTsLint() == null) { <BUGE> LOG.warn("Path to tslint not defined or not found. Skipping tslint analysis."); return; } else if (config.getConfigFile() == null && config.getPathToTsConfig() == null) { LOG.warn("Path to tslint.json and tsconfig.json configuration files either not defined or not found - at least one is required. Skipping tslint analysis."); return; }  boolean skipTypeDefFiles = settings.getBoolean(TypeScriptPlugin.SETTING_EXCLUDE_TYPE_DEFINITION_FILES);  Collection<ActiveRule> allRules = ctx.activeRules().findByRepository(TsRulesDefinition.REPOSITORY_NAME); HashSet<String> ruleNames = new HashSet<>(); for (ActiveRule rule : allRules) { ruleNames.add(rule.ruleKey().rule()); }  List<String> paths = new ArrayList<String>();  for (InputFile file : ctx.fileSystem().inputFiles(ctx.fileSystem().predicates().hasLanguage(TypeScriptLanguage.LANGUAGE_KEY))) { if (shouldSkipFile(file.file(), skipTypeDefFiles)) {
@Override public void execute(SensorContext ctx) { if (!this.settings.getBoolean(TypeScriptPlugin.SETTING_TS_LINT_ENABLED)) { LOG.debug("Skipping tslint execution - " + TypeScriptPlugin.SETTING_TS_LINT_ENABLED + " set to false"); return; }  TsLintExecutorConfig config = TsLintExecutorConfig.fromSettings(this.settings, ctx, this.resolver);  if (config.getPathToTsLint() == null) { LOG.warn("Path to tslint not defined or not found. Skipping tslint analysis."); return; } <BUGS> else if (config.getConfigFile() == null && config.getPathToTsConfig() == null) { LOG.warn("Path to tslint.json and tsconfig.json configuration files either not defined or not found - at least one is required. Skipping tslint analysis."); return; <BUGE> }  boolean skipTypeDefFiles = settings.getBoolean(TypeScriptPlugin.SETTING_EXCLUDE_TYPE_DEFINITION_FILES);  Collection<ActiveRule> allRules = ctx.activeRules().findByRepository(TsRulesDefinition.REPOSITORY_NAME); HashSet<String> ruleNames = new HashSet<>(); for (ActiveRule rule : allRules) { ruleNames.add(rule.ruleKey().rule()); }  List<String> paths = new ArrayList<String>();  for (InputFile file : ctx.fileSystem().inputFiles(ctx.fileSystem().predicates().hasLanguage(TypeScriptLanguage.LANGUAGE_KEY))) { if (shouldSkipFile(file.file(), skipTypeDefFiles)) {
private static Command getBaseCommand(String pathToTsLint, String configFile, String rulesDir) { <BUGS> Command command = <BUGE> Command .create("node") .addArgument('"' + pathToTsLint + '"') .addArgument("--format") .addArgument("json");  if (rulesDir != null && rulesDir.length() > 0) { command .addArgument("--rules-dir") .addArgument('"' + rulesDir + '"'); }  command .addArgument("--config") .addArgument('"' + configFile + '"') .setNewShell(false);  return command; }
private static Command getBaseCommand(String pathToTsLint, String configFile, String rulesDir) { Command command = Command <BUGS> .create("node") .addArgument('"' + pathToTsLint + '"') .addArgument("--format") .addArgument("json"); <BUGE>  if (rulesDir != null && rulesDir.length() > 0) { command .addArgument("--rules-dir") .addArgument('"' + rulesDir + '"'); }  command .addArgument("--config") .addArgument('"' + configFile + '"') .setNewShell(false);  return command; }
private static Command getBaseCommand(String pathToTsLint, String configFile, String rulesDir) { Command command = Command .create("node") .addArgument('"' + pathToTsLint + '"') .addArgument("--format") .addArgument("json");  <BUGS> if (rulesDir != null && rulesDir.length() > 0) { command .addArgument("--rules-dir") .addArgument('"' + rulesDir + '"'); <BUGE> }  command .addArgument("--config") .addArgument('"' + configFile + '"') .setNewShell(false);  return command; }
private static Command getBaseCommand(String pathToTsLint, String configFile, String rulesDir) { Command command = Command .create("node") .addArgument('"' + pathToTsLint + '"') .addArgument("--format") .addArgument("json");  if (rulesDir != null && rulesDir.length() > 0) { command .addArgument("--rules-dir") .addArgument('"' + rulesDir + '"'); }  <BUGS> command .addArgument("--config") .addArgument('"' + configFile + '"') .setNewShell(false); <BUGE>  return command; }
private static Command getBaseCommand(String pathToTsLint, String configFile, String rulesDir) { Command command = Command .create("node") .addArgument('"' + pathToTsLint + '"') .addArgument("--format") .addArgument("json");  if (rulesDir != null && rulesDir.length() > 0) { command .addArgument("--rules-dir") .addArgument('"' + rulesDir + '"'); }  command .addArgument("--config") .addArgument('"' + configFile + '"') .setNewShell(false);  <BUGS> return command; <BUGE> }
} protected String getTsLintPath() { <BUGS> String toReturn = settings.getString(TypeScriptPlugin.SETTING_TS_LINT_PATH); if (toReturn == null || toReturn.isEmpty()) { LOG.debug("Path to TsLint not specified, falling back to node_modules"); toReturn = TSLINT_FALLBACK_PATH; <BUGE> } else { LOG.debug("Found TsLint path to be '" + toReturn + "'"); } File candidateFile = new java.io.File(toReturn); if (!candidateFile.isAbsolute()) { candidateFile = new java.io.File(this.fileSystem.baseDir().getAbsolutePath(), toReturn); } if (!doesFileExist(candidateFile)) { LOG.warn("Could not find tslint at path '" + toReturn + "' - skipping tslint analysis"); toReturn = null; } return toReturn; }
} protected String getTsLintPath() { String toReturn = settings.getString(TypeScriptPlugin.SETTING_TS_LINT_PATH); if (toReturn == null || toReturn.isEmpty()) { LOG.debug("Path to TsLint not specified, falling back to node_modules"); toReturn = TSLINT_FALLBACK_PATH; } else { <BUGS> LOG.debug("Found TsLint path to be '" + toReturn + "'"); <BUGE> } File candidateFile = new java.io.File(toReturn); if (!candidateFile.isAbsolute()) { candidateFile = new java.io.File(this.fileSystem.baseDir().getAbsolutePath(), toReturn); } if (!doesFileExist(candidateFile)) { LOG.warn("Could not find tslint at path '" + toReturn + "' - skipping tslint analysis"); toReturn = null; } return toReturn; }
} protected String getTsLintPath() { String toReturn = settings.getString(TypeScriptPlugin.SETTING_TS_LINT_PATH); if (toReturn == null || toReturn.isEmpty()) { LOG.debug("Path to TsLint not specified, falling back to node_modules"); toReturn = TSLINT_FALLBACK_PATH; } else { LOG.debug("Found TsLint path to be '" + toReturn + "'"); } <BUGS> File candidateFile = new java.io.File(toReturn); if (!candidateFile.isAbsolute()) { candidateFile = new java.io.File(this.fileSystem.baseDir().getAbsolutePath(), toReturn); <BUGE> } if (!doesFileExist(candidateFile)) { LOG.warn("Could not find tslint at path '" + toReturn + "' - skipping tslint analysis"); toReturn = null; } return toReturn; }
} protected String getTsLintPath() { String toReturn = settings.getString(TypeScriptPlugin.SETTING_TS_LINT_PATH); if (toReturn == null || toReturn.isEmpty()) { LOG.debug("Path to TsLint not specified, falling back to node_modules"); toReturn = TSLINT_FALLBACK_PATH; } else { LOG.debug("Found TsLint path to be '" + toReturn + "'"); } File candidateFile = new java.io.File(toReturn); if (!candidateFile.isAbsolute()) { candidateFile = new java.io.File(this.fileSystem.baseDir().getAbsolutePath(), toReturn); } <BUGS> if (!doesFileExist(candidateFile)) { LOG.warn("Could not find tslint at path '" + toReturn + "' - skipping tslint analysis"); toReturn = null; <BUGE> } return toReturn; }
} protected String getTsLintPath() { String toReturn = settings.getString(TypeScriptPlugin.SETTING_TS_LINT_PATH); if (toReturn == null || toReturn.isEmpty()) { LOG.debug("Path to TsLint not specified, falling back to node_modules"); toReturn = TSLINT_FALLBACK_PATH; } else { LOG.debug("Found TsLint path to be '" + toReturn + "'"); } File candidateFile = new java.io.File(toReturn); if (!candidateFile.isAbsolute()) { candidateFile = new java.io.File(this.fileSystem.baseDir().getAbsolutePath(), toReturn); } if (!doesFileExist(candidateFile)) { LOG.warn("Could not find tslint at path '" + toReturn + "' - skipping tslint analysis"); toReturn = null; } <BUGS> return toReturn; <BUGE> }
public void analyse(Project project, SensorContext context) {   <BUGS> TsLintExecutor executor = this.getTsLintExecutor(); TsLintParser parser = this.getTsLintParser(); <BUGE>  /* Build the config file*/ File configFile = new File(this.fileSystem.workDir(), CONFIG_FILENAME); TsLintConfig config = getConfiguration(); String configSerialised = new GsonBuilder().setPrettyPrinting().create().toJson(config);  try { writeConfiguration(configSerialised, configFile, Charsets.UTF_8); } catch (IOException e) { throw Throwables.propagate(e); }  boolean skipTypeDefFiles = settings.getBoolean(TypeScriptPlugin.SETTING_EXCLUDE_TYPE_DEFINITION_FILES);  for (File file : fileSystem.files(this.filePredicates.hasLanguage(TypeScriptLanguage.LANGUAGE_EXTENSION))) { if (skipTypeDefFiles && file.getName().toLowerCase().endsWith("." + TypeScriptLanguage.LANGUAGE_DEFINITION_EXTENSION)) { continue; }  Resource resource = this.getFileFromIOFile(file, project); Issuable issuable = perspectives.as(Issuable.class, resource);  String pathToTsLint = settings.getString(TypeScriptPlugin.SETTING_TS_LINT_PATH); String jsonResult = executor.execute(pathToTsLint, configFile.getPath(), file.getAbsolutePath());
public void analyse(Project project, SensorContext context) {   TsLintExecutor executor = this.getTsLintExecutor(); TsLintParser parser = this.getTsLintParser();  /* Build the config file*/ <BUGS> File configFile = new File(this.fileSystem.workDir(), CONFIG_FILENAME); TsLintConfig config = getConfiguration(); String configSerialised = new GsonBuilder().setPrettyPrinting().create().toJson(config); <BUGE>  try { writeConfiguration(configSerialised, configFile, Charsets.UTF_8); } catch (IOException e) { throw Throwables.propagate(e); }  boolean skipTypeDefFiles = settings.getBoolean(TypeScriptPlugin.SETTING_EXCLUDE_TYPE_DEFINITION_FILES);  for (File file : fileSystem.files(this.filePredicates.hasLanguage(TypeScriptLanguage.LANGUAGE_EXTENSION))) { if (skipTypeDefFiles && file.getName().toLowerCase().endsWith("." + TypeScriptLanguage.LANGUAGE_DEFINITION_EXTENSION)) { continue; }  Resource resource = this.getFileFromIOFile(file, project); Issuable issuable = perspectives.as(Issuable.class, resource);  String pathToTsLint = settings.getString(TypeScriptPlugin.SETTING_TS_LINT_PATH); String jsonResult = executor.execute(pathToTsLint, configFile.getPath(), file.getAbsolutePath());
public void analyse(Project project, SensorContext context) {   TsLintExecutor executor = this.getTsLintExecutor(); TsLintParser parser = this.getTsLintParser();  /* Build the config file*/ File configFile = new File(this.fileSystem.workDir(), CONFIG_FILENAME); TsLintConfig config = getConfiguration(); String configSerialised = new GsonBuilder().setPrettyPrinting().create().toJson(config);  try { <BUGS> writeConfiguration(configSerialised, configFile, Charsets.UTF_8); <BUGE> } catch (IOException e) { throw Throwables.propagate(e); }  boolean skipTypeDefFiles = settings.getBoolean(TypeScriptPlugin.SETTING_EXCLUDE_TYPE_DEFINITION_FILES);  for (File file : fileSystem.files(this.filePredicates.hasLanguage(TypeScriptLanguage.LANGUAGE_EXTENSION))) { if (skipTypeDefFiles && file.getName().toLowerCase().endsWith("." + TypeScriptLanguage.LANGUAGE_DEFINITION_EXTENSION)) { continue; }  Resource resource = this.getFileFromIOFile(file, project); Issuable issuable = perspectives.as(Issuable.class, resource);  String pathToTsLint = settings.getString(TypeScriptPlugin.SETTING_TS_LINT_PATH); String jsonResult = executor.execute(pathToTsLint, configFile.getPath(), file.getAbsolutePath());
public void analyse(Project project, SensorContext context) {   TsLintExecutor executor = this.getTsLintExecutor(); TsLintParser parser = this.getTsLintParser();  /* Build the config file*/ File configFile = new File(this.fileSystem.workDir(), CONFIG_FILENAME); TsLintConfig config = getConfiguration(); String configSerialised = new GsonBuilder().setPrettyPrinting().create().toJson(config);  try { writeConfiguration(configSerialised, configFile, Charsets.UTF_8); } catch (IOException e) { throw Throwables.propagate(e); <BUGS> } <BUGE>  boolean skipTypeDefFiles = settings.getBoolean(TypeScriptPlugin.SETTING_EXCLUDE_TYPE_DEFINITION_FILES);  for (File file : fileSystem.files(this.filePredicates.hasLanguage(TypeScriptLanguage.LANGUAGE_EXTENSION))) { if (skipTypeDefFiles && file.getName().toLowerCase().endsWith("." + TypeScriptLanguage.LANGUAGE_DEFINITION_EXTENSION)) { continue; }  Resource resource = this.getFileFromIOFile(file, project); Issuable issuable = perspectives.as(Issuable.class, resource);  String pathToTsLint = settings.getString(TypeScriptPlugin.SETTING_TS_LINT_PATH); String jsonResult = executor.execute(pathToTsLint, configFile.getPath(), file.getAbsolutePath());
public void analyse(Project project, SensorContext context) {   TsLintExecutor executor = this.getTsLintExecutor(); TsLintParser parser = this.getTsLintParser();  /* Build the config file*/ File configFile = new File(this.fileSystem.workDir(), CONFIG_FILENAME); TsLintConfig config = getConfiguration(); String configSerialised = new GsonBuilder().setPrettyPrinting().create().toJson(config);  try { writeConfiguration(configSerialised, configFile, Charsets.UTF_8); } catch (IOException e) { throw Throwables.propagate(e); }  <BUGS> boolean skipTypeDefFiles = settings.getBoolean(TypeScriptPlugin.SETTING_EXCLUDE_TYPE_DEFINITION_FILES); <BUGE>  for (File file : fileSystem.files(this.filePredicates.hasLanguage(TypeScriptLanguage.LANGUAGE_EXTENSION))) { if (skipTypeDefFiles && file.getName().toLowerCase().endsWith("." + TypeScriptLanguage.LANGUAGE_DEFINITION_EXTENSION)) { continue; }  Resource resource = this.getFileFromIOFile(file, project); Issuable issuable = perspectives.as(Issuable.class, resource);  String pathToTsLint = settings.getString(TypeScriptPlugin.SETTING_TS_LINT_PATH); String jsonResult = executor.execute(pathToTsLint, configFile.getPath(), file.getAbsolutePath());
public void analyse(Project project, SensorContext context) {   TsLintExecutor executor = this.getTsLintExecutor(); TsLintParser parser = this.getTsLintParser();  /* Build the config file*/ File configFile = new File(this.fileSystem.workDir(), CONFIG_FILENAME); TsLintConfig config = getConfiguration(); String configSerialised = new GsonBuilder().setPrettyPrinting().create().toJson(config);  try { writeConfiguration(configSerialised, configFile, Charsets.UTF_8); } catch (IOException e) { throw Throwables.propagate(e); }  boolean skipTypeDefFiles = settings.getBoolean(TypeScriptPlugin.SETTING_EXCLUDE_TYPE_DEFINITION_FILES);  <BUGS> for (File file : fileSystem.files(this.filePredicates.hasLanguage(TypeScriptLanguage.LANGUAGE_EXTENSION))) { <BUGE> if (skipTypeDefFiles && file.getName().toLowerCase().endsWith("." + TypeScriptLanguage.LANGUAGE_DEFINITION_EXTENSION)) { continue; }  Resource resource = this.getFileFromIOFile(file, project); Issuable issuable = perspectives.as(Issuable.class, resource);  String pathToTsLint = settings.getString(TypeScriptPlugin.SETTING_TS_LINT_PATH); String jsonResult = executor.execute(pathToTsLint, configFile.getPath(), file.getAbsolutePath());
this.filePredicates = fileSystem.predicates(); this.perspectives = perspectives; this.rulesProfile = rulesProfile; }  public boolean shouldExecuteOnProject(Project project) { boolean toReturn = hasFilesToAnalyze();  return toReturn; }  private boolean hasFilesToAnalyze() { return fileSystem.files(this.filePredicates.hasLanguage(TypeScriptLanguage.LANGUAGE_EXTENSION)).iterator().hasNext(); } } <BUGS> } <BUGE>  protected org.sonar.api.resources.File getFileFromIOFile(File file, Project project) { return org.sonar.api.resources.File.fromIOFile(file, project); }  protected void writeConfiguration(String configSerialised, File configFile, Charset encoding) throws IOException { Files.write(configSerialised, configFile, encoding); }  protected TsLintExecutor getTsLintExecutor() { return new TsLintExecutorImpl(); }  protected TsLintParser getTsLintParser() {
@CheckForNull private FileData loadCurrentFileData(final Map<InputFile, FileData> files, String line) { <BUGS> String filePath = line.substring(SF.length()); FileData fileData = null; <BUGE> /* some tools (like Istanbul, Karma) provide relative paths, so let's consider them relative to project directory*/ InputFile inputFile = context.fileSystem().inputFile(context.fileSystem().predicates().hasPath(filePath));  /* Try to accommodate Angular projects that, when the angular template loader's used*/ /* by checking for a ! in the filepath if the path isn't found - have a bash at seeking*/ /* everything after the ! as a second fallback pass*/  if (inputFile != null) { fileData = files.get(inputFile); if (fileData == null) { fileData = new FileData(inputFile); files.put(inputFile, fileData); } } else { unresolvedPaths.add(filePath); } return fileData; }
@CheckForNull private FileData loadCurrentFileData(final Map<InputFile, FileData> files, String line) { String filePath = line.substring(SF.length()); FileData fileData = null; /* some tools (like Istanbul, Karma) provide relative paths, so let's consider them relative to project directory*/ <BUGS> InputFile inputFile = context.fileSystem().inputFile(context.fileSystem().predicates().hasPath(filePath)); <BUGE>  /* Try to accommodate Angular projects that, when the angular template loader's used*/ /* by checking for a ! in the filepath if the path isn't found - have a bash at seeking*/ /* everything after the ! as a second fallback pass*/  if (inputFile != null) { fileData = files.get(inputFile); if (fileData == null) { fileData = new FileData(inputFile); files.put(inputFile, fileData); } } else { unresolvedPaths.add(filePath); } return fileData; }
@CheckForNull private FileData loadCurrentFileData(final Map<InputFile, FileData> files, String line) { String filePath = line.substring(SF.length()); FileData fileData = null; /* some tools (like Istanbul, Karma) provide relative paths, so let's consider them relative to project directory*/ InputFile inputFile = context.fileSystem().inputFile(context.fileSystem().predicates().hasPath(filePath));  /* Try to accommodate Angular projects that, when the angular template loader's used*/ /* by checking for a ! in the filepath if the path isn't found - have a bash at seeking*/ /* everything after the ! as a second fallback pass*/  <BUGS> if (inputFile != null) { <BUGE> fileData = files.get(inputFile); if (fileData == null) { fileData = new FileData(inputFile); files.put(inputFile, fileData); } } else { unresolvedPaths.add(filePath); } return fileData; }
@CheckForNull private FileData loadCurrentFileData(final Map<InputFile, FileData> files, String line) { String filePath = line.substring(SF.length()); FileData fileData = null; /* some tools (like Istanbul, Karma) provide relative paths, so let's consider them relative to project directory*/ InputFile inputFile = context.fileSystem().inputFile(context.fileSystem().predicates().hasPath(filePath));  /* Try to accommodate Angular projects that, when the angular template loader's used*/ /* by checking for a ! in the filepath if the path isn't found - have a bash at seeking*/ /* everything after the ! as a second fallback pass*/  if (inputFile != null) { fileData = files.get(inputFile); if (fileData == null) { fileData = new FileData(inputFile); files.put(inputFile, fileData); } } else { <BUGS> unresolvedPaths.add(filePath); <BUGE> } return fileData; }
@CheckForNull private FileData loadCurrentFileData(final Map<InputFile, FileData> files, String line) { String filePath = line.substring(SF.length()); FileData fileData = null; /* some tools (like Istanbul, Karma) provide relative paths, so let's consider them relative to project directory*/ InputFile inputFile = context.fileSystem().inputFile(context.fileSystem().predicates().hasPath(filePath));  /* Try to accommodate Angular projects that, when the angular template loader's used*/ /* by checking for a ! in the filepath if the path isn't found - have a bash at seeking*/ /* everything after the ! as a second fallback pass*/  if (inputFile != null) { fileData = files.get(inputFile); if (fileData == null) { fileData = new FileData(inputFile); files.put(inputFile, fileData); } } else { unresolvedPaths.add(filePath); } <BUGS> return fileData; <BUGE> }
@CheckForNull private FileData loadCurrentFileData(final Map<InputFile, FileData> files, String line) { <BUGS> String filePath = line.substring(SF.length()); FileData fileData = null; <BUGE>  /* some tools (like Istanbul, Karma) provide relative paths, so let's consider them relative to project directory*/ InputFile inputFile = null; try { Paths.get(filePath); inputFile = context.fileSystem().inputFile(context.fileSystem().predicates().hasPath(filePath)); } catch (InvalidPathException ex) { LOG.debug("LCOV file referred to path that appears invalid (not just not on disk): " + filePath); }  /* Try to accommodate Angular projects that, when the angular template loader's used*/ /* by checking for a ! in the filepath if the path isn't found - have a bash at seeking*/ /* everything after the last ! as a second fallback pass*/ if (inputFile == null && filePath.contains("!") && (filePath.indexOf("!") + 1) < filePath.length()) { String amendedPath = filePath.substring(filePath.indexOf("!") + 1);  LOG.debug("Failed to resolve " + filePath + " as a valid source file, so attempting " + amendedPath + " instead");  inputFile = context.fileSystem().inputFile(context.fileSystem().predicates().hasPath(amendedPath)); }  if (inputFile != null) { fileData = files.get(inputFile); if (fileData == null) { fileData = new FileData(inputFile);
@CheckForNull private FileData loadCurrentFileData(final Map<InputFile, FileData> files, String line) { String filePath = line.substring(SF.length()); FileData fileData = null;  /* some tools (like Istanbul, Karma) provide relative paths, so let's consider them relative to project directory*/ <BUGS> InputFile inputFile = null; <BUGE> try { Paths.get(filePath); inputFile = context.fileSystem().inputFile(context.fileSystem().predicates().hasPath(filePath)); } catch (InvalidPathException ex) { LOG.debug("LCOV file referred to path that appears invalid (not just not on disk): " + filePath); }  /* Try to accommodate Angular projects that, when the angular template loader's used*/ /* by checking for a ! in the filepath if the path isn't found - have a bash at seeking*/ /* everything after the last ! as a second fallback pass*/ if (inputFile == null && filePath.contains("!") && (filePath.indexOf("!") + 1) < filePath.length()) { String amendedPath = filePath.substring(filePath.indexOf("!") + 1);  LOG.debug("Failed to resolve " + filePath + " as a valid source file, so attempting " + amendedPath + " instead");  inputFile = context.fileSystem().inputFile(context.fileSystem().predicates().hasPath(amendedPath)); }  if (inputFile != null) { fileData = files.get(inputFile); if (fileData == null) { fileData = new FileData(inputFile);
@CheckForNull private FileData loadCurrentFileData(final Map<InputFile, FileData> files, String line) { String filePath = line.substring(SF.length()); FileData fileData = null;  /* some tools (like Istanbul, Karma) provide relative paths, so let's consider them relative to project directory*/ InputFile inputFile = null; try { <BUGS> Paths.get(filePath); inputFile = context.fileSystem().inputFile(context.fileSystem().predicates().hasPath(filePath)); <BUGE> } catch (InvalidPathException ex) { LOG.debug("LCOV file referred to path that appears invalid (not just not on disk): " + filePath); }  /* Try to accommodate Angular projects that, when the angular template loader's used*/ /* by checking for a ! in the filepath if the path isn't found - have a bash at seeking*/ /* everything after the last ! as a second fallback pass*/ if (inputFile == null && filePath.contains("!") && (filePath.indexOf("!") + 1) < filePath.length()) { String amendedPath = filePath.substring(filePath.indexOf("!") + 1);  LOG.debug("Failed to resolve " + filePath + " as a valid source file, so attempting " + amendedPath + " instead");  inputFile = context.fileSystem().inputFile(context.fileSystem().predicates().hasPath(amendedPath)); }  if (inputFile != null) { fileData = files.get(inputFile); if (fileData == null) { fileData = new FileData(inputFile);
@CheckForNull private FileData loadCurrentFileData(final Map<InputFile, FileData> files, String line) { String filePath = line.substring(SF.length()); FileData fileData = null;  /* some tools (like Istanbul, Karma) provide relative paths, so let's consider them relative to project directory*/ InputFile inputFile = null; try { Paths.get(filePath); inputFile = context.fileSystem().inputFile(context.fileSystem().predicates().hasPath(filePath)); } catch (InvalidPathException ex) { LOG.debug("LCOV file referred to path that appears invalid (not just not on disk): " + filePath); <BUGS> } <BUGE>  /* Try to accommodate Angular projects that, when the angular template loader's used*/ /* by checking for a ! in the filepath if the path isn't found - have a bash at seeking*/ /* everything after the last ! as a second fallback pass*/ if (inputFile == null && filePath.contains("!") && (filePath.indexOf("!") + 1) < filePath.length()) { String amendedPath = filePath.substring(filePath.indexOf("!") + 1);  LOG.debug("Failed to resolve " + filePath + " as a valid source file, so attempting " + amendedPath + " instead");  inputFile = context.fileSystem().inputFile(context.fileSystem().predicates().hasPath(amendedPath)); }  if (inputFile != null) { fileData = files.get(inputFile); if (fileData == null) { fileData = new FileData(inputFile);
@CheckForNull private FileData loadCurrentFileData(final Map<InputFile, FileData> files, String line) { String filePath = line.substring(SF.length()); FileData fileData = null;  /* some tools (like Istanbul, Karma) provide relative paths, so let's consider them relative to project directory*/ InputFile inputFile = null; try { Paths.get(filePath); inputFile = context.fileSystem().inputFile(context.fileSystem().predicates().hasPath(filePath)); } catch (InvalidPathException ex) { LOG.debug("LCOV file referred to path that appears invalid (not just not on disk): " + filePath); }  /* Try to accommodate Angular projects that, when the angular template loader's used*/ /* by checking for a ! in the filepath if the path isn't found - have a bash at seeking*/ /* everything after the last ! as a second fallback pass*/ <BUGS> if (inputFile == null && filePath.contains("!") && (filePath.indexOf("!") + 1) < filePath.length()) { String amendedPath = filePath.substring(filePath.indexOf("!") + 1); <BUGE>  LOG.debug("Failed to resolve " + filePath + " as a valid source file, so attempting " + amendedPath + " instead");  inputFile = context.fileSystem().inputFile(context.fileSystem().predicates().hasPath(amendedPath)); }  if (inputFile != null) { fileData = files.get(inputFile); if (fileData == null) { fileData = new FileData(inputFile);
@CheckForNull private FileData loadCurrentFileData(final Map<InputFile, FileData> files, String line) { String filePath = line.substring(SF.length()); FileData fileData = null;  /* some tools (like Istanbul, Karma) provide relative paths, so let's consider them relative to project directory*/ InputFile inputFile = null; try { Paths.get(filePath); inputFile = context.fileSystem().inputFile(context.fileSystem().predicates().hasPath(filePath)); } catch (InvalidPathException ex) { LOG.debug("LCOV file referred to path that appears invalid (not just not on disk): " + filePath); }  /* Try to accommodate Angular projects that, when the angular template loader's used*/ /* by checking for a ! in the filepath if the path isn't found - have a bash at seeking*/ /* everything after the last ! as a second fallback pass*/ if (inputFile == null && filePath.contains("!") && (filePath.indexOf("!") + 1) < filePath.length()) { String amendedPath = filePath.substring(filePath.indexOf("!") + 1);  <BUGS> LOG.debug("Failed to resolve " + filePath + " as a valid source file, so attempting " + amendedPath + " instead"); <BUGE>  inputFile = context.fileSystem().inputFile(context.fileSystem().predicates().hasPath(amendedPath)); }  if (inputFile != null) { fileData = files.get(inputFile); if (fileData == null) { fileData = new FileData(inputFile);
@CheckForNull private FileData loadCurrentFileData(final Map<InputFile, FileData> files, String line) { String filePath = line.substring(SF.length()); FileData fileData = null;  /* some tools (like Istanbul, Karma) provide relative paths, so let's consider them relative to project directory*/ InputFile inputFile = null; try { Paths.get(filePath); inputFile = context.fileSystem().inputFile(context.fileSystem().predicates().hasPath(filePath)); } catch (InvalidPathException ex) { LOG.debug("LCOV file referred to path that appears invalid (not just not on disk): " + filePath); }  /* Try to accommodate Angular projects that, when the angular template loader's used*/ /* by checking for a ! in the filepath if the path isn't found - have a bash at seeking*/ /* everything after the last ! as a second fallback pass*/ if (inputFile == null && filePath.contains("!") && (filePath.indexOf("!") + 1) < filePath.length()) { String amendedPath = filePath.substring(filePath.indexOf("!") + 1);  LOG.debug("Failed to resolve " + filePath + " as a valid source file, so attempting " + amendedPath + " instead");  <BUGS> inputFile = context.fileSystem().inputFile(context.fileSystem().predicates().hasPath(amendedPath)); <BUGE> }  if (inputFile != null) { fileData = files.get(inputFile); if (fileData == null) { fileData = new FileData(inputFile);
@CheckForNull private FileData loadCurrentFileData(final Map<InputFile, FileData> files, String line) { String filePath = line.substring(SF.length()); FileData fileData = null;  /* some tools (like Istanbul, Karma) provide relative paths, so let's consider them relative to project directory*/ InputFile inputFile = null; try { Paths.get(filePath); inputFile = context.fileSystem().inputFile(context.fileSystem().predicates().hasPath(filePath)); } catch (InvalidPathException ex) { LOG.debug("LCOV file referred to path that appears invalid (not just not on disk): " + filePath); }  /* Try to accommodate Angular projects that, when the angular template loader's used*/ /* by checking for a ! in the filepath if the path isn't found - have a bash at seeking*/ /* everything after the last ! as a second fallback pass*/ if (inputFile == null && filePath.contains("!") && (filePath.indexOf("!") + 1) < filePath.length()) { String amendedPath = filePath.substring(filePath.indexOf("!") + 1);  LOG.debug("Failed to resolve " + filePath + " as a valid source file, so attempting " + amendedPath + " instead");  inputFile = context.fileSystem().inputFile(context.fileSystem().predicates().hasPath(amendedPath)); }  <BUGS> if (inputFile != null) { <BUGE> fileData = files.get(inputFile); if (fileData == null) { fileData = new FileData(inputFile);
Map<InputFile, NewCoverage> coveredFiles = new HashMap<InputFile, NewCoverage>(); for (Map.Entry<InputFile, FileData> e : files.entrySet()) { NewCoverage newCoverage = context.newCoverage().onFile(e.getKey()).ofType(CoverageType.UNIT); e.getValue().save(newCoverage); coveredFiles.put(e.getKey(), newCoverage); } return coveredFiles; }  private static void logWrongDataWarning(String dataType, String lineNumber, IllegalArgumentException e) { LOG.warn(String.format("Problem during processing LCOV report: can't save %s data for line %s (%s).", dataType, lineNumber, e.getMessage())); }  } else { <BUGS> LOG.debug("Failed to resolve path " + filePath + " to a file in the analysis set"); unresolvedPaths.add(filePath); <BUGE> } return fileData; }  private static class FileData { /** * line number -> branch number -> taken */ private Map<Integer, Map<String, Integer>> branches = new HashMap<Integer, Map<String, Integer>>();  /** * line number -> execution count */
Map<InputFile, NewCoverage> coveredFiles = new HashMap<InputFile, NewCoverage>(); for (Map.Entry<InputFile, FileData> e : files.entrySet()) { NewCoverage newCoverage = context.newCoverage().onFile(e.getKey()).ofType(CoverageType.UNIT); e.getValue().save(newCoverage); coveredFiles.put(e.getKey(), newCoverage); } return coveredFiles; }  private static void logWrongDataWarning(String dataType, String lineNumber, IllegalArgumentException e) { LOG.warn(String.format("Problem during processing LCOV report: can't save %s data for line %s (%s).", dataType, lineNumber, e.getMessage())); }  } <BUGS> return fileData; <BUGE> }  private static class FileData { /** * line number -> branch number -> taken */ private Map<Integer, Map<String, Integer>> branches = new HashMap<Integer, Map<String, Integer>>();  /** * line number -> execution count */ private Map<Integer, Integer> hits = new HashMap<Integer, Integer>();  /**
@CheckForNull private FileData loadCurrentFileData(final Map<InputFile, FileData> files, String line) { <BUGS> String filePath = line.substring(SF.length()); FileData fileData = null; <BUGE>  /* some tools (like Istanbul, Karma) provide relative paths, so let's consider them relative to project directory*/ InputFile inputFile = null; try { Paths.get(filePath); inputFile = context.fileSystem().inputFile(context.fileSystem().predicates().hasPath(filePath)); } catch (InvalidPathException ex) { LOG.debug("LCOV file referred to path that appears invalid (not just not on disk): " + filePath); }  /* Try to accommodate Angular projects that, when the angular template loader's used*/ /* by checking for a ! in the filepath if the path isn't found - have a bash at seeking*/ /* everything after the last ! as a second fallback pass*/ if (inputFile == null && filePath.contains("!") && (filePath.indexOf("!") + 1) < filePath.length()) { String amendedPath = filePath.substring(filePath.indexOf("!") + 1);  LOG.debug("Failed to resolve " + filePath + " as a valid source file, so attempting " + amendedPath + " instead");  inputFile = context.fileSystem().inputFile(context.fileSystem().predicates().hasPath(amendedPath)); }  if (inputFile != null) { fileData = files.get(inputFile); if (fileData == null) { fileData = new FileData(inputFile);
@CheckForNull private FileData loadCurrentFileData(final Map<InputFile, FileData> files, String line) { String filePath = line.substring(SF.length()); FileData fileData = null;  /* some tools (like Istanbul, Karma) provide relative paths, so let's consider them relative to project directory*/ <BUGS> InputFile inputFile = null; <BUGE> try { Paths.get(filePath); inputFile = context.fileSystem().inputFile(context.fileSystem().predicates().hasPath(filePath)); } catch (InvalidPathException ex) { LOG.debug("LCOV file referred to path that appears invalid (not just not on disk): " + filePath); }  /* Try to accommodate Angular projects that, when the angular template loader's used*/ /* by checking for a ! in the filepath if the path isn't found - have a bash at seeking*/ /* everything after the last ! as a second fallback pass*/ if (inputFile == null && filePath.contains("!") && (filePath.indexOf("!") + 1) < filePath.length()) { String amendedPath = filePath.substring(filePath.indexOf("!") + 1);  LOG.debug("Failed to resolve " + filePath + " as a valid source file, so attempting " + amendedPath + " instead");  inputFile = context.fileSystem().inputFile(context.fileSystem().predicates().hasPath(amendedPath)); }  if (inputFile != null) { fileData = files.get(inputFile); if (fileData == null) { fileData = new FileData(inputFile);
@CheckForNull private FileData loadCurrentFileData(final Map<InputFile, FileData> files, String line) { String filePath = line.substring(SF.length()); FileData fileData = null;  /* some tools (like Istanbul, Karma) provide relative paths, so let's consider them relative to project directory*/ InputFile inputFile = null; try { <BUGS> Paths.get(filePath); inputFile = context.fileSystem().inputFile(context.fileSystem().predicates().hasPath(filePath)); <BUGE> } catch (InvalidPathException ex) { LOG.debug("LCOV file referred to path that appears invalid (not just not on disk): " + filePath); }  /* Try to accommodate Angular projects that, when the angular template loader's used*/ /* by checking for a ! in the filepath if the path isn't found - have a bash at seeking*/ /* everything after the last ! as a second fallback pass*/ if (inputFile == null && filePath.contains("!") && (filePath.indexOf("!") + 1) < filePath.length()) { String amendedPath = filePath.substring(filePath.indexOf("!") + 1);  LOG.debug("Failed to resolve " + filePath + " as a valid source file, so attempting " + amendedPath + " instead");  inputFile = context.fileSystem().inputFile(context.fileSystem().predicates().hasPath(amendedPath)); }  if (inputFile != null) { fileData = files.get(inputFile); if (fileData == null) { fileData = new FileData(inputFile);
@CheckForNull private FileData loadCurrentFileData(final Map<InputFile, FileData> files, String line) { String filePath = line.substring(SF.length()); FileData fileData = null;  /* some tools (like Istanbul, Karma) provide relative paths, so let's consider them relative to project directory*/ InputFile inputFile = null; try { Paths.get(filePath); inputFile = context.fileSystem().inputFile(context.fileSystem().predicates().hasPath(filePath)); } catch (InvalidPathException ex) { LOG.debug("LCOV file referred to path that appears invalid (not just not on disk): " + filePath); <BUGS> } <BUGE>  /* Try to accommodate Angular projects that, when the angular template loader's used*/ /* by checking for a ! in the filepath if the path isn't found - have a bash at seeking*/ /* everything after the last ! as a second fallback pass*/ if (inputFile == null && filePath.contains("!") && (filePath.indexOf("!") + 1) < filePath.length()) { String amendedPath = filePath.substring(filePath.indexOf("!") + 1);  LOG.debug("Failed to resolve " + filePath + " as a valid source file, so attempting " + amendedPath + " instead");  inputFile = context.fileSystem().inputFile(context.fileSystem().predicates().hasPath(amendedPath)); }  if (inputFile != null) { fileData = files.get(inputFile); if (fileData == null) { fileData = new FileData(inputFile);
@CheckForNull private FileData loadCurrentFileData(final Map<InputFile, FileData> files, String line) { String filePath = line.substring(SF.length()); FileData fileData = null;  /* some tools (like Istanbul, Karma) provide relative paths, so let's consider them relative to project directory*/ InputFile inputFile = null; try { Paths.get(filePath); inputFile = context.fileSystem().inputFile(context.fileSystem().predicates().hasPath(filePath)); } catch (InvalidPathException ex) { LOG.debug("LCOV file referred to path that appears invalid (not just not on disk): " + filePath); }  /* Try to accommodate Angular projects that, when the angular template loader's used*/ /* by checking for a ! in the filepath if the path isn't found - have a bash at seeking*/ /* everything after the last ! as a second fallback pass*/ <BUGS> if (inputFile == null && filePath.contains("!") && (filePath.indexOf("!") + 1) < filePath.length()) { String amendedPath = filePath.substring(filePath.indexOf("!") + 1); <BUGE>  LOG.debug("Failed to resolve " + filePath + " as a valid source file, so attempting " + amendedPath + " instead");  inputFile = context.fileSystem().inputFile(context.fileSystem().predicates().hasPath(amendedPath)); }  if (inputFile != null) { fileData = files.get(inputFile); if (fileData == null) { fileData = new FileData(inputFile);
@CheckForNull private FileData loadCurrentFileData(final Map<InputFile, FileData> files, String line) { String filePath = line.substring(SF.length()); FileData fileData = null;  /* some tools (like Istanbul, Karma) provide relative paths, so let's consider them relative to project directory*/ InputFile inputFile = null; try { Paths.get(filePath); inputFile = context.fileSystem().inputFile(context.fileSystem().predicates().hasPath(filePath)); } catch (InvalidPathException ex) { LOG.debug("LCOV file referred to path that appears invalid (not just not on disk): " + filePath); }  /* Try to accommodate Angular projects that, when the angular template loader's used*/ /* by checking for a ! in the filepath if the path isn't found - have a bash at seeking*/ /* everything after the last ! as a second fallback pass*/ if (inputFile == null && filePath.contains("!") && (filePath.indexOf("!") + 1) < filePath.length()) { String amendedPath = filePath.substring(filePath.indexOf("!") + 1);  <BUGS> LOG.debug("Failed to resolve " + filePath + " as a valid source file, so attempting " + amendedPath + " instead"); <BUGE>  inputFile = context.fileSystem().inputFile(context.fileSystem().predicates().hasPath(amendedPath)); }  if (inputFile != null) { fileData = files.get(inputFile); if (fileData == null) { fileData = new FileData(inputFile);
@CheckForNull private FileData loadCurrentFileData(final Map<InputFile, FileData> files, String line) { String filePath = line.substring(SF.length()); FileData fileData = null;  /* some tools (like Istanbul, Karma) provide relative paths, so let's consider them relative to project directory*/ InputFile inputFile = null; try { Paths.get(filePath); inputFile = context.fileSystem().inputFile(context.fileSystem().predicates().hasPath(filePath)); } catch (InvalidPathException ex) { LOG.debug("LCOV file referred to path that appears invalid (not just not on disk): " + filePath); }  /* Try to accommodate Angular projects that, when the angular template loader's used*/ /* by checking for a ! in the filepath if the path isn't found - have a bash at seeking*/ /* everything after the last ! as a second fallback pass*/ if (inputFile == null && filePath.contains("!") && (filePath.indexOf("!") + 1) < filePath.length()) { String amendedPath = filePath.substring(filePath.indexOf("!") + 1);  LOG.debug("Failed to resolve " + filePath + " as a valid source file, so attempting " + amendedPath + " instead");  <BUGS> inputFile = context.fileSystem().inputFile(context.fileSystem().predicates().hasPath(amendedPath)); <BUGE> }  if (inputFile != null) { fileData = files.get(inputFile); if (fileData == null) { fileData = new FileData(inputFile);
@CheckForNull private FileData loadCurrentFileData(final Map<InputFile, FileData> files, String line) { String filePath = line.substring(SF.length()); FileData fileData = null;  /* some tools (like Istanbul, Karma) provide relative paths, so let's consider them relative to project directory*/ InputFile inputFile = null; try { Paths.get(filePath); inputFile = context.fileSystem().inputFile(context.fileSystem().predicates().hasPath(filePath)); } catch (InvalidPathException ex) { LOG.debug("LCOV file referred to path that appears invalid (not just not on disk): " + filePath); }  /* Try to accommodate Angular projects that, when the angular template loader's used*/ /* by checking for a ! in the filepath if the path isn't found - have a bash at seeking*/ /* everything after the last ! as a second fallback pass*/ if (inputFile == null && filePath.contains("!") && (filePath.indexOf("!") + 1) < filePath.length()) { String amendedPath = filePath.substring(filePath.indexOf("!") + 1);  LOG.debug("Failed to resolve " + filePath + " as a valid source file, so attempting " + amendedPath + " instead");  inputFile = context.fileSystem().inputFile(context.fileSystem().predicates().hasPath(amendedPath)); }  <BUGS> if (inputFile != null) { <BUGE> fileData = files.get(inputFile); if (fileData == null) { fileData = new FileData(inputFile);
Map<InputFile, NewCoverage> coveredFiles = new HashMap<InputFile, NewCoverage>(); for (Map.Entry<InputFile, FileData> e : files.entrySet()) { NewCoverage newCoverage = context.newCoverage().onFile(e.getKey()).ofType(CoverageType.UNIT); e.getValue().save(newCoverage); coveredFiles.put(e.getKey(), newCoverage); } return coveredFiles; }  private static void logWrongDataWarning(String dataType, String lineNumber, IllegalArgumentException e) { LOG.warn(String.format("Problem during processing LCOV report: can't save %s data for line %s (%s).", dataType, lineNumber, e.getMessage())); }  } else { <BUGS> LOG.debug("Failed to resolve path " + filePath + " to a file in the analysis set"); unresolvedPaths.add(filePath); <BUGE> } return fileData; }  private static class FileData { /** * line number -> branch number -> taken */ private Map<Integer, Map<String, Integer>> branches = new HashMap<Integer, Map<String, Integer>>();  /** * line number -> execution count */
Map<InputFile, NewCoverage> coveredFiles = new HashMap<InputFile, NewCoverage>(); for (Map.Entry<InputFile, FileData> e : files.entrySet()) { NewCoverage newCoverage = context.newCoverage().onFile(e.getKey()).ofType(CoverageType.UNIT); e.getValue().save(newCoverage); coveredFiles.put(e.getKey(), newCoverage); } return coveredFiles; }  private static void logWrongDataWarning(String dataType, String lineNumber, IllegalArgumentException e) { LOG.warn(String.format("Problem during processing LCOV report: can't save %s data for line %s (%s).", dataType, lineNumber, e.getMessage())); }  } <BUGS> return fileData; <BUGE> }  private static class FileData { /** * line number -> branch number -> taken */ private Map<Integer, Map<String, Integer>> branches = new HashMap<Integer, Map<String, Integer>>();  /** * line number -> execution count */ private Map<Integer, Integer> hits = new HashMap<Integer, Integer>();  /**
@Override public String getAWSSecretKey() { <BUGS> return this.authenticationInfo.getPassphrase(); <BUGE> }
<BUGS> public InputStreamSet(InputStream... inputStream) { fileInputStreams = Sets.newHashSet(inputStream); } <BUGE>
<BUGS> public InputStreamSet(InputStream... inputStream) { fileInputStreams = Sets.newHashSet(inputStream); } <BUGE>
<BUGS> public WeakConcurrentSet(Cleaner cleaner) { switch (cleaner) { <BUGE> case INLINE: target = new WeakConcurrentMap.WithInlinedExpunction<V, Boolean>(); break; case THREAD: case MANUAL: target = new WeakConcurrentMap<V, Boolean>(cleaner == Cleaner.THREAD); break; default: throw new AssertionError(); } }
public WeakConcurrentSet(Cleaner cleaner) { switch (cleaner) { case INLINE: <BUGS> target = new WeakConcurrentMap.WithInlinedExpunction<V, Boolean>(); break; <BUGE> case THREAD: case MANUAL: target = new WeakConcurrentMap<V, Boolean>(cleaner == Cleaner.THREAD); break; default: throw new AssertionError(); } }
public WeakConcurrentSet(Cleaner cleaner) { switch (cleaner) { case INLINE: target = new WeakConcurrentMap.WithInlinedExpunction<V, Boolean>(); break; case THREAD: case MANUAL: target = new WeakConcurrentMap<V, Boolean>(cleaner == Cleaner.THREAD); break; default: throw new AssertionError(); } <BUGS> } <BUGE>
*/ private Projection parseProjection(Map params, Ellipsoid ellipsoid) { <BUGS> Projection projection = null; <BUGE>  String s; s = (String) params.get(Proj4Keyword.proj); if (s != null) { projection = registry.getProjection(s); if (projection == null) throw new InvalidValueException("Unknown projection: " + s); }  projection.setEllipsoid(ellipsoid);  /*TODO: better error handling for things like bad number syntax.*/ /* Should be able to report the original param string in the error message*/ /* Should the exception be lib-specific?  (e.g. ParseException)*/  s = (String) params.get(Proj4Keyword.alpha); if (s != null) projection.setAlphaDegrees(Double.parseDouble(s));  s = (String) params.get(Proj4Keyword.lonc); if (s != null) projection.setLonCDegrees(Double.parseDouble(s));  s = (String) params.get(Proj4Keyword.lat_0); if (s != null) projection.setProjectionLatitudeDegrees(parseAngle(s));
*/ private Projection parseProjection(Map params, Ellipsoid ellipsoid) { Projection projection = null;  String s; <BUGS> s = (String) params.get(Proj4Keyword.proj); if (s != null) { projection = registry.getProjection(s); if (projection == null) <BUGE> throw new InvalidValueException("Unknown projection: " + s); }  projection.setEllipsoid(ellipsoid);  /*TODO: better error handling for things like bad number syntax.*/ /* Should be able to report the original param string in the error message*/ /* Should the exception be lib-specific?  (e.g. ParseException)*/  s = (String) params.get(Proj4Keyword.alpha); if (s != null) projection.setAlphaDegrees(Double.parseDouble(s));  s = (String) params.get(Proj4Keyword.lonc); if (s != null) projection.setLonCDegrees(Double.parseDouble(s));  s = (String) params.get(Proj4Keyword.lat_0); if (s != null) projection.setProjectionLatitudeDegrees(parseAngle(s));
*/ private Projection parseProjection(Map params, Ellipsoid ellipsoid) { Projection projection = null;  String s; s = (String) params.get(Proj4Keyword.proj); if (s != null) { projection = registry.getProjection(s); if (projection == null) throw new InvalidValueException("Unknown projection: " + s); }  <BUGS> projection.setEllipsoid(ellipsoid); <BUGE>  /*TODO: better error handling for things like bad number syntax.*/ /* Should be able to report the original param string in the error message*/ /* Should the exception be lib-specific?  (e.g. ParseException)*/  s = (String) params.get(Proj4Keyword.alpha); if (s != null) projection.setAlphaDegrees(Double.parseDouble(s));  s = (String) params.get(Proj4Keyword.lonc); if (s != null) projection.setLonCDegrees(Double.parseDouble(s));  s = (String) params.get(Proj4Keyword.lat_0); if (s != null) projection.setProjectionLatitudeDegrees(parseAngle(s));
*/ private Projection parseProjection(Map params, Ellipsoid ellipsoid) { Projection projection = null;  String s; s = (String) params.get(Proj4Keyword.proj); if (s != null) { projection = registry.getProjection(s); if (projection == null) throw new InvalidValueException("Unknown projection: " + s); }  projection.setEllipsoid(ellipsoid);  /*TODO: better error handling for things like bad number syntax.*/ /* Should be able to report the original param string in the error message*/ /* Should the exception be lib-specific?  (e.g. ParseException)*/  <BUGS> s = (String) params.get(Proj4Keyword.alpha); if (s != null) <BUGE> projection.setAlphaDegrees(Double.parseDouble(s));  s = (String) params.get(Proj4Keyword.lonc); if (s != null) projection.setLonCDegrees(Double.parseDouble(s));  s = (String) params.get(Proj4Keyword.lat_0); if (s != null) projection.setProjectionLatitudeDegrees(parseAngle(s));
*/ private Projection parseProjection(Map params, Ellipsoid ellipsoid) { Projection projection = null;  String s; s = (String) params.get(Proj4Keyword.proj); if (s != null) { projection = registry.getProjection(s); if (projection == null) throw new InvalidValueException("Unknown projection: " + s); }  projection.setEllipsoid(ellipsoid);  /*TODO: better error handling for things like bad number syntax.*/ /* Should be able to report the original param string in the error message*/ /* Should the exception be lib-specific?  (e.g. ParseException)*/  s = (String) params.get(Proj4Keyword.alpha); if (s != null) projection.setAlphaDegrees(Double.parseDouble(s));  <BUGS> s = (String) params.get(Proj4Keyword.lonc); if (s != null) <BUGE> projection.setLonCDegrees(Double.parseDouble(s));  s = (String) params.get(Proj4Keyword.lat_0); if (s != null) projection.setProjectionLatitudeDegrees(parseAngle(s));
*/ private Projection parseProjection(Map params, Ellipsoid ellipsoid) { Projection projection = null;  String s; s = (String) params.get(Proj4Keyword.proj); if (s != null) { projection = registry.getProjection(s); if (projection == null) throw new InvalidValueException("Unknown projection: " + s); }  projection.setEllipsoid(ellipsoid);  /*TODO: better error handling for things like bad number syntax.*/ /* Should be able to report the original param string in the error message*/ /* Should the exception be lib-specific?  (e.g. ParseException)*/  s = (String) params.get(Proj4Keyword.alpha); if (s != null) projection.setAlphaDegrees(Double.parseDouble(s));  s = (String) params.get(Proj4Keyword.lonc); if (s != null) projection.setLonCDegrees(Double.parseDouble(s));  <BUGS> s = (String) params.get(Proj4Keyword.lat_0); if (s != null) <BUGE> projection.setProjectionLatitudeDegrees(parseAngle(s));
parseEllipsoid(params, datumParam); Datum datum = datumParam.getDatum(); Ellipsoid ellipsoid = datum.getEllipsoid(); /* TODO: this makes a difference - why?*/ /* which is better?*/ /*    Ellipsoid ellipsoid = datumParam.getEllipsoid(); */ Projection proj = parseProjection(params, ellipsoid); return new CoordinateReferenceSystem(name, args, datum, proj); }  /** * Creates a {@link Projection} * initialized from a PROJ.4 argument list.  <BUGS> s = (String) params.get(Proj4Keyword.lon_0); if (s != null) projection.setProjectionLongitudeDegrees(parseAngle(s)); <BUGE>  s = (String) params.get(Proj4Keyword.lat_1); if (s != null) projection.setProjectionLatitude1Degrees(parseAngle(s));  s = (String) params.get(Proj4Keyword.lat_2); if (s != null) projection.setProjectionLatitude2Degrees(parseAngle(s));  s = (String) params.get(Proj4Keyword.lat_ts); if (s != null) projection.setTrueScaleLatitudeDegrees(parseAngle(s));
parseDatum(params, datumParam); parseEllipsoid(params, datumParam); Datum datum = datumParam.getDatum(); Ellipsoid ellipsoid = datum.getEllipsoid(); /* TODO: this makes a difference - why?*/ /* which is better?*/ /*    Ellipsoid ellipsoid = datumParam.getEllipsoid(); */ Projection proj = parseProjection(params, ellipsoid); return new CoordinateReferenceSystem(name, args, datum, proj); }  /** * Creates a {@link Projection} * initialized from a PROJ.4 argument list.  <BUGS> s = (String) params.get(Proj4Keyword.lat_1); if (s != null) <BUGE> projection.setProjectionLatitude1Degrees(parseAngle(s));  s = (String) params.get(Proj4Keyword.lat_2); if (s != null) projection.setProjectionLatitude2Degrees(parseAngle(s));  s = (String) params.get(Proj4Keyword.lat_ts); if (s != null) projection.setTrueScaleLatitudeDegrees(parseAngle(s));  s = (String) params.get(Proj4Keyword.x_0); if (s != null) projection.setFalseEasting(Double.parseDouble(s));
parseDatum(params, datumParam); parseEllipsoid(params, datumParam); Datum datum = datumParam.getDatum(); Ellipsoid ellipsoid = datum.getEllipsoid(); /* TODO: this makes a difference - why?*/ /* which is better?*/ /*    Ellipsoid ellipsoid = datumParam.getEllipsoid(); */ Projection proj = parseProjection(params, ellipsoid); return new CoordinateReferenceSystem(name, args, datum, proj); }  /** * Creates a {@link Projection} * initialized from a PROJ.4 argument list.  <BUGS> s = (String) params.get(Proj4Keyword.lat_2); if (s != null) <BUGE> projection.setProjectionLatitude2Degrees(parseAngle(s));  s = (String) params.get(Proj4Keyword.lat_ts); if (s != null) projection.setTrueScaleLatitudeDegrees(parseAngle(s));  s = (String) params.get(Proj4Keyword.x_0); if (s != null) projection.setFalseEasting(Double.parseDouble(s));  s = (String) params.get(Proj4Keyword.y_0); if (s != null) projection.setFalseNorthing(Double.parseDouble(s));
parseDatum(params, datumParam); parseEllipsoid(params, datumParam); Datum datum = datumParam.getDatum(); Ellipsoid ellipsoid = datum.getEllipsoid(); /* TODO: this makes a difference - why?*/ /* which is better?*/ /*    Ellipsoid ellipsoid = datumParam.getEllipsoid(); */ Projection proj = parseProjection(params, ellipsoid); return new CoordinateReferenceSystem(name, args, datum, proj); }  /** * Creates a {@link Projection} * initialized from a PROJ.4 argument list.  <BUGS> s = (String) params.get(Proj4Keyword.lat_ts); if (s != null) <BUGE> projection.setTrueScaleLatitudeDegrees(parseAngle(s));  s = (String) params.get(Proj4Keyword.x_0); if (s != null) projection.setFalseEasting(Double.parseDouble(s));  s = (String) params.get(Proj4Keyword.y_0); if (s != null) projection.setFalseNorthing(Double.parseDouble(s));  s = (String) params.get(Proj4Keyword.k_0); if (s == null) s = (String) params.get(Proj4Keyword.k);
parseEllipsoid(params, datumParam); Datum datum = datumParam.getDatum(); Ellipsoid ellipsoid = datum.getEllipsoid(); /* TODO: this makes a difference - why?*/ /* which is better?*/ /*    Ellipsoid ellipsoid = datumParam.getEllipsoid(); */ Projection proj = parseProjection(params, ellipsoid); return new CoordinateReferenceSystem(name, args, datum, proj); }  /** * Creates a {@link Projection} * initialized from a PROJ.4 argument list.  <BUGS> s = (String) params.get(Proj4Keyword.x_0); if (s != null) projection.setFalseEasting(Double.parseDouble(s)); <BUGE>  s = (String) params.get(Proj4Keyword.y_0); if (s != null) projection.setFalseNorthing(Double.parseDouble(s));  s = (String) params.get(Proj4Keyword.k_0); if (s == null) s = (String) params.get(Proj4Keyword.k); if (s != null) projection.setScaleFactor(Double.parseDouble(s)); s = (String) params.get(Proj4Keyword.gamma); if (s != null) projection.setGamma(Double.parseDouble(s) * ProjectionMath.DTR);
parseEllipsoid(params, datumParam); Datum datum = datumParam.getDatum(); Ellipsoid ellipsoid = datum.getEllipsoid(); /* TODO: this makes a difference - why?*/ /* which is better?*/ /*    Ellipsoid ellipsoid = datumParam.getEllipsoid(); */ Projection proj = parseProjection(params, ellipsoid); return new CoordinateReferenceSystem(name, args, datum, proj); }  /** * Creates a {@link Projection} * initialized from a PROJ.4 argument list.  <BUGS> s = (String) params.get(Proj4Keyword.y_0); if (s != null) projection.setFalseNorthing(Double.parseDouble(s)); <BUGE>  s = (String) params.get(Proj4Keyword.k_0); if (s == null) s = (String) params.get(Proj4Keyword.k); if (s != null) projection.setScaleFactor(Double.parseDouble(s)); s = (String) params.get(Proj4Keyword.gamma); if (s != null) projection.setGamma(Double.parseDouble(s) * ProjectionMath.DTR);  s = (String) params.get(Proj4Keyword.units); if (s != null) { Unit unit = Units.findUnits(s);
Ellipsoid ellipsoid = datum.getEllipsoid(); /* TODO: this makes a difference - why?*/ /* which is better?*/ /*    Ellipsoid ellipsoid = datumParam.getEllipsoid(); */ Projection proj = parseProjection(params, ellipsoid); return new CoordinateReferenceSystem(name, args, datum, proj); }  /** * Creates a {@link Projection} * initialized from a PROJ.4 argument list.  <BUGS> s = (String) params.get(Proj4Keyword.k_0); if (s == null) s = (String) params.get(Proj4Keyword.k); if (s != null) projection.setScaleFactor(Double.parseDouble(s)); s = (String) params.get(Proj4Keyword.gamma); if (s != null) <BUGE> projection.setGamma(Double.parseDouble(s) * ProjectionMath.DTR);  s = (String) params.get(Proj4Keyword.units); if (s != null) { Unit unit = Units.findUnits(s); /* TODO: report unknown units name as error*/ if (unit != null) { projection.setFromMetres(1.0 / unit.value); projection.setUnits(unit); } }
parseEllipsoid(params, datumParam); Datum datum = datumParam.getDatum(); Ellipsoid ellipsoid = datum.getEllipsoid(); /* TODO: this makes a difference - why?*/ /* which is better?*/ /*    Ellipsoid ellipsoid = datumParam.getEllipsoid(); */ Projection proj = parseProjection(params, ellipsoid); return new CoordinateReferenceSystem(name, args, datum, proj); }  /** * Creates a {@link Projection} * initialized from a PROJ.4 argument list.  <BUGS> s = (String) params.get(Proj4Keyword.units); if (s != null) { Unit unit = Units.findUnits(s); <BUGE> /* TODO: report unknown units name as error*/ if (unit != null) { projection.setFromMetres(1.0 / unit.value); projection.setUnits(unit); } }  s = (String) params.get(Proj4Keyword.to_meter); if (s != null) projection.setFromMetres(1.0 / Double.parseDouble(s));  if (params.containsKey(Proj4Keyword.south)) projection.setSouthernHemisphere(true);
parseEllipsoid(params, datumParam); Datum datum = datumParam.getDatum(); Ellipsoid ellipsoid = datum.getEllipsoid(); /* TODO: this makes a difference - why?*/ /* which is better?*/ /*    Ellipsoid ellipsoid = datumParam.getEllipsoid(); */ Projection proj = parseProjection(params, ellipsoid); return new CoordinateReferenceSystem(name, args, datum, proj); }  /** * Creates a {@link Projection} * initialized from a PROJ.4 argument list. /* TODO: report unknown units name as error*/ <BUGS> if (unit != null) { projection.setFromMetres(1.0 / unit.value); projection.setUnits(unit); <BUGE> } }  s = (String) params.get(Proj4Keyword.to_meter); if (s != null) projection.setFromMetres(1.0 / Double.parseDouble(s));  if (params.containsKey(Proj4Keyword.south)) projection.setSouthernHemisphere(true);  s = (String) params.get(Proj4Keyword.pm); if (s != null) projection.setPrimeMeridian(s);
parseDatum(params, datumParam); parseEllipsoid(params, datumParam); Datum datum = datumParam.getDatum(); Ellipsoid ellipsoid = datum.getEllipsoid(); /* TODO: this makes a difference - why?*/ /* which is better?*/ /*    Ellipsoid ellipsoid = datumParam.getEllipsoid(); */ Projection proj = parseProjection(params, ellipsoid); return new CoordinateReferenceSystem(name, args, datum, proj); }  /** * Creates a {@link Projection} * initialized from a PROJ.4 argument list.  <BUGS> s = (String) params.get(Proj4Keyword.to_meter); if (s != null) <BUGE> projection.setFromMetres(1.0 / Double.parseDouble(s));  if (params.containsKey(Proj4Keyword.south)) projection.setSouthernHemisphere(true);  s = (String) params.get(Proj4Keyword.pm); if (s != null) projection.setPrimeMeridian(s);  s = (String) params.get(Proj4Keyword.axis); if (s != null) projection.setAxisOrder(s);
parseDatum(params, datumParam); parseEllipsoid(params, datumParam); Datum datum = datumParam.getDatum(); Ellipsoid ellipsoid = datum.getEllipsoid(); /* TODO: this makes a difference - why?*/ /* which is better?*/ /*    Ellipsoid ellipsoid = datumParam.getEllipsoid(); */ Projection proj = parseProjection(params, ellipsoid); return new CoordinateReferenceSystem(name, args, datum, proj); }  /** * Creates a {@link Projection} * initialized from a PROJ.4 argument list.  <BUGS> if (params.containsKey(Proj4Keyword.south)) <BUGE> projection.setSouthernHemisphere(true);  s = (String) params.get(Proj4Keyword.pm); if (s != null) projection.setPrimeMeridian(s);  s = (String) params.get(Proj4Keyword.axis); if (s != null) projection.setAxisOrder(s);  /*TODO: implement some of these parameters ?*/  /* this must be done last, since behaviour depends on other params being set (eg +south)*/ if (projection instanceof TransverseMercatorProjection) {
parseDatum(params, datumParam); parseEllipsoid(params, datumParam); Datum datum = datumParam.getDatum(); Ellipsoid ellipsoid = datum.getEllipsoid(); /* TODO: this makes a difference - why?*/ /* which is better?*/ /*    Ellipsoid ellipsoid = datumParam.getEllipsoid(); */ Projection proj = parseProjection(params, ellipsoid); return new CoordinateReferenceSystem(name, args, datum, proj); }  /** * Creates a {@link Projection} * initialized from a PROJ.4 argument list.  <BUGS> s = (String) params.get(Proj4Keyword.pm); if (s != null) <BUGE> projection.setPrimeMeridian(s);  s = (String) params.get(Proj4Keyword.axis); if (s != null) projection.setAxisOrder(s);  /*TODO: implement some of these parameters ?*/  /* this must be done last, since behaviour depends on other params being set (eg +south)*/ if (projection instanceof TransverseMercatorProjection) { s = (String) params.get(Proj4Keyword.zone); if (s != null) ((TransverseMercatorProjection) projection).setUTMZone(Integer
parseDatum(params, datumParam); parseEllipsoid(params, datumParam); Datum datum = datumParam.getDatum(); Ellipsoid ellipsoid = datum.getEllipsoid(); /* TODO: this makes a difference - why?*/ /* which is better?*/ /*    Ellipsoid ellipsoid = datumParam.getEllipsoid(); */ Projection proj = parseProjection(params, ellipsoid); return new CoordinateReferenceSystem(name, args, datum, proj); }  /** * Creates a {@link Projection} * initialized from a PROJ.4 argument list.  <BUGS> s = (String) params.get(Proj4Keyword.axis); if (s != null) <BUGE> projection.setAxisOrder(s);  /*TODO: implement some of these parameters ?*/  /* this must be done last, since behaviour depends on other params being set (eg +south)*/ if (projection instanceof TransverseMercatorProjection) { s = (String) params.get(Proj4Keyword.zone); if (s != null) ((TransverseMercatorProjection) projection).setUTMZone(Integer .parseInt(s)); } if (projection instanceof ExtendedTransverseMercatorProjection) { s = (String) params.get(Proj4Keyword.zone);
parseDatum(params, datumParam); parseEllipsoid(params, datumParam); Datum datum = datumParam.getDatum(); Ellipsoid ellipsoid = datum.getEllipsoid(); /* TODO: this makes a difference - why?*/ /* which is better?*/ /*    Ellipsoid ellipsoid = datumParam.getEllipsoid(); */ Projection proj = parseProjection(params, ellipsoid); return new CoordinateReferenceSystem(name, args, datum, proj); }  /** * Creates a {@link Projection} * initialized from a PROJ.4 argument list. /* this must be done last, since behaviour depends on other params being set (eg +south)*/ <BUGS> if (projection instanceof TransverseMercatorProjection) { <BUGE> s = (String) params.get(Proj4Keyword.zone); if (s != null) ((TransverseMercatorProjection) projection).setUTMZone(Integer .parseInt(s)); } if (projection instanceof ExtendedTransverseMercatorProjection) { s = (String) params.get(Proj4Keyword.zone); if (s != null) ((ExtendedTransverseMercatorProjection) projection).setUTMZone(Integer .parseInt(s)); }  projection.initialize();
parseEllipsoid(params, datumParam); Datum datum = datumParam.getDatum(); Ellipsoid ellipsoid = datum.getEllipsoid(); /* TODO: this makes a difference - why?*/ /* which is better?*/ /*    Ellipsoid ellipsoid = datumParam.getEllipsoid(); */ Projection proj = parseProjection(params, ellipsoid); return new CoordinateReferenceSystem(name, args, datum, proj); }  /** * Creates a {@link Projection} * initialized from a PROJ.4 argument list. } <BUGS> if (projection instanceof ExtendedTransverseMercatorProjection) { s = (String) params.get(Proj4Keyword.zone); if (s != null) <BUGE> ((ExtendedTransverseMercatorProjection) projection).setUTMZone(Integer .parseInt(s)); }  projection.initialize();  return projection; }  private void parseDatum(Map params, DatumParameters datumParam) { String towgs84 = (String) params.get(Proj4Keyword.towgs84); if (towgs84 != null) { double[] datumConvParams = parseToWGS84(towgs84);
parseDatum(params, datumParam); parseEllipsoid(params, datumParam); Datum datum = datumParam.getDatum(); Ellipsoid ellipsoid = datum.getEllipsoid(); /* TODO: this makes a difference - why?*/ /* which is better?*/ /*    Ellipsoid ellipsoid = datumParam.getEllipsoid(); */ Projection proj = parseProjection(params, ellipsoid); return new CoordinateReferenceSystem(name, args, datum, proj); }  /** * Creates a {@link Projection} * initialized from a PROJ.4 argument list.  <BUGS> projection.initialize(); <BUGE>  return projection; }  private void parseDatum(Map params, DatumParameters datumParam) { String towgs84 = (String) params.get(Proj4Keyword.towgs84); if (towgs84 != null) { double[] datumConvParams = parseToWGS84(towgs84); datumParam.setDatumTransform(datumConvParams); }  String code = (String) params.get(Proj4Keyword.datum); if (code != null) { Datum datum = registry.getDatum(code);
parseDatum(params, datumParam); parseEllipsoid(params, datumParam); Datum datum = datumParam.getDatum(); Ellipsoid ellipsoid = datum.getEllipsoid(); /* TODO: this makes a difference - why?*/ /* which is better?*/ /*    Ellipsoid ellipsoid = datumParam.getEllipsoid(); */ Projection proj = parseProjection(params, ellipsoid); return new CoordinateReferenceSystem(name, args, datum, proj); }  /** * Creates a {@link Projection} * initialized from a PROJ.4 argument list.  <BUGS> return projection; <BUGE> }  private void parseDatum(Map params, DatumParameters datumParam) { String towgs84 = (String) params.get(Proj4Keyword.towgs84); if (towgs84 != null) { double[] datumConvParams = parseToWGS84(towgs84); datumParam.setDatumTransform(datumConvParams); }  String code = (String) params.get(Proj4Keyword.datum); if (code != null) { Datum datum = registry.getDatum(code); if (datum == null) throw new InvalidValueException("Unknown datum: " + code);
public static void checkUnsupported(String paramKey) { <BUGS> if (!isSupported(paramKey)) { throw new UnsupportedParameterException(paramKey + " parameter is not supported"); <BUGE> } }
public static void checkUnsupported(String paramKey) { if (!isSupported(paramKey)) { throw new UnsupportedParameterException(paramKey + " parameter is not supported"); } <BUGS> } <BUGE>
*/ public static Complex zpoly1d(Complex z, Complex[] C, Complex der) { Complex a, b; double t; <BUGS> boolean first = true; <BUGE>  a = new Complex(C[C.length - 1]); b = new Complex(a); for (int i = C.length - 1; i > 0; i--) { if (first) { first = false; } else { b.r = a.r + z.r * (t = b.r) - z.i * b.i; b.i = a.i + z.r * b.i + z.i * t; } Complex c = C[i]; a.r = c.r + z.r * (t = a.r) - z.i * a.i; a.i = c.i + z.r * a.i + z.i * t; }  b.r = a.r + z.r * (t = b.r) - z.i * b.i; b.i = a.i + z.r * b.i + z.i * t; a.r = z.r * (t = a.r) - z.i * a.i; a.i = z.r * a.i + z.i * t; der.i = b.i; der.r = b.r; return a; }
*/ public static Complex zpoly1d(Complex z, Complex[] C, Complex der) { Complex a, b; double t; boolean first = true;  <BUGS> a = new Complex(C[C.length - 1]); b = new Complex(a); for (int i = C.length - 1; i > 0; i--) { if (first) { first = false; <BUGE> } else { b.r = a.r + z.r * (t = b.r) - z.i * b.i; b.i = a.i + z.r * b.i + z.i * t; } Complex c = C[i]; a.r = c.r + z.r * (t = a.r) - z.i * a.i; a.i = c.i + z.r * a.i + z.i * t; }  b.r = a.r + z.r * (t = b.r) - z.i * b.i; b.i = a.i + z.r * b.i + z.i * t; a.r = z.r * (t = a.r) - z.i * a.i; a.i = z.r * a.i + z.i * t; der.i = b.i; der.r = b.r; return a; }
*/ public static Complex zpoly1d(Complex z, Complex[] C, Complex der) { Complex a, b; double t; boolean first = true;  a = new Complex(C[C.length - 1]); b = new Complex(a); for (int i = C.length - 1; i > 0; i--) { if (first) { first = false; } else { <BUGS> b.r = a.r + z.r * (t = b.r) - z.i * b.i; b.i = a.i + z.r * b.i + z.i * t; <BUGE> } Complex c = C[i]; a.r = c.r + z.r * (t = a.r) - z.i * a.i; a.i = c.i + z.r * a.i + z.i * t; }  b.r = a.r + z.r * (t = b.r) - z.i * b.i; b.i = a.i + z.r * b.i + z.i * t; a.r = z.r * (t = a.r) - z.i * a.i; a.i = z.r * a.i + z.i * t; der.i = b.i; der.r = b.r; return a; }
*/ public static Complex zpoly1d(Complex z, Complex[] C, Complex der) { Complex a, b; double t; boolean first = true;  a = new Complex(C[C.length - 1]); b = new Complex(a); for (int i = C.length - 1; i > 0; i--) { if (first) { first = false; } else { b.r = a.r + z.r * (t = b.r) - z.i * b.i; b.i = a.i + z.r * b.i + z.i * t; } <BUGS> Complex c = C[i]; a.r = c.r + z.r * (t = a.r) - z.i * a.i; a.i = c.i + z.r * a.i + z.i * t; <BUGE> }  b.r = a.r + z.r * (t = b.r) - z.i * b.i; b.i = a.i + z.r * b.i + z.i * t; a.r = z.r * (t = a.r) - z.i * a.i; a.i = z.r * a.i + z.i * t; der.i = b.i; der.r = b.r; return a; }
*/ public static Complex zpoly1d(Complex z, Complex[] C, Complex der) { Complex a, b; double t; boolean first = true;  a = new Complex(C[C.length - 1]); b = new Complex(a); for (int i = C.length - 1; i > 0; i--) { if (first) { first = false; } else { b.r = a.r + z.r * (t = b.r) - z.i * b.i; b.i = a.i + z.r * b.i + z.i * t; } Complex c = C[i]; a.r = c.r + z.r * (t = a.r) - z.i * a.i; a.i = c.i + z.r * a.i + z.i * t; }  <BUGS> b.r = a.r + z.r * (t = b.r) - z.i * b.i; b.i = a.i + z.r * b.i + z.i * t; a.r = z.r * (t = a.r) - z.i * a.i; a.i = z.r * a.i + z.i * t; der.i = b.i; der.r = b.r; return a; <BUGE> }
public Projection getProjection(String name) { /*    if ( projRegistry == null )*/ /*      initialize();*/ <BUGS> Class cls = (Class) projRegistry.get(name); if (cls != null) { <BUGE> try { Projection projection = (Projection) cls.newInstance(); if (projection != null) projection.setName(name); return projection; } catch (IllegalAccessException e) { e.printStackTrace(); } catch (InstantiationException e) { e.printStackTrace(); } } return null; }
public Projection getProjection(String name) { /*    if ( projRegistry == null )*/ /*      initialize();*/ Class cls = (Class) projRegistry.get(name); if (cls != null) { try { <BUGS> Projection projection = (Projection) cls.newInstance(); if (projection != null) projection.setName(name); return projection; <BUGE> } catch (IllegalAccessException e) { e.printStackTrace(); } catch (InstantiationException e) { e.printStackTrace(); } } return null; }
public Projection getProjection(String name) { /*    if ( projRegistry == null )*/ /*      initialize();*/ Class cls = (Class) projRegistry.get(name); if (cls != null) { try { Projection projection = (Projection) cls.newInstance(); if (projection != null) projection.setName(name); return projection; } catch (IllegalAccessException e) { e.printStackTrace(); } catch (InstantiationException e) { e.printStackTrace(); } } <BUGS> return null; <BUGE> }
*/ public boolean isEqual(Datum datum) { /* false if tranforms are not equal*/ <BUGS> if (getTransformType() != datum.getTransformType()) { <BUGE> return false; } /* false if ellipsoids are not (approximately) equal*/ if (ellipsoid.getEquatorRadius() != ellipsoid.getEquatorRadius()) { if (Math.abs(ellipsoid.getEccentricitySquared() - datum.ellipsoid.getEccentricitySquared()) > ELLIPSOID_E2_TOLERANCE) return false; }  /* false if transform parameters are not identical*/ if (getTransformType() == TYPE_3PARAM || getTransformType() == TYPE_7PARAM) { for (int i = 0; i < transform.length; i++) { if (transform[i] != datum.transform[i]) return false; } return true; } else if (getTransformType() == TYPE_GRIDSHIFT) { return grids.equals(datum.grids); } return true; /* datums are equal*/  }
*/ public boolean isEqual(Datum datum) { /* false if tranforms are not equal*/ if (getTransformType() != datum.getTransformType()) { return false; } /* false if ellipsoids are not (approximately) equal*/ <BUGS> if (ellipsoid.getEquatorRadius() != ellipsoid.getEquatorRadius()) { <BUGE> if (Math.abs(ellipsoid.getEccentricitySquared() - datum.ellipsoid.getEccentricitySquared()) > ELLIPSOID_E2_TOLERANCE) return false; }  /* false if transform parameters are not identical*/ if (getTransformType() == TYPE_3PARAM || getTransformType() == TYPE_7PARAM) { for (int i = 0; i < transform.length; i++) { if (transform[i] != datum.transform[i]) return false; } return true; } else if (getTransformType() == TYPE_GRIDSHIFT) { return grids.equals(datum.grids); } return true; /* datums are equal*/  }
*/ public boolean isEqual(Datum datum) { /* false if tranforms are not equal*/ if (getTransformType() != datum.getTransformType()) { return false; } /* false if ellipsoids are not (approximately) equal*/ if (ellipsoid.getEquatorRadius() != ellipsoid.getEquatorRadius()) { if (Math.abs(ellipsoid.getEccentricitySquared() - datum.ellipsoid.getEccentricitySquared()) > ELLIPSOID_E2_TOLERANCE) return false; }  /* false if transform parameters are not identical*/ <BUGS> if (getTransformType() == TYPE_3PARAM || getTransformType() == TYPE_7PARAM) { <BUGE> for (int i = 0; i < transform.length; i++) { if (transform[i] != datum.transform[i]) return false; } return true; } else if (getTransformType() == TYPE_GRIDSHIFT) { return grids.equals(datum.grids); } return true; /* datums are equal*/  }
*/ public boolean isEqual(Datum datum) { /* false if tranforms are not equal*/ if (getTransformType() != datum.getTransformType()) { return false; } /* false if ellipsoids are not (approximately) equal*/ if (ellipsoid.getEquatorRadius() != ellipsoid.getEquatorRadius()) { if (Math.abs(ellipsoid.getEccentricitySquared() - datum.ellipsoid.getEccentricitySquared()) > ELLIPSOID_E2_TOLERANCE) return false; }  /* false if transform parameters are not identical*/ if (getTransformType() == TYPE_3PARAM || getTransformType() == TYPE_7PARAM) { for (int i = 0; i < transform.length; i++) { if (transform[i] != datum.transform[i]) return false; } return true; <BUGS> } else if (getTransformType() == TYPE_GRIDSHIFT) { return grids.equals(datum.grids); <BUGE> } return true; /* datums are equal*/  }
public String getName() { <BUGS> if ( name != null ) return name; <BUGE> return toString(); }
*/ private Projection parseProjection(Map params, Ellipsoid ellipsoid) { <BUGS> Projection projection = null; <BUGE>  String s; s = (String) params.get(Proj4Keyword.proj); if (s != null) { projection = registry.getProjection(s); if (projection == null) throw new InvalidValueException("Unknown projection: " + s); } else { throw new InvalidValueException("Keyword '" + Proj4Keyword.proj + "' is a required parameter"); } projection.setEllipsoid(ellipsoid);  /*TODO: better error handling for things like bad number syntax.*/ /* Should be able to report the original param string in the error message*/ /* Should the exception be lib-specific?  (e.g. ParseException)*/  s = (String) params.get(Proj4Keyword.alpha); if (s != null) projection.setAlphaDegrees(Double.parseDouble(s));  s = (String) params.get(Proj4Keyword.lonc); if (s != null) projection.setLonCDegrees(Double.parseDouble(s));  s = (String) params.get(Proj4Keyword.lat_0); if (s != null)
*/ private Projection parseProjection(Map params, Ellipsoid ellipsoid) { Projection projection = null;  String s; <BUGS> s = (String) params.get(Proj4Keyword.proj); if (s != null) { projection = registry.getProjection(s); if (projection == null) <BUGE> throw new InvalidValueException("Unknown projection: " + s); } else { throw new InvalidValueException("Keyword '" + Proj4Keyword.proj + "' is a required parameter"); } projection.setEllipsoid(ellipsoid);  /*TODO: better error handling for things like bad number syntax.*/ /* Should be able to report the original param string in the error message*/ /* Should the exception be lib-specific?  (e.g. ParseException)*/  s = (String) params.get(Proj4Keyword.alpha); if (s != null) projection.setAlphaDegrees(Double.parseDouble(s));  s = (String) params.get(Proj4Keyword.lonc); if (s != null) projection.setLonCDegrees(Double.parseDouble(s));  s = (String) params.get(Proj4Keyword.lat_0); if (s != null)
*/ private Projection parseProjection(Map params, Ellipsoid ellipsoid) { Projection projection = null;  String s; s = (String) params.get(Proj4Keyword.proj); if (s != null) { projection = registry.getProjection(s); if (projection == null) throw new InvalidValueException("Unknown projection: " + s); } else { throw new InvalidValueException("Keyword '" + Proj4Keyword.proj + "' is a required parameter"); } <BUGS> projection.setEllipsoid(ellipsoid); <BUGE>  /*TODO: better error handling for things like bad number syntax.*/ /* Should be able to report the original param string in the error message*/ /* Should the exception be lib-specific?  (e.g. ParseException)*/  s = (String) params.get(Proj4Keyword.alpha); if (s != null) projection.setAlphaDegrees(Double.parseDouble(s));  s = (String) params.get(Proj4Keyword.lonc); if (s != null) projection.setLonCDegrees(Double.parseDouble(s));  s = (String) params.get(Proj4Keyword.lat_0); if (s != null)
*/ private Projection parseProjection(Map params, Ellipsoid ellipsoid) { Projection projection = null;  String s; s = (String) params.get(Proj4Keyword.proj); if (s != null) { projection = registry.getProjection(s); if (projection == null) throw new InvalidValueException("Unknown projection: " + s); } else { throw new InvalidValueException("Keyword '" + Proj4Keyword.proj + "' is a required parameter"); } projection.setEllipsoid(ellipsoid);  /*TODO: better error handling for things like bad number syntax.*/ /* Should be able to report the original param string in the error message*/ /* Should the exception be lib-specific?  (e.g. ParseException)*/  <BUGS> s = (String) params.get(Proj4Keyword.alpha); if (s != null) projection.setAlphaDegrees(Double.parseDouble(s)); <BUGE>  s = (String) params.get(Proj4Keyword.lonc); if (s != null) projection.setLonCDegrees(Double.parseDouble(s));  s = (String) params.get(Proj4Keyword.lat_0); if (s != null)
*/ private Projection parseProjection(Map params, Ellipsoid ellipsoid) { Projection projection = null;  String s; s = (String) params.get(Proj4Keyword.proj); if (s != null) { projection = registry.getProjection(s); if (projection == null) throw new InvalidValueException("Unknown projection: " + s); } else { throw new InvalidValueException("Keyword '" + Proj4Keyword.proj + "' is a required parameter"); } projection.setEllipsoid(ellipsoid);  /*TODO: better error handling for things like bad number syntax.*/ /* Should be able to report the original param string in the error message*/ /* Should the exception be lib-specific?  (e.g. ParseException)*/  s = (String) params.get(Proj4Keyword.alpha); if (s != null) projection.setAlphaDegrees(Double.parseDouble(s));  <BUGS> s = (String) params.get(Proj4Keyword.lonc); if (s != null) projection.setLonCDegrees(Double.parseDouble(s)); <BUGE>  s = (String) params.get(Proj4Keyword.lat_0); if (s != null)
*/ private Projection parseProjection(Map params, Ellipsoid ellipsoid) { Projection projection = null;  String s; s = (String) params.get(Proj4Keyword.proj); if (s != null) { projection = registry.getProjection(s); if (projection == null) throw new InvalidValueException("Unknown projection: " + s); } else { throw new InvalidValueException("Keyword '" + Proj4Keyword.proj + "' is a required parameter"); } projection.setEllipsoid(ellipsoid);  /*TODO: better error handling for things like bad number syntax.*/ /* Should be able to report the original param string in the error message*/ /* Should the exception be lib-specific?  (e.g. ParseException)*/  s = (String) params.get(Proj4Keyword.alpha); if (s != null) projection.setAlphaDegrees(Double.parseDouble(s));  s = (String) params.get(Proj4Keyword.lonc); if (s != null) projection.setLonCDegrees(Double.parseDouble(s));  <BUGS> s = (String) params.get(Proj4Keyword.lat_0); if (s != null)
parseEllipsoid(params, datumParam); Datum datum = datumParam.getDatum(); Ellipsoid ellipsoid = datum.getEllipsoid(); /* TODO: this makes a difference - why?*/ /* which is better?*/ /*    Ellipsoid ellipsoid = datumParam.getEllipsoid(); */ Projection proj = parseProjection(params, ellipsoid); return new CoordinateReferenceSystem(name, args, datum, proj); }  /** * Creates a {@link Projection} * initialized from a PROJ.4 argument list.  <BUGS> s = (String) params.get(Proj4Keyword.lon_0); if (s != null) projection.setProjectionLongitudeDegrees(parseAngle(s)); <BUGE>  s = (String) params.get(Proj4Keyword.lat_1); if (s != null) projection.setProjectionLatitude1Degrees(parseAngle(s));  s = (String) params.get(Proj4Keyword.lat_2); if (s != null) projection.setProjectionLatitude2Degrees(parseAngle(s));  s = (String) params.get(Proj4Keyword.lat_ts); if (s != null) projection.setTrueScaleLatitudeDegrees(parseAngle(s));
parseEllipsoid(params, datumParam); Datum datum = datumParam.getDatum(); Ellipsoid ellipsoid = datum.getEllipsoid(); /* TODO: this makes a difference - why?*/ /* which is better?*/ /*    Ellipsoid ellipsoid = datumParam.getEllipsoid(); */ Projection proj = parseProjection(params, ellipsoid); return new CoordinateReferenceSystem(name, args, datum, proj); }  /** * Creates a {@link Projection} * initialized from a PROJ.4 argument list.  <BUGS> s = (String) params.get(Proj4Keyword.lat_1); if (s != null) projection.setProjectionLatitude1Degrees(parseAngle(s)); <BUGE>  s = (String) params.get(Proj4Keyword.lat_2); if (s != null) projection.setProjectionLatitude2Degrees(parseAngle(s));  s = (String) params.get(Proj4Keyword.lat_ts); if (s != null) projection.setTrueScaleLatitudeDegrees(parseAngle(s));  s = (String) params.get(Proj4Keyword.x_0); if (s != null) projection.setFalseEasting(Double.parseDouble(s));
parseEllipsoid(params, datumParam); Datum datum = datumParam.getDatum(); Ellipsoid ellipsoid = datum.getEllipsoid(); /* TODO: this makes a difference - why?*/ /* which is better?*/ /*    Ellipsoid ellipsoid = datumParam.getEllipsoid(); */ Projection proj = parseProjection(params, ellipsoid); return new CoordinateReferenceSystem(name, args, datum, proj); }  /** * Creates a {@link Projection} * initialized from a PROJ.4 argument list.  <BUGS> s = (String) params.get(Proj4Keyword.lat_2); if (s != null) projection.setProjectionLatitude2Degrees(parseAngle(s)); <BUGE>  s = (String) params.get(Proj4Keyword.lat_ts); if (s != null) projection.setTrueScaleLatitudeDegrees(parseAngle(s));  s = (String) params.get(Proj4Keyword.x_0); if (s != null) projection.setFalseEasting(Double.parseDouble(s));  s = (String) params.get(Proj4Keyword.y_0); if (s != null) projection.setFalseNorthing(Double.parseDouble(s));
parseEllipsoid(params, datumParam); Datum datum = datumParam.getDatum(); Ellipsoid ellipsoid = datum.getEllipsoid(); /* TODO: this makes a difference - why?*/ /* which is better?*/ /*    Ellipsoid ellipsoid = datumParam.getEllipsoid(); */ Projection proj = parseProjection(params, ellipsoid); return new CoordinateReferenceSystem(name, args, datum, proj); }  /** * Creates a {@link Projection} * initialized from a PROJ.4 argument list.  <BUGS> s = (String) params.get(Proj4Keyword.lat_ts); if (s != null) projection.setTrueScaleLatitudeDegrees(parseAngle(s)); <BUGE>  s = (String) params.get(Proj4Keyword.x_0); if (s != null) projection.setFalseEasting(Double.parseDouble(s));  s = (String) params.get(Proj4Keyword.y_0); if (s != null) projection.setFalseNorthing(Double.parseDouble(s));  s = (String) params.get(Proj4Keyword.k_0); if (s == null) s = (String) params.get(Proj4Keyword.k); if (s != null)
parseEllipsoid(params, datumParam); Datum datum = datumParam.getDatum(); Ellipsoid ellipsoid = datum.getEllipsoid(); /* TODO: this makes a difference - why?*/ /* which is better?*/ /*    Ellipsoid ellipsoid = datumParam.getEllipsoid(); */ Projection proj = parseProjection(params, ellipsoid); return new CoordinateReferenceSystem(name, args, datum, proj); }  /** * Creates a {@link Projection} * initialized from a PROJ.4 argument list.  <BUGS> s = (String) params.get(Proj4Keyword.x_0); if (s != null) projection.setFalseEasting(Double.parseDouble(s)); <BUGE>  s = (String) params.get(Proj4Keyword.y_0); if (s != null) projection.setFalseNorthing(Double.parseDouble(s));  s = (String) params.get(Proj4Keyword.k_0); if (s == null) s = (String) params.get(Proj4Keyword.k); if (s != null) projection.setScaleFactor(Double.parseDouble(s)); if (params.containsKey(Proj4Keyword.no_uoff)) projection.setNoUoff(true); s = (String) params.get(Proj4Keyword.gamma);
parseEllipsoid(params, datumParam); Datum datum = datumParam.getDatum(); Ellipsoid ellipsoid = datum.getEllipsoid(); /* TODO: this makes a difference - why?*/ /* which is better?*/ /*    Ellipsoid ellipsoid = datumParam.getEllipsoid(); */ Projection proj = parseProjection(params, ellipsoid); return new CoordinateReferenceSystem(name, args, datum, proj); }  /** * Creates a {@link Projection} * initialized from a PROJ.4 argument list.  <BUGS> s = (String) params.get(Proj4Keyword.y_0); if (s != null) projection.setFalseNorthing(Double.parseDouble(s)); <BUGE>  s = (String) params.get(Proj4Keyword.k_0); if (s == null) s = (String) params.get(Proj4Keyword.k); if (s != null) projection.setScaleFactor(Double.parseDouble(s)); if (params.containsKey(Proj4Keyword.no_uoff)) projection.setNoUoff(true); s = (String) params.get(Proj4Keyword.gamma); if (s != null) projection.setGammaDegrees(Double.parseDouble(s));  s = (String) params.get(Proj4Keyword.units);
/* TODO: this makes a difference - why?*/ /* which is better?*/ /*    Ellipsoid ellipsoid = datumParam.getEllipsoid(); */ Projection proj = parseProjection(params, ellipsoid); return new CoordinateReferenceSystem(name, args, datum, proj); }  /** * Creates a {@link Projection} * initialized from a PROJ.4 argument list.  <BUGS> s = (String) params.get(Proj4Keyword.k_0); if (s == null) s = (String) params.get(Proj4Keyword.k); if (s != null) projection.setScaleFactor(Double.parseDouble(s)); if (params.containsKey(Proj4Keyword.no_uoff)) projection.setNoUoff(true); s = (String) params.get(Proj4Keyword.gamma); if (s != null) projection.setGammaDegrees(Double.parseDouble(s)); <BUGE>  s = (String) params.get(Proj4Keyword.units); if (s != null) { Unit unit = Units.findUnits(s); /* TODO: report unknown units name as error*/ if (unit != null) { projection.setFromMetres(1.0 / unit.value); projection.setUnits(unit); }
parseEllipsoid(params, datumParam); Datum datum = datumParam.getDatum(); Ellipsoid ellipsoid = datum.getEllipsoid(); /* TODO: this makes a difference - why?*/ /* which is better?*/ /*    Ellipsoid ellipsoid = datumParam.getEllipsoid(); */ Projection proj = parseProjection(params, ellipsoid); return new CoordinateReferenceSystem(name, args, datum, proj); }  /** * Creates a {@link Projection} * initialized from a PROJ.4 argument list.  <BUGS> s = (String) params.get(Proj4Keyword.units); if (s != null) { Unit unit = Units.findUnits(s); <BUGE> /* TODO: report unknown units name as error*/ if (unit != null) { projection.setFromMetres(1.0 / unit.value); projection.setUnits(unit); } }  s = (String) params.get(Proj4Keyword.to_meter); if (s != null) projection.setFromMetres(1.0 / Double.parseDouble(s));  s = (String) params.get(Proj4Keyword.h); if (s != null) {
parseEllipsoid(params, datumParam); Datum datum = datumParam.getDatum(); Ellipsoid ellipsoid = datum.getEllipsoid(); /* TODO: this makes a difference - why?*/ /* which is better?*/ /*    Ellipsoid ellipsoid = datumParam.getEllipsoid(); */ Projection proj = parseProjection(params, ellipsoid); return new CoordinateReferenceSystem(name, args, datum, proj); }  /** * Creates a {@link Projection} * initialized from a PROJ.4 argument list. /* TODO: report unknown units name as error*/ <BUGS> if (unit != null) { projection.setFromMetres(1.0 / unit.value); projection.setUnits(unit); <BUGE> } }  s = (String) params.get(Proj4Keyword.to_meter); if (s != null) projection.setFromMetres(1.0 / Double.parseDouble(s));  s = (String) params.get(Proj4Keyword.h); if (s != null) { projection.setHeightOfOrbit(Double.parseDouble(s)); }  if (params.containsKey(Proj4Keyword.south))
parseEllipsoid(params, datumParam); Datum datum = datumParam.getDatum(); Ellipsoid ellipsoid = datum.getEllipsoid(); /* TODO: this makes a difference - why?*/ /* which is better?*/ /*    Ellipsoid ellipsoid = datumParam.getEllipsoid(); */ Projection proj = parseProjection(params, ellipsoid); return new CoordinateReferenceSystem(name, args, datum, proj); }  /** * Creates a {@link Projection} * initialized from a PROJ.4 argument list.  <BUGS> s = (String) params.get(Proj4Keyword.to_meter); if (s != null) projection.setFromMetres(1.0 / Double.parseDouble(s)); <BUGE>  s = (String) params.get(Proj4Keyword.h); if (s != null) { projection.setHeightOfOrbit(Double.parseDouble(s)); }  if (params.containsKey(Proj4Keyword.south)) projection.setSouthernHemisphere(true);  s = (String) params.get(Proj4Keyword.pm); if (s != null) projection.setPrimeMeridian(s);
parseDatum(params, datumParam); parseEllipsoid(params, datumParam); Datum datum = datumParam.getDatum(); Ellipsoid ellipsoid = datum.getEllipsoid(); /* TODO: this makes a difference - why?*/ /* which is better?*/ /*    Ellipsoid ellipsoid = datumParam.getEllipsoid(); */ Projection proj = parseProjection(params, ellipsoid); return new CoordinateReferenceSystem(name, args, datum, proj); }  /** * Creates a {@link Projection} * initialized from a PROJ.4 argument list.  <BUGS> s = (String) params.get(Proj4Keyword.h); if (s != null) { <BUGE> projection.setHeightOfOrbit(Double.parseDouble(s)); }  if (params.containsKey(Proj4Keyword.south)) projection.setSouthernHemisphere(true);  s = (String) params.get(Proj4Keyword.pm); if (s != null) projection.setPrimeMeridian(s);  s = (String) params.get(Proj4Keyword.axis); if (s != null) projection.setAxisOrder(s);
parseDatum(params, datumParam); parseEllipsoid(params, datumParam); Datum datum = datumParam.getDatum(); Ellipsoid ellipsoid = datum.getEllipsoid(); /* TODO: this makes a difference - why?*/ /* which is better?*/ /*    Ellipsoid ellipsoid = datumParam.getEllipsoid(); */ Projection proj = parseProjection(params, ellipsoid); return new CoordinateReferenceSystem(name, args, datum, proj); }  /** * Creates a {@link Projection} * initialized from a PROJ.4 argument list.  <BUGS> if (params.containsKey(Proj4Keyword.south)) projection.setSouthernHemisphere(true); <BUGE>  s = (String) params.get(Proj4Keyword.pm); if (s != null) projection.setPrimeMeridian(s);  s = (String) params.get(Proj4Keyword.axis); if (s != null) projection.setAxisOrder(s);  /* Radius of the sphere given in meters. If used in conjuction with +ellps +R takes precedence. */ s = (String) params.get(Proj4Keyword.R); if (s != null) projection.setRadius(Double.parseDouble(s));
parseEllipsoid(params, datumParam); Datum datum = datumParam.getDatum(); Ellipsoid ellipsoid = datum.getEllipsoid(); /* TODO: this makes a difference - why?*/ /* which is better?*/ /*    Ellipsoid ellipsoid = datumParam.getEllipsoid(); */ Projection proj = parseProjection(params, ellipsoid); return new CoordinateReferenceSystem(name, args, datum, proj); }  /** * Creates a {@link Projection} * initialized from a PROJ.4 argument list.  <BUGS> s = (String) params.get(Proj4Keyword.pm); if (s != null) projection.setPrimeMeridian(s); <BUGE>  s = (String) params.get(Proj4Keyword.axis); if (s != null) projection.setAxisOrder(s);  /* Radius of the sphere given in meters. If used in conjuction with +ellps +R takes precedence. */ s = (String) params.get(Proj4Keyword.R); if (s != null) projection.setRadius(Double.parseDouble(s));  /*TODO: implement some of these parameters ?*/  /* this must be done last, since behaviour depends on other params being set (eg +south)*/
parseEllipsoid(params, datumParam); Datum datum = datumParam.getDatum(); Ellipsoid ellipsoid = datum.getEllipsoid(); /* TODO: this makes a difference - why?*/ /* which is better?*/ /*    Ellipsoid ellipsoid = datumParam.getEllipsoid(); */ Projection proj = parseProjection(params, ellipsoid); return new CoordinateReferenceSystem(name, args, datum, proj); }  /** * Creates a {@link Projection} * initialized from a PROJ.4 argument list.  <BUGS> s = (String) params.get(Proj4Keyword.axis); if (s != null) projection.setAxisOrder(s); <BUGE>  /* Radius of the sphere given in meters. If used in conjuction with +ellps +R takes precedence. */ s = (String) params.get(Proj4Keyword.R); if (s != null) projection.setRadius(Double.parseDouble(s));  /*TODO: implement some of these parameters ?*/  /* this must be done last, since behaviour depends on other params being set (eg +south)*/ if (projection instanceof TransverseMercatorProjection) { s = (String) params.get(Proj4Keyword.zone); if (s != null) ((TransverseMercatorProjection) projection).setUTMZone(Integer
parseDatum(params, datumParam); parseEllipsoid(params, datumParam); Datum datum = datumParam.getDatum(); Ellipsoid ellipsoid = datum.getEllipsoid(); /* TODO: this makes a difference - why?*/ /* which is better?*/ /*    Ellipsoid ellipsoid = datumParam.getEllipsoid(); */ Projection proj = parseProjection(params, ellipsoid); return new CoordinateReferenceSystem(name, args, datum, proj); }  /** * Creates a {@link Projection} * initialized from a PROJ.4 argument list. /* Radius of the sphere given in meters. If used in conjuction with +ellps +R takes precedence. */ <BUGS> s = (String) params.get(Proj4Keyword.R); if (s != null) <BUGE> projection.setRadius(Double.parseDouble(s));  /*TODO: implement some of these parameters ?*/  /* this must be done last, since behaviour depends on other params being set (eg +south)*/ if (projection instanceof TransverseMercatorProjection) { s = (String) params.get(Proj4Keyword.zone); if (s != null) ((TransverseMercatorProjection) projection).setUTMZone(Integer .parseInt(s)); } if (projection instanceof ExtendedTransverseMercatorProjection) { s = (String) params.get(Proj4Keyword.zone);
parseEllipsoid(params, datumParam); Datum datum = datumParam.getDatum(); Ellipsoid ellipsoid = datum.getEllipsoid(); /* TODO: this makes a difference - why?*/ /* which is better?*/ /*    Ellipsoid ellipsoid = datumParam.getEllipsoid(); */ Projection proj = parseProjection(params, ellipsoid); return new CoordinateReferenceSystem(name, args, datum, proj); }  /** * Creates a {@link Projection} * initialized from a PROJ.4 argument list. /* this must be done last, since behaviour depends on other params being set (eg +south)*/ <BUGS> if (projection instanceof TransverseMercatorProjection) { s = (String) params.get(Proj4Keyword.zone); if (s != null) <BUGE> ((TransverseMercatorProjection) projection).setUTMZone(Integer .parseInt(s)); } if (projection instanceof ExtendedTransverseMercatorProjection) { s = (String) params.get(Proj4Keyword.zone); if (s != null) ((ExtendedTransverseMercatorProjection) projection).setUTMZone(Integer .parseInt(s)); }  projection.initialize();  return projection;
Datum datum = datumParam.getDatum(); Ellipsoid ellipsoid = datum.getEllipsoid(); /* TODO: this makes a difference - why?*/ /* which is better?*/ /*    Ellipsoid ellipsoid = datumParam.getEllipsoid(); */ Projection proj = parseProjection(params, ellipsoid); return new CoordinateReferenceSystem(name, args, datum, proj); }  /** * Creates a {@link Projection} * initialized from a PROJ.4 argument list. } <BUGS> if (projection instanceof ExtendedTransverseMercatorProjection) { s = (String) params.get(Proj4Keyword.zone); if (s != null) ((ExtendedTransverseMercatorProjection) projection).setUTMZone(Integer .parseInt(s)); <BUGE> }  projection.initialize();  return projection; }  private void parseDatum(Map params, DatumParameters datumParam) { String towgs84 = (String) params.get(Proj4Keyword.towgs84); if (towgs84 != null) { double[] datumConvParams = parseToWGS84(towgs84); datumParam.setDatumTransform(datumConvParams);
parseDatum(params, datumParam); parseEllipsoid(params, datumParam); Datum datum = datumParam.getDatum(); Ellipsoid ellipsoid = datum.getEllipsoid(); /* TODO: this makes a difference - why?*/ /* which is better?*/ /*    Ellipsoid ellipsoid = datumParam.getEllipsoid(); */ Projection proj = parseProjection(params, ellipsoid); return new CoordinateReferenceSystem(name, args, datum, proj); }  /** * Creates a {@link Projection} * initialized from a PROJ.4 argument list.  <BUGS> projection.initialize(); <BUGE>  return projection; }  private void parseDatum(Map params, DatumParameters datumParam) { String towgs84 = (String) params.get(Proj4Keyword.towgs84); if (towgs84 != null) { double[] datumConvParams = parseToWGS84(towgs84); datumParam.setDatumTransform(datumConvParams); }  String code = (String) params.get(Proj4Keyword.datum); if (code != null) { Datum datum = registry.getDatum(code);
parseDatum(params, datumParam); parseEllipsoid(params, datumParam); Datum datum = datumParam.getDatum(); Ellipsoid ellipsoid = datum.getEllipsoid(); /* TODO: this makes a difference - why?*/ /* which is better?*/ /*    Ellipsoid ellipsoid = datumParam.getEllipsoid(); */ Projection proj = parseProjection(params, ellipsoid); return new CoordinateReferenceSystem(name, args, datum, proj); }  /** * Creates a {@link Projection} * initialized from a PROJ.4 argument list.  <BUGS> return projection; <BUGE> }  private void parseDatum(Map params, DatumParameters datumParam) { String towgs84 = (String) params.get(Proj4Keyword.towgs84); if (towgs84 != null) { double[] datumConvParams = parseToWGS84(towgs84); datumParam.setDatumTransform(datumConvParams); }  String code = (String) params.get(Proj4Keyword.datum); if (code != null) { Datum datum = registry.getDatum(code); if (datum == null) throw new InvalidValueException("Unknown datum: " + code);
public void transformFromGeocentricToWgs84(ProjCoordinate p) { <BUGS> if (transform.length == 3) { <BUGE> p.x += transform[0]; p.y += transform[1]; p.z += transform[2];  } else if (transform.length == 7) { double Dx_BF = transform[0]; double Dy_BF = transform[1]; double Dz_BF = transform[2]; double Rx_BF = transform[3]; double Ry_BF = transform[4]; double Rz_BF = transform[5]; double M_BF = transform[6];  double x_out = M_BF * (p.x - Rz_BF * p.y + Ry_BF * p.z) + Dx_BF; double y_out = M_BF * (Rz_BF * p.x + p.y - Rx_BF * p.z) + Dy_BF; double z_out = M_BF * (-Ry_BF * p.x + Rx_BF * p.y + p.z) + Dz_BF;  p.x = x_out; p.y = y_out; p.z = z_out; } }
public void transformFromGeocentricToWgs84(ProjCoordinate p) { if (transform.length == 3) { p.x += transform[0]; p.y += transform[1]; p.z += transform[2];  <BUGS> } else if (transform.length == 7) { double Dx_BF = transform[0]; double Dy_BF = transform[1]; double Dz_BF = transform[2]; double Rx_BF = transform[3]; double Ry_BF = transform[4]; double Rz_BF = transform[5]; double M_BF = transform[6]; <BUGE>  double x_out = M_BF * (p.x - Rz_BF * p.y + Ry_BF * p.z) + Dx_BF; double y_out = M_BF * (Rz_BF * p.x + p.y - Rx_BF * p.z) + Dy_BF; double z_out = M_BF * (-Ry_BF * p.x + Rx_BF * p.y + p.z) + Dz_BF;  p.x = x_out; p.y = y_out; p.z = z_out; } }
public void transformFromGeocentricToWgs84(ProjCoordinate p) { if (transform.length == 3) { p.x += transform[0]; p.y += transform[1]; p.z += transform[2];  } else if (transform.length == 7) { double Dx_BF = transform[0]; double Dy_BF = transform[1]; double Dz_BF = transform[2]; double Rx_BF = transform[3]; double Ry_BF = transform[4]; double Rz_BF = transform[5]; double M_BF = transform[6];  <BUGS> double x_out = M_BF * (p.x - Rz_BF * p.y + Ry_BF * p.z) + Dx_BF; double y_out = M_BF * (Rz_BF * p.x + p.y - Rx_BF * p.z) + Dy_BF; double z_out = M_BF * (-Ry_BF * p.x + Rx_BF * p.y + p.z) + Dz_BF; <BUGE>  p.x = x_out; p.y = y_out; p.z = z_out; } }
public void transformFromGeocentricToWgs84(ProjCoordinate p) { if (transform.length == 3) { p.x += transform[0]; p.y += transform[1]; p.z += transform[2];  } else if (transform.length == 7) { double Dx_BF = transform[0]; double Dy_BF = transform[1]; double Dz_BF = transform[2]; double Rx_BF = transform[3]; double Ry_BF = transform[4]; double Rz_BF = transform[5]; double M_BF = transform[6];  double x_out = M_BF * (p.x - Rz_BF * p.y + Ry_BF * p.z) + Dx_BF; double y_out = M_BF * (Rz_BF * p.x + p.y - Rx_BF * p.z) + Dy_BF; double z_out = M_BF * (-Ry_BF * p.x + Rx_BF * p.y + p.z) + Dz_BF;  <BUGS> p.x = x_out; p.y = y_out; p.z = z_out; <BUGE> } }
public void transformFromGeocentricToWgs84(ProjCoordinate p) { if (transform.length == 3) { p.x += transform[0]; p.y += transform[1]; p.z += transform[2];  } else if (transform.length == 7) { double Dx_BF = transform[0]; double Dy_BF = transform[1]; double Dz_BF = transform[2]; double Rx_BF = transform[3]; double Ry_BF = transform[4]; double Rz_BF = transform[5]; double M_BF = transform[6];  double x_out = M_BF * (p.x - Rz_BF * p.y + Ry_BF * p.z) + Dx_BF; double y_out = M_BF * (Rz_BF * p.x + p.y - Rx_BF * p.z) + Dy_BF; double z_out = M_BF * (-Ry_BF * p.x + Rx_BF * p.y + p.z) + Dz_BF;  p.x = x_out; p.y = y_out; p.z = z_out; } <BUGS> } <BUGE>
public void transformFromGeocentricToWgs84(ProjCoordinate p) { <BUGS> if (transform.length == 3) { <BUGE> p.x += transform[0]; p.y += transform[1]; p.z += transform[2];  } else if (transform.length == 7) { double Dx_BF = transform[0]; double Dy_BF = transform[1]; double Dz_BF = transform[2]; double Rx_BF = transform[3]; double Ry_BF = transform[4]; double Rz_BF = transform[5]; double M_BF = transform[6];  double x_out = M_BF * (p.x - Rz_BF * p.y + Ry_BF * p.z) + Dx_BF; double y_out = M_BF * (Rz_BF * p.x + p.y - Rx_BF * p.z) + Dy_BF; double z_out = M_BF * (-Ry_BF * p.x + Rx_BF * p.y + p.z) + Dz_BF;  p.x = x_out; p.y = y_out; p.z = z_out; } }
public void transformFromGeocentricToWgs84(ProjCoordinate p) { if (transform.length == 3) { p.x += transform[0]; p.y += transform[1]; p.z += transform[2];  <BUGS> } else if (transform.length == 7) { double Dx_BF = transform[0]; double Dy_BF = transform[1]; double Dz_BF = transform[2]; double Rx_BF = transform[3]; double Ry_BF = transform[4]; double Rz_BF = transform[5]; double M_BF = transform[6]; <BUGE>  double x_out = M_BF * (p.x - Rz_BF * p.y + Ry_BF * p.z) + Dx_BF; double y_out = M_BF * (Rz_BF * p.x + p.y - Rx_BF * p.z) + Dy_BF; double z_out = M_BF * (-Ry_BF * p.x + Rx_BF * p.y + p.z) + Dz_BF;  p.x = x_out; p.y = y_out; p.z = z_out; } }
public void transformFromGeocentricToWgs84(ProjCoordinate p) { if (transform.length == 3) { p.x += transform[0]; p.y += transform[1]; p.z += transform[2];  } else if (transform.length == 7) { double Dx_BF = transform[0]; double Dy_BF = transform[1]; double Dz_BF = transform[2]; double Rx_BF = transform[3]; double Ry_BF = transform[4]; double Rz_BF = transform[5]; double M_BF = transform[6];  <BUGS> double x_out = M_BF * (p.x - Rz_BF * p.y + Ry_BF * p.z) + Dx_BF; double y_out = M_BF * (Rz_BF * p.x + p.y - Rx_BF * p.z) + Dy_BF; double z_out = M_BF * (-Ry_BF * p.x + Rx_BF * p.y + p.z) + Dz_BF; <BUGE>  p.x = x_out; p.y = y_out; p.z = z_out; } }
public void transformFromGeocentricToWgs84(ProjCoordinate p) { if (transform.length == 3) { p.x += transform[0]; p.y += transform[1]; p.z += transform[2];  } else if (transform.length == 7) { double Dx_BF = transform[0]; double Dy_BF = transform[1]; double Dz_BF = transform[2]; double Rx_BF = transform[3]; double Ry_BF = transform[4]; double Rz_BF = transform[5]; double M_BF = transform[6];  double x_out = M_BF * (p.x - Rz_BF * p.y + Ry_BF * p.z) + Dx_BF; double y_out = M_BF * (Rz_BF * p.x + p.y - Rx_BF * p.z) + Dy_BF; double z_out = M_BF * (-Ry_BF * p.x + Rx_BF * p.y + p.z) + Dz_BF;  <BUGS> p.x = x_out; p.y = y_out; p.z = z_out; <BUGE> } }
public void transformFromGeocentricToWgs84(ProjCoordinate p) { if (transform.length == 3) { p.x += transform[0]; p.y += transform[1]; p.z += transform[2];  } else if (transform.length == 7) { double Dx_BF = transform[0]; double Dy_BF = transform[1]; double Dz_BF = transform[2]; double Rx_BF = transform[3]; double Ry_BF = transform[4]; double Rz_BF = transform[5]; double M_BF = transform[6];  double x_out = M_BF * (p.x - Rz_BF * p.y + Ry_BF * p.z) + Dx_BF; double y_out = M_BF * (Rz_BF * p.x + p.y - Rx_BF * p.z) + Dy_BF; double z_out = M_BF * (-Ry_BF * p.x + Rx_BF * p.y + p.z) + Dz_BF;  p.x = x_out; p.y = y_out; p.z = z_out; } <BUGS> } <BUGE>
public void setBreaks(boolean breaks) { <BUGS> this.breaks = breaks; } <BUGE>
protected void token(String src, boolean top, boolean bq, LexerContext context){ <BUGS> while(src.length() > 0){ <BUGE> /* newline*/ { List<String> cap = rules.get("newline").exec(src); if(!cap.isEmpty()){ src = src.substring(cap.get(0).length()); if(cap.get(0).length() > 1){ context.pushToken(new SpaceToken()); } } }  /* code*/ { List<String> cap = rules.get("code").exec(src); if(!cap.isEmpty()){ src = src.substring(cap.get(0).length()); String code = cap.get(0).replaceAll("(?m)^ {4}", ""); if(!options.isPedantic()){ context.pushToken(new CodeToken(code.replaceAll("\\n+$", ""), null, false)); } else { context.pushToken(new CodeToken(code, null, false)); } continue; } }  /* fences (gfm)*/
protected void token(String src, boolean top, boolean bq, LexerContext context){ while(src.length() > 0){ /* newline*/ { <BUGS> List<String> cap = rules.get("newline").exec(src); if(!cap.isEmpty()){ <BUGE> src = src.substring(cap.get(0).length()); if(cap.get(0).length() > 1){ context.pushToken(new SpaceToken()); } } }  /* code*/ { List<String> cap = rules.get("code").exec(src); if(!cap.isEmpty()){ src = src.substring(cap.get(0).length()); String code = cap.get(0).replaceAll("(?m)^ {4}", ""); if(!options.isPedantic()){ context.pushToken(new CodeToken(code.replaceAll("\\n+$", ""), null, false)); } else { context.pushToken(new CodeToken(code, null, false)); } continue; } }  /* fences (gfm)*/
protected void token(String src, boolean top, boolean bq, LexerContext context){ while(src.length() > 0){ /* newline*/ { List<String> cap = rules.get("newline").exec(src); if(!cap.isEmpty()){ src = src.substring(cap.get(0).length()); if(cap.get(0).length() > 1){ context.pushToken(new SpaceToken()); } } }  /* code*/ { <BUGS> List<String> cap = rules.get("code").exec(src); if(!cap.isEmpty()){ <BUGE> src = src.substring(cap.get(0).length()); String code = cap.get(0).replaceAll("(?m)^ {4}", ""); if(!options.isPedantic()){ context.pushToken(new CodeToken(code.replaceAll("\\n+$", ""), null, false)); } else { context.pushToken(new CodeToken(code, null, false)); } continue; } }  /* fences (gfm)*/
public LexerResult lex(String src){ LexerContext context = new LexerContext();  token(src .replace("\r\n", "\n") .replace("\r", "\n") .replace("\t", "    ") .replace("\u00a0", " ") .replace("\u2424", "\n"), true, false, context);  return new LexerResult(context.getTokens(), context.getLinks()); } { <BUGS> List<String> cap = rules.get("fences").exec(src); if(!cap.isEmpty()){ <BUGE> src = src.substring(cap.get(0).length()); context.pushToken(new CodeToken(cap.get(3), cap.get(2), false)); continue; } }  /* heading*/ { List<String> cap = rules.get("heading").exec(src); if(!cap.isEmpty()){ src = src.substring(cap.get(0).length()); context.pushToken(new HeadingToken(cap.get(1).length(), cap.get(2))); continue;
public LexerResult lex(String src){ LexerContext context = new LexerContext();  token(src .replace("\r\n", "\n") .replace("\r", "\n") .replace("\t", "    ") .replace("\u00a0", " ") .replace("\u2424", "\n"), true, false, context);  return new LexerResult(context.getTokens(), context.getLinks()); } { <BUGS> List<String> cap = rules.get("heading").exec(src); if(!cap.isEmpty()){ <BUGE> src = src.substring(cap.get(0).length()); context.pushToken(new HeadingToken(cap.get(1).length(), cap.get(2))); continue; } }  /* table no leading pipe (gfm)*/ if(top){ List<String> cap = rules.get("nptable").exec(src); if(!cap.isEmpty()){ src = src.substring(cap.get(0).length());  String[] header = cap.get(1).replaceAll("^ *| *\\| *$", "").split(" *\\| *");
public LexerResult lex(String src){ LexerContext context = new LexerContext();  token(src .replace("\r\n", "\n") .replace("\r", "\n") .replace("\t", "    ") .replace("\u00a0", " ") .replace("\u2424", "\n"), true, false, context);  return new LexerResult(context.getTokens(), context.getLinks()); } /* table no leading pipe (gfm)*/ <BUGS> if(top){ List<String> cap = rules.get("nptable").exec(src); if(!cap.isEmpty()){ <BUGE> src = src.substring(cap.get(0).length());  String[] header = cap.get(1).replaceAll("^ *| *\\| *$", "").split(" *\\| *"); String[] align  = cap.get(2).replaceAll("^ *|\\| *$", "").split(" *\\| *"); String[] cells  = cap.get(3).replaceAll("\n$", "").split("\n");  List<String> header2 = Arrays.asList(header);  List<String> align2 = new ArrayList<>(); for (String s : align) { if(s.matches("^ *-+: *$")){ align2.add("right"); } else if(s.matches("^ *:-+: *$")){
public LexerResult lex(String src){ LexerContext context = new LexerContext();  token(src .replace("\r\n", "\n") .replace("\r", "\n") .replace("\t", "    ") .replace("\u00a0", " ") .replace("\u2424", "\n"), true, false, context);  return new LexerResult(context.getTokens(), context.getLinks()); } { <BUGS> List<String> cap = rules.get("lheading").exec(src); if(!cap.isEmpty()){ <BUGE> src = src.substring(cap.get(0).length()); if(cap.get(2).equals("=")){ context.pushToken(new HeadingToken(1, cap.get(1))); } else { context.pushToken(new HeadingToken(2, cap.get(1))); } continue; } }  /* hr*/ { List<String> cap = rules.get("hr").exec(src);
public LexerResult lex(String src){ LexerContext context = new LexerContext();  token(src .replace("\r\n", "\n") .replace("\r", "\n") .replace("\t", "    ") .replace("\u00a0", " ") .replace("\u2424", "\n"), true, false, context);  return new LexerResult(context.getTokens(), context.getLinks()); } { <BUGS> List<String> cap = rules.get("hr").exec(src); if(!cap.isEmpty()){ <BUGE> src = src.substring(cap.get(0).length()); context.pushToken(new HrToken()); continue; } }  /* blockquote*/ { List<String> cap = rules.get("blockquote").exec(src); if(!cap.isEmpty()){ src = src.substring(cap.get(0).length()); context.pushToken(new BlockquoteStartToken()); token(cap.get(0).replaceAll("(?m) *> ?", ""), top, true, context);
public LexerResult lex(String src){ LexerContext context = new LexerContext();  token(src .replace("\r\n", "\n") .replace("\r", "\n") .replace("\t", "    ") .replace("\u00a0", " ") .replace("\u2424", "\n"), true, false, context);  return new LexerResult(context.getTokens(), context.getLinks()); } { <BUGS> List<String> cap = rules.get("blockquote").exec(src); if(!cap.isEmpty()){ <BUGE> src = src.substring(cap.get(0).length()); context.pushToken(new BlockquoteStartToken()); token(cap.get(0).replaceAll("(?m) *> ?", ""), top, true, context); context.pushToken(new BlockquoteEndToken()); continue; } }  /* list*/ { List<String> cap = rules.get("list").exec(src); if(!cap.isEmpty()){ src = src.substring(cap.get(0).length());
public LexerResult lex(String src){ LexerContext context = new LexerContext();  token(src .replace("\r\n", "\n") .replace("\r", "\n") .replace("\t", "    ") .replace("\u00a0", " ") .replace("\u2424", "\n"), true, false, context);  return new LexerResult(context.getTokens(), context.getLinks()); } { <BUGS> List<String> cap = rules.get("list").exec(src); if(!cap.isEmpty()){ <BUGE> src = src.substring(cap.get(0).length()); String bull = cap.get(2);  context.pushToken(new ListStartToken(bull.matches("^[0-9]+\\.$"))); boolean next = false;  /* Get each top-level item.*/ cap = rules.get("item").exec(cap.get(0)); if(!cap.isEmpty()){ for(int i = 0; i < cap.size(); i++){ String item = cap.get(i);  /* Remove the list item's bullet*/
public LexerResult lex(String src){ LexerContext context = new LexerContext();  token(src .replace("\r\n", "\n") .replace("\r", "\n") .replace("\t", "    ") .replace("\u00a0", " ") .replace("\u2424", "\n"), true, false, context);  return new LexerResult(context.getTokens(), context.getLinks()); } { <BUGS> List<String> cap = rules.get("html").exec(src); if(!cap.isEmpty()){ <BUGE> src = src.substring(cap.get(0).length()); if(options.isSanitize()){ context.pushToken(new ParagraphToken(cap.get(0))); } else { context.pushToken(new HtmlToken(cap.get(0), !options.isSanitize() && (cap.get(0).equals("pre") || cap.get(0).equals("script") || cap.get(0).equals("style")))); } continue; } }  /* def*/ if(!bq && top){
public LexerResult lex(String src){ LexerContext context = new LexerContext();  token(src .replace("\r\n", "\n") .replace("\r", "\n") .replace("\t", "    ") .replace("\u00a0", " ") .replace("\u2424", "\n"), true, false, context);  return new LexerResult(context.getTokens(), context.getLinks()); } /* def*/ <BUGS> if(!bq && top){ List<String> cap = rules.get("def").exec(src); if(!cap.isEmpty()){ <BUGE> src = src.substring(cap.get(0).length()); context.defineLink(cap.get(1).toLowerCase(), new Link(cap.get(2), cap.get(3))); continue; } }  /* table (gfm)*/ if(top){ List<String> cap = rules.get("table").exec(src); if(!cap.isEmpty()){ src = src.substring(cap.get(0).length());  String[] header = cap.get(1).replaceAll("^ *| *\\| *$", "").split(" *\\| *");
public LexerResult lex(String src){ LexerContext context = new LexerContext();  token(src .replace("\r\n", "\n") .replace("\r", "\n") .replace("\t", "    ") .replace("\u00a0", " ") .replace("\u2424", "\n"), true, false, context);  return new LexerResult(context.getTokens(), context.getLinks()); } /* table (gfm)*/ <BUGS> if(top){ List<String> cap = rules.get("table").exec(src); if(!cap.isEmpty()){ <BUGE> src = src.substring(cap.get(0).length());  String[] header = cap.get(1).replaceAll("^ *| *\\| *$", "").split(" *\\| *"); String[] align  = cap.get(2).replaceAll("^ *|\\| *$", "").split(" *\\| *"); String[] cells  = cap.get(3).replaceAll("(?: *\\| *)?\\n$", "").split("\\n");  List<String> header2 = Arrays.asList(header);  List<String> align2 = new ArrayList<>(); for (String s : align) { if(s.matches("^ *-+: *$")){ align2.add("right"); } else if(s.matches("^ *:-+: *$")){
LexerContext context = new LexerContext();  token(src .replace("\r\n", "\n") .replace("\r", "\n") .replace("\t", "    ") .replace("\u00a0", " ") .replace("\u2424", "\n"), true, false, context);  return new LexerResult(context.getTokens(), context.getLinks()); } /* top-level paragraph*/ <BUGS> if(top){ List<String> cap = rules.get("paragraph").exec(src); if(!cap.isEmpty()){ src = src.substring(cap.get(0).length()); if(cap.get(1).charAt(cap.get(1).length() - 1) == '\n'){ <BUGE> context.pushToken(new ParagraphToken(cap.get(1).substring(0, cap.get(1).length() - 1))); } else { context.pushToken(new ParagraphToken(cap.get(1))); } continue; } }  /* text*/ { List<String> cap = rules.get("text").exec(src); if(!cap.isEmpty()){
public LexerResult lex(String src){ LexerContext context = new LexerContext();  token(src .replace("\r\n", "\n") .replace("\r", "\n") .replace("\t", "    ") .replace("\u00a0", " ") .replace("\u2424", "\n"), true, false, context);  return new LexerResult(context.getTokens(), context.getLinks()); } } else { <BUGS> context.pushToken(new ParagraphToken(cap.get(1))); <BUGE> } continue; } }  /* text*/ { List<String> cap = rules.get("text").exec(src); if(!cap.isEmpty()){ src = src.substring(cap.get(0).length()); context.pushToken(new TextToken((cap.get(0)))); continue; } }
public LexerResult lex(String src){ LexerContext context = new LexerContext();  token(src .replace("\r\n", "\n") .replace("\r", "\n") .replace("\t", "    ") .replace("\u00a0", " ") .replace("\u2424", "\n"), true, false, context);  return new LexerResult(context.getTokens(), context.getLinks()); } } <BUGS> continue; <BUGE> } }  /* text*/ { List<String> cap = rules.get("text").exec(src); if(!cap.isEmpty()){ src = src.substring(cap.get(0).length()); context.pushToken(new TextToken((cap.get(0)))); continue; } }  /* TODO Error*/
public LexerResult lex(String src){ LexerContext context = new LexerContext();  token(src .replace("\r\n", "\n") .replace("\r", "\n") .replace("\t", "    ") .replace("\u00a0", " ") .replace("\u2424", "\n"), true, false, context);  return new LexerResult(context.getTokens(), context.getLinks()); } } <BUGS> } <BUGE>  public static class LexerContext { private Stack<Token> tokens = new Stack<>(); private Map<String, Link> links = new HashMap<>();  public void pushToken(Token token){ this.tokens.push(token); }  public void defineLink(String key, Link link){ this.links.put(key, link); }  public Stack<Token> getTokens() {
*/ public Aether(@NotNull final MavenProject prj, @NotNull final File repo) { <BUGS> this(prj.getRemoteProjectRepositories(), repo); <BUGE> }
*/ <BUGS> public StSender(final String name, final String addr) { <BUGE> try { this.email = new InternetAddress(name, addr, "UTF-8").toString(); } catch (final UnsupportedEncodingException ex) { throw new IllegalStateException(ex); } }
*/ public StSender(final String name, final String addr) { try { <BUGS> this.email = new InternetAddress(name, addr, "UTF-8").toString(); <BUGE> } catch (final UnsupportedEncodingException ex) { throw new IllegalStateException(ex); } }
*/ public StSender(final String name, final String addr) { try { this.email = new InternetAddress(name, addr, "UTF-8").toString(); } catch (final UnsupportedEncodingException ex) { throw new IllegalStateException(ex); <BUGS> } } <BUGE>
*/ private String tail(final Throwable throwable) { final String tail; <BUGS> if (this.verbose) { <BUGE> tail = Logger.format("%[exception]s", throwable); } else { tail = Logger.format( "%[type]s('%s')", throwable, throwable.getMessage() ); } return tail; }
*/ private String tail(final Throwable throwable) { final String tail; if (this.verbose) { tail = Logger.format("%[exception]s", throwable); } else { <BUGS> tail = Logger.format( <BUGE> "%[type]s('%s')", throwable, throwable.getMessage() ); } return tail; }
*/ private String tail(final Throwable throwable) { final String tail; if (this.verbose) { tail = Logger.format("%[exception]s", throwable); } else { tail = Logger.format( "%[type]s('%s')", throwable, <BUGS> throwable.getMessage() <BUGE> ); } return tail; }
*/ private String tail(final Throwable throwable) { final String tail; if (this.verbose) { tail = Logger.format("%[exception]s", throwable); } else { tail = Logger.format( "%[type]s('%s')", throwable, throwable.getMessage() ); } <BUGS> return tail; <BUGE> }
*/ <BUGS> public SizeDecor(final Long sze) { this.size = sze; } <BUGE>
*/ public static String format(final String fmt, final Object... args) { final String result; <BUGS> if (args.length == 0) { <BUGE> result = fmt; } else { final PreFormatter pre = new PreFormatter(fmt, args); result = String.format(pre.getFormat(), pre.getArguments()); } return result; }
*/ public static String format(final String fmt, final Object... args) { final String result; if (args.length == 0) { result = fmt; } else { <BUGS> final PreFormatter pre = new PreFormatter(fmt, args); <BUGE> result = String.format(pre.getFormat(), pre.getArguments()); } return result; }
*/ public static String format(final String fmt, final Object... args) { final String result; <BUGS> if (args.length == 0) { <BUGE> result = fmt; } else { final PreFormatter pre = new PreFormatter(fmt, args); result = String.format(pre.getFormat(), pre.getArguments()); } return result; }
*/ public static String format(final String fmt, final Object... args) { final String result; if (args.length == 0) { result = fmt; } else { <BUGS> final PreFormatter pre = new PreFormatter(fmt, args); <BUGE> result = String.format(pre.getFormat(), pre.getArguments()); } return result; }
*/ public VerboseProcess(final Process prc, final Level stdout, final Level stderr) { if (prc == null) { throw new IllegalArgumentException("process can't be NULL"); } if (stdout == null) { throw new IllegalArgumentException("stdout LEVEL can't be NULL"); } if (stderr == null) { throw new IllegalArgumentException("stderr LEVEL can't be NULL"); } this.process = prc; this.olevel = stdout; this.elevel = stderr; }
*/ public VerboseProcess(final Process prc, final Level stdout, <BUGS> final Level stderr) { if (prc == null) { <BUGE> throw new IllegalArgumentException("process can't be NULL"); } if (stdout == null) { throw new IllegalArgumentException("stdout LEVEL can't be NULL"); } if (stderr == null) { throw new IllegalArgumentException("stderr LEVEL can't be NULL"); } this.process = prc; this.olevel = stdout; this.elevel = stderr; }
*/ public VerboseProcess(final Process prc, final Level stdout, final Level stderr) { if (prc == null) { throw new IllegalArgumentException("process can't be NULL"); } <BUGS> if (stdout == null) { <BUGE> throw new IllegalArgumentException("stdout LEVEL can't be NULL"); } if (stderr == null) { throw new IllegalArgumentException("stderr LEVEL can't be NULL"); } this.process = prc; this.olevel = stdout; this.elevel = stderr; }
*/ public VerboseProcess(final Process prc, final Level stdout, final Level stderr) { if (prc == null) { throw new IllegalArgumentException("process can't be NULL"); } if (stdout == null) { throw new IllegalArgumentException("stdout LEVEL can't be NULL"); } <BUGS> if (stderr == null) { <BUGE> throw new IllegalArgumentException("stderr LEVEL can't be NULL"); } this.process = prc; this.olevel = stdout; this.elevel = stderr; }
*/ public VerboseProcess(final Process prc, final Level stdout, final Level stderr) { if (prc == null) { throw new IllegalArgumentException("process can't be NULL"); } if (stdout == null) { throw new IllegalArgumentException("stdout LEVEL can't be NULL"); } if (stderr == null) { throw new IllegalArgumentException("stderr LEVEL can't be NULL"); } <BUGS> this.process = prc; this.olevel = stdout; this.elevel = stderr; } <BUGE>
*/ public VerboseProcess(final Process prc, final Level stdout, final Level stderr) { if (prc == null) { throw new IllegalArgumentException("process can't be NULL"); } if (stdout == null) { throw new IllegalArgumentException("stdout LEVEL can't be NULL"); } if (stderr == null) { throw new IllegalArgumentException("stderr LEVEL can't be NULL"); } if (Level.ALL.equals(stdout)) { throw new IllegalArgumentException( "stdout LEVEL can't be set to ALL" ); } if (Level.ALL.equals(stderr)) { throw new IllegalArgumentException( "stderr LEVEL can't be set to ALL" ); } this.process = prc; this.olevel = stdout; this.elevel = stderr; }
*/ public VerboseProcess(final Process prc, final Level stdout, <BUGS> final Level stderr) { if (prc == null) { <BUGE> throw new IllegalArgumentException("process can't be NULL"); } if (stdout == null) { throw new IllegalArgumentException("stdout LEVEL can't be NULL"); } if (stderr == null) { throw new IllegalArgumentException("stderr LEVEL can't be NULL"); } if (Level.ALL.equals(stdout)) { throw new IllegalArgumentException( "stdout LEVEL can't be set to ALL" ); } if (Level.ALL.equals(stderr)) { throw new IllegalArgumentException( "stderr LEVEL can't be set to ALL" ); } this.process = prc; this.olevel = stdout; this.elevel = stderr; }
*/ public VerboseProcess(final Process prc, final Level stdout, final Level stderr) { if (prc == null) { throw new IllegalArgumentException("process can't be NULL"); } <BUGS> if (stdout == null) { <BUGE> throw new IllegalArgumentException("stdout LEVEL can't be NULL"); } if (stderr == null) { throw new IllegalArgumentException("stderr LEVEL can't be NULL"); } if (Level.ALL.equals(stdout)) { throw new IllegalArgumentException( "stdout LEVEL can't be set to ALL" ); } if (Level.ALL.equals(stderr)) { throw new IllegalArgumentException( "stderr LEVEL can't be set to ALL" ); } this.process = prc; this.olevel = stdout; this.elevel = stderr; }
*/ public VerboseProcess(final Process prc, final Level stdout, final Level stderr) { if (prc == null) { throw new IllegalArgumentException("process can't be NULL"); } if (stdout == null) { throw new IllegalArgumentException("stdout LEVEL can't be NULL"); } <BUGS> if (stderr == null) { <BUGE> throw new IllegalArgumentException("stderr LEVEL can't be NULL"); } if (Level.ALL.equals(stdout)) { throw new IllegalArgumentException( "stdout LEVEL can't be set to ALL" ); } if (Level.ALL.equals(stderr)) { throw new IllegalArgumentException( "stderr LEVEL can't be set to ALL" ); } this.process = prc; this.olevel = stdout; this.elevel = stderr; }
*/ public VerboseProcess(final Process prc, final Level stdout, final Level stderr) { if (prc == null) { throw new IllegalArgumentException("process can't be NULL"); } if (stdout == null) { throw new IllegalArgumentException("stdout LEVEL can't be NULL"); } if (stderr == null) { throw new IllegalArgumentException("stderr LEVEL can't be NULL"); } <BUGS> if (Level.ALL.equals(stdout)) { throw new IllegalArgumentException( <BUGE> "stdout LEVEL can't be set to ALL" ); } if (Level.ALL.equals(stderr)) { throw new IllegalArgumentException( "stderr LEVEL can't be set to ALL" ); } this.process = prc; this.olevel = stdout; this.elevel = stderr; }
*/ public VerboseProcess(final Process prc, final Level stdout, final Level stderr) { if (prc == null) { throw new IllegalArgumentException("process can't be NULL"); } if (stdout == null) { throw new IllegalArgumentException("stdout LEVEL can't be NULL"); } if (stderr == null) { throw new IllegalArgumentException("stderr LEVEL can't be NULL"); } if (Level.ALL.equals(stdout)) { throw new IllegalArgumentException( "stdout LEVEL can't be set to ALL" ); } <BUGS> if (Level.ALL.equals(stderr)) { throw new IllegalArgumentException( <BUGE> "stderr LEVEL can't be set to ALL" ); } this.process = prc; this.olevel = stdout; this.elevel = stderr; }
*/ public static String format(final String fmt, final Object... args) { final String result; <BUGS> if (args.length == 0) { <BUGE> result = fmt; } else { final PreFormatter pre = new PreFormatter(fmt, args); result = String.format(pre.getFormat(), pre.getArguments()); } return result; }
*/ public static String format(final String fmt, final Object... args) { final String result; if (args.length == 0) { result = fmt; } else { <BUGS> final PreFormatter pre = new PreFormatter(fmt, args); <BUGE> result = String.format(pre.getFormat(), pre.getArguments()); } return result; }
@SuppressWarnings("PMD.ConfusingTernary") private void process(final CharSequence fmt, final Object... args) { <BUGS> this.arguments = new CopyOnWriteArrayList<Object>(); final StringBuffer buf = new StringBuffer(fmt.length()); final Matcher matcher = PreFormatter.PATTERN.matcher(fmt); int pos = 0; while (matcher.find()) { final String group = matcher.group(); if (PreFormatter.NO_ARG_SPECIFIERS.contains(group)) { <BUGE> matcher.appendReplacement( buf, Matcher.quoteReplacement(group) ); } else { final String decor = matcher.group(3); if (matcher.group(1) != null) { matcher.appendReplacement( buf, Matcher.quoteReplacement(group) ); } else if (decor == null) { matcher.appendReplacement( buf, Matcher.quoteReplacement(group) ); this.arguments.add(args[pos]); } else { matcher.appendReplacement( buf, Matcher.quoteReplacement( group.replace(matcher.group(2), "") ) );
@SuppressWarnings("PMD.ConfusingTernary") private void process(final CharSequence fmt, final Object... args) { this.arguments = new CopyOnWriteArrayList<Object>(); final StringBuffer buf = new StringBuffer(fmt.length()); final Matcher matcher = PreFormatter.PATTERN.matcher(fmt); int pos = 0; while (matcher.find()) { final String group = matcher.group(); if (PreFormatter.NO_ARG_SPECIFIERS.contains(group)) { matcher.appendReplacement( buf, Matcher.quoteReplacement(group) ); } else { <BUGS> final String decor = matcher.group(3); if (matcher.group(1) != null) { matcher.appendReplacement( buf, Matcher.quoteReplacement(group) <BUGE> ); } else if (decor == null) { matcher.appendReplacement( buf, Matcher.quoteReplacement(group) ); this.arguments.add(args[pos]); } else { matcher.appendReplacement( buf, Matcher.quoteReplacement( group.replace(matcher.group(2), "") ) );
@SuppressWarnings("PMD.ConfusingTernary") private void process(final CharSequence fmt, final Object... args) { this.arguments = new CopyOnWriteArrayList<Object>(); final StringBuffer buf = new StringBuffer(fmt.length()); final Matcher matcher = PreFormatter.PATTERN.matcher(fmt); int pos = 0; while (matcher.find()) { final String group = matcher.group(); if (PreFormatter.NO_ARG_SPECIFIERS.contains(group)) { matcher.appendReplacement( buf, Matcher.quoteReplacement(group) ); } else { final String decor = matcher.group(3); if (matcher.group(1) != null) { matcher.appendReplacement( buf, Matcher.quoteReplacement(group) ); <BUGS> } else if (decor == null) { matcher.appendReplacement( buf, Matcher.quoteReplacement(group) <BUGE> ); this.arguments.add(args[pos]); } else { matcher.appendReplacement( buf, Matcher.quoteReplacement( group.replace(matcher.group(2), "") ) );
@SuppressWarnings("PMD.ConfusingTernary") private void process(final CharSequence fmt, final Object... args) { this.arguments = new CopyOnWriteArrayList<Object>(); final StringBuffer buf = new StringBuffer(fmt.length()); final Matcher matcher = PreFormatter.PATTERN.matcher(fmt); int pos = 0; while (matcher.find()) { final String group = matcher.group(); if (PreFormatter.NO_ARG_SPECIFIERS.contains(group)) { matcher.appendReplacement( buf, Matcher.quoteReplacement(group) ); } else { final String decor = matcher.group(3); if (matcher.group(1) != null) { matcher.appendReplacement( buf, Matcher.quoteReplacement(group) ); } else if (decor == null) { matcher.appendReplacement( buf, Matcher.quoteReplacement(group) ); <BUGS> this.arguments.add(args[pos]); <BUGE> } else { matcher.appendReplacement( buf, Matcher.quoteReplacement( group.replace(matcher.group(2), "") ) );
/** * Get new list of arguments. * @return The list of arguments */ public Object[] getArguments() { return this.arguments.toArray(new Object[this.arguments.size()]); }  /** * Process the data provided. * @param fmt The formatting string * @param args The list of arguments * @checkstyle ExecutableStatementCountCheck (100 lines) */ } <BUGS> ++pos; <BUGE> } } if (pos < args.length) { throw new IllegalArgumentException( String.format( /* @checkstyle LineLength (1 line)*/ "There are %d parameter(s) but only %d format argument(s) were provided.", args.length, pos ) ); } matcher.appendTail(buf); this.format = buf.toString();
/** * Get new list of arguments. * @return The list of arguments */ public Object[] getArguments() { return this.arguments.toArray(new Object[this.arguments.size()]); }  /** * Process the data provided. * @param fmt The formatting string * @param args The list of arguments * @checkstyle ExecutableStatementCountCheck (100 lines) */ } <BUGS> } <BUGE> if (pos < args.length) { throw new IllegalArgumentException( String.format( /* @checkstyle LineLength (1 line)*/ "There are %d parameter(s) but only %d format argument(s) were provided.", args.length, pos ) ); } matcher.appendTail(buf); this.format = buf.toString(); }
*/ public static Matcher<String> matchesPattern(final String pattern) { <BUGS> throw new UnsupportedOperationException( <BUGE> "matchesPattern not yet implemented" ); }
*/ public static Matcher<String> containsPattern(final String pattern) { <BUGS> throw new UnsupportedOperationException( <BUGE> "containsPattern not yet implemented" ); }
*/ public Value withOverrides(Value overrides) { <BUGS> if ((overrides == null) || (overrides == EMPTY)) { <BUGE> return this; } Include vi = overrides._valueInclusion; Include ci = overrides._contentInclusion;  boolean viDiff = (vi != _valueInclusion) && (vi != Include.USE_DEFAULTS); boolean ciDiff = (ci != _valueInclusion) && (ci != Include.USE_DEFAULTS);  if (viDiff) { if (ciDiff) { return new Value(vi, ci); } return new Value(vi, _contentInclusion); } return this; }
*/ public Value withOverrides(Value overrides) { if ((overrides == null) || (overrides == EMPTY)) { return this; } <BUGS> Include vi = overrides._valueInclusion; Include ci = overrides._contentInclusion; <BUGE>  boolean viDiff = (vi != _valueInclusion) && (vi != Include.USE_DEFAULTS); boolean ciDiff = (ci != _valueInclusion) && (ci != Include.USE_DEFAULTS);  if (viDiff) { if (ciDiff) { return new Value(vi, ci); } return new Value(vi, _contentInclusion); } return this; }
*/ public Value withOverrides(Value overrides) { if ((overrides == null) || (overrides == EMPTY)) { return this; } Include vi = overrides._valueInclusion; Include ci = overrides._contentInclusion;  <BUGS> boolean viDiff = (vi != _valueInclusion) && (vi != Include.USE_DEFAULTS); boolean ciDiff = (ci != _valueInclusion) && (ci != Include.USE_DEFAULTS); <BUGE>  if (viDiff) { if (ciDiff) { return new Value(vi, ci); } return new Value(vi, _contentInclusion); } return this; }
*/ public Value withOverrides(Value overrides) { if ((overrides == null) || (overrides == EMPTY)) { return this; } Include vi = overrides._valueInclusion; Include ci = overrides._contentInclusion;  boolean viDiff = (vi != _valueInclusion) && (vi != Include.USE_DEFAULTS); boolean ciDiff = (ci != _valueInclusion) && (ci != Include.USE_DEFAULTS);  <BUGS> if (viDiff) { if (ciDiff) { return new Value(vi, ci); <BUGE> } return new Value(vi, _contentInclusion); } return this; }
*/ public Value withOverrides(Value overrides) { if ((overrides == null) || (overrides == EMPTY)) { return this; } Include vi = overrides._valueInclusion; Include ci = overrides._contentInclusion;  boolean viDiff = (vi != _valueInclusion) && (vi != Include.USE_DEFAULTS); boolean ciDiff = (ci != _valueInclusion) && (ci != Include.USE_DEFAULTS);  if (viDiff) { if (ciDiff) { return new Value(vi, ci); } return new Value(vi, _contentInclusion); } <BUGS> return this; <BUGE> }
@Override public boolean equals(Object obj) { <BUGS> Optional<Point> other = ObjectsHelper.asClass(obj, Point.class); if (other.isPresent()) { return Objects.equal(mbr, other.get().mbr()); <BUGE> } else return false; }
public boolean intersects(Point point) { <BUGS> return intersects(point.mbr()); <BUGE> }
@Override public Geometry geometry() { <BUGS> return this; <BUGE> }
private void requestSome(long n) { /* back pressure path*/ /* this algorithm copied roughly from*/ /* rxjava-core/OnSubscribeFromIterable.java*/  /* rxjava used AtomicLongFieldUpdater instead of AtomicLong*/ /* but benchmarks showed no benefit here so reverted to AtomicLong*/ <BUGS> long previousCount = requested.getAndAdd(n); if (previousCount == 0) { <BUGE> /* don't touch stack every time during the loop because*/ /* is a volatile and every write forces a thread memory*/ /* cache flush*/ ImmutableStack<NodePosition<T, S>> st = stack; while (true) { /* minimize atomic reads by assigning to a variable here*/ long r = requested.get(); long numToEmit = r; st = Backpressure.search(condition, subscriber, st, numToEmit); if (st.isEmpty()) { if (!subscriber.isUnsubscribed()) { subscriber.onCompleted(); break; } else break; } else if (requested.addAndGet(-r) == 0) break; } stack = st; }
private void requestSome(long n) { /* back pressure path*/ /* this algorithm copied roughly from*/ /* rxjava-core/OnSubscribeFromIterable.java*/  /* rxjava used AtomicLongFieldUpdater instead of AtomicLong*/ /* but benchmarks showed no benefit here so reverted to AtomicLong*/ long previousCount = requested.getAndAdd(n); if (previousCount == 0) { /* don't touch stack every time during the loop because*/ /* is a volatile and every write forces a thread memory*/ /* cache flush*/ <BUGS> ImmutableStack<NodePosition<T, S>> st = stack; <BUGE> while (true) { /* minimize atomic reads by assigning to a variable here*/ long r = requested.get(); long numToEmit = r; st = Backpressure.search(condition, subscriber, st, numToEmit); if (st.isEmpty()) { if (!subscriber.isUnsubscribed()) { subscriber.onCompleted(); break; } else break; } else if (requested.addAndGet(-r) == 0) break; } stack = st; }
private void requestSome(long n) { /* back pressure path*/ /* this algorithm copied roughly from*/ /* rxjava-core/OnSubscribeFromIterable.java*/  /* rxjava used AtomicLongFieldUpdater instead of AtomicLong*/ /* but benchmarks showed no benefit here so reverted to AtomicLong*/ long previousCount = requested.getAndAdd(n); if (previousCount == 0) { /* don't touch stack every time during the loop because*/ /* is a volatile and every write forces a thread memory*/ /* cache flush*/ ImmutableStack<NodePosition<T, S>> st = stack; while (true) { /* minimize atomic reads by assigning to a variable here*/ <BUGS> long r = requested.get(); long numToEmit = r; st = Backpressure.search(condition, subscriber, st, numToEmit); if (st.isEmpty()) { <BUGE> if (!subscriber.isUnsubscribed()) { subscriber.onCompleted(); break; } else break; } else if (requested.addAndGet(-r) == 0) break; } stack = st; }
private void requestSome(long n) { /* back pressure path*/ /* this algorithm copied roughly from*/ /* rxjava-core/OnSubscribeFromIterable.java*/  /* rxjava used AtomicLongFieldUpdater instead of AtomicLong*/ /* but benchmarks showed no benefit here so reverted to AtomicLong*/ long previousCount = requested.getAndAdd(n); if (previousCount == 0) { /* don't touch stack every time during the loop because*/ /* is a volatile and every write forces a thread memory*/ /* cache flush*/ ImmutableStack<NodePosition<T, S>> st = stack; while (true) { /* minimize atomic reads by assigning to a variable here*/ long r = requested.get(); long numToEmit = r; st = Backpressure.search(condition, subscriber, st, numToEmit); if (st.isEmpty()) { if (!subscriber.isUnsubscribed()) { subscriber.onCompleted(); break; } else break; <BUGS> } else if (requested.addAndGet(-r) == 0) break; } stack = st; <BUGE> }
private void requestSome(long n) { /* back pressure path*/ /* this algorithm copied roughly from*/ /* rxjava-core/OnSubscribeFromIterable.java*/  /* rxjava used AtomicLongFieldUpdater instead of AtomicLong*/ /* but benchmarks showed no benefit here so reverted to AtomicLong*/ long previousCount = requested.getAndAdd(n); if (previousCount == 0) { /* don't touch stack every time during the loop because*/ /* is a volatile and every write forces a thread memory*/ /* cache flush*/ ImmutableStack<NodePosition<T, S>> st = stack; while (true) { /* minimize atomic reads by assigning to a variable here*/ long r = requested.get(); long numToEmit = r; st = Backpressure.search(condition, subscriber, st, numToEmit); if (st.isEmpty()) { if (!subscriber.isUnsubscribed()) { subscriber.onCompleted(); break; } else break; } else if (requested.addAndGet(-r) == 0) break; } stack = st; }
@VisibleForTesting static byte[] readFully(InputStream is, int numBytes) throws IOException { <BUGS> byte[] b = new byte[numBytes]; int n = is.read(b); if (n != numBytes) throw new RuntimeException("unexpected"); <BUGE> return b; }
@Override public int hashCode() { <BUGS> return Objects.hashCode(mbr); <BUGE> }
